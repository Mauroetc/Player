
/*start of file .\beloved_bad_commits.txt*/

<commit>
<details>
Battle Commands from Maniacs - 3yr ago
Description:
/!\ This branch is not intended to be an exact replica of Maniacs' effects, but to enable the use of similar commands, so a project made under Maniacs is likely to have bugs. /!\

Common Event can run in Battle ( Begin Battle and Parallel Battle )

Should be okay :
- Command Control Battle
- Command Control ATB Gauge
- Command Battle Command EX
- Command Get battle Info
</details>
<diff>
--- CMakeLists.txt ---
@@ -174,6 +174,8 @@ add_library(${PROJECT_NAME} OBJECT
	src/game_interpreter_map.h
	src/game_map.cpp
	src/game_map.h
+	src/game_maniacs.cpp
+	src/game_maniacs.h
	src/game_message.cpp
	src/game_message.h
	src/game_party_base.cpp

--- src\game_battle.cpp ---
@@ -36,6 +36,8 @@
#include "output.h"
#include "utils.h"
#include "rand.h"
+#include "game_map.h"
+#include <game_maniacs.h>

namespace Game_Battle {
 const lcf::rpg::Troop* troop = nullptr;
@@ -218,6 +220,31 @@ void Game_Battle::UpdateAtbGauges() {
 const auto cur_atb = bat->GetAtbGauge();
 const auto multiplier = std::max(1.0, static_cast<double>(275000 - cur_atb) / 55000.0);
 increment = Utils::RoundTo<int>(multiplier * increment);
+ int CE_ID = ManiacsBattle::Get_ATBCE();
+ int Var_ID = ManiacsBattle::Get_ATBVar();
+ if (CE_ID > 0) {
+ if (bat->GetType() == Game_Battler::Type_Enemy) {
+
+ Main_Data::game_variables->Set(Var_ID, 1);
+ auto* enemy = static_cast<Game_Enemy*>(bat);
+ Main_Data::game_variables->Set(Var_ID + 1, enemy->GetTroopMemberId() - 1);
+
+					}
+ else {
+ Main_Data::game_variables->Set(Var_ID, 0);
+ Main_Data::game_variables->Set(Var_ID + 1, Main_Data::game_party->GetActorPositionInParty(bat->GetId()));
+					}
+
+ Main_Data::game_variables->Set(Var_ID + 2, cur_atb);
+ Main_Data::game_variables->Set(Var_ID + 3, increment);

--- src\game_battle.h ---
@@ -25,6 +25,7 @@
#include "teleport_target.h"
#include "utils.h"
#include "point.h"
+#include "game_commonevent.h"

class Game_Battler;
class Game_Enemy;
@@ -197,6 +198,12 @@ namespace Game_Battle {

 /** Don't reference this, use IsBattleRunning()! */
 extern bool battle_running;
+
+ /**
+ * Common Event in Battle
+ */
+ void StartCommonEvent(int i);
+ Game_CommonEvent* StartCommonEventID(int id);
}

inline bool Game_Battle::IsBattleRunning() {

--- src\game_battlealgorithm.cpp ---
@@ -50,6 +50,8 @@
#include "attribute.h"
#include "spriteset_battle.h"
#include "feature.h"
+#include <game_maniacs.h>
+#include <game_variables.h>

static inline int MaxDamageValue() {
 return lcf::Data::system.easyrpg_max_damage == -1 ? (Player::IsRPG2k() ? 999 : 9999) : lcf::Data::system.easyrpg_max_damage;
@@ -373,6 +375,122 @@ void Game_BattleAlgorithm::AlgorithmBase::Start() {
 assert(current_target == targets.end() || IsCurrentTargetValid());

 source->SetCharged(false);
+
+ int CE_ID = ManiacsBattle::Get_TargetCE();
+ int Var_ID = ManiacsBattle::Get_TargetVar();
+ if (CE_ID > 0) {
+ Main_Data::game_variables->Set(Var_ID + 1, 123);
+
+ Main_Data::game_variables->Set(Var_ID + 5, 123);
+

--- src\game_battler.cpp ---
@@ -43,6 +43,8 @@
#include "attribute.h"
#include "algo.h"
#include "rand.h"
+#include <game_maniacs.h>
+#include <game_variables.h>

Game_Battler::Game_Battler() {
}
@@ -332,6 +334,31 @@ bool Game_Battler::AddState(int state_id, bool allow_battle_states) {
 return was_added;
	}

+ int CE_ID = ManiacsBattle::Get_StateCE();
+ int Var_ID = ManiacsBattle::Get_StateVar();
+ if (CE_ID > 0) {
+ int index = 0;
+ if (GetType() == Game_Battler::Type_Ally) {
+ Main_Data::game_variables->Set(Var_ID, 0);
+ index = Main_Data::game_party->GetActorPositionInParty(GetId());
+		}
+ else {
+ Main_Data::game_variables->Set(Var_ID, 1);
+ Game_Enemy* e = (Game_Enemy*)this;
+ index = Main_Data::game_enemyparty->GetEnemyPositionInParty(e);

--- src\game_commonevent.cpp ---
@@ -23,6 +23,8 @@
#include "main_data.h"
#include <lcf/reader_util.h>
#include <cassert>
+#include <game_maniacs.h>
+#include <output.h>

Game_CommonEvent::Game_CommonEvent(int common_event_id) :
 common_event_id(common_event_id)
@@ -38,6 +40,18 @@ Game_CommonEvent::Game_CommonEvent(int common_event_id) :

}

+void Game_CommonEvent::ForceCreate(int ce_ID) {
+ auto* ce = lcf::ReaderUtil::GetElement(lcf::Data::commonevents, ce_ID);
+
+ if ((ce->trigger == lcf::rpg::EventPage::Trigger_parallel || ce->ID == ManiacsBattle::Get_ATBCE() || ce->ID == ManiacsBattle::Get_TargetCE() ||
+ ce->ID == ManiacsBattle::Get_DamageCE() || ce->ID == ManiacsBattle::Get_StateCE() || ce->ID == ManiacsBattle::Get_StatsCE())
+ && !ce->event_commands.empty())
+	{
+ interpreter.reset(new Game_Interpreter_Map());

--- src\game_commonevent.h ---
@@ -54,6 +54,8 @@ public:
 */
 AsyncOp Update(bool resume_async);

+ AsyncOp Game_CommonEvent::UpdateBattle(bool resume_async, int ce_ID);
+
 /**
 * Gets common event index.
 *
@@ -107,6 +109,13 @@ public:
 */
 bool IsWaitingBackgroundExecution(bool force_run) const;

+ /**
+ * Force creation of Common Event
+ *
+ * @param ce_ID Common Event ID
+ */
+ void ForceCreate(int ce_ID);
+
private:
 int common_event_id;


--- src\game_interpreter_battle.cpp ---
@@ -30,6 +30,8 @@
#include "game_map.h"
#include "spriteset_battle.h"
#include <cassert>
+#include <scene_battle.h>
+#include <game_maniacs.h>

enum BranchBattleSubcommand {
 eOptionBranchBattleElse = 1
@@ -538,39 +540,420 @@ bool Game_Interpreter_Battle::CommandEndBranchBattle(lcf::rpg::EventCommand cons
 return true;
}

-bool Game_Interpreter_Battle::CommandManiacControlBattle(lcf::rpg::EventCommand const&) {
+bool Game_Interpreter_Battle::CommandManiacControlBattle(lcf::rpg::EventCommand const& com) {
 if (!Player::IsPatchManiac()) {
 return true;
	}
+ if (com.parameters[0] == 0) {
+ // Target

- Output::Warning("Maniac Patch: Command ControlBattle not supported");
+ ManiacsBattle::Set_ATBCE(com.parameters[2]);
+ ManiacsBattle::Set_ATBVar(com.parameters[3]);

--- src\game_interpreter_battle.h ---
@@ -58,6 +58,10 @@ public:
 bool IsForceFleeEnabled() const;

 bool ExecuteCommand() override;
+
+ Game_CommonEvent* StartCommonEvent(int i);
+ void PushCommonEvent(Game_CommonEvent* ev);
+
private:
 bool CommandCallCommonEvent(lcf::rpg::EventCommand const& com);
 bool CommandForceFlee(lcf::rpg::EventCommand const& com);

--- src\game_maniacs.cpp ---
@@ -0,0 +1,106 @@
+#include "game_maniacs.h"
+
+namespace ManiacsBattle
+{
+ int damage_CE;
+ int damage_Var;
+
+ void Set_DamageCE(int i) {
+ damage_CE = i;
+	}
+ int Get_DamageCE() {
+ return damage_CE;
+	}
+
+ void Set_DamageVar(int i) {
+ damage_Var = i;
+	}
+ int Get_DamageVar() {
+ return damage_Var;
+	}
+
+ int target_CE;
+ int target_Var;
+
+ void Set_TargetCE(int i) {
+ target_CE = i;
+	}
+ int Get_TargetCE() {
+ return target_CE;
+	}
+
+ void Set_TargetVar(int i) {

--- src\game_maniacs.h ---
@@ -0,0 +1,42 @@
+#include <vector>
+
+namespace ManiacsBattle
+{
+ void Set_DamageCE(int i);
+ int Get_DamageCE();
+
+ void Set_DamageVar(int i);
+ int Get_DamageVar();
+
+
+ void Set_TargetCE(int i);
+ int Get_TargetCE();
+
+ void Set_TargetVar(int i);
+ int Get_TargetVar();
+
+ void Set_AutoSelect(bool i);
+ bool Get_AutoSelect();
+
+ void Set_ATBCE(int i);
+ int Get_ATBCE();
+
+ void Set_ATBVar(int i);
+ int Get_ATBVar();
+
+ void Set_StateCE(int i);
+ int Get_StateCE();
+
+ void Set_StateVar(int i);
+ int Get_StateVar();

--- src\scene_battle.cpp ---
@@ -136,6 +136,8 @@ void Scene_Battle::Start() {
 InitEscapeChance();

 SetState(State_Start);
+
+ Game_Battle::StartCommonEvent(1);
}

void Scene_Battle::InitEscapeChance() {
@@ -605,3 +607,40 @@ void Scene_Battle::EndBattle(BattleResult result) {
	}
}

+void Scene_Battle::reset_easyrpg_battle_options(std::vector<int16_t> cmds) {
+
+ lcf::Data::system.easyrpg_battle_options = cmds;
+
+ battle_options = {};
+
+ for (auto option : lcf::Data::system.easyrpg_battle_options) {
+ if (true) {
+ battle_options.push_back((BattleOptionType)option);
+		}
+	}
+
+
+ std::vector<std::string> commands;

--- src\scene_battle.h ---
@@ -123,11 +123,16 @@ public:
 enum BattleOptionType {
 Battle,
 AutoBattle,
- Escape
+ Escape,
+ Win,
+ Lose
	};

 static void SelectionFlash(Game_Battler* battler);

+ Window_Command* GetOptionsWindow();
+ void Scene_Battle::reset_easyrpg_battle_options(std::vector<int16_t> cmds);
+
protected:
 explicit Scene_Battle(const BattleArgs& args);

@@ -206,4 +211,8 @@ inline bool Scene_Battle::IsEscapeAllowed() const {
 return allow_escape;
}

+inline Window_Command* Scene_Battle::GetOptionsWindow() {
+ return options_window.get();
+}
+
#endif

--- src\scene_battle_rpg2k3.cpp ---
@@ -49,6 +49,8 @@
#include <algorithm>
#include <memory>
#include "feature.h"
+#include <game_maniacs.h>
+#include "game_variables.h"

//#define EP_DEBUG_BATTLE2K3_STATE_MACHINE

@@ -960,6 +962,11 @@ void Scene_Battle_Rpg2k3::vUpdate() {
		}
	}

+ if (!Game_Message::IsMessageActive()) {
+ Game_Battle::StartCommonEvent(2);
+	}
+
+
 UpdateAnimations();
 UpdateGraphics();
}
@@ -2189,6 +2196,34 @@ Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleAction
 b->BattleStateHeal();
 int damageTaken = b->ApplyConditions();
 if (damageTaken != 0) {
+ int CE_ID = ManiacsBattle::Get_DamageCE();
</diff>
</commit>
================================================================================

<commit>
<details> 
Fix For dual wielding - 2yrs ago
Description: none
</details>
<diff>
--- src\game_battlealgorithm.cpp ---
@@ -379,9 +379,9 @@ void Game_BattleAlgorithm::AlgorithmBase::Start() {
 int CE_ID = ManiacsBattle::Get_TargetCE();
 int Var_ID = ManiacsBattle::Get_TargetVar();
 if (CE_ID > 0) {
- Main_Data::game_variables->Set(Var_ID + 1, 123);
+ Main_Data::game_variables->Set(Var_ID + 1, 0);

- Main_Data::game_variables->Set(Var_ID + 5, 123);
+ Main_Data::game_variables->Set(Var_ID + 5, 0);

 //Source Var
 if (source->GetType() == Game_Battler::Type_Enemy) {
@@ -396,6 +396,26 @@ void Game_BattleAlgorithm::AlgorithmBase::Start() {

 // Target Var
 int size = std::distance(targets.begin(), targets.end());
+ if (GetType() == Type::Normal) {
+
+ size = 1;
+
+ if (source->GetType() == Game_Battler::Type_Ally) {
+ auto* actor = static_cast<Game_Actor*>(source);
+ auto* normal = static_cast<Game_BattleAlgorithm::Normal*>(this);
+ if (normal->GetWeapon()) {
+ auto w = actor->GetWeapon();
+ if (normal->GetWeapon() == 2)
+ w = actor->Get2ndWeapon();
+ if (w)
+ if (w->attack_all) {
+ size = 2;
+						}
+				}
</diff>
</commit>
================================================================================

<commit>
<details> 
Test BR - 9mth ago
Description:
none
</details>
<diff>
--- src\game_actor.cpp ---
@@ -934,6 +934,8 @@ void Game_Actor::ChangeBattleCommands(bool add, int id) {
 data.changed_battle_commands = true;
	}

+ need_refresh_commands = true;
+
 // The battle commands array always has a size of 7 padded with -1. The last element before the padding is 0 which
 // stands for the Row command
 if (add) {

--- src\game_actor.h ---
@@ -930,6 +930,8 @@ public:

 int GetActorAi() const;

+ bool need_refresh_commands;
+
private:
 void AdjustEquipmentStates(const lcf::rpg::Item* item, bool add, bool allow_battle_states);
 void Fixup();

--- src\game_battle.cpp ---
@@ -45,6 +45,7 @@ namespace Game_Battle {
 std::string background_name;

 std::unique_ptr<Game_Interpreter_Battle> interpreter;
+ std::unique_ptr<Game_Interpreter_Battle> interpreter_pp;
 /** Contains battle related sprites */
 std::unique_ptr<Spriteset_Battle> spriteset;

@@ -73,6 +74,7 @@ void Game_Battle::Init(int troop_id) {
 Main_Data::game_actors->ResetBattle();

 interpreter.reset(new Game_Interpreter_Battle(troop->pages));
+ interpreter_pp.reset(new Game_Interpreter_Battle(troop->pages));
 spriteset.reset(new Spriteset_Battle(background_name, terrain_id));
 spriteset->Update();
 animation_actors.reset();
@@ -90,6 +92,7 @@ void Game_Battle::Quit() {
	}

 interpreter.reset();
+ interpreter_pp.reset();
 spriteset.reset();
 animation_actors.reset();
 animation_enemies.reset();
@@ -238,9 +241,12 @@ void Game_Battle::UpdateAtbGauges() {
 Main_Data::game_variables->Set(Var_ID + 2, cur_atb);
 Main_Data::game_variables->Set(Var_ID + 3, increment);

+ // TODO
 Game_CommonEvent* ce = Game_Battle::StartCommonEventID(CE_ID);
 ce->UpdateBattle(true, CE_ID);
- Game_Battle::GetInterpreter().Clear();
+ ce->KillCE();
+ Game_Battle::interpreter_pp->RemoveCommonEventID(CE_ID);

--- src\game_battle.h ---
@@ -123,6 +123,7 @@ namespace Game_Battle {
 * @return the game interpreter.
 */
 Game_Interpreter& GetInterpreter();
+ Game_Interpreter& GetInterpreter_pp();

 /**
 * Gets the battle game interpreter.

--- src\game_battlealgorithm.cpp ---
@@ -445,9 +445,8 @@ void Game_BattleAlgorithm::AlgorithmBase::Start() {

 // Actions Var

- Game_CommonEvent* ce = Game_Battle::StartCommonEventID(CE_ID);
+ auto ce = Game_Battle::StartCommonEventID(CE_ID);
 ce->UpdateBattle(true, CE_ID);
- Game_Battle::GetInterpreter().Clear();

 int v = ManiacsBattle::Get_TargetVar() + 4;
 int target_type = Main_Data::game_variables->Get(v);

--- src\game_battler.cpp ---
@@ -350,9 +350,8 @@ bool Game_Battler::AddState(int state_id, bool allow_battle_states) {
 Main_Data::game_variables->Set(Var_ID + 1, index);
 Main_Data::game_variables->Set(Var_ID + 2, state_id);

- Game_CommonEvent* ce = Game_Battle::StartCommonEventID(CE_ID);
+ auto ce = Game_Battle::StartCommonEventID(CE_ID);
 ce->UpdateBattle(true, CE_ID);
- Game_Battle::GetInterpreter().Clear();

 int v = Var_ID + 2;
 state_id = Main_Data::game_variables->Get(v);
@@ -552,10 +551,8 @@ int Game_Battler::ChangeSp(int sp) {
 Main_Data::game_variables->Set(Var_ID + 5, sp);


- Game_CommonEvent* ce = Game_Battle::StartCommonEventID(CE_ID);
-
+ auto ce = Game_Battle::StartCommonEventID(CE_ID);
 ce->UpdateBattle(true, CE_ID);
- Game_Battle::GetInterpreter().Clear();

 sp = Main_Data::game_variables->Get(Var_ID + 5);

@@ -826,9 +823,8 @@ int Game_Battler::ChangeAtkModifier(int modifier) {
 Main_Data::game_variables->Set(Var_ID + 5, delta);


- Game_CommonEvent* ce = Game_Battle::StartCommonEventID(CE_ID);
+ auto ce = Game_Battle::StartCommonEventID(CE_ID);
 ce->UpdateBattle(true, CE_ID);

--- src\game_commonevent.cpp ---
@@ -31,7 +31,7 @@ Game_CommonEvent::Game_CommonEvent(int common_event_id) :
{
 auto* ce = lcf::ReaderUtil::GetElement(lcf::Data::commonevents, common_event_id);

- if (ce->trigger == lcf::rpg::EventPage::Trigger_parallel
+ if ((ce->trigger == lcf::rpg::EventPage::Trigger_parallel)// || ce->trigger == 7 || ce->trigger == 6)
 && !ce->event_commands.empty()) {
 interpreter.reset(new Game_Interpreter_Map());
 interpreter->Push(this);
@@ -43,12 +43,19 @@ Game_CommonEvent::Game_CommonEvent(int common_event_id) :
void Game_CommonEvent::ForceCreate(int ce_ID) {
 auto* ce = lcf::ReaderUtil::GetElement(lcf::Data::commonevents, ce_ID);

- if ((ce->trigger == lcf::rpg::EventPage::Trigger_parallel || ce->ID == ManiacsBattle::Get_ATBCE() || ce->ID == ManiacsBattle::Get_TargetCE() ||
+ if ((ce->trigger == lcf::rpg::EventPage::Trigger_parallel || ce->trigger == 7 || ce->trigger == 6 || ce->ID == ManiacsBattle::Get_ATBCE() || ce->ID == ManiacsBattle::Get_TargetCE() ||
 ce->ID == ManiacsBattle::Get_DamageCE() || ce->ID == ManiacsBattle::Get_StateCE() || ce->ID == ManiacsBattle::Get_StatsCE())
 && !ce->event_commands.empty())
	{
- interpreter.reset(new Game_Interpreter_Map());
- interpreter->Push(this);
+ bool main_flag = false;
+ /*	main_flag = true;
+ if (ce->trigger != 7)
+ main_flag = false;*/
+

--- src\game_commonevent.h ---
@@ -26,6 +26,7 @@
#include <lcf/rpg/saveeventexecstate.h>
#include "async_op.h"
#include "string_view.h"
+#include <game_interpreter_battle.h>

/**
 * Game_CommonEvent class.
@@ -54,7 +55,9 @@ public:
 */
 AsyncOp Update(bool resume_async);

- AsyncOp Game_CommonEvent::UpdateBattle(bool resume_async, int ce_ID);
+ AsyncOp UpdateBattle(bool resume_async, int ce_ID);
+
+ void KillCE();

 /**
 * Gets common event index.
@@ -121,6 +124,7 @@ private:

 /** Interpreter for parallel common events. */
 std::unique_ptr<Game_Interpreter_Map> interpreter;
+ std::unique_ptr<Game_Interpreter_Battle> interpreter_pp;
};

#endif

--- src\game_interpreter.cpp ---
@@ -68,6 +68,8 @@
#include "baseui.h"
#include "algo.h"
#include "rand.h"
+#include <game_maniacs.h>
+#include <scene_battle.h>

enum BranchSubcommand {
 eOptionBranchElse = 1
@@ -108,6 +110,7 @@ void Game_Interpreter::Push(
 return;
	}

+ // Output::Debug("Limit : {}", (int)_state.stack.size());
 if ((int)_state.stack.size() > call_stack_limit) {
 Output::Error("Call Event limit ({}) has been exceeded", call_stack_limit);
	}
@@ -421,9 +424,13 @@ void Game_Interpreter::Update(bool reset_loop_count) {
 break;
			}

- if (!Input::IsTriggered(Input::DECISION)) {
+ /*if (!Input::IsTriggered(Input::DECISION)) {
+ break;
+ }*/
+ if (!Input::IsAnyTriggered()) {
 break;
			}
+
 _state.wait_key_enter = false;
		}

@@ -489,7 +496,7 @@ void Game_Interpreter::Update(bool reset_loop_count) {

 if (Game_Battle::IsBattleRunning() && Player::IsRPG2k3() && Game_Battle::CheckWin()) {

--- src\game_interpreter.h ---
@@ -290,6 +290,16 @@ protected:
 bool CommandManiacControlStrings(lcf::rpg::EventCommand const& com);
 bool CommandManiacCallCommand(lcf::rpg::EventCommand const& com);

+ bool CommandManiacGetBattleInfo(lcf::rpg::EventCommand const& com);
+ bool CommandManiacControlBattle(lcf::rpg::EventCommand const& com);
+ bool CommandManiacControlAtbGauge(lcf::rpg::EventCommand const& com);
+ bool CommandManiacChangeBattleCommandEx(lcf::rpg::EventCommand const& com);
+
+ bool CommandGetStringFromDB(lcf::rpg::EventCommand const& com);
+ bool CommandUseItem(lcf::rpg::EventCommand const& com);
+ bool CommandCanUseItem(lcf::rpg::EventCommand const& com);
+ bool CommandPrint(lcf::rpg::EventCommand const& com);
+
 int DecodeInt(lcf::DBArray<int32_t>::const_iterator& it);
 const std::string DecodeString(lcf::DBArray<int32_t>::const_iterator& it);
 lcf::rpg::MoveCommand DecodeMove(lcf::DBArray<int32_t>::const_iterator& it);

--- src\game_interpreter_battle.cpp ---
@@ -43,6 +43,11 @@ Game_Interpreter_Battle::Game_Interpreter_Battle(Span<const lcf::rpg::TroopPage>
{
}

+Game_Interpreter_Battle::Game_Interpreter_Battle(bool main_flag)
+	: Game_Interpreter(main_flag)
+{
+}
+
bool Game_Interpreter_Battle::AreConditionsMet(const lcf::rpg::TroopPageCondition& condition, Game_Battler* source) {
 if (!condition.flags.switch_a &&
 !condition.flags.switch_b &&
@@ -458,9 +463,14 @@ bool Game_Interpreter_Battle::CommandShowBattleAnimation(lcf::rpg::EventCommand

 if (allies) {
 // Allies counted from 1
- target -= 1;
- if (target >= 0 && target < Main_Data::game_party->GetBattlerCount()) {
+ //target -= 1;
+ // ??? The editor display all actors, and not only Actors in party

--- src\game_interpreter_battle.h ---
+ explicit Game_Interpreter_Battle(bool main_flag = false);

 int GetNumPages() const;

@@ -60,6 +61,7 @@ public:

 Game_CommonEvent* StartCommonEvent(int i);
 void PushCommonEvent(Game_CommonEvent* ev);
+ void RemoveCommonEventID(int eventID);

 bool ExecuteCommand(lcf::rpg::EventCommand const& com) override;

@@ -78,10 +80,6 @@ private:
 bool CommandElseBranchBattle(lcf::rpg::EventCommand const& com);
 bool CommandEndBranchBattle(lcf::rpg::EventCommand const& com);

- bool CommandManiacControlBattle(lcf::rpg::EventCommand const& com);
- bool CommandManiacControlAtbGauge(lcf::rpg::EventCommand const& com);
- bool CommandManiacChangeBattleCommandEx(lcf::rpg::EventCommand const& com);
- bool CommandManiacGetBattleInfo(lcf::rpg::EventCommand const& com);

private:
 Span<const lcf::rpg::TroopPage> pages;

--- src\game_interprete…ntrol_variables.cpp ---
@@ -134,7 +134,7 @@ int ControlVariables::Actor(int op, int actor_id) {
 case 16:
 // ATB
 if (Player::IsPatchManiac()) {
- return actor->GetAtbGauge();
+ return actor->GetAtbGauge() * 100 / actor->GetMaxAtbGauge();
			}
 break;
	}
@@ -349,7 +349,7 @@ int ControlVariables::Enemy(int op, int enemy_idx) {
 case 9:
 // ATB
 if (Player::IsPatchManiac()) {
- return enemy->GetAtbGauge();
+ return enemy->GetAtbGauge() * 100 / enemy->GetMaxAtbGauge();
			}
 break;
	}

--- src\game_map.cpp ---
@@ -157,8 +157,9 @@ int Game_Map::GetMapSaveCount() {
void Game_Map::Setup(std::unique_ptr<lcf::rpg::Map> map_in) {
 Dispose();

- screen_width = (Player::screen_width / 16) * SCREEN_TILE_SIZE;
- screen_height = (Player::screen_height / 16) * SCREEN_TILE_SIZE;
+ int screen_mod = Player::screen_width % 8;
+ screen_width = (Player::screen_width / 8 + screen_mod) * SCREEN_TILE_SIZE / 2;
+ screen_height = (Player::screen_height / 8) * SCREEN_TILE_SIZE / 2;

 map = std::move(map_in);


--- src\game_strings.cpp ---
@@ -141,6 +141,7 @@ int Game_Strings::Split(Str_Params params, const std::string& delimiter, int str
 splits++;
 str.erase(0, index + delimiter.length());
			}
+ splits++;
		}
	}


--- src\game_strings.h ---
@@ -72,8 +72,9 @@ public:
 static std::optional<std::string> ManiacsCommandInserter(char ch, const char** iter, const char* end, uint32_t escape_char);
 static std::optional<std::string> ManiacsCommandInserterHex(char ch, const char** iter, const char* end, uint32_t escape_char);

-private:
 void Set(Str_Params params, StringView string);
+private:
+ //void Set(Str_Params params, StringView string);
 bool ShouldWarn(int id) const;
 void WarnGet(int id) const;


--- src\maniac_patch.cpp ---
@@ -407,6 +407,15 @@ int process(std::vector<int32_t>::iterator& it, std::vector<int32_t>::iterator e
					}
 return 0;
			}
+ case Op::AssignInplace:
+
+ Output::Debug("EasyRPG : WIP command (v[Z] = v[X]=YYY )");
+ ++it;
+ imm = process(it, end, ip);
+ imm2 = process(it, end, ip);
+ Main_Data::game_variables->Set(imm, imm2);
+ return Main_Data::game_variables->Get(imm);
+
 default:
 Output::Warning("Maniac: Expression contains unsupported operation {}", static_cast<int>(op));
 return 0;

--- src\scene_battle.cpp ---
@@ -137,7 +137,6 @@ void Scene_Battle::Start() {

 SetState(State_Start);

- Game_Battle::StartCommonEvent(1);
}

void Scene_Battle::InitEscapeChance() {

--- src\scene_battle_rpg2k3.cpp ---
@@ -351,7 +351,8 @@ void Scene_Battle_Rpg2k3::CreateUi() {
 status_window->SetY(y);

 if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_gauge) {
- command_window->SetY(Player::screen_height / 2 - 80 / 2 + 12);
+ command_window->SetY(185);
+ command_window->SetHeight(54);
 item_window->SetY(76);
 skill_window->SetY(76);
		}
@@ -631,9 +632,11 @@ void Scene_Battle_Rpg2k3::CreateBattleCommandWindow() {

 SetBattleCommandsDisable(*command_window, actor);

- int height = 80;
+ int height = 55;

+ command_window->SetWidth(88);
 command_window->SetHeight(height);
+
 switch (lcf::Data::battlecommands.battle_type) {

--- src\sprite_actor.cpp ---
@@ -141,6 +141,9 @@ void Sprite_Actor::SetAnimationState(int state, LoopState loop, int animation_id
 if (state == 101) {
 state = 7;
	}
+ bool was_defending = false;
+ if (anim_state == AnimationState_Defending)
+ was_defending = true;

 anim_state = state;

@@ -178,9 +181,18 @@ void Sprite_Actor::SetAnimationState(int state, LoopState loop, int animation_id
 Output::Warning("Invalid battle animation ID {}", animation_id);
 animation.reset();
			} else {
+
+ if (anim_state == AnimationState_Defending) {
+ if (!was_defending) {
 		animation.reset(new BattleAnimationBattler(*battle_anim, { battler }));
 		animation->SetZ(GetZ());
					}
+				}

</diff>
</commit>
================================================================================

<commit>
<details> 
EasyRPG Update - 8mth ago
Description:
none
</details>
<diff>
--- src\game_commonevent.cpp ---
@@ -87,7 +87,7 @@ AsyncOp Game_CommonEvent::Update(bool resume_async) {
void Game_CommonEvent::KillCE() {
 if (interpreter_pp) {
 interpreter_pp->Clear();
- interpreter_pp.reset(new Game_Interpreter_Battle());
+ interpreter_pp.reset(new Game_Interpreter_Battle(true));
	}
}


--- src\game_interpreter.cpp ---
@@ -807,17 +807,6 @@ bool Game_Interpreter::ExecuteCommand(lcf::rpg::EventCommand const& com) {
 return CommandCanUseItem(com);
 case 2057:
 return CommandUseItem(com);
- return CmdSetup<&Game_Interpreter::CommandManiacCallCommand, 6>(com);
- case Cmd::Maniac_GetGameInfo:
- return CmdSetup<&Game_Interpreter::CommandManiacGetGameInfo, 8>(com);
- case Cmd::EasyRpg_SetInterpreterFlag:
- return CmdSetup<&Game_Interpreter::CommandEasyRpgSetInterpreterFlag, 2>(com);
- case Cmd::EasyRpg_ProcessJson:
- return CmdSetup<&Game_Interpreter::CommandEasyRpgProcessJson, 8>(com);
- case Cmd::EasyRpg_CloneMapEvent:
- return CmdSetup<&Game_Interpreter::CommandEasyRpgCloneMapEvent, 10>(com);
- case Cmd::EasyRpg_DestroyMapEvent:
- return CmdSetup<&Game_Interpreter::CommandEasyRpgDestroyMapEvent, 2>(com);
 default:
 return true;
	}
@@ -1722,78 +1711,6 @@ bool Game_Interpreter::CommandChangeLevel(lcf::rpg::EventCommand const& com) { /
 return true;
}

-int Game_Interpreter::ValueOrVariable(int mode, int val) {
- if (mode == 0) {
- return val;

--- src\game_interpreter_battle.cpp ---
@@ -73,7 +73,7 @@ std::unique_ptr<Game_Interpreter_Battle> maniac_interpreter;
Game_Interpreter_Battle::Game_Interpreter_Battle(Span<const lcf::rpg::TroopPage> pages)
	: Game_Interpreter(true), pages(pages), executed(pages.size(), false)
{
- maniac_interpreter.reset(new Game_Interpreter_Battle());
+ maniac_interpreter.reset(new Game_Interpreter_Battle(true));
}

Game_Interpreter_Battle::Game_Interpreter_Battle()
@@ -253,14 +253,6 @@ bool Game_Interpreter_Battle::ExecuteCommand(lcf::rpg::EventCommand const& com)
 return CmdSetup<&Game_Interpreter_Battle::CommandElseBranchBattle, 0>(com);
 case Cmd::EndBranch_B:
 return CmdSetup<&Game_Interpreter_Battle::CommandEndBranchBattle, 0>(com);
- case Cmd::Maniac_ControlBattle:
- return CmdSetup<&Game_Interpreter_Battle::CommandManiacControlBattle, 4>(com);
- case Cmd::Maniac_ControlAtbGauge:
- return CmdSetup<&Game_Interpreter_Battle::CommandManiacControlAtbGauge, 7>(com);
- case Cmd::Maniac_ChangeBattleCommandEx:
- return CmdSetup<&Game_Interpreter_Battle::CommandManiacChangeBattleCommandEx, 2>(com);
- case Cmd::Maniac_GetBattleInfo:
- return CmdSetup<&Game_Interpreter_Battle::CommandManiacGetBattleInfo, 5>(com);
 default:
 return Game_Interpreter::ExecuteCommand(com);
	}
@@ -782,266 +774,6 @@ bool Game_Interpreter_Battle::ProcessManiacSubEvents() {
 return false;
}

--- src\game_strings.cpp ---
@@ -162,12 +162,14 @@ int Game_Strings::Split(Str_Params params, const std::string& delimiter, int str
 params.string_id++;
 components++;
		}
-	} else {
+	}
+ else {
 components = 1;

 if (str.find(delimiter) == std::string::npos) {
 // token not found
-		} else {
+		}
+ else {
 // This works for UTF-8
 std::string token;
 for (auto index = str.find(delimiter); index != std::string::npos; index = str.find(delimiter)) {
@@ -177,7 +179,6 @@ int Game_Strings::Split(Str_Params params, const std::string& delimiter, int str
 components++;
 str.erase(0, index + delimiter.length());
			}
- splits++;
		}
	}


--- src\maniac_patch.cpp ---
@@ -526,15 +526,6 @@ int Process(std::vector<int32_t>::iterator& it, std::vector<int32_t>::iterator e
					}
 return 0;
			}
- case Op::AssignInplace:
-
- Output::Debug("EasyRPG : WIP command (v[Z] = v[X]=YYY )");
- ++it;
- imm = process(it, end, ip);
- imm2 = process(it, end, ip);
- Main_Data::game_variables->Set(imm, imm2);
- return Main_Data::game_variables->Get(imm);
-
 default:
 Output::Warning("Maniac: Expression contains unsupported operation {}", static_cast<int>(op));
 return 0;
</diff>
</commit>
================================================================================


<commit>
<details> 
Test BR - 9mth ago
Description:
none
</details>
<diff>
--- src\game_actor.cpp ---
@@ -934,6 +934,8 @@ void Game_Actor::ChangeBattleCommands(bool add, int id) {
 data.changed_battle_commands = true;
	}

+ need_refresh_commands = true;
+
 // The battle commands array always has a size of 7 padded with -1. The last element before the padding is 0 which
 // stands for the Row command
 if (add) {

--- src\game_actor.h ---
@@ -930,6 +930,8 @@ public:

 int GetActorAi() const;

+ bool need_refresh_commands;
+
private:
 void AdjustEquipmentStates(const lcf::rpg::Item* item, bool add, bool allow_battle_states);
 void Fixup();

--- src\game_battle.cpp ---
@@ -45,6 +45,7 @@ namespace Game_Battle {
 std::string background_name;

 std::unique_ptr<Game_Interpreter_Battle> interpreter;
+ std::unique_ptr<Game_Interpreter_Battle> interpreter_pp;
 /** Contains battle related sprites */
 std::unique_ptr<Spriteset_Battle> spriteset;

@@ -73,6 +74,7 @@ void Game_Battle::Init(int troop_id) {
 Main_Data::game_actors->ResetBattle();

 interpreter.reset(new Game_Interpreter_Battle(troop->pages));
+ interpreter_pp.reset(new Game_Interpreter_Battle(troop->pages));
 spriteset.reset(new Spriteset_Battle(background_name, terrain_id));
 spriteset->Update();
 animation_actors.reset();
@@ -90,6 +92,7 @@ void Game_Battle::Quit() {
	}

 interpreter.reset();
+ interpreter_pp.reset();
 spriteset.reset();
 animation_actors.reset();
 animation_enemies.reset();
@@ -238,9 +241,12 @@ void Game_Battle::UpdateAtbGauges() {
 Main_Data::game_variables->Set(Var_ID + 2, cur_atb);
 Main_Data::game_variables->Set(Var_ID + 3, increment);

+ // TODO
 Game_CommonEvent* ce = Game_Battle::StartCommonEventID(CE_ID);
 ce->UpdateBattle(true, CE_ID);
- Game_Battle::GetInterpreter().Clear();
+ ce->KillCE();
+ Game_Battle::interpreter_pp->RemoveCommonEventID(CE_ID);

--- src\game_battle.h ---
@@ -123,6 +123,7 @@ namespace Game_Battle {
 * @return the game interpreter.
 */
 Game_Interpreter& GetInterpreter();
+ Game_Interpreter& GetInterpreter_pp();

 /**
 * Gets the battle game interpreter.

--- src\game_battlealgorithm.cpp ---
@@ -445,9 +445,8 @@ void Game_BattleAlgorithm::AlgorithmBase::Start() {

 // Actions Var

- Game_CommonEvent* ce = Game_Battle::StartCommonEventID(CE_ID);
+ auto ce = Game_Battle::StartCommonEventID(CE_ID);
 ce->UpdateBattle(true, CE_ID);
- Game_Battle::GetInterpreter().Clear();

 int v = ManiacsBattle::Get_TargetVar() + 4;
 int target_type = Main_Data::game_variables->Get(v);

--- src\game_battler.cpp ---
@@ -350,9 +350,8 @@ bool Game_Battler::AddState(int state_id, bool allow_battle_states) {
 Main_Data::game_variables->Set(Var_ID + 1, index);
 Main_Data::game_variables->Set(Var_ID + 2, state_id);

- Game_CommonEvent* ce = Game_Battle::StartCommonEventID(CE_ID);
+ auto ce = Game_Battle::StartCommonEventID(CE_ID);
 ce->UpdateBattle(true, CE_ID);
- Game_Battle::GetInterpreter().Clear();

 int v = Var_ID + 2;
 state_id = Main_Data::game_variables->Get(v);
@@ -552,10 +551,8 @@ int Game_Battler::ChangeSp(int sp) {
 Main_Data::game_variables->Set(Var_ID + 5, sp);


- Game_CommonEvent* ce = Game_Battle::StartCommonEventID(CE_ID);
-
+ auto ce = Game_Battle::StartCommonEventID(CE_ID);
 ce->UpdateBattle(true, CE_ID);
- Game_Battle::GetInterpreter().Clear();

 sp = Main_Data::game_variables->Get(Var_ID + 5);

@@ -826,9 +823,8 @@ int Game_Battler::ChangeAtkModifier(int modifier) {
 Main_Data::game_variables->Set(Var_ID + 5, delta);


- Game_CommonEvent* ce = Game_Battle::StartCommonEventID(CE_ID);
+ auto ce = Game_Battle::StartCommonEventID(CE_ID);
 ce->UpdateBattle(true, CE_ID);

--- src\game_commonevent.cpp ---
@@ -31,7 +31,7 @@ Game_CommonEvent::Game_CommonEvent(int common_event_id) :
{
 auto* ce = lcf::ReaderUtil::GetElement(lcf::Data::commonevents, common_event_id);

- if (ce->trigger == lcf::rpg::EventPage::Trigger_parallel
+ if ((ce->trigger == lcf::rpg::EventPage::Trigger_parallel)// || ce->trigger == 7 || ce->trigger == 6)
 && !ce->event_commands.empty()) {
 interpreter.reset(new Game_Interpreter_Map());
 interpreter->Push(this);
@@ -43,12 +43,19 @@ Game_CommonEvent::Game_CommonEvent(int common_event_id) :
void Game_CommonEvent::ForceCreate(int ce_ID) {
 auto* ce = lcf::ReaderUtil::GetElement(lcf::Data::commonevents, ce_ID);

- if ((ce->trigger == lcf::rpg::EventPage::Trigger_parallel || ce->ID == ManiacsBattle::Get_ATBCE() || ce->ID == ManiacsBattle::Get_TargetCE() ||
+ if ((ce->trigger == lcf::rpg::EventPage::Trigger_parallel || ce->trigger == 7 || ce->trigger == 6 || ce->ID == ManiacsBattle::Get_ATBCE() || ce->ID == ManiacsBattle::Get_TargetCE() ||
 ce->ID == ManiacsBattle::Get_DamageCE() || ce->ID == ManiacsBattle::Get_StateCE() || ce->ID == ManiacsBattle::Get_StatsCE())
 && !ce->event_commands.empty())
	{
- interpreter.reset(new Game_Interpreter_Map());
- interpreter->Push(this);
+ bool main_flag = false;
+ /*	main_flag = true;
+ if (ce->trigger != 7)
+ main_flag = false;*/
+

--- src\game_commonevent.h ---
@@ -26,6 +26,7 @@
#include <lcf/rpg/saveeventexecstate.h>
#include "async_op.h"
#include "string_view.h"
+#include <game_interpreter_battle.h>

/**
 * Game_CommonEvent class.
@@ -54,7 +55,9 @@ public:
 */
 AsyncOp Update(bool resume_async);

- AsyncOp Game_CommonEvent::UpdateBattle(bool resume_async, int ce_ID);
+ AsyncOp UpdateBattle(bool resume_async, int ce_ID);
+
+ void KillCE();

 /**
 * Gets common event index.
@@ -121,6 +124,7 @@ private:

 /** Interpreter for parallel common events. */
 std::unique_ptr<Game_Interpreter_Map> interpreter;
+ std::unique_ptr<Game_Interpreter_Battle> interpreter_pp;
};

#endif

--- src\game_interpreter.cpp ---
@@ -68,6 +68,8 @@
#include "baseui.h"
#include "algo.h"
#include "rand.h"
+#include <game_maniacs.h>
+#include <scene_battle.h>

enum BranchSubcommand {
 eOptionBranchElse = 1
@@ -108,6 +110,7 @@ void Game_Interpreter::Push(
 return;
	}

+ // Output::Debug("Limit : {}", (int)_state.stack.size());
 if ((int)_state.stack.size() > call_stack_limit) {
 Output::Error("Call Event limit ({}) has been exceeded", call_stack_limit);
	}
@@ -421,9 +424,13 @@ void Game_Interpreter::Update(bool reset_loop_count) {
 break;
			}

- if (!Input::IsTriggered(Input::DECISION)) {
+ /*if (!Input::IsTriggered(Input::DECISION)) {
+ break;
+ }*/
+ if (!Input::IsAnyTriggered()) {
 break;
			}
+
 _state.wait_key_enter = false;
		}

@@ -489,7 +496,7 @@ void Game_Interpreter::Update(bool reset_loop_count) {

 if (Game_Battle::IsBattleRunning() && Player::IsRPG2k3() && Game_Battle::CheckWin()) {

--- src\game_interpreter.h ---
@@ -290,6 +290,16 @@ protected:
 bool CommandManiacControlStrings(lcf::rpg::EventCommand const& com);
 bool CommandManiacCallCommand(lcf::rpg::EventCommand const& com);

+ bool CommandManiacGetBattleInfo(lcf::rpg::EventCommand const& com);
+ bool CommandManiacControlBattle(lcf::rpg::EventCommand const& com);
+ bool CommandManiacControlAtbGauge(lcf::rpg::EventCommand const& com);
+ bool CommandManiacChangeBattleCommandEx(lcf::rpg::EventCommand const& com);
+
+ bool CommandGetStringFromDB(lcf::rpg::EventCommand const& com);
+ bool CommandUseItem(lcf::rpg::EventCommand const& com);
+ bool CommandCanUseItem(lcf::rpg::EventCommand const& com);
+ bool CommandPrint(lcf::rpg::EventCommand const& com);
+
 int DecodeInt(lcf::DBArray<int32_t>::const_iterator& it);
 const std::string DecodeString(lcf::DBArray<int32_t>::const_iterator& it);
 lcf::rpg::MoveCommand DecodeMove(lcf::DBArray<int32_t>::const_iterator& it);

--- src\game_interpreter_battle.cpp ---
@@ -43,6 +43,11 @@ Game_Interpreter_Battle::Game_Interpreter_Battle(Span<const lcf::rpg::TroopPage>
{
}

+Game_Interpreter_Battle::Game_Interpreter_Battle(bool main_flag)
+	: Game_Interpreter(main_flag)
+{
+}
+
bool Game_Interpreter_Battle::AreConditionsMet(const lcf::rpg::TroopPageCondition& condition, Game_Battler* source) {
 if (!condition.flags.switch_a &&
 !condition.flags.switch_b &&
@@ -458,9 +463,14 @@ bool Game_Interpreter_Battle::CommandShowBattleAnimation(lcf::rpg::EventCommand

 if (allies) {
 // Allies counted from 1
- target -= 1;
- if (target >= 0 && target < Main_Data::game_party->GetBattlerCount()) {
+ //target -= 1;
+ // ??? The editor display all actors, and not only Actors in party

--- src\game_interpreter_battle.h ---
+ explicit Game_Interpreter_Battle(bool main_flag = false);

 int GetNumPages() const;

@@ -60,6 +61,7 @@ public:

 Game_CommonEvent* StartCommonEvent(int i);
 void PushCommonEvent(Game_CommonEvent* ev);
+ void RemoveCommonEventID(int eventID);

 bool ExecuteCommand(lcf::rpg::EventCommand const& com) override;

@@ -78,10 +80,6 @@ private:
 bool CommandElseBranchBattle(lcf::rpg::EventCommand const& com);
 bool CommandEndBranchBattle(lcf::rpg::EventCommand const& com);

- bool CommandManiacControlBattle(lcf::rpg::EventCommand const& com);
- bool CommandManiacControlAtbGauge(lcf::rpg::EventCommand const& com);
- bool CommandManiacChangeBattleCommandEx(lcf::rpg::EventCommand const& com);
- bool CommandManiacGetBattleInfo(lcf::rpg::EventCommand const& com);

private:
 Span<const lcf::rpg::TroopPage> pages;

--- src\game_interprete…ntrol_variables.cpp ---
@@ -134,7 +134,7 @@ int ControlVariables::Actor(int op, int actor_id) {
 case 16:
 // ATB
 if (Player::IsPatchManiac()) {
- return actor->GetAtbGauge();
+ return actor->GetAtbGauge() * 100 / actor->GetMaxAtbGauge();
			}
 break;
	}
@@ -349,7 +349,7 @@ int ControlVariables::Enemy(int op, int enemy_idx) {
 case 9:
 // ATB
 if (Player::IsPatchManiac()) {
- return enemy->GetAtbGauge();
+ return enemy->GetAtbGauge() * 100 / enemy->GetMaxAtbGauge();
			}
 break;
	}

--- src\game_map.cpp ---
@@ -157,8 +157,9 @@ int Game_Map::GetMapSaveCount() {
void Game_Map::Setup(std::unique_ptr<lcf::rpg::Map> map_in) {
 Dispose();

- screen_width = (Player::screen_width / 16) * SCREEN_TILE_SIZE;
- screen_height = (Player::screen_height / 16) * SCREEN_TILE_SIZE;
+ int screen_mod = Player::screen_width % 8;
+ screen_width = (Player::screen_width / 8 + screen_mod) * SCREEN_TILE_SIZE / 2;
+ screen_height = (Player::screen_height / 8) * SCREEN_TILE_SIZE / 2;

 map = std::move(map_in);


--- src\game_strings.cpp ---
@@ -141,6 +141,7 @@ int Game_Strings::Split(Str_Params params, const std::string& delimiter, int str
 splits++;
 str.erase(0, index + delimiter.length());
			}
+ splits++;
		}
	}


--- src\game_strings.h ---
@@ -72,8 +72,9 @@ public:
 static std::optional<std::string> ManiacsCommandInserter(char ch, const char** iter, const char* end, uint32_t escape_char);
 static std::optional<std::string> ManiacsCommandInserterHex(char ch, const char** iter, const char* end, uint32_t escape_char);

-private:
 void Set(Str_Params params, StringView string);
+private:
+ //void Set(Str_Params params, StringView string);
 bool ShouldWarn(int id) const;
 void WarnGet(int id) const;


--- src\maniac_patch.cpp ---
@@ -407,6 +407,15 @@ int process(std::vector<int32_t>::iterator& it, std::vector<int32_t>::iterator e
					}
 return 0;
			}
+ case Op::AssignInplace:
+
+ Output::Debug("EasyRPG : WIP command (v[Z] = v[X]=YYY )");
+ ++it;
+ imm = process(it, end, ip);
+ imm2 = process(it, end, ip);
+ Main_Data::game_variables->Set(imm, imm2);
+ return Main_Data::game_variables->Get(imm);
+
 default:
 Output::Warning("Maniac: Expression contains unsupported operation {}", static_cast<int>(op));
 return 0;

--- src\scene_battle.cpp ---
@@ -137,7 +137,6 @@ void Scene_Battle::Start() {

 SetState(State_Start);

- Game_Battle::StartCommonEvent(1);
}

void Scene_Battle::InitEscapeChance() {

--- src\scene_battle_rpg2k3.cpp ---
@@ -351,7 +351,8 @@ void Scene_Battle_Rpg2k3::CreateUi() {
 status_window->SetY(y);

 if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_gauge) {
- command_window->SetY(Player::screen_height / 2 - 80 / 2 + 12);
+ command_window->SetY(185);
+ command_window->SetHeight(54);
 item_window->SetY(76);
 skill_window->SetY(76);
		}
@@ -631,9 +632,11 @@ void Scene_Battle_Rpg2k3::CreateBattleCommandWindow() {

 SetBattleCommandsDisable(*command_window, actor);

- int height = 80;
+ int height = 55;

+ command_window->SetWidth(88);
 command_window->SetHeight(height);
+
 switch (lcf::Data::battlecommands.battle_type) {

--- src\sprite_actor.cpp ---
@@ -141,6 +141,9 @@ void Sprite_Actor::SetAnimationState(int state, LoopState loop, int animation_id
 if (state == 101) {
 state = 7;
	}
+ bool was_defending = false;
+ if (anim_state == AnimationState_Defending)
+ was_defending = true;

 anim_state = state;

@@ -178,9 +181,18 @@ void Sprite_Actor::SetAnimationState(int state, LoopState loop, int animation_id
 Output::Warning("Invalid battle animation ID {}", animation_id);
 animation.reset();
			} else {
+
+ if (anim_state == AnimationState_Defending) {
+ if (!was_defending) {
 		animation.reset(new BattleAnimationBattler(*battle_anim, { battler }));
 		animation->SetZ(GetZ());
					}
+				}

</diff>
</commit>
================================================================================

<commit>
<details> 
EasyRPG Update - 8mth ago
Description:
none
</details>
<diff>
--- src\game_commonevent.cpp ---
@@ -87,7 +87,7 @@ AsyncOp Game_CommonEvent::Update(bool resume_async) {
void Game_CommonEvent::KillCE() {
 if (interpreter_pp) {
 interpreter_pp->Clear();
- interpreter_pp.reset(new Game_Interpreter_Battle());
+ interpreter_pp.reset(new Game_Interpreter_Battle(true));
	}
}


--- src\game_interpreter.cpp ---
@@ -807,17 +807,6 @@ bool Game_Interpreter::ExecuteCommand(lcf::rpg::EventCommand const& com) {
 return CommandCanUseItem(com);
 case 2057:
 return CommandUseItem(com);
- return CmdSetup<&Game_Interpreter::CommandManiacCallCommand, 6>(com);
- case Cmd::Maniac_GetGameInfo:
- return CmdSetup<&Game_Interpreter::CommandManiacGetGameInfo, 8>(com);
- case Cmd::EasyRpg_SetInterpreterFlag:
- return CmdSetup<&Game_Interpreter::CommandEasyRpgSetInterpreterFlag, 2>(com);
- case Cmd::EasyRpg_ProcessJson:
- return CmdSetup<&Game_Interpreter::CommandEasyRpgProcessJson, 8>(com);
- case Cmd::EasyRpg_CloneMapEvent:
- return CmdSetup<&Game_Interpreter::CommandEasyRpgCloneMapEvent, 10>(com);
- case Cmd::EasyRpg_DestroyMapEvent:
- return CmdSetup<&Game_Interpreter::CommandEasyRpgDestroyMapEvent, 2>(com);
 default:
 return true;
	}
@@ -1722,78 +1711,6 @@ bool Game_Interpreter::CommandChangeLevel(lcf::rpg::EventCommand const& com) { /
 return true;
}

-int Game_Interpreter::ValueOrVariable(int mode, int val) {
- if (mode == 0) {
- return val;

--- src\game_interpreter_battle.cpp ---
@@ -73,7 +73,7 @@ std::unique_ptr<Game_Interpreter_Battle> maniac_interpreter;
Game_Interpreter_Battle::Game_Interpreter_Battle(Span<const lcf::rpg::TroopPage> pages)
	: Game_Interpreter(true), pages(pages), executed(pages.size(), false)
{
- maniac_interpreter.reset(new Game_Interpreter_Battle());
+ maniac_interpreter.reset(new Game_Interpreter_Battle(true));
}

Game_Interpreter_Battle::Game_Interpreter_Battle()
@@ -253,14 +253,6 @@ bool Game_Interpreter_Battle::ExecuteCommand(lcf::rpg::EventCommand const& com)
 return CmdSetup<&Game_Interpreter_Battle::CommandElseBranchBattle, 0>(com);
 case Cmd::EndBranch_B:
 return CmdSetup<&Game_Interpreter_Battle::CommandEndBranchBattle, 0>(com);
- case Cmd::Maniac_ControlBattle:
- return CmdSetup<&Game_Interpreter_Battle::CommandManiacControlBattle, 4>(com);
- case Cmd::Maniac_ControlAtbGauge:
- return CmdSetup<&Game_Interpreter_Battle::CommandManiacControlAtbGauge, 7>(com);
- case Cmd::Maniac_ChangeBattleCommandEx:
- return CmdSetup<&Game_Interpreter_Battle::CommandManiacChangeBattleCommandEx, 2>(com);
- case Cmd::Maniac_GetBattleInfo:
- return CmdSetup<&Game_Interpreter_Battle::CommandManiacGetBattleInfo, 5>(com);
 default:
 return Game_Interpreter::ExecuteCommand(com);
	}
@@ -782,266 +774,6 @@ bool Game_Interpreter_Battle::ProcessManiacSubEvents() {
 return false;
}

--- src\game_strings.cpp ---
@@ -162,12 +162,14 @@ int Game_Strings::Split(Str_Params params, const std::string& delimiter, int str
 params.string_id++;
 components++;
		}
-	} else {
+	}
+ else {
 components = 1;

 if (str.find(delimiter) == std::string::npos) {
 // token not found
-		} else {
+		}
+ else {
 // This works for UTF-8
 std::string token;
 for (auto index = str.find(delimiter); index != std::string::npos; index = str.find(delimiter)) {
@@ -177,7 +179,6 @@ int Game_Strings::Split(Str_Params params, const std::string& delimiter, int str
 components++;
 str.erase(0, index + delimiter.length());
			}
- splits++;
		}
	}


--- src\maniac_patch.cpp ---
@@ -526,15 +526,6 @@ int Process(std::vector<int32_t>::iterator& it, std::vector<int32_t>::iterator e
					}
 return 0;
			}
- case Op::AssignInplace:
-
- Output::Debug("EasyRPG : WIP command (v[Z] = v[X]=YYY )");
- ++it;
- imm = process(it, end, ip);
- imm2 = process(it, end, ip);
- Main_Data::game_variables->Set(imm, imm2);
- return Main_Data::game_variables->Get(imm);
-
 default:
 Output::Warning("Maniac: Expression contains unsupported operation {}", static_cast<int>(op));
 return 0;
</diff>
</commit>
================================================================================



/*end of file .\beloved_bad_commits.txt*/

/*start of file .\algo.cpp*/

/* ... license chunk ... */
#include "algo.h"
#include "game_battler.h"
#include "game_actor.h"
#include "game_enemy.h"
#include "game_system.h"
#include "main_data.h"
#include "game_player.h"
#include "game_targets.h"
#include "game_battle.h"
#include "attribute.h"
#include "player.h"
#include "rand.h"
#include <lcf/rpg/skill.h>
#include <lcf/reader_util.h>
#include "feature.h"

#include <algorithm>

namespace Algo {

bool IsRowAdjusted(lcf::rpg::SaveActor::RowType row, lcf::rpg::System::BattleCondition cond, bool offense) {
	return (cond == lcf::rpg::System::BattleCondition_surround
			|| (row != static_cast<int>(offense)
				&& (cond == lcf::rpg::System::BattleCondition_none || cond == lcf::rpg::System::BattleCondition_initiative))
			|| (row == static_cast<int>(offense)
				&& (cond == lcf::rpg::System::BattleCondition_back))
		   );
}

bool IsRowAdjusted(const Game_Battler& battler, lcf::rpg::System::BattleCondition cond, bool offense, bool allow_enemy) {
	lcf::rpg::SaveActor::RowType row = lcf::rpg::SaveActor::RowType_front;
	if (battler.GetType() == Game_Battler::Type_Ally) {
		row = static_cast<const Game_Actor&>(battler).GetBattleRow();
	}

	if (battler.GetType() == Game_Battler::Type_Ally || allow_enemy) {
		return IsRowAdjusted(row, cond, offense);
	}
	return false;
}

static int CalcToHitAgiAdjustment(int to_hit, const Game_Battler& source, const Game_Battler& target, Game_Battler::Weapon weapon) {
	// NOTE: RPG_RT 2k3 has a bug where if the source is an actor with a selected weapon, the agi
	// calculation calls a bespoke function which doesn't consider states which can cause half or double AGI.
	const float src_agi = std::max(1, source.GetAgi(weapon));
	const float tgt_agi = target.GetAgi();

	return 100 - (100 - to_hit) * (1.0f + (tgt_agi / src_agi - 1.0f) / 2.0f);
}

int CalcNormalAttackToHit(const Game_Battler &source,
		const Game_Battler &target,
		Game_Battler::Weapon weapon,
		lcf::rpg::System::BattleCondition cond,
		bool emulate_2k3_enemy_row_bug) {
	auto to_hit = source.GetHitChance(weapon);

	// If target has rm2k3 state which grants 100% dodge.
	if (target.EvadesAllPhysicalAttacks()) {
		return 0;
	}

	// If target has Restriction "do_nothing", the attack always hits
	if (!target.CanAct()) {
		return 100;
	}

	// Modify hit chance for each state the source has
	to_hit = (to_hit * source.GetHitChanceModifierFromStates()) / 100;

	// Stop here if attacker ignores evasion.
	if (source.AttackIgnoresEvasion(weapon)) {
		return to_hit;
	}

	// AGI adjustment.
	to_hit = CalcToHitAgiAdjustment(to_hit, source, target, weapon);

	// If target has physical dodge evasion:
	if (target.HasPhysicalEvasionUp()) {
		to_hit -= 25;
	}

	// Defender row adjustment
	if (Feature::HasRow() && IsRowAdjusted(target, cond, false, emulate_2k3_enemy_row_bug)) {
		to_hit -= 25;
	}

	return to_hit;
}


int CalcSkillToHit(const Game_Battler& source, const Game_Battler& target, const lcf::rpg::Skill& skill, lcf::rpg::System::BattleCondition cond, bool emulate_2k3_enemy_row_bug) {
	auto to_hit = (skill.hit == -1 ? source.GetHitChance(Game_Battler::WeaponAll) : skill.hit);

	if (!SkillTargetsAllies(skill) && skill.easyrpg_affected_by_evade_all_physical_attacks && target.EvadesAllPhysicalAttacks()) {
		return 0;
	}

	// RPG_RT BUG: rm2k3 editor doesn't let you set the failure message for skills, and so you can't make them physical type anymore.
	// Despite that, RPG_RT still checks the flag and run the below code?
	if (skill.failure_message != 3 || SkillTargetsAllies(skill)) {
		return to_hit;
	}

	// RPG_RT BUG: RPG_RT 2k3 does not check for "EvadesAllPhysicaAttacks() states here

	// If target has Restriction "do_nothing", the attack always hits
	if (!target.CanAct()) {
		return 100;
	}

	// Modify hit chance for each state the source has
	to_hit = (to_hit * source.GetHitChanceModifierFromStates()) / 100;

	// Stop here if attacker ignores evasion.
	if (source.AttackIgnoresEvasion(Game_Battler::WeaponAll)) {
		return to_hit;
	}

	// AGI adjustment.
	to_hit = CalcToHitAgiAdjustment(to_hit, source, target, Game_Battler::WeaponAll);

	// If target has physical dodge evasion:
	if (target.HasPhysicalEvasionUp()) {
		to_hit -= 25;
	}

	// Defender row adjustment
	if (Feature::HasRow() && skill.easyrpg_affected_by_row_modifiers && IsRowAdjusted(target, cond, false, emulate_2k3_enemy_row_bug)) {
		to_hit -= 25;
	}

	return to_hit;
}

int CalcCriticalHitChance(const Game_Battler& source, const Game_Battler& target, Game_Battler::Weapon weapon, int fixed_chance) {
	auto crit_chance = (fixed_chance < 0 ? static_cast<int>(source.GetCriticalHitChance(weapon) * 100.0) : fixed_chance);
	if (target.PreventsCritical()) {
		crit_chance = 0;
	}
	if (source.GetType() == target.GetType()) {
		crit_chance = 0;
	}
	return crit_chance;
}

int VarianceAdjustEffect(int base, int var) {
	// FIXME: RPG_RT 2k3 doesn't apply variance if negative attribute flips damage
	if (var > 0 && (base > 0 || Player::IsLegacy())) {
		int adj = std::max(1, var * base / 10);
		return base + Rand::GetRandomNumber(0, adj) - adj / 2;
	}
	return base;
}

int AdjustDamageForDefend(int dmg, const Game_Battler& target) {
	if (RuntimePatches::GuardRevamp::OverrideDamageAdjustment(dmg, target)) {
		return dmg;
	}
	if (target.IsDefending()) {
		dmg /= 2;
		if (target.HasStrongDefense()) {
			dmg /= 2;
		}
	}
	return dmg;
}

int CalcNormalAttackEffect(const Game_Battler& source,
		const Game_Battler& target,
		Game_Battler::Weapon weapon,
		bool is_critical_hit,
		bool is_charged,
		bool apply_variance,
		lcf::rpg::System::BattleCondition cond,
		bool emulate_2k3_enemy_row_bug)
{
	const auto atk = source.GetAtk(weapon);
	const auto def = target.GetDef();

	// Base damage
	auto dmg = std::max(0, atk / 2 - def / 4);

	// Attacker row adjustment
	if (Feature::HasRow() && IsRowAdjusted(source, cond, true, false)) {
		dmg = 125 * dmg / 100;
	}

	// Attacker weapon attribute adjustment
	dmg = Attribute::ApplyAttributeNormalAttackMultiplier(dmg, source, target, weapon);

	// Defender row adjustment
	if (Feature::HasRow() && IsRowAdjusted(target, cond, false, emulate_2k3_enemy_row_bug)) {
		dmg = 75 * dmg / 100;
	}

	// Critical and charge adjustment
	if (is_critical_hit) {
		dmg *= 3;
	} else if (is_charged) {
		dmg *= 2;
	}

	if (apply_variance) {
		dmg = VarianceAdjustEffect(dmg, 4);
	}

	return dmg;
}

int CalcSkillEffect(const Game_Battler& source,
		const Game_Battler& target,
		const lcf::rpg::Skill& skill,
		bool apply_variance,
		bool is_critical_hit,
		lcf::rpg::System::BattleCondition cond,
		bool emulate_2k3_enemy_row_bug) {

	auto effect = skill.power;
	effect += skill.physical_rate * source.GetAtk() / 20;
	effect += skill.magical_rate * source.GetSpi() / 40;

	if (SkillTargetsEnemies(skill) && !skill.ignore_defense) {
		effect -= skill.physical_rate * target.GetDef() / 40;
		effect -= skill.magical_rate * target.GetSpi() / 80;
	}

	effect = std::max<int>(0, effect);

	if (Feature::HasRow() && skill.easyrpg_affected_by_row_modifiers && IsRowAdjusted(source, cond, true, false)) {
		effect = 125 * effect / 100;
	}

	effect = Attribute::ApplyAttributeSkillMultiplier(effect, target, skill);

	if (Feature::HasRow() && skill.easyrpg_affected_by_row_modifiers && IsRowAdjusted(target, cond, false, emulate_2k3_enemy_row_bug)) {
		effect = 75 * effect / 100;
	}

	if (is_critical_hit) {
		effect *= 3;
	}

	if (apply_variance) {
		effect = VarianceAdjustEffect(effect, skill.variance);
	}

	return effect;
}

int CalcSelfDestructEffect(const Game_Battler& source,
		const Game_Battler& target,
		bool apply_variance) {

	auto effect = source.GetAtk() - target.GetDef() / 2;
	effect = std::max<int>(0, effect);

	if (apply_variance) {
		effect = VarianceAdjustEffect(effect, 4);
	}

	return effect;
}

int CalcSkillCost(const lcf::rpg::Skill& skill, int max_sp, bool half_sp_cost) {
	const auto div = half_sp_cost ? 2 : 1;
	return (Player::IsRPG2k3() && skill.sp_type == lcf::rpg::Skill::SpType_percent)
		? max_sp * skill.sp_percent / 100 / div
		: (skill.sp_cost + static_cast<int>(half_sp_cost)) / div;
}

int CalcSkillHpCost(const lcf::rpg::Skill& skill, int max_hp) {
	return (Player::IsRPG2k3() && skill.easyrpg_hp_type == lcf::rpg::Skill::HpType_percent)
		? std::min<int>(max_hp - 1, max_hp * skill.easyrpg_hp_percent / 100)
		: skill.easyrpg_hp_cost;
}

bool IsSkillUsable(const lcf::rpg::Skill& skill,
		bool require_states_persist)
{
	const auto in_battle = Game_Battle::IsBattleRunning();

	if (skill.type == lcf::rpg::Skill::Type_escape) {
		return !in_battle && Main_Data::game_system->GetAllowEscape() && Main_Data::game_targets->HasEscapeTarget() && !Main_Data::game_player->IsFlying();
	}

	if (skill.type == lcf::rpg::Skill::Type_teleport) {
		return !in_battle && Main_Data::game_system->GetAllowTeleport() && Main_Data::game_targets->HasTeleportTargets() && !Main_Data::game_player->IsFlying();
	}

	if (skill.type == lcf::rpg::Skill::Type_switch) {
		return in_battle ? skill.occasion_battle : skill.occasion_field;
	}

	if (in_battle) {
		return true;
	}

	if (SkillTargetsEnemies(skill)) {
		return false;
	}

	if (skill.affect_hp || skill.affect_sp) {
		return true;
	}

	bool affects_state = false;
	for (int i = 0; i < static_cast<int>(skill.state_effects.size()); ++i) {
		const bool inflict = skill.state_effects[i];
		if (inflict) {
			const auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, i + 1);
			if (state && (!require_states_persist || state->type == lcf::rpg::State::Persistence_persists)) {
				affects_state = true;
				break;
			}
		}
	}

	return affects_state;
}

int GetNumberOfAttacks(int actor_id, const lcf::rpg::Item& weapon) {
	assert(weapon.type == lcf::rpg::Item::Type_weapon);
	int hits = weapon.dual_attack ? 2 : 1;
	if (Player::IsRPG2k3()) {
		auto& cba = weapon.animation_data;
		if (actor_id >= 1 && actor_id <= static_cast<int>(cba.size())) {
			int cba_hits = cba[actor_id - 1].attacks + 1;
			hits *= cba_hits;
		}
	}
	return hits;
}

} // namespace Algo


/*end of file .\algo.cpp*/

/*start of file .\async_handler.cpp*/

/* ... license chunk ... */

#include <cstdlib>
#include <fstream>
#include <map>

#ifdef EMSCRIPTEN
#  include <emscripten.h>
#  include <lcf/reader_util.h>
#  include <nlohmann/json.hpp>
   using json = nlohmann::json;
#endif

#include "async_handler.h"
#include "cache.h"
#include "filefinder.h"
#include "memory_management.h"
#include "output.h"
#include "player.h"
#include "main_data.h"
#include "utils.h"
#include "transition.h"
#include "rand.h"

// When this option is enabled async requests are randomly delayed.
// This allows testing some aspects of async file fetching locally.
//#define EP_DEBUG_SIMULATE_ASYNC

namespace {
	std::unordered_map<std::string, FileRequestAsync> async_requests;
	std::unordered_map<std::string, std::string> file_mapping;
	int next_id = 0;
#ifdef EMSCRIPTEN
	int index_version = 1;
#endif

	FileRequestAsync* GetRequest(const std::string& path) {
		auto it = async_requests.find(path);

		if (it != async_requests.end()) {
			return &(it->second);
		}
		return nullptr;
	}

	FileRequestAsync* RegisterRequest(std::string path, std::string directory, std::string file)
	{
		auto req = FileRequestAsync(path, std::move(directory), std::move(file));
		auto p = async_requests.emplace(std::make_pair(std::move(path), std::move(req)));
		return &p.first->second;
	}

	FileRequestBinding CreatePending() {
		return std::make_shared<int>(next_id++);
	}

#ifdef EMSCRIPTEN
	constexpr size_t ASYNC_MAX_RETRY_COUNT{ 16 };

	struct async_download_context {
		std::string url, file, param;
		FileRequestAsync* obj;
		size_t count;

		async_download_context(
			std::string u,
			std::string f,
			std::string p,
			FileRequestAsync* o
		) : url{ std::move(u) }, file{ std::move(f) }, param{ std::move(p) }, obj{ o }, count{} {}
	};

	void download_success_retry(unsigned, void* userData, const char*) {
		auto ctx = static_cast<async_download_context*>(userData);
		ctx->obj->DownloadDone(true);
		delete ctx;
	}

	void start_async_wget_with_retry(async_download_context* ctx);

	void download_failure_retry(unsigned, void* userData, int status) {
		auto ctx = static_cast<async_download_context*>(userData);
		++ctx->count;
		if (ctx->count >= ASYNC_MAX_RETRY_COUNT) {
			Output::Warning("DL Failure: max retries exceeded: {}", ctx->obj->GetPath());
			ctx->obj->DownloadDone(false);
			delete ctx;
			return;
		}
		if (status >= 400) {
			Output::Warning("DL Failure: file not available: {}", ctx->obj->GetPath());
			ctx->obj->DownloadDone(false);
			delete ctx;
			return;
		}
		Output::Debug("DL Failure: {}. Retrying", ctx->obj->GetPath());
		start_async_wget_with_retry(ctx);
	}

	void start_async_wget_with_retry(async_download_context* ctx) {
		emscripten_async_wget2(
			ctx->url.data(),
			ctx->file.data(),
			"GET",
			ctx->param.data(),
			ctx,
			download_success_retry,
			download_failure_retry,
			nullptr
		);
	}

	void async_wget_with_retry(
		std::string url,
		std::string file,
		std::string param,
		FileRequestAsync* obj
	) {
		// ctx will be deleted when download succeeds
		auto ctx = new async_download_context{ url, file, param, obj };
		start_async_wget_with_retry(ctx);
	}

#endif
}

void AsyncHandler::CreateRequestMapping(const std::string& file) {
#ifdef EMSCRIPTEN
	auto f = FileFinder::Game().OpenInputStream(file);
	if (!f) {
		Output::Error("Emscripten: Reading index.json failed");
		return;
	}

	json j = json::parse(f, nullptr, false);
	if (j.is_discarded()) {
		Output::Error("Emscripten: index.json is not a valid JSON file");
		return;
	}

	if (j.contains("metadata") && j["metadata"].is_object()) {
		const auto& metadata = j["metadata"];
		if (metadata.contains("version") && metadata["version"].is_number()) {
			index_version = metadata["version"].get<int>();
		}
	}

	Output::Debug("Parsing index.json version {}", index_version);

	if (index_version <= 1) {
		// legacy format
		for (const auto& value : j.items()) {
			file_mapping[value.key()] = value.value().get<std::string>();
		}
	} else {
		using fn = std::function<void(const json&, const std::string&)>;
		fn parse = [&] (const json& obj, const std::string& path) {
			std::string dirname;
			if (obj.contains("_dirname") && obj["_dirname"].is_string()) {
				dirname = obj["_dirname"].get<std::string>();
			}
			dirname = FileFinder::MakePath(path, dirname);

			for (const auto& value : obj.items()) {
				const auto& second = value.value();
				if (second.is_object()) {
					parse(second, dirname);
				} else if (second.is_string()){
					file_mapping[FileFinder::MakePath(Utils::LowerCase(dirname), value.key())] = FileFinder::MakePath(dirname, second.get<std::string>());
				}
			}
		};

		if (j.contains("cache") && j["cache"].is_object()) {
			parse(j["cache"], "");
		}

		// Create some empty DLL files. Engine & patch detection depend on them.
		for (const auto& s : {"harmony.dll", "ultimate_rt_eb.dll", "dynloader.dll", "accord.dll"}) {
			auto it = file_mapping.find(s);
			if (it != file_mapping.end()) {
				FileFinder::Game().OpenOutputStream(s);
			}
		}

		// Look for Meta.ini files and fetch them. They are required for detecting the translations.
		for (const auto& item: file_mapping) {
			if (EndsWith(item.first, "meta.ini")) {
				auto* request = AsyncHandler::RequestFile(item.second);
				request->SetImportantFile(true);
				request->Start();
			}
		}
	}
#else
	// no-op
	(void)file;
#endif
}

void AsyncHandler::ClearRequests() {
	auto it = async_requests.begin();
	while (it != async_requests.end()) {
		if (it->second.IsReady()) {
			it = async_requests.erase(it);
		} else {
			++it;
		}
	}
	async_requests.clear();
}

FileRequestAsync* AsyncHandler::RequestFile(std::string_view folder_name, std::string_view file_name) {
	auto path = FileFinder::MakePath(folder_name, file_name);

	auto* request = GetRequest(path);

	if (request) {
		return request;
	}

	//Output::Debug("Waiting for {}", path);

	return RegisterRequest(std::move(path), std::string(folder_name), std::string(file_name));
}

FileRequestAsync* AsyncHandler::RequestFile(std::string_view file_name) {
	return RequestFile(".", file_name);
}

bool AsyncHandler::IsFilePending(bool important, bool graphic) {
	for (auto& ap: async_requests) {
		FileRequestAsync& request = ap.second;

#ifdef EP_DEBUG_SIMULATE_ASYNC
		request.UpdateProgress();
#endif

		if (!request.IsReady()
				&& (!important || request.IsImportantFile())
				&& (!graphic || request.IsGraphicFile())
				) {
			return true;
		}
	}

	return false;
}

void AsyncHandler::SaveFilesystem() {
#ifdef EMSCRIPTEN
	// Save changed file system
	EM_ASM({
		FS.syncfs(function(err) {
		});
	});
#endif
}

bool AsyncHandler::IsImportantFilePending() {
	return IsFilePending(true, false);
}

bool AsyncHandler::IsGraphicFilePending() {
	return IsFilePending(false, true);
}

FileRequestAsync::FileRequestAsync(std::string path, std::string directory, std::string file) :
	directory(std::move(directory)),
	file(std::move(file)),
	path(std::move(path)),
	state(State_WaitForStart)
{ }

void FileRequestAsync::SetGraphicFile(bool graphic) {
	this->graphic = graphic;
	// We need this flag in order to prevent show screen transitions
	// from starting util all graphical assets are loaded.
	// Also, the screen is erased, so you can't see any delays :)
	if (Transition::instance().IsErasedNotActive()) {
		SetImportantFile(true);
	}
}

void FileRequestAsync::Start() {
	if (file == CACHE_DEFAULT_BITMAP) {
		// Embedded asset -> Fire immediately
		DownloadDone(true);
		return;
	}

	if (state == State_Pending) {
		return;
	}

	if (IsReady()) {
		// Fire immediately
		DownloadDone(true);
		return;
	}

	state = State_Pending;

#ifdef EMSCRIPTEN
	std::string request_path;
#  ifdef EM_GAME_URL
	request_path = EM_GAME_URL;
#  else
	request_path = "games/";
#  endif

	if (!Player::emscripten_game_name.empty()) {
		request_path += Player::emscripten_game_name + "/";
	} else {
		request_path += "default/";
	}

	std::string modified_path;
	if (index_version >= 2) {
		modified_path = lcf::ReaderUtil::Normalize(path);
		modified_path = FileFinder::MakeCanonical(modified_path, 1);
	} else {
		modified_path = Utils::LowerCase(path);
		if (directory != ".") {
			modified_path = FileFinder::MakeCanonical(modified_path, 1);
		} else {
			auto it = file_mapping.find(modified_path);
			if (it == file_mapping.end()) {
				modified_path = FileFinder::MakeCanonical(modified_path, 1);
			}
		}
	}

	if (graphic && Tr::HasActiveTranslation()) {
		std::string modified_path_trans = FileFinder::MakePath(lcf::ReaderUtil::Normalize(Tr::GetCurrentTranslationFilesystem().GetFullPath()), modified_path);
		auto it = file_mapping.find(modified_path_trans);
		if (it != file_mapping.end()) {
			modified_path = modified_path_trans;
		}
	}

	auto it = file_mapping.find(modified_path);
	if (it != file_mapping.end()) {
		request_path += it->second;
	} else {
		if (file_mapping.empty()) {
			// index.json not fetched yet, fallthrough and fetch
			request_path += path;
		} else {
			// Fire immediately (error)
			Output::Debug("{} not in index.json", modified_path);
			DownloadDone(false);
			return;
		}
	}

	// URL encode %, # and +
	request_path = Utils::ReplaceAll(request_path, "%", "%25");
	request_path = Utils::ReplaceAll(request_path, "#", "%23");
	request_path = Utils::ReplaceAll(request_path, "+", "%2B");

	auto request_file = (it != file_mapping.end() ? it->second : path);
	async_wget_with_retry(request_path, std::move(request_file), "", this);
#else
#  ifdef EM_GAME_URL
#    warning EM_GAME_URL set and not an Emscripten build!
#  endif

#  ifndef EP_DEBUG_SIMULATE_ASYNC
	DownloadDone(true);
#  endif
#endif
}

void FileRequestAsync::UpdateProgress() {
#ifndef EMSCRIPTEN
	// Fake download for testing event handlers

	if (!IsReady() && Rand::ChanceOf(1, 100)) {
		DownloadDone(true);
	}
#endif
}

FileRequestBinding FileRequestAsync::Bind(void(*func)(FileRequestResult*)) {
	FileRequestBinding pending = CreatePending();

	listeners.emplace_back(FileRequestBindingWeak(pending), func);

	return pending;
}

FileRequestBinding FileRequestAsync::Bind(std::function<void(FileRequestResult*)> func) {
	FileRequestBinding pending = CreatePending();

	listeners.emplace_back(FileRequestBindingWeak(pending), func);

	return pending;
}

void FileRequestAsync::CallListeners(bool success) {
	FileRequestResult result { directory, file, -1, success };

	for (auto& listener : listeners) {
		if (!listener.first.expired()) {
			result.request_id = *listener.first.lock();
			(listener.second)(&result);
		} else {
			Output::Debug("Request cancelled: {}", GetPath());
		}
	}

	listeners.clear();
}

void FileRequestAsync::DownloadDone(bool success) {
	if (IsReady()) {
		// Change to real success state when already finished before
		success = state == State_DoneSuccess;
	}

	if (success) {
#ifdef EMSCRIPTEN
		if (state == State_Pending) {
			// Update directory structure (new file was added)
			if (FileFinder::Game()) {
				FileFinder::Game().ClearCache();
			}
		}
#endif

		state = State_DoneSuccess;

		CallListeners(true);
	}
	else {
		state = State_DoneFailure;

		CallListeners(false);
	}
}


/*end of file .\async_handler.cpp*/

/*start of file .\attribute.cpp*/

/* ... license chunk ... */
#include "attribute.h"
#include <lcf/rpg/item.h>
#include <lcf/rpg/skill.h>
#include <lcf/rpg/attribute.h>
#include <lcf/reader_util.h>
#include <lcf/data.h>
#include "game_battler.h"
#include "game_actor.h"
#include "game_enemy.h"
#include "output.h"
#include "player.h"
#include <climits>

namespace Attribute {

int GetAttributeRateModifier(int attribute_id, int rate) {
	const auto* attribute = lcf::ReaderUtil::GetElement(lcf::Data::attributes, attribute_id);

	if (!attribute) {
		Output::Warning("GetAttributeRate: Invalid attribute ID {}", attribute_id);
		return 0;
	}

	return GetAttributeRateModifier(*attribute, rate);
}

int GetAttributeRateModifier(const lcf::rpg::Attribute& attr, int rate) {
	switch (rate) {
	case 0:
		return attr.a_rate;
	case 1:
		return attr.b_rate;
	case 2:
		return attr.c_rate;
	case 3:
		return attr.d_rate;
	case 4:
		return attr.e_rate;
	default:
		break;
	}

	return 0;
}

static bool HasAttribute(Span<const lcf::DBBitArray*> attribute_sets, int id) {
	for (auto* as: attribute_sets) {
		const auto idx = id - 1;
		if (idx < static_cast<int>(as->size()) && (*as)[idx]) {
			return true;
		}
	}
	return false;
}

int ApplyAttributeMultiplier(int effect, const Game_Battler& target, Span<const lcf::DBBitArray*> attribute_sets) {
	int physical = INT_MIN;
	int magical = INT_MIN;

	int n = 0;
	for (auto* as: attribute_sets) {
		n = std::max(static_cast<int>(as->size()), n);
	}

	for (int i = 0; i < n; ++i) {
		const auto id = i + 1;

		if (!HasAttribute(attribute_sets, id)) {
			continue;
		}

		const auto* attr = lcf::ReaderUtil::GetElement(lcf::Data::attributes, id);
		if (!attr) {
			Output::Warning("ApplyAttributeMultipler: Invalid attribute ID {}", id);
			break;
		}

		const auto rate = target.GetAttributeRate(id);
		const auto mod = GetAttributeRateModifier(id, rate);
		if (attr->type == lcf::rpg::Attribute::Type_physical) {
			physical = std::max(physical, mod);
		} else {
			magical = std::max(magical, mod);
		}
	}

	// Negative attributes not supported in 2k.
	auto limit = Player::IsRPG2k() ? -1 : INT_MIN;

	if (physical > limit && magical > limit) {
		if (physical >= 0 && magical >= 0) {
			effect = magical * (physical * effect / 100) / 100;
		} else {
			effect = effect * std::max(physical, magical) / 100;
		}
	} else if (physical > limit) {
		effect = physical * effect / 100;
	} else if (magical > limit) {
		effect = magical * effect / 100;
	}
	return effect;
}

int ApplyAttributeNormalAttackMultiplier(int effect, const Game_Battler& source_battler, const Game_Battler& target, Game_Battler::Weapon weapon) {
	if (source_battler.GetType() != Game_Battler::Type_Ally && source_battler.GetType() != Game_Battler::Type_Enemy) {
		return effect;
	}

	std::array<const lcf::DBBitArray*, 2> attribute_sets = {{}};

	size_t n = 0;
	auto add = [&](int i) {
		if (source_battler.GetType() == Game_Battler::Type_Ally) {
			auto& source = static_cast<const Game_Actor&>(source_battler);
			if (source.GetWeapon() == nullptr && source.Get2ndWeapon() == nullptr) {
				lcf::rpg::Actor* allydata = lcf::ReaderUtil::GetElement(lcf::Data::actors, source.GetId());
				attribute_sets[n++] = &allydata->easyrpg_unarmed_attribute_set;
			} else {
				if (weapon == Game_Battler::Weapon(i + 1) || weapon == Game_Battler::WeaponAll) {
					auto* item = source.GetEquipment(i + 1);
					if (item && item->type == lcf::rpg::Item::Type_weapon) {
						attribute_sets[n++] = &item->attribute_set;
					}
				}
			}
		} else if (source_battler.GetType() == Game_Battler::Type_Enemy) {
			auto& source = static_cast<const Game_Enemy&>(source_battler);
			lcf::rpg::Enemy* enemydata = lcf::ReaderUtil::GetElement(lcf::Data::enemies, source.GetId());
			attribute_sets[n++] = &enemydata->easyrpg_attribute_set;
		}
	};

	for (int i = 0; i < static_cast<int>(attribute_sets.size()); ++i) {
		add(i);
	}

	return ApplyAttributeMultiplier(effect, target, Span<const lcf::DBBitArray*>(attribute_sets.data(), n));
}

int ApplyAttributeSkillMultiplier(int effect, const Game_Battler& target, const lcf::rpg::Skill& skill) {
	auto attribute_sets = Utils::MakeArray(&skill.attribute_effects);
	return ApplyAttributeMultiplier(effect, target, MakeSpan(attribute_sets));
}

} // namespace Attribute


/*end of file .\attribute.cpp*/

/*start of file .\audio.cpp*/

/* ... license chunk ... */

// Headers
#include "audio.h"
#include "audio_midi.h"
#include "system.h"
#include "baseui.h"
#include "player.h"
#include "game_clock.h"

AudioInterface& Audio() {
	static Game_ConfigAudio cfg;
	static EmptyAudio default_(cfg);
#ifdef SUPPORT_AUDIO
	if (!Player::no_audio_flag && DisplayUi)
		return DisplayUi->GetAudio();
#endif
	return default_;
}

void EmptyAudio::BGM_Play(Filesystem_Stream::InputStream, int, int, int, int) {
	bgm_starttick = Player::GetFrames();
	playing = true;
}

void EmptyAudio::BGM_Stop() {
	playing = false;
}

int EmptyAudio::BGM_GetTicks() const {
	if (!playing) {
		return 0;
	}

	// Time since BGM_Play was called, works for everything except MIDI
	return (Player::GetFrames() - bgm_starttick + 1) / Game_Clock::GetTargetGameFps();
}

void EmptyAudio::vGetConfig(Game_ConfigAudio&) const {
	// Not supported. The audio menu is disabled.
}

bool EmptyAudio::BGM_PlayedOnce() const {
	// 5 seconds, arbitrary
	return BGM_GetTicks() > (Game_Clock::GetTargetGameFps() * 5);
}

EmptyAudio::EmptyAudio(const Game_ConfigAudio& cfg) : AudioInterface(cfg) {

}

AudioInterface::AudioInterface(const Game_ConfigAudio& cfg) : cfg(cfg) {

}

Game_ConfigAudio AudioInterface::GetConfig() const {
	auto acfg = cfg;
	acfg.Hide();

#if !defined(HAVE_FLUIDSYNTH) && !defined(HAVE_FLUIDLITE)
	acfg.fluidsynth_midi.SetOptionVisible(false);
	acfg.soundfont.SetOptionVisible(false);
#endif
#ifndef HAVE_LIBWILDMIDI
	acfg.wildmidi_midi.SetOptionVisible(false);
#endif
#ifndef HAVE_NATIVE_MIDI
	acfg.native_midi.SetOptionVisible(false);
#endif
#ifndef WANT_FMMIDI
	acfg.fmmidi_midi.SetOptionVisible(false);
#endif

#ifdef __ANDROID__
	// FIXME: URI encoded SAF paths are not supported
	acfg.soundfont.SetOptionVisible(false);
#endif

	vGetConfig(acfg);
	return acfg;
}

int AudioInterface::BGM_GetGlobalVolume() const {
	return cfg.music_volume.Get();
}

void AudioInterface::BGM_SetGlobalVolume(int volume) {
	cfg.music_volume.Set(volume);
}

int AudioInterface::SE_GetGlobalVolume() const {
	return cfg.sound_volume.Get();
}

void AudioInterface::SE_SetGlobalVolume(int volume) {
	cfg.sound_volume.Set(volume);
}

bool AudioInterface::GetFluidsynthEnabled() const {
	return cfg.fluidsynth_midi.Get();
}

void AudioInterface::SetFluidsynthEnabled(bool enable) {
	cfg.fluidsynth_midi.Set(enable);
}

bool AudioInterface::GetWildMidiEnabled() const {
	return cfg.wildmidi_midi.Get();
}

void AudioInterface::SetWildMidiEnabled(bool enable) {
	cfg.wildmidi_midi.Set(enable);
}

bool AudioInterface::GetNativeMidiEnabled() const {
	return cfg.native_midi.Get();
}

void AudioInterface::SetNativeMidiEnabled(bool enable) {
	cfg.native_midi.Set(enable);
}

std::string AudioInterface::GetFluidsynthSoundfont() const {
	return cfg.soundfont.Get();
}

void AudioInterface::SetFluidsynthSoundfont(std::string_view sf) {
	cfg.soundfont.Set(ToString(sf));
	MidiDecoder::ChangeFluidsynthSoundfont(sf);
}


/*end of file .\audio.cpp*/

/*start of file .\audio_decoder.cpp*/

/* ... license chunk ... */

// Headers
#include <cassert>
#include <cmath>
#include <cstdint>
#include <cstring>
#include "audio_decoder.h"
#include "audio_decoder_base.h"
#include "audio_midi.h"
#include "audio_resampler.h"
#include "output.h"
#include "system.h"
#include "utils.h"

#include "decoder_mpg123.h"
#include "decoder_oggvorbis.h"
#include "decoder_opus.h"
#include "decoder_libsndfile.h"
#include "decoder_drwav.h"
#include "decoder_xmp.h"

using namespace std::chrono_literals;

class WMAUnsupportedFormatDecoder : public AudioDecoder {
public:
	WMAUnsupportedFormatDecoder() {
		error_message = std::string("WMA audio files are not supported. Reinstall the\n") +
			"game and don't convert them when asked by Windows!\n";
	}
	bool Open(Filesystem_Stream::InputStream) override { return false; }
	bool IsFinished() const override { return true; }
	void GetFormat(int&, Format&, int&) const override {}
	bool Seek(std::streamoff, std::ios_base::seekdir) override { return false; }
	int GetTicks() const override { return 0; }
private:
	int FillBuffer(uint8_t*, int) override { return -1; };
};
const char wma_magic[] = { (char)0x30, (char)0x26, (char)0xB2, (char)0x75 };

std::unique_ptr<AudioDecoderBase> AudioDecoder::Create(Filesystem_Stream::InputStream& stream, bool resample) {
	char magic[4] = { 0 };
	if (!stream.ReadIntoObj(magic)) {
		return nullptr;
	}
	stream.seekg(0, std::ios::beg);

	auto add_resampler = [resample](std::unique_ptr<AudioDecoder> dec) -> std::unique_ptr<AudioDecoderBase> {
#ifdef USE_AUDIO_RESAMPLER
		if (resample)
			return std::make_unique<AudioResampler>(std::move(dec));
#endif
		return dec;
	};

	// Try to use MIDI decoder, use fallback(s) if available
	if (!strncmp(magic, "MThd", 4)) {
		auto midi = MidiDecoder::Create(resample);
		if (midi) {
			return midi;
		}
	}

	// Try to use internal OGG decoder
	if (!strncmp(magic, "OggS", 4)) { // OGG
#ifdef HAVE_OPUS
		stream.seekg(28, std::ios::ios_base::beg);
		if (stream.read(magic, sizeof(magic)).gcount() == 0) {
			return nullptr;
		}
		stream.seekg(0, std::ios::ios_base::beg);

		if (!strncmp(magic, "Opus", 4)) {
			return add_resampler(std::make_unique<OpusAudioDecoder>());
		}
#endif

#if defined(HAVE_TREMOR) || defined(HAVE_OGGVORBIS)
		stream.seekg(29, std::ios::ios_base::beg);
		if (stream.read(magic, sizeof(magic)).gcount() == 0) {
			return nullptr;
		}
		stream.seekg(0, std::ios::ios_base::beg);

		if (!strncmp(magic, "vorb", 4)) {
			return add_resampler(std::make_unique<OggVorbisDecoder>());
		}
#endif
	}

#ifdef WANT_DRWAV
	// Use built-in WAV decoder (dr_wav) for faster WAV decoding
	if (!strncmp(magic, "RIFF", 4)) {
		return add_resampler(std::make_unique<DrWavDecoder>());
	}
#endif

	// Try to use libsndfile for common formats
	if (!strncmp(magic, "RIFF", 4) || // WAV
		!strncmp(magic, "FORM", 4) || // WAV AIFF
		!strncmp(magic, "OggS", 4) || // OGG
		!strncmp(magic, "fLaC", 4)) { // FLAC
#ifdef HAVE_LIBSNDFILE
		return add_resampler(std::make_unique<LibsndfileDecoder>());
#endif
		return nullptr;
	}

	// Inform about WMA issue
	if (!memcmp(magic, wma_magic, 4)) {
		return std::make_unique<WMAUnsupportedFormatDecoder>();
	}

	// Test for tracker modules
#ifdef HAVE_LIBXMP
	if (XMPDecoder::IsModule(stream)) {
		return add_resampler(std::make_unique<XMPDecoder>());
	}
#endif

	// False positive MP3s should be prevented before by checking for common headers
#ifdef HAVE_LIBMPG123
	static bool mpg123_works = true;
	if (mpg123_works) {
		auto mp3dec = add_resampler(std::make_unique<Mpg123Decoder>());
		if (mp3dec->WasInited()) {
			if (strncmp(magic, "ID3", 3) == 0) {
				return mp3dec;
			}

			// Parsing MP3s seems to be the only reliable way to detect them
			if (Mpg123Decoder::IsMp3(stream)) {
				stream.clear();
				stream.seekg(0, std::ios_base::beg);
				return mp3dec;
			}
		} else {
			mpg123_works = false;
		}
	}
#endif

	stream.clear();
	stream.seekg(0, std::ios::ios_base::beg);
	return nullptr;
}

void AudioDecoder::Pause() {
	paused = true;
}

void AudioDecoder::Resume() {
	paused = false;
}

void AudioDecoder::Update(std::chrono::microseconds delta) {
	if (fade_time <= 0ms) {
		return;
	}

	fade_time -= delta;

	volume += static_cast<float>(std::chrono::duration_cast<std::chrono::microseconds>(delta).count()) * delta_volume_step;
	volume = Utils::Clamp(static_cast<float>(volume), 0.0f, 100.0f);
	ApplyLogVolume();
}

StereoVolume AudioDecoder::GetVolume() const {
	return log_volume;
}

void AudioDecoder::SetVolume(int new_volume) {
	volume = Utils::Clamp(static_cast<float>(new_volume), 0.0f, 100.0f);
	ApplyLogVolume();
}

void AudioDecoder::SetFade(int end, std::chrono::milliseconds duration) {
	fade_time = 0ms;

	if (duration <= 0ms) {
		SetVolume(end);
		return;
	}

	fade_volume_end = end;
	fade_time = duration;
	delta_volume_step = (static_cast<float>(fade_volume_end) - volume) / fade_time.count();
}

void AudioDecoder::SetBalance(int balance) {
	AudioDecoderBase::SetBalance(balance);
	ApplyLogVolume();
}

int AudioDecoder::GetSamplesizeForFormat(AudioDecoderBase::Format format) {
	switch (format) {
		case AudioDecoderBase::Format::S8:
		case AudioDecoderBase::Format::U8:
			return 1;
		case AudioDecoderBase::Format::S16:
		case AudioDecoderBase::Format::U16:
			return 2;
		case AudioDecoderBase::Format::S32:
		case AudioDecoderBase::Format::U32:
		case AudioDecoderBase::Format::F32:
			return 4;
	}

	assert(false && "Bad format");
	return -1;
}

void AudioDecoder::ApplyLogVolume() {
	float base_gain = AdjustVolume(volume);
	int balance = GetBalance();
	float left_gain = 1.f, right_gain = 1.f;
	constexpr float pan_exp = 0.5012f;
	if (balance <= 50) {
		right_gain = std::pow(pan_exp, (50 - balance) / 10.f);
	} else {
		left_gain = std::pow(pan_exp, (balance - 50) / 10.f);
	}
	log_volume.left_volume = base_gain * left_gain;
	log_volume.right_volume = base_gain * right_gain;
}


/*end of file .\audio_decoder.cpp*/

/*start of file .\audio_decoder_base.cpp*/

/* ... license chunk ... */

// Headers
#include <cassert>
#include <cstring>
#include "audio_decoder_base.h"
#include "output.h"
#include "system.h"
#include "utils.h"

float AudioDecoderBase::AdjustVolume(float volume) {
	// Adjust to RPG_RT (Direct Sound) volume scale
	if (volume > 0) {
		return 100.0f * std::pow(10.0f, -(35.0f / 20.0f) * (1.0f - volume / 100.0f));
	}
	return 0.0f;
}

int AudioDecoderBase::Decode(uint8_t* buffer, int length) {
	return Decode(buffer, length, 0);
}

std::vector<uint8_t> AudioDecoderBase::DecodeAll() {
	const int buffer_size = 8192;

	std::vector<uint8_t> buffer;
	buffer.resize(buffer_size);

	while (!IsFinished()) {
		int read = Decode(buffer.data() + buffer.size() - buffer_size, buffer_size);
		if (read < buffer_size) {
			buffer.resize(buffer.size() - (buffer_size - read));
			break;
		}

		buffer.resize(buffer.size() + buffer_size);
	}

	return buffer;
}

void AudioDecoderBase::Rewind() {
	if (!Seek(0, std::ios_base::beg)) {
		// The libs guarantee that Rewind works
		assert(false && "Rewind");
	}
}

bool AudioDecoderBase::GetLooping() const {
	return looping;
}

void AudioDecoderBase::SetLooping(bool enable) {
	looping = enable;
}

int AudioDecoderBase::GetLoopCount() const {
	return loop_count;
}

int AudioDecoderBase::GetBalance() const {
	return balance;
}

void AudioDecoderBase::SetBalance(int new_balance) {
	balance = Utils::Clamp(new_balance, 0, 100);
}

bool AudioDecoderBase::WasInited() const {
	return true;
}

std::string AudioDecoderBase::GetError() const {
	return error_message;
}

std::string AudioDecoderBase::GetType() const {
	return music_type;
}

void AudioDecoderBase::UpdateMidi(std::chrono::microseconds delta) {
	(void)delta;
}

bool AudioDecoderBase::SetFormat(int, AudioDecoderBase::Format, int) {
	return false;
}

int AudioDecoderBase::GetPitch() const {
	return 0;
}

bool AudioDecoderBase::SetPitch(int) {
	return false;
}

std::streampos AudioDecoderBase::Tell() const {
	return -1;
}

int AudioDecoderBase::Decode(uint8_t* buffer, int length, int recursion_depth) {
	int res = FillBuffer(buffer, length);

	if (res < 0) {
		memset(buffer, '\0', length);
	}
	else if (res < length) {
		memset(&buffer[res], '\0', length - res);
	}

	if (IsFinished() && looping && recursion_depth < 10) {
		++loop_count;
		Rewind();
		if (length - res > 0) {
			int res2 = Decode(&buffer[res], length - res, ++recursion_depth);
			if (res2 <= 0) {
				return res;
			}
			return res + res2;
		}
	}

	if (recursion_depth == 10 && loop_count < 50) {
		// Only report this a few times in the hope that this is only a temporary problem and to prevent log spamming
		Output::Debug("Audio Decoder: Recursion depth exceeded. Probably stream error.");
	}

	return res;
}


/*end of file .\audio_decoder_base.cpp*/

/*start of file .\audio_decoder_midi.cpp*/

/* ... license chunk ... */

#include <array>
#include <algorithm>
#include <cmath>
#include "audio.h"
#include "audio_decoder_midi.h"
#include "midisequencer.h"
#include "output.h"
#include "utils.h"

using namespace std::chrono_literals;

constexpr int bytes_per_sample = sizeof(int16_t) * 2;

// ~1.5 ms of MIDI message resolution
#if EP_MIDI_FREQ <= 11025
constexpr int sample_divider = 4;
#elif EP_MIDI_FREQ <= 22050
constexpr int sample_divider = 2;
#else
constexpr int sample_divider = 1;
#endif
constexpr int samples_per_play = 64 / sample_divider;

static const uint8_t midi_set_reg_param_upper = 0x6;
static const uint8_t midi_control_volume = 0x7;
static const uint8_t midi_control_pan = 0xA;
static const uint8_t midi_event_control_change = 0xB;
static const uint8_t midi_set_reg_param_lower = 0x26;
static const uint8_t midi_control_all_sound_off = 0x78;
static const uint8_t midi_control_reset_all_controller = 0x79;
//static const uint8_t midi_control_all_note_off = 0x7B;
static const uint8_t midi_set_reg_param_number_lower = 0x64;
static const uint8_t midi_set_reg_param_number_upper = 0x65;

static uint32_t midimsg_make(uint8_t event_type, uint8_t channel, uint8_t value1, uint8_t value2) {
	uint32_t msg = 0;
	msg |= (((event_type << 4) & 0xF0) | (channel & 0x0F)) & 0x0000FF;
	msg |= (value1 << 8) & 0x00FF00;
	msg |= (value2 << 16) & 0xFF0000;
	return msg;
}

/*static uint32_t midimsg_all_note_off(uint8_t channel) {
	return midimsg_make(midi_event_control_change, channel, midi_control_all_note_off, 0);
}*/

static uint32_t midimsg_all_sound_off(uint8_t channel) {
	return midimsg_make(midi_event_control_change, channel, midi_control_all_sound_off, 0);
}

static uint32_t midimsg_volume(uint8_t channel, uint8_t volume) {
	return midimsg_make(midi_event_control_change, channel, midi_control_volume, volume);
}

static uint32_t midimsg_pan(uint8_t channel, uint8_t pan) {
	return midimsg_make(midi_event_control_change, channel, midi_control_pan, pan);
}

static uint32_t midimsg_reset_all_controller(uint8_t channel) {
	return midimsg_make(midi_event_control_change, channel, midi_control_reset_all_controller, 0);
}

static inline uint8_t midimsg_get_event_type(uint32_t msg) {
	return (msg & 0x0000F0) >> 4;
}

static inline uint8_t midimsg_get_channel(uint32_t msg) {
	return (msg & 0x00000F);
}

static inline uint8_t midimsg_get_value1(uint32_t msg) {
	return (msg & 0x00FF00) >> 8;
}

static inline uint8_t midimsg_get_value2(uint32_t msg) {
	return (msg & 0xFF0000) >> 16;
}

static bool midimsg_validate(uint32_t msg) {
	// Do some very basic sanity checks on the messages as
	// invalid messages can cause the underlying MIDI synth to crash.
	uint8_t event_type = midimsg_get_event_type(msg);
	//uint8_t channel = midimsg_get_channel(msg);
	uint8_t value1 = midimsg_get_value1(msg);
	//uint8_t value2 = midimsg_get_value2(msg);

	if (event_type < 64 ||
		(event_type >= 70 && event_type < 84) ||
		(event_type == 88) ||
		(event_type >= 91 && event_type < 96) ||
		(event_type >= 98 && event_type < 102))
	{
		if (value1 >= 128) {
			// These event types must have a value of 0-127
			return false;
		}
	}
	return true;
}

AudioDecoderMidi::AudioDecoderMidi(std::unique_ptr<MidiDecoder> mididec)
	: mididec(std::move(mididec)) {
	seq = std::make_unique<midisequencer::sequencer>();
	channel_volumes.fill(127);
	midi_requested_channel_pans.fill(64);
	music_type = "midi";
}

AudioDecoderMidi::~AudioDecoderMidi() {
	reset();
}

static int read_func(void* instance) {
	AudioDecoderMidi* midi = reinterpret_cast<AudioDecoderMidi*>(instance);

	if (midi->file_buffer_pos >= midi->file_buffer.size()) {
		return EOF;
	}

	return midi->file_buffer[midi->file_buffer_pos++];
}

bool AudioDecoderMidi::Open(Filesystem_Stream::InputStream stream) {
	Reset();
	seq->clear();

	file_buffer_pos = 0;
	file_buffer = Utils::ReadStream(stream);
	loop_count = 0;

	if (!seq->load(this, read_func)) {
		error_message = "Midi: Error reading file";
		return false;
	}

	seq->rewind();
	tempo.clear();
	tempo.emplace_back(this, midi_default_tempo);
	mtime = seq->get_start_skipping_silence();

	if (!mididec->SupportsMidiMessages()) {
		if (!mididec->Open(file_buffer)) {
			error_message = "Internal Midi: Error reading file";
			return false;
		}

		mididec->Seek(tempo.back().GetSamples(mtime), std::ios_base::beg);
	}

	return true;
}

void AudioDecoderMidi::Pause() {
	paused = true;
	for (int i = 0; i < 16; i++) {
		uint32_t msg = midimsg_volume(i, 0);
		mididec->SendMidiMessage(msg);
	}
}

void AudioDecoderMidi::Resume() {
	paused = false;
	for (int i = 0; i < 16; i++) {
		uint32_t msg = midimsg_volume(i, static_cast<uint8_t>(channel_volumes[i] * volume * global_volume));
		mididec->SendMidiMessage(msg);
	}
}

StereoVolume AudioDecoderMidi::GetVolume() const {
	// When handled by Midi messages fake a 100 otherwise the volume is adjusted twice

	if (!mididec->SupportsMidiMessages()) {
		return log_volume;
	}

	return {100, 100};
}

void AudioDecoderMidi::SetVolume(int new_volume) {
	// cancel any pending fades
	fade_steps = 0;

	volume = static_cast<float>(new_volume) / 100.0f;
	for (int i = 0; i < 16; i++) {
		uint32_t msg = midimsg_volume(i, static_cast<uint8_t>(channel_volumes[i] * volume * global_volume));
		mididec->SendMidiMessage(msg);
	}

	ApplyLogVolume();
}

void AudioDecoderMidi::SetFade(int end, std::chrono::milliseconds duration) {
	fade_steps = 0;
	last_fade_mtime = 0us;

	if (duration <= 0ms) {
		SetVolume(end);
		return;
	}

	fade_volume_end = end / 100.0f;
	fade_steps = duration.count() / 100.0;
	delta_volume_step = (fade_volume_end - volume) / fade_steps;
}

void AudioDecoderMidi::SetBalance(int new_balance) {
	AudioDecoderBase::SetBalance(new_balance);
	ApplyLogVolume();

	for (int channel = 0; channel < 16; channel++) {
		uint32_t msg = midimsg_pan(channel, ChannelPan(midi_requested_channel_pans[channel]));
		mididec->SendMidiMessage(msg);
	}
}

bool AudioDecoderMidi::Seek(std::streamoff offset, std::ios_base::seekdir origin) {
	assert(!tempo.empty());

	if (offset == 0 && origin == std::ios_base::beg) {
		mtime = seq->rewind_to_loop()->time;
		reset_tempos_after_loop();

		// When the loop points to the end of the track keep it alive to match
		// RPG_RT behaviour.
		loops_to_end = mtime >= seq->get_total_time();

		if (!mididec->SupportsMidiMessages()) {
			mididec->Seek(tempo.back().GetSamples(loops_to_end ? seq->get_total_time() : mtime), origin);
		}

		return true;
	}

	return false;
}

bool AudioDecoderMidi::IsFinished() const {
	if (loops_to_end) {
		return false;
	}

	return seq->is_at_end();
}

void AudioDecoderMidi::Update(std::chrono::microseconds delta) {
	(void)delta; // FIXME: Why is delta unused?

	if (paused) {
		return;
	}
	if (fade_steps > 0 && mtime - last_fade_mtime > 0.1s) {
		volume = Utils::Clamp<float>(volume + delta_volume_step, 0.0f, 1.0f);
		ApplyLogVolume();
		for (int i = 0; i < 16; i++) {
			uint32_t msg = midimsg_volume(i, static_cast<uint8_t>(channel_volumes[i] * volume * global_volume));
			mididec->SendMidiMessage(msg);
		}
		last_fade_mtime = mtime;
		fade_steps -= 1;
	}
}

void AudioDecoderMidi::UpdateMidi(std::chrono::microseconds delta) {
	// Only called when MidiOut is used

	if (paused) {
		return;
	}

	mtime += std::chrono::microseconds(static_cast<int>(delta.count() * pitch / 100));

	if (Audio().BGM_GetGlobalVolume() / 100.0f != global_volume) {
		global_volume = Audio().BGM_GetGlobalVolume() / 100.0f;
		for (int i = 0; i < 16; i++) {
			uint32_t msg = midimsg_volume(i, static_cast<uint8_t>(channel_volumes[i] * volume * global_volume));
			mididec->SendMidiMessage(msg);
		}
	}

	Update(delta);

	seq->play(mtime, this);

	if (IsFinished() && looping) {
		mtime = seq->rewind_to_loop()->time;
		reset_tempos_after_loop();
		loop_count += 1;
	}
}

void AudioDecoderMidi::GetFormat(int& freq, AudioDecoderBase::Format& format, int& channels) const {
	mididec->GetFormat(freq, format, channels);
}

bool AudioDecoderMidi::SetFormat(int freq, AudioDecoderBase::Format format, int channels) {
	frequency = freq;
	return mididec->SetFormat(freq, format, channels);
}

bool AudioDecoderMidi::SetPitch(int pitch) {
	if (!mididec->SupportsMidiMessages()) {
		if (!mididec->SetPitch(pitch)) {
			this->pitch = 100;
			return false;
		}
	}

	this->pitch = pitch;
	return true;
}

int AudioDecoderMidi::GetTicks() const {
	assert(!tempo.empty());

	return tempo.back().GetTicks(mtime);
}

void AudioDecoderMidi::Reset() {
	// Placed here to avoid reloading of a soundfont on shutdown
	mididec->OnNewMidi();

	// Generate a MIDI reset event so the device doesn't
	// leave notes playing or keeps any state
	reset();
}

bool AudioDecoderMidi::IsPaused() const {
	return paused;
}

int AudioDecoderMidi::FillBuffer(uint8_t* buffer, int length) {
	if (loops_to_end) {
		memset(buffer, '\0', length);
		return length;
	}

	if (!mididec->SupportsMidiMessages()) {
		// Fast path for WildMidi as it does not care about messages
		float delta = (float)(length / bytes_per_sample) / (frequency * 100.0f / pitch);
		mtime += std::chrono::microseconds(static_cast<int>(delta * 1'000'000));
		seq->play(mtime, this);
		return mididec->FillBuffer(buffer, length);
	}

	int samples_max = length / bytes_per_sample;
	int written = 0;

	// Advance the MIDI playback in smaller steps to achieve a good message resolution
	// Otherwise the MIDI sounds off because messages are processed too late.
	while (samples_max > 0) {
		// Process MIDI messages
		size_t samples = std::min(samples_per_play, samples_max);
		float delta = (float)samples / (frequency * 100.0f / pitch);
		mtime += std::chrono::microseconds(static_cast<int>(delta * 1'000'000));
		seq->play(mtime, this);

		// Write audio samples
		int len = samples * bytes_per_sample;
		int res = mididec->FillBuffer(buffer + written, len);
		written += res;

		if (samples < samples_per_play || res < len) {
			// Done
			break;
		}

		samples_max -= samples;
	}

	return written;
}

void AudioDecoderMidi::SendMessageToAllChannels(uint32_t midi_msg) {
	for (int channel = 0; channel < 16; channel++) {
		midi_msg &= ~(0xFu);
		midi_msg |= (channel & 0x0F);
		mididec->SendMidiMessage(midi_msg);
	}
}

void AudioDecoderMidi::midi_message(int, uint_least32_t message) {
	uint8_t event_type = midimsg_get_event_type(message);
	uint8_t channel = midimsg_get_channel(message);
	uint8_t value1 = midimsg_get_value1(message);
	uint8_t value2 = midimsg_get_value2(message);

	if (event_type == midi_event_control_change && value1 == midi_control_volume) {
		// Adjust channel volume
		channel_volumes[channel] = value2;
		// Send the modified volume to midiout
		message = midimsg_volume(channel, static_cast<uint8_t>(value2 * volume * global_volume));
	} else if (event_type == midi_event_control_change && value1 == midi_control_pan) {
		midi_requested_channel_pans[channel] = value2;
		message = midimsg_pan(channel, ChannelPan(value2));
	}
	if (midimsg_validate(message)) {
		mididec->SendMidiMessage(message);
	}
}

void AudioDecoderMidi::sysex_message(int, const void* data, std::size_t size) {
	mididec->SendSysExMessage(reinterpret_cast<const uint8_t*>(data), size);
}

void AudioDecoderMidi::meta_event(int event, const void* data, std::size_t size) {
	// Meta events are never sent over MIDI ports.
	assert(!tempo.empty());
	const auto* d = reinterpret_cast<const uint8_t*>(data);
	if (size == 3 && event == 0x51) {
		uint32_t new_tempo = (static_cast<uint32_t>(static_cast<unsigned char>(d[0])) << 16)
			| (static_cast<unsigned char>(d[1]) << 8)
			| static_cast<unsigned char>(d[2]);
		tempo.emplace_back(this, new_tempo, &tempo.back());
	}
}

void AudioDecoderMidi::reset() {
	// MIDI reset event
	SendMessageToAllChannels(midimsg_reset_all_controller(0));

	// GM system on (resets most parameters)
	const unsigned char gm_reset[] = { 0xF0, 0x7E, 0x7F, 0x09, 0x01, 0xF7 };
	mididec->SendSysExMessage(gm_reset, sizeof(gm_reset));

	// SoundOff every channel: only necessary for synths like macOS which tend to get stuck
	if (mididec->NeedsSoftReset()) {
		SendMessageToAllChannels(midimsg_all_sound_off(0));
	}

	// Set the Pitch bend range to 256
	for (int channel = 0; channel < 16; channel++) {
		auto midi_msg = midimsg_make(midi_event_control_change, channel, midi_set_reg_param_number_upper, 0);
		mididec->SendMidiMessage(midi_msg);

		midi_msg = midimsg_make(midi_event_control_change, channel, midi_set_reg_param_number_lower, 0);
		mididec->SendMidiMessage(midi_msg);

		midi_msg = midimsg_make(midi_event_control_change, channel, midi_set_reg_param_upper, 2);
		mididec->SendMidiMessage(midi_msg);

		midi_msg = midimsg_make(midi_event_control_change, channel, midi_set_reg_param_lower, 0);
		mididec->SendMidiMessage(midi_msg);
	}
}

void AudioDecoderMidi::reset_tempos_after_loop() {
	if (mtime > 0us) {
		// Throw away all tempo data after the loop point
		auto rit = std::find_if(tempo.rbegin(), tempo.rend(), [&](auto& t) { return t.mtime <= mtime; });
		auto it = rit.base();
		if (it != tempo.end()) {
			tempo.erase(it, tempo.end());
		}
	} else {
		tempo.clear();
		tempo.emplace_back(this, midi_default_tempo);
	}
}

AudioDecoderMidi::MidiTempoData::MidiTempoData(const AudioDecoderMidi* midi, uint32_t cur_tempo, const MidiTempoData* prev)
	: tempo(cur_tempo) {
	ticks_per_us = (float)midi->seq->get_division() / tempo;
	samples_per_tick = midi->frequency * 1 / (ticks_per_us * 1000000);
	mtime = midi->mtime;
	if (prev) {
		std::chrono::microseconds delta = mtime - prev->mtime;
		int ticks_since_last = static_cast<int>(ticks_per_us * delta.count());
		ticks = prev->ticks + ticks_since_last;
		samples = prev->samples + ticks_since_last * samples_per_tick;
	}
}

int AudioDecoderMidi::MidiTempoData::GetTicks(std::chrono::microseconds mtime_cur) const {
	std::chrono::microseconds delta = mtime_cur - mtime;
	return ticks + static_cast<int>(ticks_per_us * delta.count());
}

int AudioDecoderMidi::MidiTempoData::GetSamples(std::chrono::microseconds mtime_cur) const {
	std::chrono::microseconds delta = mtime_cur - mtime;
	int ticks_since_last = static_cast<int>(ticks_per_us * delta.count());
	return samples + static_cast<int>(ticks_since_last * samples_per_tick);
}

void AudioDecoderMidi::ApplyLogVolume() {
	if (!mididec->SupportsMidiMessages()) {
		float base_gain = AdjustVolume(volume);
		int balance = GetBalance();
		float left_gain = 1.f, right_gain = 1.f;
		constexpr float pan_exp = 0.5012f;
		if (balance <= 50) {
			right_gain = std::pow(pan_exp, (50 - balance) / 10.f);
		} else {
			left_gain = std::pow(pan_exp, (balance - 50) / 10.f);
		}
		log_volume.left_volume = base_gain * left_gain;
		log_volume.right_volume = base_gain * right_gain;
	}
}

int AudioDecoderMidi::ChannelPan(int desired_pan) const {
	return Utils::Clamp(desired_pan + ((GetBalance() - 50) * 2), 0, 127);
}


/*end of file .\audio_decoder_midi.cpp*/

/*start of file .\audio_generic.cpp*/

/* ... license chunk ... */

#include "system.h"

#include <cstring>
#include <cassert>
#include <memory>
#include "audio_generic.h"
#include "output.h"

GenericAudio::GenericAudio(const Game_ConfigAudio& cfg) : AudioInterface(cfg) {
	int i = 0;
	for (auto& BGM_Channel : BGM_Channels) {
		BGM_Channel.id = i++;
		BGM_Channel.decoder.reset();
		BGM_Channel.instance = this;
	}
	i = 0;
	for (auto& SE_Channel : SE_Channels) {
		SE_Channel.id = i++;
		SE_Channel.decoder.reset();
		SE_Channel.instance = this;
	}
	BGM_PlayedOnceIndicator = false;
	midi_thread.reset();

	// Initialize to some arbitrary (low-quality) format to prevent crashes
	// when the inheriting class doesn't call SetFormat
	SetFormat(12345, AudioDecoder::Format::S8, 1);
}

void GenericAudio::BGM_Play(Filesystem_Stream::InputStream stream, int volume, int pitch, int fadein, int balance) {
	if (!stream) {
		Output::Warning("Couldn't play BGM {}: File not readable", stream.GetName());
		return;
	}

	for (auto& BGM_Channel : BGM_Channels) {
		BGM_Channel.stopped = true; //Stop all running background music
		if (!BGM_Channel.IsUsed()) {
			// If there is an unused bgm channel
			LockMutex();
			BGM_PlayedOnceIndicator = false;
			UnlockMutex();
			PlayOnChannel(BGM_Channel, std::move(stream), volume, pitch, fadein, balance);
			return;
		}
	}
}

void GenericAudio::BGM_Pause() {
	for (auto& BGM_Channel : BGM_Channels) {
		if (BGM_Channel.IsUsed()) {
			BGM_Channel.SetPaused(true);
		}
	}
}

void GenericAudio::BGM_Resume() {
	for (auto& BGM_Channel : BGM_Channels) {
		if (BGM_Channel.IsUsed()) {
			BGM_Channel.SetPaused(false);
		}
	}
}

void GenericAudio::BGM_Stop() {
	LockMutex();
	for (auto& BGM_Channel : BGM_Channels) {
		BGM_Channel.Stop();
	}
	BGM_PlayedOnceIndicator = false;
	UnlockMutex();
}

bool GenericAudio::BGM_PlayedOnce() const {
	if (BGM_PlayedOnceIndicator) {
		return BGM_PlayedOnceIndicator;
	}

	LockMutex();
	// Audio Decoders set this in the Decoding thread
	for (auto& BGM_Channel : BGM_Channels) {
		if (BGM_Channel.midi_out_used) {
			BGM_PlayedOnceIndicator = midi_thread->GetMidiOut().GetLoopCount() > 0;
		}
	}
	UnlockMutex();

	return BGM_PlayedOnceIndicator;
}

bool GenericAudio::BGM_IsPlaying() const {
	for (auto& BGM_Channel : BGM_Channels) {
		if (!BGM_Channel.stopped) {
			return true;
		};
	}
	return false;
}

int GenericAudio::BGM_GetTicks() const {
	unsigned ticks = 0;
	LockMutex();
	for (auto& BGM_Channel : BGM_Channels) {
		int cur_ticks = BGM_Channel.GetTicks();
		if (cur_ticks >= 0) {
			ticks = static_cast<unsigned>(cur_ticks);
		}
	}
	UnlockMutex();
	return ticks;
}

void GenericAudio::BGM_Fade(int fade) {
	LockMutex();
	for (auto& BGM_Channel : BGM_Channels) {
		BGM_Channel.SetFade(fade);
	}
	UnlockMutex();
}

void GenericAudio::BGM_Volume(int volume) {
	LockMutex();
	for (auto& BGM_Channel : BGM_Channels) {
		BGM_Channel.SetVolume(volume);
	}
	UnlockMutex();
}

void GenericAudio::BGM_Pitch(int pitch) {
	LockMutex();
	for (auto& BGM_Channel : BGM_Channels) {
		BGM_Channel.SetPitch(pitch);
	}
	UnlockMutex();
}

void GenericAudio::BGM_Balance(int balance) {
	LockMutex();
	for (auto& BGM_Channel : BGM_Channels) {
		BGM_Channel.SetBalance(balance);
	}
	UnlockMutex();
}

std::string GenericAudio::BGM_GetType() const {
	std::string type;

	LockMutex();
	for (auto& BGM_Channel : BGM_Channels) {
		if (BGM_Channel.IsUsed()) {
			if (BGM_Channel.midi_out_used) {
				type = "midi";
				break;
			} else {
				type = BGM_Channel.decoder->GetType();
				break;
			}
		}
	}
	UnlockMutex();

	return type;
}

void GenericAudio::SE_Play(std::unique_ptr<AudioSeCache> se, int volume, int pitch, int balance) {
	if (!se) {
		Output::Warning("SE_Play: AudioSeCache data is NULL");
		return;
	}

	for (auto& SE_Channel : SE_Channels) {
		if (!SE_Channel.decoder) {
			//If there is an unused se channel
			PlayOnChannel(SE_Channel, std::move(se), volume, pitch, balance);
			return;
		}
	}
	// FIXME Not displaying as warning because multiple games exhaust free channels available, see #1356
	Output::Debug("Couldn't play {} SE. No free channel available", se->GetName());
}

void GenericAudio::SE_Stop() {
	for (auto& SE_Channel : SE_Channels) {
		SE_Channel.stopped = true; //Stop all running sound effects
	}
}

void GenericAudio::Update() {
	// no-op, handled by the Decode function called through a thread
}

GenericAudioMidiOut* GenericAudio::CreateAndGetMidiOut() {
	if (!midi_thread) {
		midi_thread = std::make_unique<GenericAudioMidiOut>();
		std::string status_message;
		if (midi_thread->IsInitialized(status_message)) {
			midi_thread->StartThread();
		} else {
			midi_thread.reset();
		}
	}
	return midi_thread.get();
}

void GenericAudio::SetFormat(int frequency, AudioDecoder::Format format, int channels) {
	output_format.frequency = frequency;
	output_format.format = format;
	output_format.channels = channels;
}

bool GenericAudio::PlayOnChannel(BgmChannel& chan, Filesystem_Stream::InputStream filestream, int volume, int pitch, int fadein, int balance) {
	chan.paused = true; // Pause channel so the audio thread doesn't work on it
	chan.stopped = false; // Unstop channel so the audio thread doesn't delete it

	if (!filestream) {
		Output::Warning("BGM file not readable: {}", filestream.GetName());
		return false;
	}

	// Midiout is only supported on channel 0 because this is an exclusive resource
	if (chan.id == 0 && GenericAudioMidiOut::IsSupported(filestream)) {
		chan.decoder.reset();

		// Order is Fluidsynth, WildMidi, Native, FmMidi
		bool fluidsynth = Audio().GetFluidsynthEnabled() && MidiDecoder::CreateFluidsynth(true);
		bool wildmidi = Audio().GetWildMidiEnabled() && MidiDecoder::CreateWildMidi(true);

		if (!fluidsynth && !wildmidi && Audio().GetNativeMidiEnabled()) {
			CreateAndGetMidiOut();

			if (midi_thread) {
				midi_thread->LockMutex();
				auto &midi_out = midi_thread->GetMidiOut();
				if (midi_out.Open(std::move(filestream))) {
					midi_out.SetPitch(pitch);
					midi_out.SetVolume(0);
					midi_out.SetFade(volume, std::chrono::milliseconds(fadein));
					midi_out.SetLooping(true);
					midi_out.SetBalance(balance);
					midi_out.Resume();
					chan.paused = false;
					chan.midi_out_used = true;
					midi_thread->UnlockMutex();
					return true;
				}
				midi_thread->UnlockMutex();
			}
		}
	}

	if (midi_thread) {
		midi_thread->GetMidiOut().Reset();
	}

	chan.decoder = AudioDecoder::Create(filestream);
	chan.midi_out_used = false;
	if (chan.decoder && chan.decoder->Open(std::move(filestream))) {
		chan.decoder->SetPitch(pitch);
		chan.decoder->SetFormat(output_format.frequency, output_format.format, output_format.channels);
		chan.decoder->SetVolume(0);
		chan.decoder->SetFade(volume, std::chrono::milliseconds(fadein));
		chan.decoder->SetLooping(true);
		chan.decoder->SetBalance(balance);
		chan.paused = false; // Unpause channel -> Play it.

		return true;
	} else {
		Output::Warning("Couldn't play BGM {}. Format not supported", filestream.GetName());
	}

	return false;
}

bool GenericAudio::PlayOnChannel(SeChannel& chan, std::unique_ptr<AudioSeCache> se, int volume, int pitch, int balance) {
	chan.paused = true; // Pause channel so the audio thread doesn't work on it
	chan.stopped = false; // Unstop channel so the audio thread doesn't delete it

	chan.decoder = se->CreateSeDecoder();
	chan.decoder->SetPitch(pitch);
	chan.decoder->SetFormat(output_format.frequency, output_format.format, output_format.channels);
	chan.decoder->SetVolume(volume);
	chan.decoder->SetBalance(balance);
	chan.paused = false; // Unpause channel -> Play it.
	return true;
}

void GenericAudio::Decode(uint8_t* output_buffer, int buffer_length) {
	bool channel_active = false;
	float total_volume = 0;
	int samples_per_frame = buffer_length / output_format.channels / 2;

	assert(buffer_length > 0);

	if (sample_buffer.size() != (size_t)buffer_length) {
		sample_buffer.resize(buffer_length);
	}
	if (mixer_buffer.size() != (size_t)buffer_length) {
		mixer_buffer.resize(buffer_length);
	}
	scrap_buffer_size = samples_per_frame * output_format.channels * sizeof(uint32_t);
	if (scrap_buffer.size() != scrap_buffer_size) {
		scrap_buffer.resize(scrap_buffer_size);
	}
	std::fill(mixer_buffer.begin(), mixer_buffer.end(), '\0');

	for (unsigned i = 0; i < nr_of_bgm_channels + nr_of_se_channels; i++) {
		int read_bytes = 0;
		int channels = 0;
		int samplesize = 0;
		int frequency = 0;
		AudioDecoder::Format sampleformat;
		float vleft, vright;

		// Mix BGM and SE together;
		bool is_bgm_channel = i < nr_of_bgm_channels;
		bool channel_used = false;

		if (is_bgm_channel) {
			BgmChannel& currently_mixed_channel = BGM_Channels[i];
			float current_master_volume = cfg.music_volume.Get() / 100.0f;

			if (currently_mixed_channel.decoder && !currently_mixed_channel.paused) {
				if (currently_mixed_channel.stopped) {
					currently_mixed_channel.decoder.reset();
				} else {
					StereoVolume volume = currently_mixed_channel.decoder->GetVolume();
					vleft = volume.left_volume / 100.0f * current_master_volume;
					vright = volume.right_volume / 100.0f * current_master_volume;
					currently_mixed_channel.decoder->GetFormat(frequency, sampleformat, channels);
					currently_mixed_channel.decoder->Update(std::chrono::milliseconds(samples_per_frame * 1000 / frequency));
					samplesize = AudioDecoder::GetSamplesizeForFormat(sampleformat);

					total_volume += std::max(vleft, vright);

					// determine how much data has to be read from this channel (but cap at the bounds of the scrap buffer)
					unsigned bytes_to_read = (samplesize * channels * samples_per_frame);
					bytes_to_read = (bytes_to_read < scrap_buffer_size) ? bytes_to_read : scrap_buffer_size;

					read_bytes = currently_mixed_channel.decoder->Decode(scrap_buffer.data(), bytes_to_read);

					if (read_bytes <= 0) {
						// An error occured when reading - the channel is faulty - discard
						currently_mixed_channel.decoder.reset();
						continue; // skip this loop run - there is nothing to mix
					}

					if (!currently_mixed_channel.stopped) {
						BGM_PlayedOnceIndicator = currently_mixed_channel.decoder->GetLoopCount() > 0;
					}

					channel_used = true;
				}
			}
		} else {
			SeChannel& currently_mixed_channel = SE_Channels[i - nr_of_bgm_channels];
			float current_master_volume = cfg.sound_volume.Get() / 100.0f;

			if (currently_mixed_channel.decoder && !currently_mixed_channel.paused) {
				if (currently_mixed_channel.stopped) {
					currently_mixed_channel.decoder.reset();
				} else {
					StereoVolume volume = currently_mixed_channel.decoder->GetVolume();
					vleft = volume.left_volume / 100.0f * current_master_volume;
					vright = volume.right_volume / 100.0f * current_master_volume;
					currently_mixed_channel.decoder->GetFormat(frequency, sampleformat, channels);
					samplesize = AudioDecoder::GetSamplesizeForFormat(sampleformat);

					total_volume += std::max(vleft, vright);

					// determine how much data has to be read from this channel (but cap at the bounds of the scrap buffer)
					unsigned bytes_to_read = (samplesize * channels * samples_per_frame);
					bytes_to_read = (bytes_to_read < scrap_buffer_size) ? bytes_to_read : scrap_buffer_size;

					read_bytes = currently_mixed_channel.decoder->Decode(scrap_buffer.data(), bytes_to_read);

					if (read_bytes <= 0) {
						// An error occured when reading - the channel is faulty - discard
						currently_mixed_channel.decoder.reset();
						continue; // skip this loop run - there is nothing to mix
					}

					// Now decide what to do when a channel has reached its end
					if (currently_mixed_channel.decoder->IsFinished()) {
						// SE are only played once so free the se if finished
						currently_mixed_channel.decoder.reset();
					}

					channel_used = true;
				}
			}
		}

		//--------------------------------------------------------------------------------------------------------------------//
		// From here downwards the currently_mixed_channel decoder may already be freed - so don't use it below this comment. //
		//--------------------------------------------------------------------------------------------------------------------//

		if (channel_used) {
			for (unsigned ii = 0; ii < (unsigned)(read_bytes / (samplesize * channels)); ii++) {

				float vall = vleft;
				float valr = vright;

				// Convert to floating point
				switch (sampleformat) {
					case AudioDecoder::Format::S8:
						vall *= (((int8_t *) scrap_buffer.data())[ii * channels] / 128.0);
						valr *= (((int8_t *) scrap_buffer.data())[ii * channels + 1] / 128.0);
						break;
					case AudioDecoder::Format::U8:
						vall *= (((uint8_t *) scrap_buffer.data())[ii * channels] / 128.0 - 1.0);
						valr *= (((uint8_t *) scrap_buffer.data())[ii * channels + 1] / 128.0 - 1.0);
						break;
					case AudioDecoder::Format::S16:
						vall *= (((int16_t *) scrap_buffer.data())[ii * channels] / 32768.0);
						valr *= (((int16_t *) scrap_buffer.data())[ii * channels + 1] / 32768.0);
						break;
					case AudioDecoder::Format::U16:
						vall *= (((uint16_t *) scrap_buffer.data())[ii * channels] / 32768.0 - 1.0);
						valr *= (((uint16_t *) scrap_buffer.data())[ii * channels + 1] / 32768.0 - 1.0);
						break;
					case AudioDecoder::Format::S32:
						vall *= (((int32_t *) scrap_buffer.data())[ii * channels] / 2147483648.0);
						valr *= (((int32_t *) scrap_buffer.data())[ii * channels + 1] / 2147483648.0);
						break;
					case AudioDecoder::Format::U32:
						vall *= (((uint32_t *) scrap_buffer.data())[ii * channels] / 2147483648.0 - 1.0);
						valr *= (((uint32_t *) scrap_buffer.data())[ii * channels + 1] / 2147483648.0 - 1.0);
						break;
					case AudioDecoder::Format::F32:
						vall *= (((float *) scrap_buffer.data())[ii * channels]);
						valr *= (((float *) scrap_buffer.data())[ii * channels + 1]);
						break;
				}

				if (!channel_active) {
					// first channel
					mixer_buffer[ii * output_format.channels] = vall;
					if (channels > 1) {
						mixer_buffer[ii * output_format.channels + 1] = valr;
					} else {
						mixer_buffer[ii * output_format.channels + 1] = mixer_buffer[ii * output_format.channels];
					}
				} else {
					mixer_buffer[ii * output_format.channels] += vall;
					if (channels > 1) {
						mixer_buffer[ii * output_format.channels + 1] += valr;
					} else {
						mixer_buffer[ii * output_format.channels + 1] = mixer_buffer[ii * output_format.channels];
					}
				}

			}
			channel_active = true;
		}
	}

	if (channel_active) {
		if (total_volume > 1.0) {
			float threshold = 0.8f;
			for (unsigned i = 0; i < (unsigned)(samples_per_frame * 2); i++) {
				float sample = mixer_buffer[i];
				float sign = (sample < 0) ? -1.0 : 1.0;
				sample /= sign;
				//dynamic range compression
				if (sample > threshold) {
					sample_buffer[i] = sign * 32768.0 * (threshold + (1.0 - threshold) * (sample - threshold) / (total_volume - threshold));
				} else {
					sample_buffer[i] = sign * sample * 32768.0;
				}
			}
		} else {
			//No dynamic range compression necessary
			for (unsigned i = 0; i < (unsigned)(samples_per_frame * 2); i++) {
				sample_buffer[i] = mixer_buffer[i] * 32768.0;
			}
		}

		memcpy(output_buffer, sample_buffer.data(), buffer_length);
	} else {
		memset(output_buffer, '\0', buffer_length);
	}
}

void GenericAudio::BgmChannel::Stop() {
	stopped = true;
	if (midi_out_used) {
		midi_out_used = false;
		instance->midi_thread->GetMidiOut().Reset();
		instance->midi_thread->GetMidiOut().Pause();
	} else if (decoder) {
		decoder.reset();
	}
}

void GenericAudio::BgmChannel::SetPaused(bool newPaused) {
	paused = newPaused;
	if (midi_out_used) {
		if (newPaused) {
			instance->midi_thread->GetMidiOut().Pause();
		} else {
			instance->midi_thread->GetMidiOut().Resume();
		}
	}
}

int GenericAudio::BgmChannel::GetTicks() const {
	if (midi_out_used) {
		return instance->midi_thread->GetMidiOut().GetTicks();
	} else if (decoder) {
		return decoder->GetTicks();
	}
	return -1;
}

void GenericAudio::BgmChannel::SetFade(int fade) {
	if (midi_out_used) {
		instance->midi_thread->GetMidiOut().SetFade(0, std::chrono::milliseconds(fade));
	} else if (decoder) {
		decoder->SetFade(0, std::chrono::milliseconds(fade));
	}
}

void GenericAudio::BgmChannel::SetVolume(int volume) {
	if (midi_out_used) {
		instance->midi_thread->GetMidiOut().SetVolume(volume);
	} else if (decoder) {
		decoder->SetVolume(volume);
	}
}

void GenericAudio::BgmChannel::SetPitch(int pitch) {
	if (midi_out_used) {
		instance->midi_thread->GetMidiOut().SetPitch(pitch);
	} else if (decoder) {
		decoder->SetPitch(pitch);
	}
}

void GenericAudio::BgmChannel::SetBalance(int balance) {
	if (midi_out_used) {
		instance->midi_thread->GetMidiOut().SetBalance(balance);
	} else if (decoder) {
		decoder->SetBalance(balance);
	}
}

bool GenericAudio::BgmChannel::IsUsed() const {
	return decoder || midi_out_used;
}


/*end of file .\audio_generic.cpp*/

/*start of file .\audio_generic_midiout.cpp*/

/* ... license chunk ... */

#include "audio_generic_midiout.h"
#include "audio_decoder_midi.h"
#include <cassert>

#ifdef HAVE_NATIVE_MIDI
#include <chrono>
#include "filesystem_stream.h"
#include "game_clock.h"
#include "output.h"

#ifdef USE_LIBRETRO
#include "platform/libretro/midiout_device.h"
#endif

#ifdef HAVE_ALSA
#include "platform/linux/midiout_device_alsa.h"
#elif _WIN32
#include "platform/windows/midiout_device_win32.h"
#elif __APPLE__
#  include <TargetConditionals.h>
#  if TARGET_OS_OSX
#    include "platform/macos/midiout_device_coreaudio.h"
#  endif
#endif

using namespace std::chrono_literals;

static struct {
	bool libretro = true;
	bool alsa = true;
	bool win32 = true;
	bool coreaudio = true;
	std::string status;
} works;

GenericAudioMidiOut::GenericAudioMidiOut() {
	stop_thread.store(false);

#ifdef USE_LIBRETRO
	std::string libretro_status;
	if (works.libretro) {
		auto dec = std::make_unique<LibretroMidiOutDevice>(libretro_status);
		if (dec->IsInitialized()) {
			midi_out = std::make_unique<AudioDecoderMidi>(std::move(dec));
		} else {
			works.libretro = false;
			Output::Debug(libretro_status);
		}
	}

	if (midi_out) {
		return;
	}
#endif

#ifdef HAVE_ALSA
	if (works.alsa) {
		auto dec = std::make_unique<AlsaMidiOutDevice>(works.status);
		if (dec->IsInitialized()) {
			midi_out = std::make_unique<AudioDecoderMidi>(std::move(dec));
		} else {
			works.alsa = false;
			Output::Debug(works.status);
		}
	}
#elif _WIN32
	if (works.win32) {
		auto dec = std::make_unique<Win32MidiOutDevice>(works.status);
		if (dec->IsInitialized()) {
			midi_out = std::make_unique<AudioDecoderMidi>(std::move(dec));
		} else {
			works.win32 = false;
			Output::Debug(works.status);
		}
	}
#elif TARGET_OS_OSX
	if (works.coreaudio) {
		auto dec = std::make_unique<CoreAudioMidiOutDevice>(works.status);
		if (dec->IsInitialized()) {
			midi_out = std::make_unique<AudioDecoderMidi>(std::move(dec));
		} else {
			works.coreaudio = false;
			Output::Debug(works.status);
		}
	}
#endif

#ifdef USE_LIBRETRO
	works.status = libretro_status + ". " + works.status;
#endif
}

GenericAudioMidiOut::~GenericAudioMidiOut() {
	if (thread_started) {
		GetMidiOut().Reset();
		StopThread();
	}
}

void GenericAudioMidiOut::LockMutex() {
	midi_mutex.lock();
}

void GenericAudioMidiOut::UnlockMutex() {
	midi_mutex.unlock();
}

void GenericAudioMidiOut::UpdateMidiOut(std::chrono::microseconds delta) {
	LockMutex();
	assert(midi_out);

	midi_out->UpdateMidi(delta);
	UnlockMutex();
}

void GenericAudioMidiOut::StartThread() {
	assert(!thread_started);
	thread_started = true;
	midi_thread = std::thread(&GenericAudioMidiOut::ThreadFunction, this);
}

void GenericAudioMidiOut::StopThread() {
	stop_thread.store(true);
	midi_thread.join();
}

void GenericAudioMidiOut::ThreadFunction() {
	// The libretro clock is not updating often enough for good MIDI timing but
	// all platforms that support Native Midi also have a working high precision clock
	using clock = std::chrono::steady_clock;

	auto start_ticks = clock::now();
	while (!stop_thread) {
		auto ticks = clock::now();

		auto us = std::chrono::duration_cast<std::chrono::microseconds>(ticks - start_ticks);
		UpdateMidiOut(us);

		std::this_thread::sleep_for(1ms);

		start_ticks = ticks;
	}
}

bool GenericAudioMidiOut::IsInitialized(std::string& status_message) const {
	status_message = works.status;
	return midi_out != nullptr;
}

bool GenericAudioMidiOut::IsSupported(Filesystem_Stream::InputStream& stream) {
	char magic[4] = { 0 };
	if (!stream.ReadIntoObj(magic)) {
		return false;
	}
	stream.seekg(0, std::ios::beg);
	return strncmp(magic, "MThd", 4) == 0;
}
#endif

AudioDecoderMidi& GenericAudioMidiOut::GetMidiOut() {
	assert(midi_out);
	return *midi_out;
}


/*end of file .\audio_generic_midiout.cpp*/

/*start of file .\audio_midi.cpp*/

/* ... license chunk ... */

// Headers
#include "audio_midi.h"
#include "audio_decoder_midi.h"
#include "audio.h"
#include "decoder_fluidsynth.h"
#include "decoder_fmmidi.h"
#include "decoder_wildmidi.h"
#include "output.h"

#ifdef USE_AUDIO_RESAMPLER
#include "audio_resampler.h"
#endif

void MidiDecoder::GetFormat(int& freq, AudioDecoderBase::Format& format, int& channels) const {
	freq = frequency;
	format = AudioDecoderBase::Format::S16;
	channels = 2;
}

bool MidiDecoder::SetFormat(int frequency, AudioDecoderBase::Format format, int channels) {
	if (frequency != EP_MIDI_FREQ || channels != 2 || format != AudioDecoderBase::Format::S16)
		return false;

	return true;
}

static struct {
	bool fluidsynth = true;
	bool wildmidi = true;
	std::string fluidsynth_status;
	std::string wildmidi_status;
} works;

std::unique_ptr<AudioDecoderBase> MidiDecoder::Create(bool resample) {
	std::unique_ptr<AudioDecoderBase> mididec;

	if (Audio().GetFluidsynthEnabled()) {
		mididec = CreateFluidsynth(resample);
	}

	if (!mididec && Audio().GetWildMidiEnabled()) {
		mididec = CreateWildMidi(resample);
	}

	if (!mididec) {
		mididec = CreateFmMidi(resample);
	}

	return mididec;
}

std::unique_ptr<AudioDecoderBase> MidiDecoder::CreateFluidsynth(bool resample) {
	std::unique_ptr<AudioDecoderBase> mididec;

#if defined(HAVE_FLUIDSYNTH) || defined(HAVE_FLUIDLITE)
	if (works.fluidsynth && FluidSynthDecoder::Initialize(works.fluidsynth_status)) {
		auto dec = std::make_unique<FluidSynthDecoder>();
		mididec = std::make_unique<AudioDecoderMidi>(std::move(dec));
	}
	else if (!mididec && works.fluidsynth) {
		Output::Debug("Fluidsynth: {}", works.fluidsynth_status);
		works.fluidsynth = false;
	}
#endif

#ifdef USE_AUDIO_RESAMPLER
	if (mididec && resample) {
		mididec = std::make_unique<AudioResampler>(std::move(mididec));
	}
#else
	(void)resample;
#endif

	return mididec;
}

std::unique_ptr<AudioDecoderBase> MidiDecoder::CreateWildMidi(bool resample) {
	std::unique_ptr<AudioDecoderBase> mididec;

#ifdef HAVE_LIBWILDMIDI
	if (!mididec && works.wildmidi && WildMidiDecoder::Initialize(works.wildmidi_status)) {
		auto dec = std::make_unique<WildMidiDecoder>();
		mididec = std::make_unique<AudioDecoderMidi>(std::move(dec));
	}
	else if (!mididec && works.wildmidi) {
		Output::Debug("WildMidi: {}", works.wildmidi_status);
		works.wildmidi = false;
	}
#endif

#ifdef USE_AUDIO_RESAMPLER
	if (mididec && resample) {
		mididec = std::make_unique<AudioResampler>(std::move(mididec));
	}
#else
	(void)resample;
#endif

	return mididec;
}

std::unique_ptr<AudioDecoderBase> MidiDecoder::CreateFmMidi(bool resample) {
	std::unique_ptr<AudioDecoderBase> mididec;

#if WANT_FMMIDI
	if (!mididec) {
		auto dec = std::make_unique<FmMidiDecoder>();
		mididec = std::make_unique<AudioDecoderMidi>(std::move(dec));
	}
#endif

#ifdef USE_AUDIO_RESAMPLER
	if (mididec && resample) {
		mididec = std::make_unique<AudioResampler>(std::move(mididec));
	}
#else
	(void)resample;
#endif

	return mididec;
}

bool MidiDecoder::CheckFluidsynth(std::string& status_message) {
	if (works.fluidsynth && works.fluidsynth_status.empty()) {
		CreateFluidsynth(true);
	}

	status_message = works.fluidsynth_status;
	return works.fluidsynth;
}

void MidiDecoder::ChangeFluidsynthSoundfont(std::string_view sf_path) {
	if (!works.fluidsynth || works.fluidsynth_status.empty()) {
		// Fluidsynth was not initialized yet or failed, will use the path from the config automatically
		works.fluidsynth = true;
		CreateFluidsynth(true);
		return;
	}

#if defined(HAVE_FLUIDSYNTH) || defined(HAVE_FLUIDLITE)
	// Was initialized before
	works.fluidsynth = FluidSynthDecoder::ChangeGlobalSoundfont(sf_path, works.fluidsynth_status);
	Output::Debug("Fluidsynth: {}", works.fluidsynth_status);
#else
	(void)sf_path;
#endif
}

bool MidiDecoder::CheckWildMidi(std::string &status_message) {
	if (works.wildmidi && works.wildmidi_status.empty()) {
		CreateWildMidi(true);
	}

	status_message = works.wildmidi_status;
	return works.wildmidi;
}

void MidiDecoder::Reset() {
	works.fluidsynth = true;
	works.wildmidi = true;

#ifdef HAVE_LIBWILDMIDI
	WildMidiDecoder::ResetState();
#endif

#if defined(HAVE_FLUIDSYNTH) || defined(HAVE_FLUIDLITE)
	FluidSynthDecoder::ResetState();
#endif
}


/*end of file .\audio_midi.cpp*/

/*start of file .\audio_resampler.cpp*/

/* ... license chunk ... */

#include "audio_decoder_base.h"
#include "system.h"

#ifdef USE_AUDIO_RESAMPLER

#include <cassert>
#include <cstring>
#include "audio_resampler.h"
#include "output.h"

#define ERROR -1
#define STANDARD_PITCH 100

/**
 * Utility function used to convert a buffer of a arbitrary AudioDecoder::Format to a float buffer
 *
 * @param[in] wrapped_decoder The decoder from which audio samples are read
 * @param[inout] buffer The buffer which will receive the converted samples,
 *			has to be at least amount_of_samples_to_read*sizeof(float) bytes big.
 * @param[in] amount_of_samples_to_read The number of samples to read.
 * @param[in] input_samplesize The size of one sample of the decoder in it's original format - given in bytes
 * @param[in] input_format The original format of the samples
 *
 * @return The number of converted samples - if this number is smaller than amount_of_samples_to_read the wrapped decoder has reaches it's end.
 *		If the returned value has a negative value an error occured.
 */
inline static int DecodeAndConvertFloat(AudioDecoderBase* wrapped_decoder,
										uint8_t * buffer,
										int amount_of_samples_to_read,
										const int input_samplesize,
										const AudioDecoder::Format input_format){
	float* bufferAsFloat = (float*)buffer;

	//Workaround for decoders which don't detect their own end
	if (wrapped_decoder->IsFinished())
		return 0;

	int amount_of_samples_read = wrapped_decoder->Decode(buffer, amount_of_samples_to_read*input_samplesize);
	if (amount_of_samples_read <= 0) {
		return amount_of_samples_read; //error occured - or nothing read
	} else {
		amount_of_samples_read /= input_samplesize;
	}

	//Convert the read data (amount_of_data_read is at least one at this moment)
	switch (input_format) {
		case AudioDecoder::Format::S8:
			//Convert inplace (the last frames are unused if smaller)
			for (int i = amount_of_samples_read - 1; i >= 0; i--) {
				bufferAsFloat[i] = ((int8_t*)bufferAsFloat)[i] / 128.0;
			}
			break;
		case AudioDecoder::Format::U8:
			//Convert inplace (the last frames are unused if smaller)
			for (int i = amount_of_samples_read - 1; i >= 0; i--) {
				bufferAsFloat[i] = ((uint8_t*)bufferAsFloat)[i] / 128.0 - 1.0;
			}
			break;
		case AudioDecoder::Format::S16:
			//Convert inplace (the last frames are unused if smaller)
			for (int i = amount_of_samples_read - 1; i >= 0; i--) {
				bufferAsFloat[i] = ((int16_t*)bufferAsFloat)[i] / 32768.0;
			}
			break;
		case AudioDecoder::Format::U16:
			//Convert inplace (the last frames are unused if smaller)
			for (int i = amount_of_samples_read - 1; i >= 0; i--) {
				bufferAsFloat[i] = ((uint16_t*)bufferAsFloat)[i] / 32768.0 - 1.0;
			}
			break;
		case AudioDecoder::Format::S32:
			//Convert inplace (same size)
			for (int i = amount_of_samples_read - 1; i >= 0; i--) {
				bufferAsFloat[i] = ((int32_t*)bufferAsFloat)[i] / 2147483648.0;
			}
			break;
		case AudioDecoder::Format::U32:
			//Convert inplace (same size)
			for (int i = amount_of_samples_read - 1; i >= 0; i--) {
				bufferAsFloat[i] = ((uint32_t*)bufferAsFloat)[i] / 2147483648.0 - 1.0;
			}
			break;
		case AudioDecoder::Format::F32:
			//Nothing to convert
			break;
	}
	return amount_of_samples_read;
}

#if defined(HAVE_LIBSPEEXDSP)
/**
 * Utility function used to convert a buffer of a arbitrary AudioDecoder::Format to a int16 buffer
 *
 * @param[in] wrapped_decoder The decoder from which audio samples are read
 * @param[inout] buffer The buffer which will receive the converted samples,
 *			has to be at least amount_of_samples_to_read*max(sizeof(int16_t),input_samplesize) bytes big.
 * @param[in] amount_of_samples_to_read The number of samples to read.
 * @param[in] input_samplesize The size of one sample of the decoder in it's original format - given in bytes
 * @param[in] input_format The original format of the samples
 *
 * @return The number of converted samples - if this number is smaller than amount_of_samples_to_read the wrapped decoder has reaches it's end.
 *		If the returned value has a negative value an error occured.
 */
inline static int DecodeAndConvertInt16(AudioDecoderBase* wrapped_decoder,
										uint8_t * buffer,
										int amount_of_samples_to_read,
										const int input_samplesize,
										const AudioDecoder::Format input_format){
	int16_t* bufferAsInt16 = (int16_t*)buffer;

	//Workaround for decoders which don't detect their own end
	if (wrapped_decoder->IsFinished())
		return 0;

	int amount_of_samples_read = wrapped_decoder->Decode(buffer, amount_of_samples_to_read*input_samplesize);
	if (amount_of_samples_read <= 0) {
		return amount_of_samples_read; //error occured - or nothing read
	} else {
		//Convert the number of bytes to the number of samples
		amount_of_samples_read /= input_samplesize;
	}
	//Convert the read data (amount_of_data_read is at least one at this moment)
	switch (input_format) {
		case AudioDecoder::Format::S8:
			//Convert inplace (the last frames are unused if smaller)
			for (int i = amount_of_samples_read - 1; i >= 0; i--) {
				bufferAsInt16[i] = ((int8_t*)bufferAsInt16)[i] << 8;
			}
			break;
		case AudioDecoder::Format::U8:
			//Convert inplace (the last frames are unused if smaller)
			for (int i = amount_of_samples_read - 1; i >= 0; i--) {
				bufferAsInt16[i] = (((int16_t)(((uint8_t*)bufferAsInt16)[i])) - 128) << 8;
			}
			break;
		case AudioDecoder::Format::S16:
			//Nothing to convert
			break;
		case AudioDecoder::Format::U16:
			//Convert unsigned to signed
			for (int i = amount_of_samples_read - 1; i >= 0; i--) {
				bufferAsInt16[i] = (int16_t)(((int32_t)(((uint16_t*)bufferAsInt16)[i])) - 32768);
			}
			break;
		case AudioDecoder::Format::S32:
			//Convert inplace (from front to back to prevent overwriting the buffer)
			for (int i = 0; i < amount_of_samples_read; i++) {
				bufferAsInt16[i] = (int16_t)((((int32_t*)bufferAsInt16)[i]) >> 16);
			}
			break;
		case AudioDecoder::Format::U32:
			//Convert inplace (from front to back to prevent overwriting the buffer)
			for (int i = 0; i < amount_of_samples_read; i++) {
				bufferAsInt16[i] = (int16_t)(((int32_t)((((uint32_t*)bufferAsInt16)[i]) >> 16)) - 32768);
			}
			break;
		case AudioDecoder::Format::F32:
			//Convert inplace (from front to back to prevent overwriting the buffer)
			for (int i = 0; i < amount_of_samples_read; i++) {
				float number = ((((float*)bufferAsInt16)[i])*32768.0);
				bufferAsInt16[i] = (number <= 32767.0) ? ((number >= -32768.0) ? number : -32768) : 32767;
			}
			break;
	}
	return amount_of_samples_read;
}
#endif

AudioResampler::AudioResampler(std::unique_ptr<AudioDecoderBase> wrapped, AudioResampler::Quality quality)
	: wrapped_decoder(std::move(wrapped))
{
	//There is no need for a standalone resampler decoder
	assert(wrapped_decoder != 0);

	music_type = wrapped_decoder->GetType();
	lasterror = 0;

	#if defined(HAVE_LIBSPEEXDSP)
		switch (quality) {
			case Quality::Low:
				sampling_quality = 0;
				break;
			case Quality::Medium:
				sampling_quality = 3;
				break;
			case Quality::High:
				sampling_quality = 5;
				break;
		}
	#elif defined(HAVE_LIBSAMPLERATE)
		switch (quality) {
			case Quality::Low:
				sampling_quality = SRC_SINC_FASTEST;
				break;
			case Quality::Medium:
				sampling_quality = SRC_SINC_MEDIUM_QUALITY;
				break;
			case Quality::High:
				sampling_quality = SRC_SINC_BEST_QUALITY;
				break;
		}
	#endif

	finished = false;
}

AudioResampler::~AudioResampler() {
	if (conversion_state) {
	#if defined(HAVE_LIBSPEEXDSP)
			speex_resampler_destroy(conversion_state);
	#elif defined(HAVE_LIBSAMPLERATE)
			src_delete(conversion_state);
	#endif
	}
}

bool AudioResampler::WasInited() const {
	return wrapped_decoder->WasInited();
}

bool AudioResampler::Open(Filesystem_Stream::InputStream stream) {
	if (wrapped_decoder->Open(std::move(stream))) {
		wrapped_decoder->GetFormat(input_rate, input_format, nr_of_channels);

		//determine if the input format is supported by the resampler
		switch (input_format) {
			case Format::F32: output_format = input_format; break;
		#ifdef HAVE_LIBSPEEXDSP
			case Format::S16: output_format = input_format; break;
		#endif
			default: output_format = Format::F32; break;
		}

		//Set input format to output_format if possible
		wrapped_decoder->SetFormat(input_rate, output_format, nr_of_channels);
		//Reread format to get new values
		wrapped_decoder->GetFormat(input_rate, input_format, nr_of_channels);
		output_rate = input_rate;

		#if defined(HAVE_LIBSPEEXDSP)
			conversion_state = speex_resampler_init(nr_of_channels, input_rate, output_rate, sampling_quality, &lasterror);
			conversion_data.ratio_num = input_rate;
			conversion_data.ratio_denom = output_rate;
			speex_resampler_skip_zeros(conversion_state);
		#elif defined(HAVE_LIBSAMPLERATE)
			conversion_state = src_new(sampling_quality, nr_of_channels, &lasterror);
		#endif

		//Init the conversion data structure
		conversion_data.input_frames = 0;
		conversion_data.input_frames_used = 0;
		finished = false;

		if (conversion_state)
			return true;
	}

	conversion_state = nullptr;
	return false;
}

void AudioResampler::Pause() {
	wrapped_decoder->Pause();
}

void AudioResampler::Resume() {
	wrapped_decoder->Resume();
}

StereoVolume AudioResampler::GetVolume() const {
	return wrapped_decoder->GetVolume();
}

void AudioResampler::SetVolume(int volume) {
	wrapped_decoder->SetVolume(volume);
}

void AudioResampler::SetFade(int end, std::chrono::milliseconds duration) {
	wrapped_decoder->SetFade(end, duration);
}

bool AudioResampler::Seek(std::streamoff offset, std::ios_base::seekdir origin) {
	if (wrapped_decoder->Seek(offset, origin)) {
		//reset conversion data
		conversion_data.input_frames = 0;
		conversion_data.input_frames_used = 0;
		finished = wrapped_decoder->IsFinished();
		#if defined(HAVE_LIBSPEEXDSP)
			speex_resampler_reset_mem(conversion_state);
		#elif defined(HAVE_LIBSAMPLERATE)
			src_reset(conversion_state);
		#endif
		return true;
	}
	return false;
}

bool AudioResampler::GetLooping() const {
	return wrapped_decoder->GetLooping();
}

void AudioResampler::SetLooping(bool enable) {
	wrapped_decoder->SetLooping(enable);
}

int AudioResampler::GetLoopCount() const {
	return wrapped_decoder->GetLoopCount();
}

int AudioResampler::GetBalance() const {
	return wrapped_decoder->GetBalance();
}

void AudioResampler::SetBalance(int new_balance) {
	wrapped_decoder->SetBalance(new_balance);
}

std::streampos AudioResampler::Tell() const {
	return wrapped_decoder->Tell();
}

int AudioResampler::GetTicks() const {
	return wrapped_decoder->GetTicks();
}

bool AudioResampler::IsFinished() const {
	return finished;
}

void AudioResampler::Update(std::chrono::microseconds delta) {
	wrapped_decoder->Update(delta);
}

void AudioResampler::GetFormat(int& frequency, AudioDecoder::Format& format, int& channels) const {
	frequency = output_rate;
	format = output_format;
	channels = mono_to_stereo_resample ? 2 : nr_of_channels;
}

bool AudioResampler::SetFormat(int freq, AudioDecoder::Format fmt, int channels) {
	//Check whether requested format is supported by the resampler
	switch (fmt) {
		case Format::F32:
			output_format = fmt;
			break;
	#ifdef HAVE_LIBSPEEXDSP
		case Format::S16:
			output_format = fmt;
			break;
	#endif
		default:
			break;
	}
	wrapped_decoder->SetFormat(input_rate, output_format, channels);
	wrapped_decoder->GetFormat(input_rate, input_format, nr_of_channels);
	output_rate = freq;

	mono_to_stereo_resample = false;
	if (channels == 2 && nr_of_channels == 1) {
		mono_to_stereo_resample = true;
	}

	return ((nr_of_channels == channels || mono_to_stereo_resample) && (output_format == fmt));
}

int AudioResampler::GetPitch() const {
	return pitch;
}

bool AudioResampler::SetPitch(int pitch_) {
	pitch_handled_by_decoder = wrapped_decoder->SetPitch(pitch_);
	pitch = pitch_;
	return true;
}

int AudioResampler::FillBuffer(uint8_t* buffer, int length) {
	int amount_filled = 0;

	int bytes_to_read = length;
	if (mono_to_stereo_resample) {
		bytes_to_read /= 2;
	}

	if ((input_rate == output_rate) && ((pitch == STANDARD_PITCH) || pitch_handled_by_decoder)) {
		// Do only format conversion
		amount_filled = FillBufferSameRate(buffer, bytes_to_read);
	} else {
		if (!conversion_state) {
			error_message = "internal error: state pointer is a nullptr";
			amount_filled = ERROR;
		} else {
			//Do samplerate conversion
			amount_filled = FillBufferDifferentRate(buffer, bytes_to_read);
		}
	}

	if (!mono_to_stereo_resample || amount_filled <= 0) {
		return amount_filled;
	}

	// Resample mono to stereo
	int sample_size = AudioDecoder::GetSamplesizeForFormat(output_format);

	// Duplicate data from the back, allows writing to the buffer directly
	for (int i = amount_filled - sample_size; i > 0; i -= sample_size) {
		// left channel
		memcpy(&buffer[i * 2], &buffer[i], sample_size);
		// right channel
		memcpy(&buffer[i * 2 + sample_size], &buffer[i], sample_size);
	}

	return amount_filled * 2;
}

int AudioResampler::FillBufferSameRate(uint8_t* buffer, int length) {
	const int input_samplesize = AudioDecoder::GetSamplesizeForFormat(input_format);
	const int output_samplesize = AudioDecoder::GetSamplesizeForFormat(output_format);
	//The buffer size has to be a multiple of a frame
	const int buffer_size=sizeof(internal_buffer) - sizeof(internal_buffer)%(nr_of_channels*input_samplesize);

	int total_output_frames = length / (output_samplesize*nr_of_channels);
	int amount_of_data_to_read = 0;
	int amount_of_data_read = total_output_frames*nr_of_channels;

	int decoded = 0;

	if (input_samplesize > output_samplesize) {
		//It is necessary to use the internal_buffer to convert the samples.
		while (total_output_frames > 0) {
			amount_of_data_to_read = buffer_size / input_samplesize;

			//limit amount_of_data_to_read in the last loop
			amount_of_data_to_read = (amount_of_data_to_read > total_output_frames) ? total_output_frames : amount_of_data_to_read;

			switch (output_format) {
				case AudioDecoder::Format::F32:
				amount_of_data_read = DecodeAndConvertFloat(wrapped_decoder.get(), internal_buffer, amount_of_data_to_read, input_samplesize, input_format);
				break;
			#ifdef HAVE_LIBSPEEXDSP
				case AudioDecoder::Format::S16:
				amount_of_data_read = DecodeAndConvertInt16(wrapped_decoder.get(), internal_buffer, amount_of_data_to_read, input_samplesize, input_format);
				break;
			#endif
				default: error_message = "internal error: output_format is not convertable"; return ERROR;
			}
			if (amount_of_data_read < 0) {
				error_message = wrapped_decoder->GetError();
				return amount_of_data_read; //error occured
			}

			//Copy the converted samples
			for (int i = 0; i < amount_of_data_read*output_samplesize; i++) {
				buffer[i] = internal_buffer[i];
			}
			//Prepare next loop
			total_output_frames -= amount_of_data_read;
			decoded += amount_of_data_read;
			buffer += amount_of_data_read*output_samplesize;

			//If the end of the decoder is reached (it has finished)
			if (amount_of_data_read < amount_of_data_to_read) {
				break;
			}

		}
	} else {
		//It is possible to work inplace as length is specified for the output samplesize.
		switch (output_format) {
			case AudioDecoder::Format::F32:
			decoded = DecodeAndConvertFloat(wrapped_decoder.get(), buffer, amount_of_data_read, input_samplesize, input_format);
			break;
		#ifdef HAVE_LIBSPEEXDSP
			case AudioDecoder::Format::S16:
			decoded = DecodeAndConvertInt16(wrapped_decoder.get(), buffer, amount_of_data_read, input_samplesize, input_format);
			break;
		#endif
			default: error_message = "internal error: output_format is not convertable"; return ERROR;
		}
	}

	finished = wrapped_decoder->IsFinished();
	if (decoded < 0) {
		error_message = wrapped_decoder->GetError();
		return decoded;
	} else {
		return decoded*output_samplesize;
	}
}

int AudioResampler::FillBufferDifferentRate(uint8_t* buffer, int length) {
	const int input_samplesize = AudioDecoder::GetSamplesizeForFormat(input_format);
	const int output_samplesize = AudioDecoder::GetSamplesizeForFormat(output_format);
	//The buffer size has to be a multiple of a frame
	const int buffer_size=sizeof(internal_buffer) - sizeof(internal_buffer)%(nr_of_channels*((input_samplesize>output_samplesize) ? input_samplesize : output_samplesize));

	int total_output_frames = length / (output_samplesize*nr_of_channels);
	int amount_of_samples_to_read = 0;
	int amount_of_samples_read = 0;

	uint8_t * advanced_input_buffer = internal_buffer;
	int unused_frames = 0;
	int empty_buffer_space = 0;
	int error = 0;

	#ifdef HAVE_LIBSPEEXDSP
		spx_uint32_t numerator = 0;
		spx_uint32_t denominator = 0;
	#endif

	while (total_output_frames > 0) {
		//Calculate how much frames of the last cycle are unused - to reuse them
		unused_frames = conversion_data.input_frames - conversion_data.input_frames_used;
		empty_buffer_space = buffer_size / output_samplesize - unused_frames*nr_of_channels;

		advanced_input_buffer = internal_buffer;

		//If there is still unused data in the input_buffer order it to the front
		for (int i = 0; i < unused_frames*nr_of_channels*output_samplesize; i++) {
			*advanced_input_buffer = *(advanced_input_buffer + empty_buffer_space*output_samplesize);
			advanced_input_buffer++;
		}
		//advanced_input_buffer is now offset to the first frame of new data!

		//ensure that the input buffer is not able to overrun
		amount_of_samples_to_read = (input_samplesize > output_samplesize) ? (empty_buffer_space*output_samplesize) / input_samplesize : empty_buffer_space;

		//Read as many frames as needed to refill the buffer (filled after the conversion to float)
		if (amount_of_samples_to_read != 0) {
			switch (output_format) {
				case AudioDecoder::Format::F32: amount_of_samples_read = DecodeAndConvertFloat(wrapped_decoder.get(), advanced_input_buffer, amount_of_samples_to_read, input_samplesize, input_format); break;
			#ifdef HAVE_LIBSPEEXDSP
				case AudioDecoder::Format::S16:  amount_of_samples_read = DecodeAndConvertInt16(wrapped_decoder.get(), advanced_input_buffer, amount_of_samples_to_read, input_samplesize, input_format); break;
			#endif
				default: error_message = "internal error: output_format is not convertable"; return ERROR;
			}
			if (amount_of_samples_read < 0) {
				error_message = wrapped_decoder->GetError();
				return amount_of_samples_read; //error occured
			}
		}
		//Now we have a prepared full buffer of converted values

		//Prepare the source data
		conversion_data.input_frames = amount_of_samples_read / nr_of_channels + unused_frames;
		conversion_data.output_frames = total_output_frames;

		#if defined(HAVE_LIBSPEEXDSP)
			conversion_data.input_frames_used = conversion_data.input_frames;
			conversion_data.output_frames_gen = conversion_data.output_frames;

			//libspeexdsp defines a sample rate conversion with a fraction (input/output)
			numerator = input_rate*pitch;
			denominator = output_rate * STANDARD_PITCH;
			if (pitch_handled_by_decoder) {
				numerator = input_rate;
				denominator = output_rate;
			}
			if (conversion_data.ratio_num != numerator || conversion_data.ratio_denom != denominator) {
				speex_resampler_set_rate_frac(conversion_state, numerator, denominator, input_rate, output_rate);
				conversion_data.ratio_num = numerator;
				conversion_data.ratio_denom = denominator;
			}

			//A pitfall from libspeexdsp if the output buffer is defined to big - everything stutters -achieved good values with the same size as the input buffer for a maximum
			conversion_data.output_frames_gen=(conversion_data.input_frames<conversion_data.output_frames_gen) ? conversion_data.input_frames :conversion_data.output_frames_gen;

			switch (output_format) {
			case Format::F32:
				error = speex_resampler_process_interleaved_float(conversion_state, (float*)internal_buffer, &conversion_data.input_frames_used, (float*)buffer, &conversion_data.output_frames_gen);
				break;
			case Format::S16:
				error = speex_resampler_process_interleaved_int(conversion_state, (spx_int16_t*)internal_buffer, &conversion_data.input_frames_used, (spx_int16_t*)buffer, &conversion_data.output_frames_gen);
				break;
			default: error_message = "internal error: output_format is not convertable"; return ERROR;
			}

			if (error != 0) {
				error_message = speex_resampler_strerror(error);
				return ERROR;
			}
		#elif defined(HAVE_LIBSAMPLERATE)
			conversion_data.data_in = (float*)internal_buffer;
			conversion_data.data_out = (float*)buffer;
			if (pitch_handled_by_decoder) {
				conversion_data.src_ratio = (output_rate*1.0) / input_rate;
			}
			else {
				conversion_data.src_ratio = (output_rate*STANDARD_PITCH *1.0) / (input_rate*pitch*1.0);
			}
			conversion_data.end_of_input = (wrapped_decoder->IsFinished()) ? 1 : 0;

			//Now let libsamplerate filter the data
			error = src_process(conversion_state, &conversion_data);

			if (error != 0) {
				error_message = src_strerror(error);
				return ERROR;
			}
		#endif

		total_output_frames -= conversion_data.output_frames_gen;
		buffer += conversion_data.output_frames_gen*nr_of_channels*output_samplesize;

		if ((conversion_data.input_frames == 0 && conversion_data.output_frames_gen <= conversion_data.output_frames) || conversion_data.output_frames_gen == 0) {
			finished = true;
			//There is nothing left to convert - return how much samples (in bytes) are converted!
			return length - total_output_frames*(output_samplesize*nr_of_channels);
		}
	}
	return length;
}

#endif


/*end of file .\audio_resampler.cpp*/

/*start of file .\audio_secache.cpp*/

/* ... license chunk ... */

// Headers
#include <cassert>
#include <cstring>
#include <map>
#include <memory>
#include <set>
#include "audio_resampler.h"
#include "audio_secache.h"
#include "game_clock.h"
#include "filefinder.h"
#include "output.h"

using namespace std::chrono_literals;

namespace {
	typedef std::map<std::string, AudioSeRef> cache_type;

	cache_type cache;

	constexpr int cache_limit = 3 * 1024 * 1024;
	int cache_size = 0;

	void FreeCacheMemory() {
		auto cur_time = Game_Clock::GetFrameTime();

		for (auto it = cache.begin(); it != cache.end(); ) {
			if (it->second.use_count() > 1) {
				// SE is currently playing
				++it;
				continue;
			}

			if (cache_size <= cache_limit && cur_time - it->second->last_access < 3s) {
				// Below memory limit and last access < 3s
				++it;
				continue;
			}

#ifdef CACHE_DEBUG
			Output::Debug("SE: Freeing memory of {}", it->first);
#endif

			cache_size -= it->second->buffer.size();

			it = cache.erase(it);
		}

#ifdef CACHE_DEBUG
		Output::Debug("SE cache size: {}", cache_size / 1024.0 / 1024);
#endif
	}
}

std::unique_ptr<AudioSeCache> AudioSeCache::Create(Filesystem_Stream::InputStream stream, std::string_view name) {
	auto se = std::make_unique<AudioSeCache>();
	se->name = ToString(name);

	auto const it = cache.find(ToString(name));
	if (it == cache.end()) {
		// Not in cache
		if (!stream) {
			return {};
		}

		se->audio_decoder = AudioDecoder::Create(stream, false);

		if (se->audio_decoder) {
			if (!se->audio_decoder->Open(std::move(stream))) {
				se->audio_decoder.reset();
			}
		}

		if (!se->audio_decoder) {
			return {};
		}
	}

	return se;
}

void AudioSeCache::GetFormat(int& frequency, AudioDecoder::Format& format, int& channels) const {
	if (!audio_decoder) {
		if (!GetCachedFormat(frequency, format, channels)) {
			assert(false);
		}

		return;
	}

	audio_decoder->GetFormat(frequency, format, channels);
}

std::unique_ptr<AudioSeCache> AudioSeCache::GetCachedSe(std::string_view name) {
	auto se = std::make_unique<AudioSeCache>();
	se->name = ToString(name);

	auto const it = cache.find(se->name);
	if (it == cache.end()) {
		return {};
	}

	return se;
}

bool AudioSeCache::GetCachedFormat(int& frequency, AudioDecoder::Format& format, int& channels) const {
	cache_type::const_iterator it = cache.find(name);

	if (it != cache.end()) {
		frequency = (*it).second->frequency;
		format = (*it).second->format;
		channels = (*it).second->channels;

		return true;
	}

	return false;
}

std::unique_ptr<AudioDecoderBase> AudioSeCache::CreateSeDecoder() {
	AudioSeRef se;

	auto it = cache.find(name);
	if (it != cache.end()) {
		se = it->second;
		se->last_access = Game_Clock::GetFrameTime();

		std::unique_ptr<AudioDecoderBase> dec = std::make_unique<AudioSeDecoder>(se);
#ifdef USE_AUDIO_RESAMPLER
		dec = std::make_unique<AudioResampler>(std::move(dec));
#endif
		Filesystem_Stream::InputStream is;
		dec->Open(std::move(is));
		return dec;
	}

	// Not cached yet: Decode the sample without any resampling

	if (!se) {
		se.reset(new AudioSeData());
	}

	assert(audio_decoder);

	audio_decoder->GetFormat(se->frequency, se->format, se->channels);
	se->buffer = audio_decoder->DecodeAll();

	cache.insert(std::make_pair(name, se));

	cache_size += se->buffer.size();

#ifdef CACHE_DEBUG
	Output::Debug("SE cache size (Add): {}", cache_size / 1024.0 / 1024.0);
#endif

	FreeCacheMemory();

	std::unique_ptr<AudioDecoderBase> dec = std::unique_ptr<AudioDecoderBase>(new AudioSeDecoder(se));
#ifdef USE_AUDIO_RESAMPLER
	dec = std::unique_ptr<AudioDecoderBase>(new AudioResampler(std::move(dec)));
#endif
	Filesystem_Stream::InputStream is;
	dec->Open(std::move(is));
	return dec;
}

AudioSeRef AudioSeCache::GetSeData() const {
	auto it = cache.find(name);
	assert(it != cache.end());

	return it->second;
};

void AudioSeCache::Clear() {
	cache_size = 0;
	cache.clear();
}

std::string_view AudioSeCache::GetName() const {
	return name;
}

AudioSeDecoder::AudioSeDecoder(const AudioSeRef& se) :
	se(se) {
	se->last_access = Game_Clock::GetFrameTime();
}

bool AudioSeDecoder::IsFinished() const {
	return offset >= se->buffer.size();
}

void AudioSeDecoder::GetFormat(int &frequency, AudioDecoder::Format &format, int &channels) const {
	frequency = se->frequency;
	format = se->format;
	channels = se->channels;
}

int AudioSeDecoder::FillBuffer(uint8_t *buffer, int size) {
	int real_size = size;

	if (offset + size > se->buffer.size()) {
		real_size = se->buffer.size() - offset;
	}

	memcpy(buffer, se->buffer.data() + offset, real_size);
	offset += real_size;

	return real_size;
}

int AudioSeDecoder::GetPitch() const {
	return 100;
}


/*end of file .\audio_secache.cpp*/

/*start of file .\autobattle.cpp*/

/* ... license chunk ... */
#include "autobattle.h"
#include "game_actor.h"
#include "game_enemy.h"
#include "game_enemyparty.h"
#include "game_party.h"
#include "game_battlealgorithm.h"
#include "game_battle.h"
#include "algo.h"
#include "player.h"
#include "output.h"
#include "rand.h"
#include <lcf/reader_util.h>
#include <lcf/data.h>

namespace AutoBattle {

#ifdef EP_DEBUG_AUTOBATTLE
template <typename... Args>
static void DebugLog(const char* fmt, Args&&... args) {
	Output::Debug(fmt, std::forward<Args>(args)...);
}
#else
template <typename... Args>
static void DebugLog(const char*, Args&&...) {}
#endif

std::unique_ptr<AlgorithmBase> CreateAlgorithm(std::string_view name) {
	if (Utils::StrICmp(name, RpgRtImproved::name) == 0) {
		return std::make_unique<RpgRtImproved>();
	}
	if (Utils::StrICmp(name, AttackOnly::name) == 0) {
		return std::make_unique<AttackOnly>();
	}
	if (Utils::StrICmp(name, RpgRtCompat::name) != 0) {
		static bool warned = false;
		if (!warned) {
			Output::Debug("Invalid AutoBattle algo name `{}' falling back to {} ...", name, RpgRtCompat::name);
			warned = true;
		}
	}
	return std::make_unique<RpgRtCompat>();
}

void AlgorithmBase::SetAutoBattleAction(Game_Actor& source) {
	vSetAutoBattleAction(source);
	if (source.GetBattleAlgorithm() == nullptr) {
		source.SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::None>(&source));
	}
}

void RpgRtCompat::vSetAutoBattleAction(Game_Actor& source) {
	SelectAutoBattleActionRpgRtCompat(source, Game_Battle::GetBattleCondition());
}

void AttackOnly::vSetAutoBattleAction(Game_Actor& source) {
	SelectAutoBattleAction(source, Game_Battler::WeaponAll, Game_Battle::GetBattleCondition(), false, false, false, false);
}

void RpgRtImproved::vSetAutoBattleAction(Game_Actor& source) {
	SelectAutoBattleAction(source, Game_Battler::WeaponAll, Game_Battle::GetBattleCondition(), true, false, false, false);
}

static int CalcSkillCostAutoBattle(const Game_Actor& source, const lcf::rpg::Skill& skill, bool emulate_bugs) {
	// RPG_RT autobattle ignores half sp cost modifier
	return emulate_bugs
		? Algo::CalcSkillCost(skill, source.GetMaxSp(), false)
		: source.CalculateSkillCost(skill.ID);
}

double CalcSkillHealAutoBattleTargetRank(const Game_Actor& source, const Game_Battler& target, const lcf::rpg::Skill& skill, lcf::rpg::System::BattleCondition cond, bool apply_variance, bool emulate_bugs) {
	assert(Algo::IsNormalOrSubskill(skill));
	assert(Algo::SkillTargetsAllies(skill));

	const double src_max_sp = source.GetMaxSp();
	const double tgt_max_hp = target.GetMaxHp();
	const double tgt_hp = target.GetHp();

	if (target.GetHp() > 0) {
		// Can the skill heal the target?
		if (!skill.affect_hp) {
			return 0.0;
		}

		const double base_effect = Algo::CalcSkillEffect(source, target, skill, apply_variance, false, cond, false);
		const double max_effect = std::min(base_effect, tgt_max_hp - tgt_hp);

		auto rank = static_cast<double>(max_effect) / static_cast<double>(tgt_max_hp);
		if (src_max_sp > 0) {
			const double cost = CalcSkillCostAutoBattle(source, skill, emulate_bugs);
			rank -= cost / src_max_sp / 8.0;
			rank = std::max(rank, 0.0);
		}
		return rank;
	}

	// Can the skill revive the target?
	if (skill.state_effects.size() > 1 && skill.state_effects[0]) {
		// BUG: RPG_RT does not check the reverse_state_effect flag to skip skills which would kill party members
		if (emulate_bugs || !skill.reverse_state_effect) {
			return static_cast<double>(skill.power) / 1000.0 + 1.0;
		}
	}
	return 0.0;
}

double CalcSkillDmgAutoBattleTargetRank(const Game_Actor& source, const Game_Battler& target, const lcf::rpg::Skill& skill, lcf::rpg::System::BattleCondition cond, bool apply_variance, bool emulate_bugs) {
	assert(Algo::IsNormalOrSubskill(skill));
	assert(Algo::SkillTargetsEnemies(skill));

	if (!(skill.affect_hp && target.Exists())) {
		return 0.0;
	}

	double rank = 0.0;
	const double src_max_sp = source.GetMaxSp();
	const double tgt_hp = target.GetHp();

	const double base_effect = Algo::CalcSkillEffect(source, target, skill, apply_variance, false, cond, false);
	rank = std::min(base_effect, tgt_hp) / tgt_hp;
	if (rank == 1.0) {
		rank = 1.5;
	}
	if (src_max_sp > 0) {
		const double cost = CalcSkillCostAutoBattle(source, skill, emulate_bugs);
		rank -= cost / src_max_sp / 4.0;
		rank = std::max(rank, 0.0);
	}

	// Bonus if the target is the first existing enemy?
	for (auto* enemy: Main_Data::game_enemyparty->GetEnemies()) {
		if (enemy->Exists()) {
			if (enemy == &target) {
				rank = rank * 1.5 + 0.5;
			}
			break;
		}
	}

	return rank;
}

double CalcSkillAutoBattleRank(const Game_Actor& source, const lcf::rpg::Skill& skill, lcf::rpg::System::BattleCondition cond, bool apply_variance, bool emulate_bugs) {
	if (!source.IsSkillUsable(skill.ID)) {
		return 0.0;
	}
	if (!Algo::IsNormalOrSubskill(skill)) {
		return 0.0;
	}

	double rank = 0.0;
	switch (skill.scope) {
		case lcf::rpg::Skill::Scope_ally:
			for (auto* target: Main_Data::game_party->GetActors()) {
				auto target_rank = CalcSkillHealAutoBattleTargetRank(source, *target, skill, cond, apply_variance, emulate_bugs);
				rank = std::max(rank, target_rank);
				DebugLog("AUTOBATTLE: Actor {} Check Skill Single Ally {} Rank : {}({}): {} -> {}", source.GetName(), target->GetName(), skill.name, skill.ID, rank, target_rank);
			}
			break;
		case lcf::rpg::Skill::Scope_party:
			for (auto* target: Main_Data::game_party->GetActors()) {
				auto target_rank = CalcSkillHealAutoBattleTargetRank(source, *target, skill, cond, apply_variance, emulate_bugs);
				rank += target_rank;
				DebugLog("AUTOBATTLE: Actor {} Check Skill Party Ally {} Rank : {}({}): {} -> {}", source.GetName(), target->GetName(), skill.name, skill.ID, rank, target_rank);
			}
			break;
		case lcf::rpg::Skill::Scope_enemy:
			for (auto* target: Main_Data::game_enemyparty->GetEnemies()) {
				auto target_rank = CalcSkillDmgAutoBattleTargetRank(source, *target, skill, cond, apply_variance, emulate_bugs);
				rank = std::max(rank, target_rank);
				DebugLog("AUTOBATTLE: Actor {} Check Skill Single Enemy {} Rank : {}({}): {} -> {}", source.GetName(), target->GetName(), skill.name, skill.ID, rank, target_rank);
			}
			break;
		case lcf::rpg::Skill::Scope_enemies:
			for (auto* target: Main_Data::game_enemyparty->GetEnemies()) {
				auto target_rank = CalcSkillDmgAutoBattleTargetRank(source, *target, skill, cond, apply_variance, emulate_bugs);
				rank += target_rank;
				DebugLog("AUTOBATTLE: Actor {} Check Skill Party Enemy {} Rank : {}({}): {} -> {}", source.GetName(), target->GetName(), skill.name, skill.ID, rank, target_rank);
			}
			break;
		case lcf::rpg::Skill::Scope_self:
			rank = CalcSkillHealAutoBattleTargetRank(source, source, skill, cond, apply_variance, emulate_bugs);
			DebugLog("AUTOBATTLE: Actor {} Check Skill Self Rank : {}({}): {}", source.GetName(), skill.name, skill.ID, rank);
			break;
	}
	if (rank > 0.0) {
		rank += Rand::GetRandomNumber(0, 99) / 100.0;
	}
	return rank;
}

double CalcNormalAttackAutoBattleTargetRank(const Game_Actor& source,
		const Game_Battler& target,
		Game_Battler::Weapon weapon,
		lcf::rpg::System::BattleCondition cond,
		bool apply_variance,
		bool emulate_bugs)
{
	if (!target.Exists()) {
		return 0.0;
	}
	const bool is_critical_hit = false;
	const bool is_charged = false;

	// RPG_RT BUG: Normal damage variance is not used
	// Note: RPG_RT does not do the "2k3_enemy_row_bug" when computing autobattle ranks.
	double base_effect = Algo::CalcNormalAttackEffect(source, target, weapon, is_critical_hit, is_charged, apply_variance, cond, false);
	// RPG_RT BUG: Dual Attack is ignored
	if (!emulate_bugs) {
		base_effect *= source.GetNumberOfAttacks(weapon);
	}
	const double tgt_hp = target.GetHp();

	auto rank = std::min(base_effect, tgt_hp) / tgt_hp;
	if (rank == 1.0) {
		rank = 1.5;
	}
	if (!emulate_bugs) {
		// EasyRPG customization - include sp cost of weapon attack using same logic as skill attack
		const auto cost = std::min(source.CalculateWeaponSpCost(weapon), source.GetSp());
		if (cost > 0) {
			const double src_max_sp = source.GetMaxSp();
			rank -= static_cast<double>(cost) / src_max_sp / 4.0;
			rank = std::max(rank, 0.0);
		}
	}

	// Bonus if the target is the first existing enemy?
	for (auto* enemy: Main_Data::game_enemyparty->GetEnemies()) {
		if (enemy->Exists()) {
			if (enemy == &target) {
				rank = rank * 1.5 + 0.5;
			}
			break;
		}
	}
	if (rank > 0.0) {
		rank = Rand::GetRandomNumber(0, 99) / 100.0 + rank * 1.5;
	}
	return rank;
}

double CalcNormalAttackAutoBattleRank(const Game_Actor& source, Game_Battler::Weapon weapon, const lcf::rpg::System::BattleCondition cond, bool apply_variance, bool emulate_bugs) {
	double rank = 0.0;
	std::vector<Game_Battler*> targets;
	Main_Data::game_enemyparty->GetBattlers(targets);

	if (!emulate_bugs && source.HasAttackAll(weapon)) {
		for (auto* target: targets) {
			auto target_rank = CalcNormalAttackAutoBattleTargetRank(source, *target, weapon, cond, apply_variance, emulate_bugs);
			rank += target_rank;
			DebugLog("AUTOBATTLE: Actor {} Check Attack Party Enemy {} Rank : {} -> {}", source.GetName(), target->GetName(), rank, target_rank);
		}
	} else {
		for (auto* target: targets) {
			auto target_rank = CalcNormalAttackAutoBattleTargetRank(source, *target, weapon, cond, apply_variance, emulate_bugs);
			rank = std::max(rank, target_rank);
			DebugLog("AUTOBATTLE: Actor {} Check Attack Single Enemy {} Rank : {} -> {}", source.GetName(), target->GetName(), rank, target_rank);
		}
	}
	return rank;
}

void SelectAutoBattleAction(Game_Actor& source,
		Game_Battler::Weapon weapon,
		lcf::rpg::System::BattleCondition cond,
		bool do_skills,
		bool attack_variance,
		bool skill_variance,
		bool emulate_bugs)
{
	double skill_rank = 0.0;
	lcf::rpg::Skill* skill = nullptr;

	// Find the highest ranking skill
	if (do_skills) {
		for (auto& skill_id: source.GetSkills()) {
			auto* candidate_skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, skill_id);
			if (candidate_skill) {
				const auto rank = CalcSkillAutoBattleRank(source, *candidate_skill, cond, skill_variance, emulate_bugs);
				DebugLog("AUTOBATTLE: Actor {} Check Skill Rank : {}({}): {}", source.GetName(), candidate_skill->name, candidate_skill->ID, rank);
				if (rank > skill_rank) {
					skill_rank = rank;
					skill = candidate_skill;
				}
			}
		}
		DebugLog("AUTOBATTLE: Actor {} Best Skill Rank : {}({}): {}", source.GetName(), skill ? skill->name : "None", skill ? skill->ID : 0, skill_rank);
	}

	double normal_attack_rank = CalcNormalAttackAutoBattleRank(source, weapon, cond, attack_variance, emulate_bugs);
	DebugLog("AUTOBATTLE: Actor {} Normal Attack Rank : {}", source.GetName(), normal_attack_rank);

	auto best_target_rank = 0.0;
	Game_Battler* best_target = nullptr;
	std::vector<Game_Battler*> targets;

	if (skill != nullptr && normal_attack_rank < skill_rank) {
		// Choose Skill Target
		switch (skill->scope) {
			case lcf::rpg::Skill::Scope_enemies:
				DebugLog("AUTOBATTLE: Actor {} Select Skill Target : ALL ENEMIES", source.GetName());
				source.SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Skill>(&source, Main_Data::game_enemyparty.get(), *skill));
				return;
			case lcf::rpg::Skill::Scope_party:
				DebugLog("AUTOBATTLE: Actor {} Select Skill Target : ALL ALLIES", source.GetName());
				source.SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Skill>(&source, Main_Data::game_party.get(), *skill));
				return;
			case lcf::rpg::Skill::Scope_enemy:
				for (auto* target: Main_Data::game_enemyparty->GetEnemies()) {
					const auto target_rank = CalcSkillDmgAutoBattleTargetRank(source, *target, *skill, cond, skill_variance, emulate_bugs);
					if (target_rank > best_target_rank) {
						best_target_rank = target_rank;
						best_target = target;
					}
				}
				break;
			case lcf::rpg::Skill::Scope_ally:
				for (auto* target: Main_Data::game_party->GetActors()) {
					const auto target_rank = CalcSkillHealAutoBattleTargetRank(source, *target, *skill, cond, skill_variance, emulate_bugs);
					if (target_rank > best_target_rank) {
						best_target_rank = target_rank;
						best_target = target;
					}
				}
				break;
			case lcf::rpg::Skill::Scope_self:
				best_target = &source;
				break;
		}
		if (best_target) {
			DebugLog("AUTOBATTLE: Actor {} Select Skill Target : {}", source.GetName(), best_target->GetName());
			source.SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Skill>(&source, best_target, *skill));
		}
		return;
	}
	// Choose normal attack
	if (source.HasAttackAll(weapon)) {
		DebugLog("AUTOBATTLE: Actor {} Select Attack Target : ALL ENEMIES", source.GetName());
		source.SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Normal>(&source, Main_Data::game_enemyparty.get()));
		return;
	}

	for (auto* target: Main_Data::game_enemyparty->GetEnemies()) {
		const auto target_rank = CalcNormalAttackAutoBattleTargetRank(source, *target, weapon, cond, attack_variance, emulate_bugs);
		// On case of ==, prefer the first enemy
		if (target_rank > best_target_rank) {
			best_target_rank = target_rank;
			best_target = target;
		}
	}

	if (best_target != nullptr) {
		DebugLog("AUTOBATTLE: Actor {} Select Attack Target : {}", source.GetName(), best_target->GetName());
		source.SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Normal>(&source, best_target));
		return;
	}
}

} // namespace AutoBattle


/*end of file .\autobattle.cpp*/

/*start of file .\background.cpp*/

/* ... license chunk ... */

// Headers
#include <string>
#include <lcf/data.h>
#include <lcf/rpg/terrain.h>
#include "cache.h"
#include "background.h"
#include "bitmap.h"
#include "main_data.h"
#include <lcf/reader_util.h>
#include "output.h"
#include "drawable_mgr.h"
#include "game_screen.h"
#include "player.h"

Background::Background(const std::string& name) : Drawable(Priority_Background)
{
	DrawableMgr::Register(this);

	if (!name.empty()) {
		FileRequestAsync* request = AsyncHandler::RequestFile("Backdrop", name);
		request->SetGraphicFile(true);
		bg_request_id = request->Bind(&Background::OnBackgroundGraphicReady, this);
		request->Start();
	}
}

Background::Background(int terrain_id) : Drawable(Priority_Background)
{
	DrawableMgr::Register(this);

	const lcf::rpg::Terrain* terrain = lcf::ReaderUtil::GetElement(lcf::Data::terrains, terrain_id);

	if (!terrain) {
		Output::Warning("Background: Invalid terrain ID {}", terrain_id);
		return;
	}

	// Either background or frame
	if (terrain->background_type == lcf::rpg::Terrain::BGAssociation_background && !terrain->background_name.empty()) {
		FileRequestAsync* request = AsyncHandler::RequestFile("Backdrop", terrain->background_name);
		request->SetGraphicFile(true);
		bg_request_id = request->Bind(&Background::OnBackgroundGraphicReady, this);
		request->Start();
		return;
	}

	// Frame
	if (!terrain->background_a_name.empty()) {
		FileRequestAsync* request = AsyncHandler::RequestFile("Frame", terrain->background_a_name);
		request->SetGraphicFile(true);
		bg_request_id = request->Bind(&Background::OnBackgroundGraphicReady, this);
		request->Start();

		bg_hscroll = terrain->background_a_scrollh ? terrain->background_a_scrollh_speed : 0;
		bg_vscroll = terrain->background_a_scrollv ? terrain->background_a_scrollv_speed : 0;
	}

	if (terrain->background_b && !terrain->background_b_name.empty()) {
		FileRequestAsync* request = AsyncHandler::RequestFile("Frame", terrain->background_b_name);
		request->SetGraphicFile(true);
		fg_request_id = request->Bind(&Background::OnForegroundFrameGraphicReady, this);
		request->Start();

		fg_hscroll = terrain->background_b_scrollh ? terrain->background_b_scrollh_speed : 0;
		fg_vscroll = terrain->background_b_scrollv ? terrain->background_b_scrollv_speed : 0;
	}
}

void Background::OnBackgroundGraphicReady(FileRequestResult* result) {
	if (result->directory == "Backdrop") {
		bg_bitmap = Cache::Backdrop(result->file);
	}
	else if (result->directory == "Frame") {
		bg_bitmap = Cache::Frame(result->file, false);
	}
}

void Background::OnForegroundFrameGraphicReady(FileRequestResult* result) {
	fg_bitmap = Cache::Frame(result->file);
}

void Background::Update(int& rate, int& value) {
	int step =
		(rate > 0) ? 2 << rate :
		(rate < 0) ? 2 << -rate :
		0;
	value += step;
}

void Background::Update() {
	Update(bg_hscroll, bg_x);
	Update(bg_vscroll, bg_y);
	Update(fg_hscroll, fg_x);
	Update(fg_vscroll, fg_y);
}

int Background::Scale(int x) {
	return x > 0 ? x / 64 : -(-x / 64);
}

void Background::Draw(Bitmap& dst) {
	Rect dst_rect = dst.GetRect();

	// If the background doesn't fill the screen, center it to support custom resolutions
	BitmapRef center_bitmap = bg_bitmap ? bg_bitmap : fg_bitmap;
	if (center_bitmap) {
		if (center_bitmap->GetWidth() < Player::screen_width) {
			dst_rect.x += Player::menu_offset_x;
			dst_rect.width = MENU_WIDTH;
		}
		if (center_bitmap->GetHeight() < Player::screen_height) {
			dst_rect.y += Player::menu_offset_y;
			dst_rect.height = MENU_HEIGHT;
		}
	}

	dst_rect.x += Main_Data::game_screen->GetShakeOffsetX();
	dst_rect.y += Main_Data::game_screen->GetShakeOffsetY();

	if (bg_bitmap)
		dst.TiledBlit(-Scale(bg_x), -Scale(bg_y), bg_bitmap->GetRect(), *bg_bitmap, dst_rect, 255);

	if (fg_bitmap)
		dst.TiledBlit(-Scale(fg_x), -Scale(fg_y), fg_bitmap->GetRect(), *fg_bitmap, dst_rect, 255);

	if (tone_effect != Tone()) {
		dst.ToneBlit(0, 0, dst, dst.GetRect(), tone_effect, Opacity::Opaque());
	}
}


/*end of file .\background.cpp*/

/*start of file .\baseui.cpp*/

/* ... license chunk ... */

// Headers
#include "baseui.h"
#include "bitmap.h"
#include "player.h"

#if USE_SDL==3
#  include "platform/sdl/sdl3_ui.h"
#elif USE_SDL==2
#  include "platform/sdl/sdl2_ui.h"
#elif USE_SDL==1
#  include "platform/sdl/sdl_ui.h"
#elif USE_LIBRETRO
#  include "platform/libretro/ui.h"
#elif defined(__3DS__)
#  include "platform/3ds/ui.h"
#elif defined(__vita__)
#  include "platform/psvita/ui.h"
#elif defined(__SWITCH__)
#  include "platform/switch/ui.h"
#endif

std::shared_ptr<BaseUi> DisplayUi;

std::shared_ptr<BaseUi> BaseUi::CreateUi(long width, long height, const Game_Config& cfg) {
#if USE_SDL==3
	return std::make_shared<Sdl3Ui>(width, height, cfg);
#elif USE_SDL==2
	return std::make_shared<Sdl2Ui>(width, height, cfg);
#elif USE_SDL==1
	return std::make_shared<SdlUi>(width, height, cfg);
#elif defined(PLAYER_UI)
	return std::make_shared<PLAYER_UI>(width, height, cfg);
#else
#  error cannot create UI
#endif
}

BaseUi::BaseUi(const Game_Config& cfg)
{
	keys.reset();

	vcfg = cfg.video;

	auto fps_limit = vcfg.fps_limit.Get();
	frame_limit = (fps_limit == 0 ? Game_Clock::duration(0) : Game_Clock::TimeStepFromFps(fps_limit));
}

BitmapRef BaseUi::CaptureScreen() {
	BitmapRef capture = Bitmap::Create(main_surface->width(), main_surface->height(), false);
	capture->BlitFast(0, 0, *main_surface, main_surface->GetRect(), Opacity::Opaque());
	return capture;
}

void BaseUi::CleanDisplay() {
	main_surface->Clear();
}

void BaseUi::SetGameResolution(ConfigEnum::GameResolution resolution) {
	vcfg.game_resolution.Set(resolution);
}

Game_ConfigVideo BaseUi::GetConfig() const {
	Game_ConfigVideo cfg = vcfg;

	cfg.Hide();

	vGetConfig(cfg);

	Rect metrics = GetWindowMetrics();
	cfg.window_x.Set(metrics.x);
	cfg.window_y.Set(metrics.y);
	cfg.window_width.Set(metrics.width);
	cfg.window_height.Set(metrics.height);

	if (!cfg.fullscreen.IsOptionVisible()) {
		cfg.fps.RemoveFromValidSet(ConfigEnum::ShowFps::Overlay);
	}

	if (cfg.vsync.IsOptionVisible()
			&& cfg.vsync.Get()) {
		cfg.fps_limit.SetLocked(true);
		cfg.fps_limit.SetDescription("This option requires V-Sync to be disabled");
	}

	if (cfg.fullscreen.IsOptionVisible()
			&& cfg.fullscreen.Get()) {
		cfg.window_zoom.SetLocked(true);
		cfg.window_zoom.SetDescription("This option requires to be in windowed mode");
	}

	if (Player::has_custom_resolution) {
		cfg.game_resolution.SetLocked(true);
		cfg.game_resolution.SetDescription("This game uses a custom resolution");
	}

	return cfg;
}

bool BaseUi::ChangeDisplaySurfaceResolution(int new_width, int new_height) {
	if (new_width == current_display_mode.width && new_height == current_display_mode.height) {
		return true;
	}

	return vChangeDisplaySurfaceResolution(new_width, new_height);
}


/*end of file .\baseui.cpp*/

/*start of file .\battle_animation.cpp*/

/* ... license chunk ... */

#include "bitmap.h"
#include <lcf/rpg/animation.h>
#include "output.h"
#include "game_battle.h"
#include "game_system.h"
#include "game_screen.h"
#include "game_map.h"
#include "main_data.h"
#include "filefinder.h"
#include "cache.h"
#include "battle_animation.h"
#include "baseui.h"
#include "spriteset_battle.h"
#include "player.h"
#include "options.h"
#include "drawable_mgr.h"
#include "scene_map.h"
#include "spriteset_map.h"

BattleAnimation::BattleAnimation(const lcf::rpg::Animation& anim, bool only_sound, int cutoff) :
	animation(anim), only_sound(only_sound)
{
	num_frames = GetRealFrames() * 2;
	if (cutoff >= 0 && cutoff < num_frames) {
		num_frames = cutoff;
	}

	SetZ(Priority_BattleAnimation);

	std::string_view name = animation.animation_name;
	BitmapRef graphic;

	if (name.empty()) return;

	if (animation.large) {
		FileRequestAsync* request = AsyncHandler::RequestFile("Battle2", name);
		request->SetGraphicFile(true);
		request_id = request->Bind(&BattleAnimation::OnBattle2SpriteReady, this);
		request->Start();
	} else {
		FileRequestAsync* request = AsyncHandler::RequestFile("Battle", name);
		request->SetGraphicFile(true);
		request_id = request->Bind(&BattleAnimation::OnBattleSpriteReady, this);
		request->Start();
	}
}

void BattleAnimation::Update() {
	if (!IsDone() && (frame & 1) == 0) {
		// Lookup any timed SFX (SE/flash/shake) data for this frame
		for (auto& timing: animation.timings) {
			if (timing.frame == GetRealFrame() + 1) {
				ProcessAnimationTiming(timing);
			}
		}
	}

	UpdateScreenFlash();
	UpdateTargetFlash();

	SetFlashEffect(Main_Data::game_screen->GetFlashColor());

	frame++;
}

void BattleAnimation::OnBattleSpriteReady(FileRequestResult* result) {
	BitmapRef bitmap = Cache::Battle(result->file);
	SetBitmap(bitmap);
	SetSrcRect(Rect(0, 0, 0, 0));
}

void BattleAnimation::OnBattle2SpriteReady(FileRequestResult* result) {
	BitmapRef bitmap = Cache::Battle2(result->file);
	SetBitmap(bitmap);
	SetSrcRect(Rect(0, 0, 0, 0));
}

void BattleAnimation::DrawAt(Bitmap& dst, int x, int y) {
	if (IsDone()) {
		return;
	}

	const lcf::rpg::AnimationFrame& anim_frame = animation.frames[GetRealFrame()];

	std::vector<lcf::rpg::AnimationCellData>::const_iterator it;
	for (it = anim_frame.cells.begin(); it != anim_frame.cells.end(); ++it) {
		const lcf::rpg::AnimationCellData& cell = *it;

		if (!cell.valid) {
			// Skip unused cells (they are created by deleting cells in the
			// animation editor, resulting in gaps)
			continue;
		}

		SetX(invert ? x - cell.x : cell.x + x);
		SetY(cell.y + y);
		int sx = cell.cell_id % 5;
		int sy = cell.cell_id / 5;
		int size = animation.large ? 128 : 96;
		SetSrcRect(Rect(sx * size, sy * size, size, size));
		SetOx(size / 2);
		SetOy(size / 2);
		SetTone(Tone(cell.tone_red * 128 / 100,
			cell.tone_green * 128 / 100,
			cell.tone_blue * 128 / 100,
			cell.tone_gray * 128 / 100));
		SetOpacity(255 * (100 - cell.transparency) / 100);
		SetZoomX(cell.zoom / 100.0);
		SetZoomY(cell.zoom / 100.0);
		SetFlipX(invert);
		Sprite::Draw(dst);
	}

	if (anim_frame.cells.empty()) {
		// Draw an empty sprite when no cell is available in the animation
		SetSrcRect(Rect(0, 0, 0, 0));
		Sprite::Draw(dst);
	}
}

void BattleAnimation::ProcessAnimationFlash(const lcf::rpg::AnimationTiming& timing) {
	if (IsOnlySound()) {
		return;
	}

	if (timing.flash_scope == lcf::rpg::AnimationTiming::FlashScope_target) {
		target_flash_timing = &timing - animation.timings.data();
	} else if (timing.flash_scope == lcf::rpg::AnimationTiming::FlashScope_screen) {
		screen_flash_timing = &timing - animation.timings.data();
	}
}

void BattleAnimation::ProcessAnimationTiming(const lcf::rpg::AnimationTiming& timing) {
	// Play the SE.
	Main_Data::game_system->SePlay(timing.se);
	if (IsOnlySound()) {
		return;
	}

	// Flash.
	ProcessAnimationFlash(timing);

	// Shake (only happens in battle).
	if (Game_Battle::IsBattleRunning()) {
		switch (timing.screen_shake) {
		case lcf::rpg::AnimationTiming::ScreenShake_nothing:
			break;
		case lcf::rpg::AnimationTiming::ScreenShake_target:
			// FIXME: Estimate, see below for screen shake.
			ShakeTargets(3, 5, 32);
			break;
		case lcf::rpg::AnimationTiming::ScreenShake_screen:
			Game_Screen* screen = Main_Data::game_screen.get();
			// FIXME: This is not proven accurate. Screen captures show that
			// the shake effect lasts for 16 animation frames (32 real frames).
			// The maximum offset observed was 6 or 7, which makes these numbers
			// seem reasonable.
			screen->ShakeOnce(3, 5, 32);
			break;
		}
	}
}

static int CalculateFlashPower(int frames, int power) {
	// This algorithm was determined numerically by measuring the flash
	// power for each frame of battle animation flashs.
	int f = 7 - ((frames + 1) / 2);
	return std::min(f * power / 6, 31);
}

void BattleAnimation::UpdateFlashGeneric(int timing_idx, int& r, int& g, int& b, int& p) {
	r = 0; g = 0; b = 0; p = 0;

	if (timing_idx >= 0) {
		auto& timing = animation.timings[timing_idx];
		int start_frame = (timing.frame - 1) * 2;
		int delta_frames = GetFrame() - start_frame;
		if (delta_frames <= 10) {
			r = timing.flash_red;
			g = timing.flash_green;
			b = timing.flash_blue;
			p = CalculateFlashPower(delta_frames, timing.flash_power);
		}
	}
}

void BattleAnimation::UpdateScreenFlash() {
	int r, g, b, p;
	UpdateFlashGeneric(screen_flash_timing, r, g, b, p);
	Main_Data::game_screen->FlashOnce(r, g, b, p, 0);
}

void BattleAnimation::UpdateTargetFlash() {
	int r, g, b, p;
	UpdateFlashGeneric(target_flash_timing, r, g, b, p);
	FlashTargets(r, g, b, p);
}

// For handling the vertical position.
// (The first argument should be an lcf::rpg::Animation::Position,
// but the position member is an int, so take an int.)
static int CalculateOffset(int pos, int target_height) {
	switch (pos) {
	case lcf::rpg::Animation::Position_down:
		return target_height / 2;
	case lcf::rpg::Animation::Position_up:
		return -(target_height / 2);
	default:
		return 0;
	}
}

/////////

BattleAnimationMap::BattleAnimationMap(const lcf::rpg::Animation& anim, Game_Character& target, bool global) :
	BattleAnimation(anim), target(&target), global(global)
{
}

void BattleAnimationMap::SetTarget(Game_Character& target) {
	this->target = &target;
}

void BattleAnimationMap::Draw(Bitmap& dst) {
	if (IsOnlySound()) {
		return;
	}

	if (global) {
		DrawGlobal(dst);
	} else {
		DrawSingle(dst);
	}
}

void BattleAnimationMap::DrawGlobal(Bitmap& dst) {
	auto rect = Main_Data::game_screen->GetScreenEffectsRect();

	for (int y = -1; y < 2; ++y) {
		for (int x = -1; x < 2; ++x) {
			DrawAt(dst, rect.width * x + rect.x, rect.height * y + rect.y);
		}
	}
}

void BattleAnimationMap::DrawSingle(Bitmap& dst) {
	//If animation is targeted on the screen
	if (animation.scope == lcf::rpg::Animation::Scope_screen) {
		DrawAt(dst, Player::screen_width / 2, Player::screen_height / 2);
		return;
	}
	const int character_height = 24;
	int x_off = target->GetScreenX();
	int y_off = target->GetScreenY(false);
	if (Scene::instance->type == Scene::Map) {
		x_off += static_cast<Scene_Map*>(Scene::instance.get())->spriteset->GetRenderOx();
		y_off += static_cast<Scene_Map*>(Scene::instance.get())->spriteset->GetRenderOy();
	}
	int vertical_center = y_off - character_height / 2;
	int offset = CalculateOffset(animation.position, character_height);

	DrawAt(dst, x_off, vertical_center + offset);
}

void BattleAnimationMap::FlashTargets(int r, int g, int b, int p) {
	target->Flash(r, g, b, p, 0);
}

void BattleAnimationMap::ShakeTargets(int /* str */, int /* spd */, int /* time */) {
}

/////////

BattleAnimationBattle::BattleAnimationBattle(const lcf::rpg::Animation& anim, std::vector<Game_Battler*> battlers, bool only_sound, int cutoff_frame, bool set_invert) :
	BattleAnimation(anim, only_sound, cutoff_frame), battlers(std::move(battlers))
{
	invert = set_invert;
}

void BattleAnimationBattle::Draw(Bitmap& dst) {
	if (IsOnlySound())
		return;
	if (animation.scope == lcf::rpg::Animation::Scope_screen) {
		DrawAt(dst, Player::menu_offset_x + (Player::screen_width / 2), Player::menu_offset_y + (Player::screen_height / 3));
		return;
	}

	for (auto* battler: battlers) {
		const Sprite_Battler* sprite = battler->GetBattleSprite();
		int offset = 0;
		if (sprite) {
			if (sprite->GetBitmap()) {
				offset = CalculateOffset(animation.position, sprite->GetHeight());
			} else {
				offset = CalculateOffset(animation.position, GetAnimationCellHeight() / 2);
			}
		}
		DrawAt(dst, Player::menu_offset_x + battler->GetBattlePosition().x, Player::menu_offset_y + battler->GetBattlePosition().y + offset);
	}
}
void BattleAnimationBattle::FlashTargets(int r, int g, int b, int p) {
	for (auto& battler: battlers) {
		battler->Flash(r, g, b, p, 0);
	}
}

void BattleAnimationBattle::ShakeTargets(int str, int spd, int time) {
	for (auto& battler: battlers) {
		battler->ShakeOnce(str, spd, time);
	}
}

BattleAnimationBattler::BattleAnimationBattler(const lcf::rpg::Animation& anim, std::vector<Game_Battler*> battlers, bool only_sound, int cutoff_frame, bool set_invert) :
	BattleAnimation(anim, only_sound, cutoff_frame), battlers(std::move(battlers))
{
	invert = set_invert;
}

void BattleAnimationBattler::Draw(Bitmap& dst) {
	if (IsOnlySound())
		return;
	if (animation.scope == lcf::rpg::Animation::Scope_screen) {
		DrawAt(dst, Player::menu_offset_x + Player::screen_width / 2, Player::menu_offset_y + Player::screen_height / 3);
		return;
	}

	for (auto* battler: battlers) {
		SetFlashEffect(battler->GetFlashColor());
		// Game_Battler::GetDisplayX() and Game_Battler::GetDisplayX() already add MENU_OFFSET
		DrawAt(dst, battler->GetDisplayX(), battler->GetDisplayY());
	}
}

void BattleAnimationBattler::FlashTargets(int r, int g, int b, int p) {
	for (auto& battler: battlers) {
		battler->Flash(r, g, b, p, 0);
	}
}

void BattleAnimationBattler::ShakeTargets(int str, int spd, int time) {
	for (auto& battler: battlers) {
		battler->ShakeOnce(str, spd, time);
	}
}

void BattleAnimationBattler::ProcessAnimationTiming(const lcf::rpg::AnimationTiming& timing) {
	// Play the SE.
	Main_Data::game_system->SePlay(timing.se);
	if (IsOnlySound()) {
		return;
	}

	// Flash.
	ProcessAnimationFlash(timing);
}

void BattleAnimationBattler::ProcessAnimationFlash(const lcf::rpg::AnimationTiming& timing) {
	if (IsOnlySound()) {
		return;
	}

	if (timing.flash_scope == lcf::rpg::AnimationTiming::FlashScope_screen) {
		target_flash_timing = &timing - animation.timings.data();
	}
}

void BattleAnimationBattler::UpdateScreenFlash() {
	int r, g, b, p;
	UpdateFlashGeneric(screen_flash_timing, r, g, b, p);
	if (r > 0 || g > 0 || b > 0 || p > 0) {
		Main_Data::game_screen->FlashOnce(r, g, b, p, 0);
	}
}

void BattleAnimationBattler::UpdateTargetFlash() {
	int r, g, b, p;
	UpdateFlashGeneric(target_flash_timing, r, g, b, p);
	if (r > 0 || g > 0 || b > 0 || p > 0) {
		FlashTargets(r, g, b, p);
	}
}

void BattleAnimation::SetFrame(int frame) {
	// Reset pending flash.
	int real_frame = frame / 2;
	screen_flash_timing = -1;
	target_flash_timing = -1;
	for (auto& timing: animation.timings) {
		if (timing.frame > real_frame + 1) {
			break;
		}
		ProcessAnimationFlash(timing);
	}

	this->frame = frame;
}

void BattleAnimation::SetInvert(bool inverted) {
	invert = inverted;
}


/*end of file .\battle_animation.cpp*/

/*start of file .\bitmap.cpp*/

/* ... license chunk ... */

// Headers
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <unordered_map>

#include "utils.h"
#include "cache.h"
#include "bitmap.h"
#include "filefinder.h"
#include "options.h"
#include <lcf/data.h>
#include "output.h"
#include "image_xyz.h"
#include "image_bmp.h"
#include "image_png.h"
#include "transform.h"
#include "font.h"
#include "output.h"
#include "util_macro.h"
#include "bitmap_hslrgb.h"
#include <iostream>

BitmapRef Bitmap::Create(int width, int height, const Color& color) {
	BitmapRef surface = Bitmap::Create(width, height, true);
	surface->Fill(color);
	return surface;
}

BitmapRef Bitmap::Create(Filesystem_Stream::InputStream stream, bool transparent, uint32_t flags) {
	BitmapRef bmp = std::make_shared<Bitmap>(std::move(stream), transparent, flags);

	if (!bmp->pixels()) {
		return BitmapRef();
	}

	return bmp;
}

BitmapRef Bitmap::Create(const uint8_t* data, unsigned bytes, bool transparent, uint32_t flags) {
	BitmapRef bmp = std::make_shared<Bitmap>(data, bytes, transparent, flags);

	if (!bmp->pixels()) {
		return BitmapRef();
	}

	return bmp;
}

BitmapRef Bitmap::Create(Bitmap const& source, Rect const& src_rect, bool transparent) {
	return std::make_shared<Bitmap>(source, src_rect, transparent);
}

BitmapRef Bitmap::Create(int width, int height, bool transparent, int /* bpp */) {
	return std::make_shared<Bitmap>(width, height, transparent);
}

BitmapRef Bitmap::Create(void *pixels, int width, int height, int pitch, const DynamicFormat& format) {
	return std::make_shared<Bitmap>(pixels, width, height, pitch, format);
}

Bitmap::Bitmap(int width, int height, bool transparent) {
	format = (transparent ? pixel_format : opaque_pixel_format);
	pixman_format = find_format(format);
	Init(width, height, (void *) NULL);
}

Bitmap::Bitmap(void *pixels, int width, int height, int pitch, const DynamicFormat& _format) {
	format = _format;
	pixman_format = find_format(format);
	Init(width, height, pixels, pitch, false);
}

Bitmap::Bitmap(Filesystem_Stream::InputStream stream, bool transparent, uint32_t flags) {
	format = (transparent ? pixel_format : opaque_pixel_format);
	pixman_format = find_format(format);

	if (!stream) {
		Output::Error("Couldn't read image file {}", stream.GetName());
		return;
	}

	ImageOut image_out;

	uint8_t data[4] = {};
	size_t bytes = stream.read(reinterpret_cast<char*>(data),  4).gcount();
	stream.seekg(0, std::ios::ios_base::beg);

	bool img_okay = false;

	if (bytes >= 4 && strncmp((char*)data, "XYZ1", 4) == 0) {
		img_okay = ImageXYZ::Read(stream, transparent, image_out);
	} else if (bytes > 2 && strncmp((char*)data, "BM", 2) == 0) {
		img_okay = ImageBMP::Read(stream, transparent, image_out);
	} else if (bytes >= 4 && strncmp((char*)(data + 1), "PNG", 3) == 0) {
		img_okay = ImagePNG::Read(stream, transparent, image_out);
	} else
		Output::Warning("Unsupported image file {} (Magic: {:02X})", stream.GetName(), *reinterpret_cast<uint32_t*>(data));

	if (!img_okay) {
		free(image_out.pixels);
		return;
	}

	Init(image_out.width, image_out.height, nullptr);

	ConvertImage(image_out.width, image_out.height, image_out.pixels, transparent, flags);

	CheckPixels(flags);

	original_bpp = image_out.bpp;

	id = ToString(stream.GetName());
}

Bitmap::Bitmap(const uint8_t* data, unsigned bytes, bool transparent, uint32_t flags) {
	format = (transparent ? pixel_format : opaque_pixel_format);
	pixman_format = find_format(format);

	ImageOut image_out;

	bool img_okay = false;

	if (bytes > 4 && strncmp((char*) data, "XYZ1", 4) == 0)
		img_okay = ImageXYZ::Read(data, bytes, transparent, image_out);
	else if (bytes > 2 && strncmp((char*) data, "BM", 2) == 0)
		img_okay = ImageBMP::Read(data, bytes, transparent, image_out);
	else if (bytes > 4 && strncmp((char*)(data + 1), "PNG", 3) == 0)
		img_okay = ImagePNG::Read((const void*) data, transparent, image_out);
	else
		Output::Warning("Unsupported image (Magic: {:02X})", bytes >= 4 ? *reinterpret_cast<const uint32_t*>(data) : 0);

	if (!img_okay) {
		free(image_out.pixels);
		return;
	}

	Init(image_out.width, image_out.height, nullptr);

	ConvertImage(image_out.width, image_out.height, image_out.pixels, transparent, flags);

	original_bpp = image_out.bpp;

	CheckPixels(flags);
}

Bitmap::Bitmap(Bitmap const& source, Rect const& src_rect, bool transparent) {
	format = (transparent ? pixel_format : opaque_pixel_format);
	pixman_format = find_format(format);

	Init(src_rect.width, src_rect.height, (void *) NULL);

	Blit(0, 0, source, src_rect, Opacity::Opaque());
}

bool Bitmap::WritePNG(std::ostream& os) const {
	size_t const width = GetWidth(), height = GetHeight();
	size_t const stride = width * 4;

	std::vector<uint32_t> data(width * height);

#ifdef WORDS_BIGENDIAN
	auto format = PIXMAN_r8g8b8;
#else
	auto format = PIXMAN_b8g8r8;
#endif

	auto dst = PixmanImagePtr{pixman_image_create_bits(format, width, height, &data.front(), stride)};
	pixman_image_composite32(PIXMAN_OP_SRC, bitmap.get(), NULL, dst.get(),
							 0, 0, 0, 0, 0, 0, width, height);

	return ImagePNG::Write(os, width, height, &data.front());
}

size_t Bitmap::GetSize() const {
	if (!bitmap) {
		return 0;
	}

	return pitch() * height();
}

ImageOpacity Bitmap::ComputeImageOpacity() const {
	if (!GetTransparent()) {
		return ImageOpacity::Opaque;
	}

	bool all_opaque = true;
	bool all_transp = true;
	bool alpha_1bit = true;

	auto* p = reinterpret_cast<const uint32_t*>(pixels());
	const auto mask = format.rgba_to_uint32_t(0, 0, 0, 0xFF);

	int n = GetSize() / sizeof(uint32_t);
	for (int i = 0; i < n; ++i ) {
		auto px = p[i] & mask;
		bool transp = (px == 0);
		bool opaque = (px == mask);
		all_transp &= transp;
		all_opaque &= opaque;
		alpha_1bit &= (transp | opaque);
	}

	return
		all_transp ? ImageOpacity::Transparent :
		all_opaque ? ImageOpacity::Opaque :
		alpha_1bit ? ImageOpacity::Alpha_1Bit :
		ImageOpacity::Alpha_8Bit;
}

ImageOpacity Bitmap::ComputeImageOpacity(Rect rect) const {
	if (!GetTransparent()) {
		return ImageOpacity::Opaque;
	}

	bool all_opaque = true;
	bool all_transp = true;
	bool alpha_1bit = true;

	const auto full_rect = GetRect();
	rect = full_rect.GetSubRect(rect);

	auto* p = reinterpret_cast<const uint32_t*>(pixels());
	const int stride = pitch() / sizeof(uint32_t);
	const auto mask = format.rgba_to_uint32_t(0, 0, 0, 0xFF);

	int xend = (rect.x + rect.width);
	int yend = (rect.y + rect.height);
	for (int y = rect.y * stride; y < yend * stride; y += stride) {
		for (int x = rect.x; x < xend; ++x) {
			auto px = p[x + y] & mask;
			bool transp = (px == 0);
			bool opaque = (px == mask);
			all_transp &= transp;
			all_opaque &= opaque;
			alpha_1bit &= (transp | opaque);
		}
	}

	return
		all_transp ? ImageOpacity::Transparent :
		all_opaque ? ImageOpacity::Opaque :
		alpha_1bit ? ImageOpacity::Alpha_1Bit :
		ImageOpacity::Alpha_8Bit;
}

void Bitmap::CheckPixels(uint32_t flags) {
	if (flags & Flag_System) {
		DynamicFormat format(32,8,24,8,16,8,8,8,0,PF::Alpha);
		uint32_t pixel;
		Bitmap bmp(reinterpret_cast<void*>(&pixel), 1, 1, 4, format);
		pixman_image_composite32(PIXMAN_OP_SRC, bitmap.get(), (pixman_image_t*) NULL, bmp.bitmap.get(),
								 0, 32,  0, 0,  0, 0,  1, 1);
		bg_color = Color((int)(pixel>>24)&0xFF, (int)(pixel>>16)&0xFF, (int)(pixel>>8)&0xFF, (int)pixel&0xFF);
		pixman_image_composite32(PIXMAN_OP_SRC, bitmap.get(), (pixman_image_t*) NULL, bmp.bitmap.get(),
								 16, 32,  0, 0,  0, 0,  1, 1);
		sh_color = Color((int)(pixel>>24)&0xFF, (int)(pixel>>16)&0xFF, (int)(pixel>>8)&0xFF, (int)pixel&0xFF);
	}

	if (flags & Flag_Chipset) {
		const int h = height() / TILE_SIZE;
		const int w = width() / TILE_SIZE;
		tile_opacity = TileOpacity(w, h);

		for (int ty = 0; ty < h; ++ty) {
			for (int tx = 0; tx < w; ++tx) {
				Rect rect(tx * TILE_SIZE, ty * TILE_SIZE, TILE_SIZE, TILE_SIZE);
				auto op = ComputeImageOpacity(rect);
				tile_opacity.Set(tx, ty, op);
			}
		}
	}

	if (flags & Flag_ReadOnly) {
		read_only = true;

		image_opacity = ComputeImageOpacity();
	}
}

Color Bitmap::GetColorAt(int x, int y) const {
	if (x < 0 || x >= width() || y < 0 || y >= height()) {
		return {};
	}

	Color color;

	const uint8_t* pos = &reinterpret_cast<const uint8_t*>(pixels())[y * pitch() + x * bpp()];
	uint32_t pixel = *reinterpret_cast<const uint32_t*>(pos);
	format.uint32_to_rgba(pixel, color.red, color.green, color.blue, color.alpha);

	return color;
}

void Bitmap::HueChangeBlit(int x, int y, Bitmap const& src, Rect const& src_rect_, double hue_) {
	Rect dst_rect(x, y, 0, 0), src_rect = src_rect_;

	if (!Rect::AdjustRectangles(src_rect, dst_rect, src.GetRect()))
		return;
	if (!Rect::AdjustRectangles(dst_rect, src_rect, GetRect()))
		return;

	int hue  = (int) (hue_ / 60.0 * 0x100);
	if (hue < 0)
		hue += ((-hue + 0x5FF) / 0x600) * 0x600;
	else if (hue > 0x600)
		hue -= (hue / 0x600) * 0x600;

	DynamicFormat format(32,8,24,8,16,8,8,8,0,PF::Alpha);
	std::vector<uint32_t> pixels;
	pixels.resize(src_rect.width * src_rect.height);
	Bitmap bmp(reinterpret_cast<void*>(&pixels.front()), src_rect.width, src_rect.height, src_rect.width * 4, format);
	bmp.Blit(0, 0, src, src_rect, Opacity::Opaque());

	for (std::vector<uint32_t>::iterator p = pixels.begin(); p != pixels.end(); ++p) {
		uint32_t pixel = *p;
		uint8_t r = (pixel>>24) & 0xFF;
		uint8_t g = (pixel>>16) & 0xFF;
		uint8_t b = (pixel>> 8) & 0xFF;
		uint8_t a = pixel & 0xFF;
		if (a > 0)
			RGB_adjust_HSL(r, g, b, hue);
		*p = ((uint32_t) r << 24) | ((uint32_t) g << 16) | ((uint32_t) b << 8) | (uint32_t) a;
	}

	Blit(dst_rect.x, dst_rect.y, bmp, bmp.GetRect(), Opacity::Opaque());
}

Point Bitmap::TextDraw(Rect const& rect, int color, std::string_view text, Text::Alignment align) {
	switch (align) {
	case Text::AlignLeft:
		return TextDraw(rect.x, rect.y, color, text);
		break;
	case Text::AlignCenter: {
		auto f = font ? font : Font::Default();
		Rect text_rect = Text::GetSize(*f, text);
		int dx = rect.x + (rect.width - text_rect.width) / 2;
		return TextDraw(dx, rect.y, color, text);
		break;
	}
	case Text::AlignRight: {
		auto f = font ? font : Font::Default();
		Rect text_rect = Text::GetSize(*f, text);
		int dx = rect.x + rect.width - text_rect.width;
		return TextDraw(dx, rect.y, color, text);
		break;
	}
	default: assert(false);
	}

	return {};
}

Point Bitmap::TextDraw(int x, int y, int color, std::string_view text, Text::Alignment align) {
	auto f = font ? font : Font::Default();
	auto system = Cache::SystemOrBlack();
	return Text::Draw(*this, x, y, *f, *system, color, text, align);
}

Point Bitmap::TextDraw(Rect const& rect, Color color, std::string_view text, Text::Alignment align) {
	switch (align) {
	case Text::AlignLeft:
		return TextDraw(rect.x, rect.y, color, text);
		break;
	case Text::AlignCenter: {
		auto f = font ? font : Font::Default();
		Rect text_rect = Text::GetSize(*f, text);
		int dx = rect.x + (rect.width - text_rect.width) / 2;
		return TextDraw(dx, rect.y, color, text);
		break;
	}
	case Text::AlignRight: {
		auto f = font ? font : Font::Default();
		Rect text_rect = Text::GetSize(*f, text);
		int dx = rect.x + rect.width - text_rect.width;
		return TextDraw(dx, rect.y, color, text);
		break;
	}
	default: assert(false);
	}

	return {};
}

Point Bitmap::TextDraw(int x, int y, Color color, std::string_view text) {
	auto f = font ? font : Font::Default();
	return Text::Draw(*this, x, y, *f, color, text);
}

Rect Bitmap::TransformRectangle(const Transform& xform, const Rect& rect) {
	pixman_box16 bounds = {
		static_cast<int16_t>(rect.x),
		static_cast<int16_t>(rect.y),
		static_cast<int16_t>(rect.x + rect.width),
		static_cast<int16_t>(rect.y + rect.height)
	};

	pixman_transform_bounds(&xform.matrix, &bounds);
	return Rect(bounds.x1, bounds.y1, bounds.x2 - bounds.x1, bounds.y2 - bounds.y1);
}

static constexpr std::array<std::pair<int,pixman_format_code_t>, 27> formats_map = {{
		{ DynamicFormat(32,8,24,8,16,8,8,8,0,PF::Alpha).code_alpha(), PIXMAN_r8g8b8a8 },
		{ DynamicFormat(32,8,24,8,16,8,8,8,0,PF::NoAlpha).code_alpha(), PIXMAN_r8g8b8x8 },

		{ DynamicFormat(32,8,16,8,8,8,0,8,24,PF::Alpha).code_alpha(), PIXMAN_a8r8g8b8 },
		{ DynamicFormat(32,8,16,8,8,8,0,0,0,PF::NoAlpha).code_alpha(), PIXMAN_x8r8g8b8 },
		{ DynamicFormat(32,8,0,8,8,8,16,8,24,PF::Alpha).code_alpha(), PIXMAN_a8b8g8r8 },
		{ DynamicFormat(32,8,0,8,8,8,16,0,0,PF::NoAlpha).code_alpha(), PIXMAN_x8b8g8r8 },
		{ DynamicFormat(32,8,8,8,16,8,24,8,0,PF::Alpha).code_alpha(), PIXMAN_b8g8r8a8 },
		{ DynamicFormat(32,8,8,8,16,8,24,0,0,PF::NoAlpha).code_alpha(), PIXMAN_b8g8r8x8 },

		{ DynamicFormat(32,6,12,6,6,6,0,0,0,PF::NoAlpha).code_alpha(), PIXMAN_x14r6g6b6 },
		{ DynamicFormat(32,10,20,10,10,10,0,0,0,PF::NoAlpha).code_alpha(), PIXMAN_x2r10g10b10 },
		{ DynamicFormat(32,10,20,10,10,10,0,2,30,PF::Alpha).code_alpha(), PIXMAN_a2r10g10b10 },
		{ DynamicFormat(32,10,0,10,10,10,20,0,0,PF::NoAlpha).code_alpha(), PIXMAN_x2b10g10r10 },
		{ DynamicFormat(32,10,0,10,10,10,20,2,30,PF::Alpha).code_alpha(), PIXMAN_a2b10g10r10 },

		{ DynamicFormat(24,8,16,8,8,8,0,0,0,PF::NoAlpha).code_alpha(), PIXMAN_r8g8b8 },
		{ DynamicFormat(24,8,0,8,8,8,16,0,0,PF::NoAlpha).code_alpha(), PIXMAN_b8g8r8 },

		{ DynamicFormat(16,5,11,6,5,5,0,0,0,PF::NoAlpha).code_alpha(), PIXMAN_r5g6b5 },
		{ DynamicFormat(16,5,0,6,5,5,11,0,0,PF::NoAlpha).code_alpha(), PIXMAN_b5g6r5 },
		{ DynamicFormat(16,5,10,5,5,5,0,1,15,PF::Alpha).code_alpha(), PIXMAN_a1r5g5b5 },
		{ DynamicFormat(16,5,10,5,5,5,0,0,0,PF::NoAlpha).code_alpha(), PIXMAN_x1r5g5b5 },
		{ DynamicFormat(16,5,0,5,5,5,10,1,15,PF::Alpha).code_alpha(), PIXMAN_a1b5g5r5 },
		{ DynamicFormat(16,5,0,5,5,5,10,0,0,PF::NoAlpha).code_alpha(), PIXMAN_x1b5g5r5 },
		{ DynamicFormat(16,4,8,4,4,4,0,4,12,PF::Alpha).code_alpha(), PIXMAN_a4r4g4b4 },
		{ DynamicFormat(16,4,8,4,4,4,0,0,0,PF::NoAlpha).code_alpha(), PIXMAN_x4r4g4b4 },
		{ DynamicFormat(16,4,0,4,4,4,8,4,12,PF::Alpha).code_alpha(), PIXMAN_a4b4g4r4 },
		{ DynamicFormat(16,4,0,4,4,4,8,0,0,PF::NoAlpha).code_alpha(), PIXMAN_x4b4g4r4 },
		{ DynamicFormat(8,8,0,8,0,8,0,8,0,PF::Alpha).code_alpha(), PIXMAN_g8 },
		{ DynamicFormat(8,8,0,8,0,8,0,0,0,PF::NoAlpha).code_alpha(), PIXMAN_g8 }
}};

pixman_format_code_t Bitmap::find_format(const DynamicFormat& format) {
	auto dcode = format.code_alpha();
	auto iter = std::find_if(formats_map.begin(), formats_map.end(), [dcode](const auto& p) { return p.first == dcode; });
	if (iter == formats_map.end()) {
		// To fix add a pair to initialize_formats that maps the outputted
		// DynamicFormat to a pixman format
		Output::Error("{}\nDynamicFormat({}, {}, {}, {}, {}, {}, {}, {}, {}, {})",
		"Couldn't find Pixman format for",
		format.bits,
		format.r.bits, format.r.shift,
		format.g.bits, format.g.shift,
		format.b.bits, format.b.shift,
		format.a.bits, format.a.shift,
		format.alpha_type == PF::Alpha ? "PF::Alpha" : "PF::NoAlpha");
	}
	return iter->second;
}

DynamicFormat Bitmap::pixel_format;
DynamicFormat Bitmap::opaque_pixel_format;
DynamicFormat Bitmap::image_format;
DynamicFormat Bitmap::opaque_image_format;

void Bitmap::SetFormat(const DynamicFormat& format) {
	pixel_format = format;
	opaque_pixel_format = format;
	opaque_pixel_format.alpha_type = PF::NoAlpha;
	image_format = format_R8G8B8A8_a().format();
	opaque_image_format = format_R8G8B8A8_n().format();
}

DynamicFormat Bitmap::ChooseFormat(const DynamicFormat& format) {
	uint32_t amask;
	amask = (format.a.mask == 0)
		? ((~0U >> (32 - format.bits)) ^ (format.r.mask | format.g.mask | format.b.mask))
		: format.a.mask;
	if (amask != 0)
		return DynamicFormat(format.bits,
							 format.r.mask, format.g.mask, format.b.mask,
							 amask, PF::Alpha);
	switch (format.bits) {
		case 16:
			return (format.r.shift > format.b.shift)
				? DynamicFormat(16,5,10,5,5,5,0,1,15,PF::Alpha)
				: DynamicFormat(16,5,0,5,5,5,10,1,15,PF::Alpha);
		case 24:
			return (format.r.shift > format.b.shift)
				? DynamicFormat(32,8,16,8,8,8,0,8,24,PF::Alpha)
				: DynamicFormat(32,8,0,8,8,8,16,8,24,PF::Alpha);
		default:
			return format_B8G8R8A8_a().format();
	}
}

static void destroy_func(pixman_image_t * /* image */, void *data) {
	free(data);
}

static pixman_indexed_t palette;
static bool palette_initialized = false;

static void initialize_palette() {
	if (palette_initialized)
		return;
	palette.color = false;
	palette.rgba[0] = 0U;
	for (int i = 1; i < PIXMAN_MAX_INDEXED; i++)
		palette.rgba[i] = ~0U;
	palette_initialized = true;
}

void Bitmap::Init(int width, int height, void* data, int pitch, bool destroy) {
	if (!pitch)
		pitch = width * format.bytes;

	bitmap.reset(pixman_image_create_bits(pixman_format, width, height, (uint32_t*) data, pitch));

	if (bitmap == NULL) {
		Output::Error("Couldn't create {}x{} image.", width, height);
	}

	if (format.bits == 8) {
		initialize_palette();
		pixman_image_set_indexed(bitmap.get(), &palette);
	}

	if (data != NULL && destroy)
		pixman_image_set_destroy_function(bitmap.get(), destroy_func, data);
}

void Bitmap::ConvertImage(int& width, int& height, void*& pixels, bool transparent, uint32_t flags) {
	const DynamicFormat& img_format = transparent ? image_format : opaque_image_format;

	// premultiply alpha
	if ((flags & Flag_SystemBgPreserveColor) == 0) {
		for (int y = 0; y < height; y++) {
			uint8_t* dst = (uint8_t*) pixels + y * width * 4;
			for (int x = 0; x < width; x++) {
				uint8_t &r = *dst++;
				uint8_t &g = *dst++;
				uint8_t &b = *dst++;
				uint8_t &a = *dst++;
				MultiplyAlpha(r, g, b, a);
			}
		}
	} else {
		for (int y = 0; y < height; y++) {
			uint8_t* dst = (uint8_t*) pixels + y * width * 4;
			for (int x = 0; x < width; x++) {
				uint8_t &r = *dst++;
				uint8_t &g = *dst++;
				uint8_t &b = *dst++;
				uint8_t &a = *dst++;

				// Skip alpha calculation for 32x32 system background graphic
				if (x < 32 && y < 32) {
					continue;
				}

				MultiplyAlpha(r, g, b, a);
			}
		}
	}

	Bitmap src(pixels, width, height, 0, img_format);
	Clear();
	BlitFast(0, 0, src, src.GetRect(), Opacity::Opaque());
	free(pixels);
}

void* Bitmap::pixels() {
	if (!bitmap) {
		return nullptr;
	}

	return (void*) pixman_image_get_data(bitmap.get());
}
void const* Bitmap::pixels() const {
	return (void const*) pixman_image_get_data(bitmap.get());
}

int Bitmap::bpp() const {
	return (pixman_image_get_depth(bitmap.get()) + 7) / 8;
}

int Bitmap::width() const {
	return pixman_image_get_width(bitmap.get());
}

int Bitmap::height() const {
	return pixman_image_get_height(bitmap.get());
}

int Bitmap::pitch() const {
	return pixman_image_get_stride(bitmap.get());
}

namespace {
	PixmanImagePtr CreateMask(Opacity const& opacity, Rect const& src_rect, Transform const* pxform = nullptr) {
		if (opacity.IsOpaque()) {
			return nullptr;
		}

		if (!opacity.IsSplit()) {
			pixman_color_t tcolor = {0, 0, 0, static_cast<uint16_t>(opacity.Value() << 8)};
			return PixmanImagePtr{ pixman_image_create_solid_fill(&tcolor) };
		}

		auto mask = PixmanImagePtr{pixman_image_create_bits(PIXMAN_a8, 1, 2, (uint32_t*) NULL, 4)};
		uint32_t* pixels = pixman_image_get_data(mask.get());
		*reinterpret_cast<uint8_t*>(&pixels[0]) = (opacity.top & 0xFF);
		*reinterpret_cast<uint8_t*>(&pixels[1]) = (opacity.bottom & 0xFF);

		Transform xform = Transform::Scale(1.0 / src_rect.width, 1.0 / src_rect.height);
		xform *= Transform::Translation(0, opacity.split);

		if (pxform)
			xform *= *pxform;

		pixman_image_set_transform(mask.get(), &xform.matrix);

		return mask;
	}
} // anonymous namespace

void Bitmap::Blit(int x, int y, Bitmap const& src, Rect const& src_rect, Opacity const& opacity, Bitmap::BlendMode blend_mode) {
	if (opacity.IsTransparent()) {
		return;
	}

	auto mask = CreateMask(opacity, src_rect);

	pixman_image_composite32(src.GetOperator(mask.get(), blend_mode),
							 src.bitmap.get(),
							 mask.get(), bitmap.get(),
							 src_rect.x, src_rect.y,
							 0, 0,
							 x, y,
							 src_rect.width, src_rect.height);
}

void Bitmap::BlitFast(int x, int y, Bitmap const & src, Rect const & src_rect, Opacity const & opacity) {
	if (opacity.IsTransparent()) {
		return;
	}

	pixman_image_composite32(PIXMAN_OP_SRC,
		src.bitmap.get(),
		nullptr, bitmap.get(),
		src_rect.x, src_rect.y,
		0, 0,
		x, y,
		src_rect.width, src_rect.height);
}

PixmanImagePtr Bitmap::GetSubimage(Bitmap const& src, const Rect& src_rect) {
	uint8_t* pixels = (uint8_t*) src.pixels() + src_rect.x * src.bpp() + src_rect.y * src.pitch();
	return PixmanImagePtr{ pixman_image_create_bits(src.pixman_format, src_rect.width, src_rect.height,
									(uint32_t*) pixels, src.pitch()) };
}

void Bitmap::TiledBlit(Rect const& src_rect, Bitmap const& src, Rect const& dst_rect, Opacity const& opacity, Bitmap::BlendMode blend_mode) {
	TiledBlit(0, 0, src_rect, src, dst_rect, opacity, blend_mode);
}

void Bitmap::TiledBlit(int ox, int oy, Rect const& src_rect, Bitmap const& src, Rect const& dst_rect, Opacity const& opacity, Bitmap::BlendMode blend_mode) {
	if (opacity.IsTransparent()) {
		return;
	}

	if (ox >= src_rect.width)	ox %= src_rect.width;
	if (oy >= src_rect.height)	oy %= src_rect.height;
	if (ox < 0) ox += src_rect.width  * ((-ox + src_rect.width  - 1) / src_rect.width);
	if (oy < 0) oy += src_rect.height * ((-oy + src_rect.height - 1) / src_rect.height);

	auto src_bm = GetSubimage(src, src_rect);

	pixman_image_set_repeat(src_bm.get(), PIXMAN_REPEAT_NORMAL);

	auto mask = CreateMask(opacity, src_rect);

	pixman_image_composite32(src.GetOperator(mask.get(), blend_mode),
							 src_bm.get(), mask.get(), bitmap.get(),
							 ox, oy,
							 0, 0,
							 dst_rect.x, dst_rect.y,
							 dst_rect.width, dst_rect.height);
}

void Bitmap::StretchBlit(Bitmap const&  src, Rect const& src_rect, Opacity const& opacity, Bitmap::BlendMode blend_mode) {
	StretchBlit(GetRect(), src, src_rect, opacity, blend_mode);
}

void Bitmap::StretchBlit(Rect const& dst_rect, Bitmap const& src, Rect const& src_rect, Opacity const& opacity, Bitmap::BlendMode blend_mode) {
	if (opacity.IsTransparent()) {
		return;
	}

	double zoom_x = (double)src_rect.width  / dst_rect.width;
	double zoom_y = (double)src_rect.height / dst_rect.height;

	Transform xform = Transform::Scale(zoom_x, zoom_y);

	pixman_image_set_transform(src.bitmap.get(), &xform.matrix);

	auto mask = CreateMask(opacity, src_rect, &xform);

	pixman_image_composite32(src.GetOperator(mask.get(), blend_mode),
							 src.bitmap.get(), mask.get(), bitmap.get(),
							 src_rect.x / zoom_x, src_rect.y / zoom_y,
							 0, 0,
							 dst_rect.x, dst_rect.y,
							 dst_rect.width, dst_rect.height);

	pixman_image_set_transform(src.bitmap.get(), nullptr);
}

void Bitmap::WaverBlit(int x, int y, double zoom_x, double zoom_y, Bitmap const& src, Rect const& src_rect, int depth, double phase, Opacity const& opacity, Bitmap::BlendMode blend_mode) {
	if (opacity.IsTransparent()) {
		return;
	}

	Transform xform = Transform::Scale(1.0 / zoom_x, 1.0 / zoom_y);

	pixman_image_set_transform(src.bitmap.get(), &xform.matrix);

	auto mask = CreateMask(opacity, src_rect, &xform);

	int height = static_cast<int>(std::floor(src_rect.height * zoom_y));
	int width  = static_cast<int>(std::floor(src_rect.width * zoom_x));
	const auto xoff = src_rect.x * zoom_x;
	const auto yoff = src_rect.y * zoom_y;
	const auto yclip = y < 0 ? -y : 0;
	const auto yend = std::min(height, this->height() - y);
	for (int i = yclip; i < yend; i++) {
		int dy = y + i;
		// RPG_RT starts the effect from the top of the screen even if the image is clipped. The result
		// is that moving images which cross the top of the screen can appear to go too fast or too slow
		// in RPT_RT. The (i - yclip) is RPG_RT compatible behavior. Just (i) would be more correct.
		const double sy = (i - yclip) * (2 * M_PI) / (32.0 * zoom_y);
		const int offset = 2 * zoom_x * depth * std::sin(phase + sy);

		pixman_image_composite32(src.GetOperator(mask.get(), blend_mode),
								 src.bitmap.get(), mask.get(), bitmap.get(),
								 xoff, yoff + i,
								 0, i,
								 x + offset, dy,
								 width, 1);
	}

	pixman_image_set_transform(src.bitmap.get(), nullptr);
}

static pixman_color_t PixmanColor(const Color &color) {
	pixman_color_t pcolor;
	pcolor.red = color.red * color.alpha;
	pcolor.green = color.green * color.alpha;
	pcolor.blue = color.blue * color.alpha;
	pcolor.alpha = color.alpha << 8;
	return pcolor;
}

void Bitmap::Fill(const Color &color) {
	pixman_color_t pcolor = PixmanColor(color);

	pixman_box32_t box = { 0, 0, width(), height() };

	pixman_image_fill_boxes(PIXMAN_OP_SRC, bitmap.get(), &pcolor, 1, &box);
}

void Bitmap::FillRect(Rect const& dst_rect, const Color &color) {
	pixman_color_t pcolor = PixmanColor(color);

	auto timage = PixmanImagePtr{pixman_image_create_solid_fill(&pcolor)};

	pixman_image_composite32(PIXMAN_OP_OVER,
			timage.get(), nullptr, bitmap.get(),
			0, 0,
			0, 0,
			dst_rect.x, dst_rect.y,
			dst_rect.width, dst_rect.height);
}

void Bitmap::Clear() {
	if (!pixels()) {
		// Happens when height or width of bitmap are 0
		return;
	}

	memset(pixels(), '\0', height() * pitch());
}

void Bitmap::ClearRect(Rect const& dst_rect) {
	pixman_color_t pcolor = {};
	pixman_box32_t box = {
		dst_rect.x,
		dst_rect.y,
		dst_rect.x + dst_rect.width,
		dst_rect.y + dst_rect.height
	};

	box.x2 = Utils::Clamp<int32_t>(box.x2, 0, width());
	box.y2 = Utils::Clamp<int32_t>(box.y2, 0, height());

	pixman_image_fill_boxes(PIXMAN_OP_CLEAR, bitmap.get(), &pcolor, 1, &box);
}

// Hard light lookup table mapping source color to destination color
// FIXME: Replace this with std::array<std::array<uint8_t,256>,256> when we have C++17
struct HardLightTable {
	uint8_t table[256][256] = {};
};

static constexpr HardLightTable make_hard_light_lookup() {
	HardLightTable hl;
	for (int i = 0; i < 256; ++i) {
		for (int j = 0; j < 256; ++j) {
			int res = 0;
			if (i <= 128)
				res = (2 * i * j) / 255;
			else
				res = 255 - 2 * (255 - i) * (255 - j) / 255;
			hl.table[i][j] = res > 255 ? 255 : res < 0 ? 0 : res;
		}
	}
	return hl;
}

constexpr auto hard_light = make_hard_light_lookup();


// Saturation Tone Inline: Changes a pixel saturation
static inline void saturation_tone(uint32_t &src_pixel, const int saturation, const int rs, const int gs, const int bs, const int as) {
	// Algorithm from OpenPDN (MIT license)
	// Transformation in Y'CbCr color space
	uint8_t r = (src_pixel >> rs) & 0xFF;
	uint8_t g = (src_pixel >> gs) & 0xFF;
	uint8_t b = (src_pixel >> bs) & 0xFF;
	uint8_t a = (src_pixel >> as) & 0xFF;

	// Y' = 0.299 R' + 0.587 G' + 0.114 B'
	uint8_t lum = (7471 * b + 38470 * g + 19595 * r) >> 16;

	// Scale Cb/Cr by scale factor "sat"
	int red = ((lum * 1024 + (r - lum) * saturation) >> 10);
	red = red > 255 ? 255 : red < 0 ? 0 : red;
	int green = ((lum * 1024 + (g - lum) * saturation) >> 10);
	green = green > 255 ? 255 : green < 0 ? 0 : green;
	int blue = ((lum * 1024 + (b - lum) * saturation) >> 10);
	blue = blue > 255 ? 255 : blue < 0 ? 0 : blue;

	src_pixel = ((uint32_t)red << rs) | ((uint32_t)green << gs) | ((uint32_t)blue << bs) | ((uint32_t)a << as);
}

// Color Tone Inline: Changes color of a pixel by hard light table
static inline void color_tone(uint32_t &src_pixel, const Tone& tone, const int rs, const int gs, const int bs, const int as) {
	src_pixel = ((uint32_t)hard_light.table[tone.red][(src_pixel >> rs) & 0xFF] << rs)
		| ((uint32_t)hard_light.table[tone.green][(src_pixel >> gs) & 0xFF] << gs)
		| ((uint32_t)hard_light.table[tone.blue][(src_pixel >> bs) & 0xFF] << bs)
		| ((uint32_t)((src_pixel >> as) & 0xFF) << as);
}

static inline void color_tone_alpha(uint32_t &src_pixel, const Tone& tone, const int rs, const int gs, const int bs, const int as) {
	uint8_t a = (src_pixel >> as) & 0xFF;
	uint8_t r = ((uint32_t)hard_light.table[tone.red][(src_pixel >> rs) & 0xFF]) * a / 255;
	uint8_t g = ((uint32_t)hard_light.table[tone.green][(src_pixel >> gs) & 0xFF]) * a / 255;
	uint8_t b = ((uint32_t)hard_light.table[tone.blue][(src_pixel >> bs) & 0xFF]) * a / 255;
	src_pixel = ((uint32_t)r << rs) | ((uint32_t)g << gs) | ((uint32_t)b << bs) | ((uint32_t)a << as);
}

void Bitmap::ToneBlit(int x, int y, Bitmap const& src, Rect const& src_rect, const Tone &tone, Opacity const& opacity) {
	if (opacity.IsTransparent()) {
		return;
	}

	// Optimisations based on Opacity:
	// Transparent: Nothing to do
	// Opaque: Alpha check can be skipped
	// 1 Bit: Premultiplied Alpha can be skipped
	// 8 Bit: No optimisations possible

	auto src_opacity = src.GetImageOpacity();

	if (src_opacity == ImageOpacity::Transparent) {
		return;
	}

	if (tone == Tone(128,128,128,128)) {
		if (&src != this) {
			Blit(x, y, src, src_rect, opacity);
		}
		return;
	}

	// Only needed here, other codepaths are sanity checked by pixman
	if (x < 0 || y < 0 || x >= width() || y >= height()) {
		return;
	}

	if (&src != this) {
		pixman_image_composite32(src.GetOperator(),
		src.bitmap.get(), nullptr, bitmap.get(),
		src_rect.x, src_rect.y,
		0, 0,
		x, y,
		src_rect.width, src_rect.height);
	}

	const int as = pixel_format.a.shift;
	const int rs = pixel_format.r.shift;
	const int gs = pixel_format.g.shift;
	const int bs = pixel_format.b.shift;
	int next_row = pitch() / sizeof(uint32_t);
	uint32_t* pixels = (uint32_t*)this->pixels();
	pixels = pixels + (y - 1) * next_row + x;

	const uint16_t limit_height = std::min<uint16_t>(src_rect.height, height());
	const uint16_t limit_width = std::min<uint16_t>(src_rect.width, width());

	const bool apply_sat = tone.gray != 128;
	const bool apply_tone = (tone.red != 128 || tone.green != 128 || tone.blue != 128);

	// If Saturation + Color:
	if (apply_sat && apply_tone) {
		int sat = tone.gray > 128 ? 1024 + (tone.gray - 128) * 16 : tone.gray * 8;

		if (src_opacity == ImageOpacity::Opaque) {
			for (uint16_t i = 0; i < limit_height; ++i) {
				pixels += next_row;
				for (uint16_t j = 0; j < limit_width; ++j) {
					saturation_tone(pixels[j], sat, rs, gs, bs, as);
					color_tone(pixels[j], tone, rs, gs, bs, as);
				}
			}
		} else if (src_opacity == ImageOpacity::Alpha_1Bit) {
			for (uint16_t i = 0; i < limit_height; ++i) {
				pixels += next_row;
				for (uint16_t j = 0; j < limit_width; ++j) {
					uint8_t a = (uint8_t)((pixels[j] >> as) & 0xFF);
					if (a == 0)
						continue;

					saturation_tone(pixels[j], sat, rs, gs, bs, as);
					color_tone(pixels[j], tone, rs, gs, bs, as);
				}
			}
		} else { // 8 Bit Alpha
			for (uint16_t i = 0; i < limit_height; ++i) {
				pixels += next_row;
				for (uint16_t j = 0; j < limit_width; ++j) {
					uint8_t a = (uint8_t)((pixels[j] >> as) & 0xFF);
					if (a == 0) {
						continue;
					}

					saturation_tone(pixels[j], sat, rs, gs, bs, as);
					color_tone_alpha(pixels[j], tone, rs, gs, bs, as);
				}
			}
		}
	}

	// If Only Saturation:
	else if (apply_sat) {
		int sat = tone.gray > 128 ? 1024 + (tone.gray - 128) * 16 : tone.gray * 8;

		if (src_opacity == ImageOpacity::Opaque) {
			for (uint16_t i = 0; i < limit_height; ++i) {
				pixels += next_row;
				for (uint16_t j = 0; j < limit_width; ++j) {
					saturation_tone(pixels[j], sat, rs, gs, bs, as);
				}
			}
		} else { // Any kind of alpha
			for (uint16_t i = 0; i < limit_height; ++i) {
				pixels += next_row;
				for (uint16_t j = 0; j < limit_width; ++j) {
					uint8_t a = (uint8_t)((pixels[j] >> as) & 0xFF);
					if (a == 0)
						continue;

					saturation_tone(pixels[j], sat, rs, gs, bs, as);
				}
			}
		}
	}

	// If Only Color:
	else if (apply_tone) {
		if (src_opacity == ImageOpacity::Opaque) {
			for (uint16_t i = 0; i < limit_height; ++i) {
				pixels += next_row;
				for (uint16_t j = 0; j < limit_width; ++j) {
					color_tone(pixels[j], tone, rs, gs, bs, as);
				}
			}
		} else if (src_opacity == ImageOpacity::Alpha_1Bit) {
			for (uint16_t i = 0; i < limit_height; ++i) {
				pixels += next_row;
				for (uint16_t j = 0; j < limit_width; ++j) {
					uint8_t a = (uint8_t)((pixels[j] >> as) & 0xFF);
					if (a == 0)
						continue;

					color_tone(pixels[j], tone, rs, gs, bs, as);
				}
			}
		} else { // 8 Bit Alpha
			for (uint16_t i = 0; i < limit_height; ++i) {
				pixels += next_row;
				for (uint16_t j = 0; j < limit_width; ++j) {
					uint8_t a = (uint8_t)((pixels[j] >> as) & 0xFF);
					if (a == 0)
						continue;
					else if (a == 255) {
						color_tone(pixels[j], tone, rs, gs, bs, as);
					} else {
						color_tone_alpha(pixels[j], tone, rs, gs, bs, as);
					}
				}
			}
		}
	}
}

void Bitmap::BlendBlit(int x, int y, Bitmap const& src, Rect const& src_rect, const Color& color, Opacity const& opacity) {
	if (opacity.IsTransparent()) {
		return;
	}

	if (color.alpha == 0) {
		if (&src != this)
			Blit(x, y, src, src_rect, opacity);
		return;
	}

	if (&src != this)
		pixman_image_composite32(src.GetOperator(),
								 src.bitmap.get(), nullptr, bitmap.get(),
								 src_rect.x, src_rect.y,
								 0, 0,
								 x, y,
								 src_rect.width, src_rect.height);

	pixman_color_t tcolor = PixmanColor(color);
	auto timage = PixmanImagePtr{ pixman_image_create_solid_fill(&tcolor) };

	pixman_image_composite32(PIXMAN_OP_OVER,
							 timage.get(), src.bitmap.get(), bitmap.get(),
							 0, 0,
							 src_rect.x, src_rect.y,
							 x, y,
							 src_rect.width, src_rect.height);
}

void Bitmap::FlipBlit(int x, int y, Bitmap const& src, Rect const& src_rect, bool horizontal, bool vertical, Opacity const& opacity, Bitmap::BlendMode blend_mode) {
	if (opacity.IsTransparent()) {
		return;
	}

	bool has_xform = (horizontal || vertical);
	const auto img_w = src.GetWidth();
	const auto img_h = src.GetHeight();

	auto rect = src_rect;
	if (has_xform) {
		Transform xform = Transform::Scale(horizontal ? -1 : 1, vertical ? -1 : 1);
		xform *= Transform::Translation(horizontal ? -img_w : 0, vertical ? -img_h : 0);

		pixman_image_set_transform(src.bitmap.get(), &xform.matrix);
		const auto src_x = horizontal ? img_w - src_rect.x - src_rect.width : src_rect.x;
		const auto src_y = vertical ? img_h - src_rect.y - src_rect.height : src_rect.y;

		rect = Rect{ src_x, src_y, src_rect.width, src_rect.height };
	}

	Blit(x, y, src, rect, opacity, blend_mode);

	if (has_xform) {
		pixman_image_set_transform(src.bitmap.get(), nullptr);
	}
}

void Bitmap::Flip(bool horizontal, bool vertical) {
	if (!horizontal && !vertical) {
		return;
	}
	const auto w = GetWidth();
	const auto h = GetHeight();
	const auto p = pitch();

	auto temp = PixmanImagePtr{ pixman_image_create_bits(pixman_format, w, h, nullptr, p) };

	std::memcpy(pixman_image_get_data(temp.get()),
			pixman_image_get_data(bitmap.get()),
			p * h);

	Transform xform = Transform::Scale(horizontal ? -1 : 1, vertical ? -1 : 1);
	xform *= Transform::Translation(horizontal ? -w : 0, vertical ? -h : 0);

	pixman_image_set_transform(temp.get(), &xform.matrix);

	pixman_image_composite32(PIXMAN_OP_SRC,
							 temp.get(), nullptr, bitmap.get(),
							 0, 0, 0, 0, 0, 0, w, h);
}

void Bitmap::MaskedBlit(Rect const& dst_rect, Bitmap const& mask, int mx, int my, Color const& color) {
	pixman_color_t tcolor = {
		static_cast<uint16_t>(color.red << 8),
		static_cast<uint16_t>(color.green << 8),
		static_cast<uint16_t>(color.blue << 8),
		static_cast<uint16_t>(color.alpha << 8)};

	auto source = PixmanImagePtr{ pixman_image_create_solid_fill(&tcolor) };

	pixman_image_composite32(PIXMAN_OP_OVER,
							 source.get(), mask.bitmap.get(), bitmap.get(),
							 0, 0,
							 mx, my,
							 dst_rect.x, dst_rect.y,
							 dst_rect.width, dst_rect.height);
}

void Bitmap::MaskedBlit(Rect const& dst_rect, Bitmap const& mask, int mx, int my, Bitmap const& src, int sx, int sy) {
	pixman_image_composite32(PIXMAN_OP_OVER,
							 src.bitmap.get(), mask.bitmap.get(), bitmap.get(),
							 sx, sy,
							 mx, my,
							 dst_rect.x, dst_rect.y,
							 dst_rect.width, dst_rect.height);
}

void Bitmap::Blit2x(Rect const& dst_rect, Bitmap const& src, Rect const& src_rect) {
	Transform xform = Transform::Scale(0.5, 0.5);

	pixman_image_set_transform(src.bitmap.get(), &xform.matrix);

	pixman_image_composite32(PIXMAN_OP_SRC,
							 src.bitmap.get(), nullptr, bitmap.get(),
							 src_rect.x, src_rect.y,
							 0, 0,
							 dst_rect.x, dst_rect.y,
							 dst_rect.width, dst_rect.height);

	pixman_image_set_transform(src.bitmap.get(), nullptr);
}

void Bitmap::EffectsBlit(int x, int y, int ox, int oy,
						 Bitmap const& src, Rect const& src_rect,
						 Opacity const& opacity,
						 double zoom_x, double zoom_y, double angle,
						 int waver_depth, double waver_phase, Bitmap::BlendMode blend_mode) {
	if (opacity.IsTransparent()) {
		return;
	}

	bool rotate = angle != 0.0;
	bool scale = zoom_x != 1.0 || zoom_y != 1.0;
	bool waver = waver_depth != 0;

	if (waver) {
		WaverBlit(x - ox * zoom_x, y - oy * zoom_y, zoom_x, zoom_y, src, src_rect,
				  waver_depth, waver_phase, opacity, blend_mode);
	}
	else if (rotate) {
		RotateZoomOpacityBlit(x, y, ox, oy, src, src_rect, angle, zoom_x, zoom_y, opacity, blend_mode);
	}
	else if (scale) {
		ZoomOpacityBlit(x, y, ox, oy, src, src_rect, zoom_x, zoom_y, opacity, blend_mode);
	}
	else {
		Blit(x - ox, y - oy, src, src_rect, opacity, blend_mode);
	}
}

void Bitmap::RotateZoomOpacityBlit(int x, int y, int ox, int oy,
		Bitmap const& src, Rect const& src_rect,
		double angle, double zoom_x, double zoom_y, Opacity const& opacity, Bitmap::BlendMode blend_mode)
{
	if (opacity.IsTransparent()) {
		return;
	}

	auto* src_img = src.bitmap.get();

	Transform fwd = Transform::Translation(x, y);
	fwd *= Transform::Rotation(angle);
	if (zoom_x != 1.0 || zoom_y != 1.0) {
		fwd *= Transform::Scale(zoom_x, zoom_y);
	}
	fwd *= Transform::Translation(-ox, -oy);

	Rect dst_rect = TransformRectangle(fwd, Rect{0, 0, src_rect.width, src_rect.height});
	dst_rect.Adjust(GetRect());
	if (dst_rect.IsEmpty())
		return;

	auto inv = fwd.Inverse();

	PixmanImagePtr temp;
	if (src_rect != src.GetRect()) {
		temp = GetSubimage(src, src_rect);
		src_img = temp.get();
	}

	pixman_image_set_transform(src_img, &inv.matrix);

	auto mask = CreateMask(opacity, src_rect, &inv);

	// OP_SRC draws a black rectangle around the rotated image making this operator unusable here
	blend_mode = (blend_mode == BlendMode::Default ? BlendMode::Normal : blend_mode);
	pixman_image_composite32(GetOperator(mask.get(), blend_mode),
							 src_img, mask.get(), bitmap.get(),
							 dst_rect.x, dst_rect.y,
							 dst_rect.x, dst_rect.y,
							 dst_rect.x, dst_rect.y,
							 dst_rect.width, dst_rect.height);

	pixman_image_set_transform(src_img, nullptr);
}

void Bitmap::ZoomOpacityBlit(int x, int y, int ox, int oy,
							 Bitmap const& src, Rect const& src_rect,
							 double zoom_x, double zoom_y,
							 Opacity const& opacity, Bitmap::BlendMode blend_mode)
{
	if (opacity.IsTransparent()) {
		return;
	}

	Rect dst_rect(
		x - static_cast<int>(std::floor(ox * zoom_x)),
		y - static_cast<int>(std::floor(oy * zoom_y)),
		static_cast<int>(std::floor(src_rect.width * zoom_x)),
		static_cast<int>(std::floor(src_rect.height * zoom_y)));
	StretchBlit(dst_rect, src, src_rect, opacity, blend_mode);
}

pixman_op_t Bitmap::GetOperator(pixman_image_t* mask, Bitmap::BlendMode blend_mode) const {
	if (blend_mode != BlendMode::Default) {
		switch (blend_mode) {
			case BlendMode::Normal:
				return PIXMAN_OP_OVER;
			case BlendMode::NormalWithoutAlpha:
				return PIXMAN_OP_SRC;
			case BlendMode::XOR:
				return PIXMAN_OP_XOR;
			case BlendMode::Additive:
				return PIXMAN_OP_ADD;
			case BlendMode::Multiply:
				return PIXMAN_OP_MULTIPLY;
			case BlendMode::Overlay:
				return PIXMAN_OP_OVERLAY;
			case BlendMode::Saturate:
				return PIXMAN_OP_SATURATE;
			case BlendMode::Darken:
				return PIXMAN_OP_DARKEN;
			case BlendMode::Lighten:
				return PIXMAN_OP_LIGHTEN;
			case BlendMode::ColorDodge:
				return PIXMAN_OP_COLOR_DODGE;
			case BlendMode::ColorBurn:
				return PIXMAN_OP_COLOR_BURN;
			case BlendMode::Difference:
				return PIXMAN_OP_DIFFERENCE;
			case BlendMode::Exclusion:
				return PIXMAN_OP_EXCLUSION;
			case BlendMode::SoftLight:
				return PIXMAN_OP_SOFT_LIGHT;
			case BlendMode::HardLight:
				return PIXMAN_OP_HARD_LIGHT;
			default:
				return PIXMAN_OP_CLEAR;
		}
	}

	if (!mask && (!GetTransparent() || GetImageOpacity() == ImageOpacity::Opaque)) {
		return PIXMAN_OP_SRC;
	}

	return PIXMAN_OP_OVER;
}

void Bitmap::EdgeMirrorBlit(int x, int y, Bitmap const& src, Rect const& src_rect, bool mirror_x, bool mirror_y, Opacity const& opacity) {
	if (opacity.IsTransparent())
		return;

	auto mask = CreateMask(opacity, src_rect);

	const auto dst_rect = GetRect();

	auto draw = [&](int x, int y) {
		pixman_image_composite32(src.GetOperator(mask.get()),
				src.bitmap.get(),
				mask.get(), bitmap.get(),
				src_rect.x, src_rect.y,
				0, 0,
				x, y,
				src_rect.width, src_rect.height);
	};

	draw(x, y);

	const bool clone_x = (mirror_x && x + src_rect.width > dst_rect.width);
	const bool clone_y = (mirror_y && y + src_rect.height > dst_rect.height);

	if (clone_x) {
		draw(x - dst_rect.width, y);
	}

	if (clone_y) {
		draw(x, y - dst_rect.height);
	}

	if (clone_x && clone_y) {
		draw(x - dst_rect.width, y - dst_rect.height);
	}
}



/*end of file .\bitmap.cpp*/

/*start of file .\cache.cpp*/

/* ... license chunk ... */

// Headers
#ifdef _MSC_VER
#  pragma warning(disable: 4003)
#endif

#include <map>
#include <tuple>
#include <chrono>
#include <cassert>

#include "async_handler.h"
#include "cache.h"
#include "filefinder.h"
#include "exfont.h"
#include "default_graphics.h"
#include "bitmap.h"
#include "output.h"
#include "player.h"
#include <lcf/data.h>
#include "game_clock.h"
#include "translation.h"

using namespace std::chrono_literals;

namespace {
	std::string MakeHashKey(std::string_view folder_name, std::string_view filename, bool transparent, uint32_t extra_flags = 0) {
		return fmt::format("{}:{}:{}:{}", folder_name, filename, transparent, extra_flags);
	}

	std::string MakeTileHashKey(std::string_view chipset_name, int id) {
		std::string key;
		key.reserve(chipset_name.size() + sizeof(int) + 2);
		key.append(reinterpret_cast<char*>(&id), sizeof(id));
		key.append(1, ':');
		key.append(chipset_name.begin(), chipset_name.end());

		return key;
	}

	int IdFromTileHash(std::string_view key) {
		int id = 0;
		if (key.size() > sizeof(id)) {
			std::memcpy(&id, key.data(), sizeof(id));
		}
		return id;
	}

	const char* NameFromTileHash(std::string_view key) {
		int offset = sizeof(int) + 1;
		if (static_cast<int>(key.size()) < offset) {
			return "";
		}
		return key.data() + offset;
	}

	struct CacheItem {
		BitmapRef bitmap;
		Game_Clock::time_point last_access;
	};

	using key_type = std::string;
	std::unordered_map<key_type, CacheItem> cache;

	using tile_key_type = std::string;
	std::unordered_map<tile_key_type, std::weak_ptr<Bitmap>> cache_tiles;

	// rect, flip_x, flip_y, tone, blend
	using effect_key_type = std::tuple<std::string, bool, Rect, bool, bool, Tone, Color>;
	std::map<effect_key_type, std::weak_ptr<Bitmap>> cache_effects;

	std::string system_name;

	std::string system2_name;

	constexpr int cache_limit = 10 * 1024 * 1024;
	size_t cache_size = 0;

	void FreeBitmapMemory() {
		auto cur_ticks = Game_Clock::GetFrameTime();

		for (auto it = cache.begin(); it != cache.end();) {
			if (it->second.bitmap.use_count() != 1) {
				// Bitmap is referenced
				++it;
				continue;
			}

			auto last_access = cur_ticks - it->second.last_access;
			bool cache_exhausted = cache_size > cache_limit;
			if (cache_exhausted) {
				if (last_access <= 50ms) {
					// Used during the last 3 frames, must be important, keep it.
					++it;
					continue;
				}
			} else if (last_access <= 3s) {
				++it;
				continue;
			}

#ifdef CACHE_DEBUG
			Output::Debug("Freeing memory of {}/{}", std::get<0>(i.first), std::get<1>(i.first));
#endif

			cache_size -= it->second.bitmap->GetSize();

			it = cache.erase(it);
		}

#ifdef CACHE_DEBUG
		Output::Debug("Bitmap cache size: {}", cache_size / 1024.0 / 1024);
#endif
	}

	BitmapRef AddToCache(const std::string& key, BitmapRef bmp) {
		if (bmp) {
			cache_size += bmp->GetSize();
#ifdef CACHE_DEBUG
			Output::Debug("Bitmap cache size (Add): {}", cache_size / 1024.0 / 1024.0);
#endif
		}

		return (cache[key] = {bmp, Game_Clock::GetFrameTime()}).bitmap;
	}

	struct Material {
		enum Type {
			REND = -1,
			Backdrop,
			Battle,
			Charset,
			Chipset,
			Faceset,
			Gameover,
			Monster,
			Panorama,
			Picture,
			System,
			Title,
			System2,
			Battle2,
			Battlecharset,
			Battleweapon,
			Frame,
			END
		};

	}; // struct Material

	using DummyRenderer = BitmapRef(*)();

	template<Material::Type T> BitmapRef DrawCheckerboard();

	BitmapRef DummySystem() {
		return Bitmap::Create(system_h, sizeof(system_h), true, Bitmap::Flag_System | Bitmap::Flag_ReadOnly);
	}

	struct Spec {
		char const* directory;
		DummyRenderer dummy_renderer;
		bool transparent;
		int min_width , max_width;
		int min_height, max_height;
		bool oob_check;
		bool warn_missing;
	};
	constexpr Spec spec[] = {
		{ "Backdrop", DrawCheckerboard<Material::Backdrop>, false, 320, 320, 160, 240, true, true },
		{ "Battle", DrawCheckerboard<Material::Battle>, true, 96, 480, 96, 480, true, true },
		{ "CharSet", DrawCheckerboard<Material::Charset>, true, 288, 288, 256, 256, true, true },
		{ "ChipSet", DrawCheckerboard<Material::Chipset>, true, 480, 480, 256, 256, true, true },
		{ "FaceSet", DrawCheckerboard<Material::Faceset>, true, 192, 192, 192, 192, true, true},
		{ "GameOver", DrawCheckerboard<Material::Gameover>, false, 320, 320, 240, 240, true, true },
		{ "Monster", DrawCheckerboard<Material::Monster>, true, 16, 320, 16, 160, false, false },
		{ "Panorama", DrawCheckerboard<Material::Panorama>, false, 80, 640, 80, 480, false, true },
		{ "Picture", DrawCheckerboard<Material::Picture>, true, 1, 640, 1, 480, false, true },
		{ "System", DummySystem, true, 160, 160, 80, 80, true, true },
		{ "Title", DrawCheckerboard<Material::Title>, false, 320, 320, 240, 240, true, true },
		{ "System2", DrawCheckerboard<Material::System2>, true, 80, 80, 96, 96, true, true },
		{ "Battle2", DrawCheckerboard<Material::Battle2>, true, 640, 640, 640, 640, true, true },
		{ "BattleCharSet", DrawCheckerboard<Material::Battlecharset>, true, 144, 144, 384, 384, true, false },
		{ "BattleWeapon", DrawCheckerboard<Material::Battleweapon>, true, 192, 192, 512, 512, true, false },
		{ "Frame", DrawCheckerboard<Material::Frame>, true, 320, 320, 240, 240, true, true },
	};

	template<Material::Type T>
	BitmapRef DrawCheckerboard() {
		static_assert(Material::REND < T && T < Material::END, "Invalid material.");
		const Spec& s = spec[T];

		BitmapRef bitmap = Bitmap::Create(s.max_width, s.max_height, false);

		// ToDo: Maybe use different renderers depending on material
		// Will look ugly for some image types

		// Draw chess board
		Color color[2] = { Color(255, 255, 255, 255), Color(128, 128, 128, 255) };
		for (int i = 0; i < s.max_width / 16; ++i) {
			for (int j = 0; j < s.max_height / 16; ++j) {
				bitmap->FillRect(Rect(i * 16, j * 16, 16, 16), color[(i + j) % 2]);
			}
		}

		return bitmap;
	}

	template<Material::Type T>
	BitmapRef CreateEmpty() {
		static_assert(Material::REND < T && T < Material::END, "Invalid material.");
		const Spec& s = spec[T];
		return Bitmap::Create(s.min_width, s.min_height, true);
	}

	template<Material::Type T>
	BitmapRef LoadDummyBitmap(std::string_view, std::string_view, bool) {
		static_assert(Material::REND < T && T < Material::END, "Invalid material.");
		const Spec& s = spec[T];
		return s.dummy_renderer();
	}

	template<Material::Type T>
	BitmapRef LoadBitmap(std::string_view filename, bool transparent, uint32_t extra_flags = 0) {
		static_assert(Material::REND < T && T < Material::END, "Invalid material.");
		const Spec& s = spec[T];

		// This assert is triggered by the request cache clear when switching languages
		// Remove comment to test if all assets are requested correctly
		//auto* req = AsyncHandler::RequestFile(s.directory, filename);
		//assert(req != nullptr && req->IsReady());

		BitmapRef bmp;

		const auto key = MakeHashKey(s.directory, filename, transparent, extra_flags);
		auto it = cache.find(key);
		if (it == cache.end()) {
			if (filename == CACHE_DEFAULT_BITMAP) {
				bmp = LoadDummyBitmap<T>(s.directory, filename, true);
			}

			if (!bmp) {
				auto is = FileFinder::OpenImage(s.directory, filename);

				FreeBitmapMemory();

				if (!is) {
					if (s.warn_missing) {
						Output::Warning("Image not found: {}/{}", s.directory, filename);
					} else {
						Output::Debug("Image not found: {}/{}", s.directory, filename);
						bmp = CreateEmpty<T>();
					}
				} else {
					auto flags = Bitmap::Flag_ReadOnly | (
							T == Material::Chipset ? Bitmap::Flag_Chipset :
							T == Material::System ? Bitmap::Flag_System : 0);
					flags |= extra_flags;

					bmp = Bitmap::Create(std::move(is), transparent, flags);
					if (!bmp) {
						Output::Warning("Invalid image: {}/{}", s.directory, filename);
					} else {
						if (bmp->GetOriginalBpp() > 8) {
							// FIXME: This HasActiveTranslation check will also load 32 bit images in the game directory when
							// a translation is active and our API does not expose whether the asset was redirected or not.
							if (!Player::HasEasyRpgExtensions() && !Player::IsPatchManiac() && !Tr::HasActiveTranslation()) {
								Output::Warning("Image {}/{} has a bit depth of {} that is not supported by RPG_RT. Enable EasyRPG Extensions or Maniac Patch to load such images.", s.directory, filename, bmp->GetOriginalBpp());
								bmp.reset();
							}
						}
					}
				}
			}

			if (!bmp) {
				// Even for images without "warn_missing" this still creates a checkboard for invalid images
				bmp = LoadDummyBitmap<T>(s.directory, filename, transparent);
			}

			bmp = AddToCache(key, bmp);
		} else {
			it->second.last_access = Game_Clock::GetFrameTime();
			bmp = it->second.bitmap;
		}

		assert(bmp);

		if (s.oob_check) {
			int w = bmp->GetWidth();
			int h = bmp->GetHeight();
			int min_h = s.min_height;
			int max_h = s.max_height;
			int min_w = s.min_width;
			int max_w = s.max_width;

			// 240px backdrop height is 2k3 specific, for 2k is 160px
			if (T == Material::Backdrop) {
				max_h = min_h = Player::IsRPG2k() ? 160 : 240;
			}

			// EasyRPG extensions add support for large charsets; size is spoofed to ignore the error
			if (!filename.empty() && filename.front() == '$' && T == Material::Charset && Player::HasEasyRpgExtensions()) {
				w = 288;
				h = 256;
			}

			if (w < min_w || max_w < w || h < min_h || max_h < h) {
				Output::Debug("Image size out of bounds: {}/{} ({}x{} < {}x{} < {}x{})",
							s.directory, filename, min_w, min_h, w, h, max_w, max_h);
			}
		}

		return bmp;
	}

	template<Material::Type T>
	BitmapRef LoadBitmap(std::string_view f, uint32_t extra_flags = 0) {
		static_assert(Material::REND < T && T < Material::END, "Invalid material.");
		const Spec& s = spec[T];
		return LoadBitmap<T>(f, s.transparent, extra_flags);
	}
}

std::vector<uint8_t> Cache::exfont_custom;

BitmapRef Cache::Backdrop(std::string_view file) {
	return LoadBitmap<Material::Backdrop>(file);
}

BitmapRef Cache::Battle(std::string_view file) {
	return LoadBitmap<Material::Battle>(file);
}

BitmapRef Cache::Battle2(std::string_view file) {
	return LoadBitmap<Material::Battle2>(file);
}

BitmapRef Cache::Battlecharset(std::string_view file) {
	return LoadBitmap<Material::Battlecharset>(file);
}

BitmapRef Cache::Battleweapon(std::string_view file) {
	return LoadBitmap<Material::Battleweapon>(file);
}

BitmapRef Cache::Charset(std::string_view file) {
	return LoadBitmap<Material::Charset>(file);
}

BitmapRef Cache::Chipset(std::string_view file) {
	return LoadBitmap<Material::Chipset>(file);
}

BitmapRef Cache::Faceset(std::string_view file) {
	return LoadBitmap<Material::Faceset>(file);
}

BitmapRef Cache::Frame(std::string_view file, bool transparent) {
	return LoadBitmap<Material::Frame>(file, transparent);
}

BitmapRef Cache::Gameover(std::string_view file) {
	return LoadBitmap<Material::Gameover>(file);
}

BitmapRef Cache::Monster(std::string_view file) {
	return LoadBitmap<Material::Monster>(file);
}

BitmapRef Cache::Panorama(std::string_view file) {
	return LoadBitmap<Material::Panorama>(file);
}

BitmapRef Cache::Picture(std::string_view file, bool transparent) {
	return LoadBitmap<Material::Picture>(file, transparent);
}

BitmapRef Cache::System2(std::string_view file) {
	return LoadBitmap<Material::System2>(file);
}

BitmapRef Cache::Title(std::string_view file) {
	return LoadBitmap<Material::Title>(file);
}

BitmapRef Cache::System(std::string_view file, bool bg_preserve_transparent_color) {
	uint32_t flags = 0;
	if (bg_preserve_transparent_color || Player::IsRPG2k()) {
		flags = Bitmap::Flag_SystemBgPreserveColor;
	}

	return LoadBitmap<Material::System>(file, flags);
}

BitmapRef Cache::Exfont() {
	const auto key = MakeHashKey("ExFont", "ExFont", false);

	auto it = cache.find(key);

	if (it == cache.end()) {
		// Allow overwriting of built-in exfont with a custom ExFont image file
		// exfont_custom is filled by Player::CreateGameObjects
		BitmapRef exfont_img;
		if (!exfont_custom.empty()) {
			exfont_img = Bitmap::Create(exfont_custom.data(), exfont_custom.size(), true);
		}
		// exfont_custom can contain invalid data and fail
		if (!exfont_img) {
			exfont_img = Bitmap::Create(exfont_h, sizeof(exfont_h), true);
		}

		return AddToCache(key, exfont_img);
	} else {
		it->second.last_access = Game_Clock::GetFrameTime();
		return it->second.bitmap;
	}
}

BitmapRef Cache::Tile(std::string_view filename, int tile_id) {
	const auto key = MakeTileHashKey(filename, tile_id);
	auto it = cache_tiles.find(key);

	if (it == cache_tiles.end() || it->second.expired()) {
		BitmapRef chipset = Cache::Chipset(filename);
		Rect rect = Rect(0, 0, 16, 16);

		int sub_tile_id = 0;

		if (tile_id > 0 && tile_id < 48) {
			sub_tile_id = tile_id;
			rect.x += 288;
			rect.y += 128;
		} else if (tile_id >= 48 && tile_id < 96) {
			sub_tile_id = tile_id - 48;
			rect.x += 384;
		} else if (tile_id >= 96 && tile_id < 144) {
			sub_tile_id = tile_id - 96;
			rect.x += 384;
			rect.y += 128;
		} else { // Invalid -> Use empty tile (first one)
			rect.x = 288;
			rect.y = 128;
		}

		rect.x += sub_tile_id % 6 * 16;
		rect.y += sub_tile_id / 6 * 16;

		auto bmp = Bitmap::Create(*chipset, rect);
		bmp->SetId(fmt::format("{}/{}", chipset->GetId(), tile_id));
		cache_tiles[key] = bmp;

		return bmp;
	} else { return it->second.lock(); }
}

BitmapRef Cache::SpriteEffect(const BitmapRef& src_bitmap, const Rect& rect, bool flip_x, bool flip_y, const Tone& tone, const Color& blend) {
	std::string id = ToString(src_bitmap->GetId());

	if (id.empty()) {
		// Log causes false positives when empty bitmaps or placeholder (checkerboard)
		// bitmaps are used.
		//Output::Debug("Bitmap has no ID. Please report a bug!");
		id = fmt::format("{}", (void*)(src_bitmap.get()));
	}

	const effect_key_type key {
		id,
		src_bitmap->GetTransparent(),
		rect,
		flip_x,
		flip_y,
		tone,
		blend
	};

	const auto it = cache_effects.find(key);

	if (it == cache_effects.end() || it->second.expired()) {
		BitmapRef bitmap_effects;

		auto create = [&rect] () -> BitmapRef {
			return Bitmap::Create(rect.width, rect.height, true);
		};

		if (tone != Tone()) {
			bitmap_effects = create();
			bitmap_effects->ToneBlit(0, 0, *src_bitmap, rect, tone, Opacity::Opaque());
		}

		if (blend != Color()) {
			if (bitmap_effects) {
				// Tone blit was applied
				bitmap_effects->BlendBlit(0, 0, *bitmap_effects, bitmap_effects->GetRect(), blend, Opacity::Opaque());
			} else {
				bitmap_effects = create();
				bitmap_effects->BlendBlit(0, 0, *src_bitmap, rect, blend, Opacity::Opaque());
			}
		}

		if (flip_x || flip_y) {
			if (bitmap_effects) {
				// Tone or blend blit was applied
				bitmap_effects->Flip(flip_x, flip_y);
			} else {
				bitmap_effects = create();
				bitmap_effects->FlipBlit(0, 0, *src_bitmap, rect, flip_x, flip_y, Opacity::Opaque());
			}
		}

		assert(bitmap_effects && "Effect cache used but no effect applied!");

		return(cache_effects[key] = bitmap_effects).lock();
	} else { return it->second.lock(); }
}

void Cache::Clear() {
	cache_effects.clear();
	cache.clear();
	cache_size = 0;

	for (auto& kv : cache_tiles) {
		auto& key = kv.first;
		if (kv.second.expired()) {
			continue;
		}
		Output::Debug("possible leak in cached tilemap {}/{}",
				NameFromTileHash(key), IdFromTileHash(key));
	}

	cache_tiles.clear();
}

void Cache::ClearAll() {
	Cache::Clear();

	system_name.clear();
	system2_name.clear();
}

void Cache::SetSystemName(std::string filename) {
	system_name = std::move(filename);
}

void Cache::SetSystem2Name(std::string filename) {
	system2_name = std::move(filename);
}

BitmapRef Cache::System(bool bg_preserve_transparent_color) {
	if (!system_name.empty()) {
		return Cache::System(system_name, bg_preserve_transparent_color);
	} else {
		return nullptr;
	}
}

BitmapRef Cache::SysBlack() {
	static auto system_black = Bitmap::Create(160, 80, false);
	return system_black;
}

BitmapRef Cache::SystemOrBlack(bool bg_preserve_transparent_color) {
	auto system = Cache::System(bg_preserve_transparent_color);
	if (system) {
		return system;
	}
	return SysBlack();
}

BitmapRef Cache::System2() {
	if (!system2_name.empty()) {
		return Cache::System2(system2_name);
	} else {
		return nullptr;
	}
}


/*end of file .\cache.cpp*/

/*start of file .\cmdline_parser.cpp*/

/* ... license chunk ... */

#include "cmdline_parser.h"
#include "utils.h"
#include "output.h"
#include <cstring>

#include <iostream>
#include <sstream>

bool CmdlineArg::ParseValue(int i, std::string& value) const {
	if (i >= NumValues()) {
		return false;
	}
	value = Value(i);
	return true;
}

bool CmdlineArg::ParseValue(int i, long& value) const {
	if (i >= NumValues()) {
		return false;
	}
	auto& s = Value(i);

	auto* p = s.c_str();
	auto* e = p + s.size();
	long v = strtol(p, const_cast<char**>(&e), 10);
	if (p == e) {
		return false;
	}
	value = v;
	return true;
}

CmdlineParser::CmdlineParser(std::vector<std::string> arguments)
{
	size_t argc = arguments.size();
	if (argc > 0) {
		args.reserve(argc - 1);
		copy(arguments.begin() + 1, arguments.end(), back_inserter(args));
	}
}

template <typename F>
bool CmdlineParser::DoParseNext(CmdlineArg& arg, int max_values, F&& is_longval, char shortval) {
	const auto nargs = static_cast<int>(args.size());

	if (index >= nargs) {
		return false;
	}

	if (!(is_longval(args[index])
			|| (shortval
				&& args[index][0] == '-'
				&& args[index][1] == shortval
				&& args[index][2] == '\0')))
	{
		return false;
	}

	auto* ptr = args.data() + index;
	++index;

	int nv = 0;
	while (nv < max_values) {
		if (index >= nargs) {
			break;
		}

		auto& next = args[index];
		if (!next.empty() && next.front() == '-') {
			break;
		}

		++nv;
		++index;
	}

	arg = CmdlineArg(ptr, nv);

	return true;
}

bool CmdlineParser::ParseNext(CmdlineArg& arg, int max_values, const char* longval, char shortval) {
	return DoParseNext(arg, max_values,
			[=](auto& s) { return Utils::StrICmp(longval, s.c_str()) == 0; },
			shortval);
}

bool CmdlineParser::ParseNext(CmdlineArg& arg, int max_values, std::initializer_list<const char*> longvals, char shortval) {
	return DoParseNext(arg, max_values,
			[=](auto& s) {
				for (auto& lv: longvals) {
					if (Utils::StrICmp(lv, s.c_str()) == 0) {
						return true;
					}
				}
				return false;
			},
			shortval);
}

void CmdlineParser::SkipNext() {
	assert(index < static_cast<int>(args.size()));
	++index;
}

void CmdlineParser::RewindBy(int rewind) {
	assert(rewind >= 0);
	index -= rewind;
	assert(index >= 0);
}


/*end of file .\cmdline_parser.cpp*/

/*start of file .\decoder_drwav.cpp*/

/* ... license chunk ... */

// Headers
#include "decoder_drwav.h"

#ifdef WANT_DRWAV

#define DR_WAV_IMPLEMENTATION
// Use system dr_wav header if available
#if __has_include(<dr_wav.h>)
#  include <dr_wav.h>
#else
#  include "external/dr_wav.h"
#endif


DrWavDecoder::DrWavDecoder() {
	music_type = "wav";
}

DrWavDecoder::~DrWavDecoder() {
	drwav_uninit(&handle);
}

size_t read_func(void* userdata, void* ptr, size_t count) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);

	return f->read(reinterpret_cast<char*>(ptr), count).gcount();
}

drwav_bool32 seek_func(void* userdata, int offset, drwav_seek_origin origin) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);
	if (f->eof()) f->clear(); // emulate behaviour of fseek

	f->seekg(offset, Filesystem_Stream::CSeekdirToCppSeekdir(origin));

	return DRWAV_TRUE;
}

drwav_bool32 tell_func(void* userdata, drwav_int64* cursor) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);

	*cursor = f->GetPosition();

	return DRWAV_TRUE;
}

bool DrWavDecoder::Open(Filesystem_Stream::InputStream stream_) {
	this->stream = std::move(stream_);
#if DRWAV_VERSION_MINOR < 14
	init = drwav_init_ex(&handle, read_func, seek_func, nullptr, &this->stream, nullptr, DRWAV_SEQUENTIAL, nullptr) == DRWAV_TRUE;
#else
	init = drwav_init_ex(&handle, read_func, seek_func, tell_func, nullptr, &this->stream, nullptr, DRWAV_SEQUENTIAL, nullptr) == DRWAV_TRUE;
#endif
	return init;
}

bool DrWavDecoder::Seek(std::streamoff offset, std::ios_base::seekdir origin) {
	if (origin == std::ios_base::beg) {
		finished = false;
		drwav_seek_to_pcm_frame(&handle, offset);
		decoded_samples = 0;
		return true;
	}
	return false;
}

bool DrWavDecoder::IsFinished() const {
	return finished;
}

void DrWavDecoder::GetFormat(int& frequency, AudioDecoder::Format& format, int& channels) const {
	if (!init) return;
	frequency = handle.sampleRate;
	channels = handle.channels;
	format = AudioDecoder::Format::S16;
}

bool DrWavDecoder::SetFormat(int, AudioDecoder::Format, int) {
	return false;
}

int DrWavDecoder::GetTicks() const {
	if (!init) {
		return 0;
	}

	return decoded_samples / handle.sampleRate;
}

int DrWavDecoder::FillBuffer(uint8_t* buffer, int length) {
	if (!init) {
		return -1;
	}

	if (finished) {
		return 0;
	}

	int decoded = static_cast<int>(drwav_read_pcm_frames_s16(&handle, length / (handle.channels * 2), reinterpret_cast<drwav_int16*>(buffer)));
	decoded_samples += decoded;
	decoded *= handle.channels * 2;

	if (decoded < length)
		finished = true;

	return decoded;
}

#endif


/*end of file .\decoder_drwav.cpp*/

/*start of file .\decoder_fluidsynth.cpp*/

/* ... license chunk ... */

#include "system.h"
#include "audio.h"
#include "decoder_fluidsynth.h"

#if defined(HAVE_FLUIDSYNTH) || defined(HAVE_FLUIDLITE)

#include <cassert>
#include "filefinder.h"
#include "output.h"

#if FLUIDSYNTH_VERSION_MAJOR >= 3 || (FLUIDSYNTH_VERSION_MAJOR == 2 && FLUIDSYNTH_VERSION_MINOR >= 2)
#define FLUIDSYNTH_22_OR_NEWER
#endif

#ifdef HAVE_FLUIDSYNTH
static void* vio_open(const char* filename) {
#else
static void* vio_open(fluid_fileapi_t*, const char* filename) {
#endif
	auto is = FileFinder::Game().OpenInputStream(filename);
	if (!is) {
		is = FileFinder::Root().OpenInputStream(filename);
		if (!is) {
			return nullptr;
		}
	}
	return new Filesystem_Stream::InputStream { std::move(is) };
}

#ifdef FLUIDSYNTH_22_OR_NEWER
static int vio_read(void *ptr, fluid_long_long_t count, void* userdata) {
#else
static int vio_read(void *ptr, int count, void* userdata) {
#endif
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);
	return f->read(reinterpret_cast<char*>(ptr), count).gcount();
}

#ifdef FLUIDSYNTH_22_OR_NEWER
static int vio_seek(void* userdata, fluid_long_long_t offset, int origin) {
#else
static int vio_seek(void* userdata, long offset, int origin) {
#endif
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);
	if (f->eof()) f->clear(); // emulate behaviour of fseek

	f->seekg(offset, Filesystem_Stream::CSeekdirToCppSeekdir(origin));

	return f->tellg();
}

#ifdef FLUIDSYNTH_22_OR_NEWER
static fluid_long_long_t vio_tell(void* userdata) {
#else
static long vio_tell(void* userdata) {
#endif
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);
	return f->tellg();
}

static int vio_close(void* userdata) {
	auto stream_ref = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);
	delete stream_ref;

	return 0;
}

#ifdef HAVE_FLUIDLITE
static fluid_fileapi_t fluidlite_vio = {
	nullptr,
	nullptr,
	vio_open,
	vio_read,
	vio_seek,
	vio_close,
	vio_tell
};
#endif

struct FluidSynthDeleter {
	void operator()(fluid_settings_t* s) const {
		delete_fluid_settings(s);
	}

	void operator()(fluid_synth_t* s) const {
		delete_fluid_synth(s);
	}
};

namespace {
	bool once = false;
	bool init = false;

	std::unique_ptr<fluid_settings_t, FluidSynthDeleter> global_settings;
	std::unique_ptr<fluid_synth_t, FluidSynthDeleter> global_synth;
	std::unique_ptr<fluid_synth_t, FluidSynthDeleter> pending_global_synth;

	int instances = 0;
}

static bool load_default_sf(std::string& status_message, fluid_synth_t* syn) {
	// Attempt loading a soundfont
	std::vector<std::string> sf_paths;
	std::string preferred_soundfont = Audio().GetFluidsynthSoundfont();
	if (!preferred_soundfont.empty()) {
		sf_paths.emplace_back(preferred_soundfont);
	}
	sf_paths.emplace_back("easyrpg.soundfont");

#if FLUIDSYNTH_VERSION_MAJOR >= 2
	char* default_sf = nullptr;
	if (fluid_settings_dupstr(global_settings.get(), "synth.default-soundfont", &default_sf) == 0) {
		if (default_sf != nullptr && default_sf[0] != '\0') {
			sf_paths.emplace_back(default_sf);
		}
	}
	fluid_free(default_sf);
#endif

	if (getenv("SDL_SOUNDFONTS")) {
		auto sdl_sfs = Utils::Tokenize(getenv("SDL_SOUNDFONTS"), [](char32_t t) {
#ifdef _WIN32
			return t == ';';
#else
			return t == ':' || t == ';';
#endif
		});
		sf_paths.insert(sf_paths.end(), sdl_sfs.begin(), sdl_sfs.end());
	}

#ifdef SYSTEM_DESKTOP_LINUX_BSD_MACOS
	auto sf_files = {"FluidR3_GM.sf2"};
	for (const auto& sf_file: sf_files) {
		sf_paths.emplace_back(FileFinder::MakePath("/usr/share/soundfonts", sf_file));
		sf_paths.emplace_back(FileFinder::MakePath("/usr/share/sounds/sf2", sf_file));
	}
#endif

	bool sf_load_success = false;
	for (const auto& sf_name: sf_paths) {
		if (fluid_synth_sfload(syn, sf_name.c_str(), 1) != FLUID_FAILED) {
			sf_load_success = true;
			status_message = fmt::format("Using soundfont {}", sf_name);
			break;
		}
	}

	if (!sf_load_success) {
		status_message = "Could not load soundfont.";
		return false;
	}

	return true;
}

static fluid_synth_t* create_synth(std::string& status_message) {
	fluid_synth_t* syn = new_fluid_synth(global_settings.get());
	if (!syn) {
		status_message = "new_fluid_synth failed";
		return nullptr;
	}

#if defined(HAVE_FLUIDSYNTH) && FLUIDSYNTH_VERSION_MAJOR > 1
	// Fluidsynth 1.x does not support VIO API for soundfonts
	// owned by fluid_synth
	auto* loader = new_fluid_defsfloader(global_settings.get());
	fluid_sfloader_set_callbacks(loader,
			vio_open, vio_read, vio_seek, vio_tell, vio_close);
	fluid_synth_add_sfloader(syn, loader);
#endif

	fluid_synth_set_interp_method(syn, -1, FLUID_INTERP_LINEAR);

	return syn;
}

FluidSynthDecoder::FluidSynthDecoder() {
	++instances;

	// Optimisation: Only create the soundfont once and share the synth
	// Sharing is only not possible when a Midi is played as a SE (unlikely)
	if (instances > 1) {
		std::string error_message;
		local_synth = create_synth(error_message);
		if (!local_synth) {
			// unlikely, the SF was already allocated once
			Output::Debug("FluidSynth failed: {}", error_message);
		}
	} else {
		use_global_synth = true;
		fluid_synth_program_reset(global_synth.get());
	}
}

FluidSynthDecoder::~FluidSynthDecoder() {
	--instances;
	assert(instances >= 0);

	if (use_global_synth) {
		// Exhaust the internal synth buffer
		// Prevents that old samples play when a new Midi song starts (even when there was a longer break between them)
		std::array<uint8_t, 64 * 4> buffer;
		fluid_synth_write_s16(global_synth.get(), buffer.size() / 4, buffer.data(), 0, 2, buffer.data(), 1, 2);
	} else {
		delete_fluid_synth(local_synth);
	}
}

bool FluidSynthDecoder::Initialize(std::string& status_message) {
	// only initialize once until a new game starts
	if (once) {
		if (!init && global_settings && !global_synth) {
			global_synth.reset(create_synth(status_message));
			if (global_synth) {
				if (!load_default_sf(status_message, global_synth.get())) {
					global_synth.reset();
				}
			}

			init = (global_synth != nullptr);
		}
		return init;
	}

	once = true;

#ifdef HAVE_FLUIDLITE
	fluid_set_default_fileapi(&fluidlite_vio);
#endif

	global_settings.reset(new_fluid_settings());
	if (!global_settings) {
		return false;
	}
	fluid_settings_setstr(global_settings.get(), "player.timing-source", "sample");
	fluid_settings_setint(global_settings.get(), "synth.lock-memory", 0);

	fluid_settings_setnum(global_settings.get(), "synth.gain", 0.6);
	fluid_settings_setnum(global_settings.get(), "synth.sample-rate", EP_MIDI_FREQ);
	fluid_settings_setint(global_settings.get(), "synth.polyphony", 256);

#if defined(HAVE_FLUIDSYNTH) && FLUIDSYNTH_VERSION_MAJOR > 1
	fluid_settings_setint(global_settings.get(), "synth.reverb.active", 0);
	fluid_settings_setint(global_settings.get(), "synth.chorus.active", 0);
#else
	fluid_settings_setstr(global_settings.get(), "synth.reverb.active", "no");
	fluid_settings_setstr(global_settings.get(), "synth.chorus.active", "no");
#endif

	global_synth.reset(create_synth(status_message));
	if (!global_synth) {
		return false;
	}

	if (!load_default_sf(status_message, global_synth.get())) {
		global_synth.reset();
		return false;
	}

	init = true;

	return init;
}

void FluidSynthDecoder::ResetState() {
	once = false;
	init = false;

	global_synth.reset();
	global_settings.reset();
	pending_global_synth.reset();
}

bool FluidSynthDecoder::ChangeGlobalSoundfont(std::string_view sf_path, std::string& status_message) {
	if (!global_synth) {
		return false;
	}

	pending_global_synth.reset(create_synth(status_message));

	if (!pending_global_synth) {
		return false;
	}

	if (sf_path.empty()) {
		return load_default_sf(status_message, pending_global_synth.get());
	}

	if (fluid_synth_sfload(pending_global_synth.get(), ToString(sf_path).c_str(), 1) != FLUID_FAILED) {
		status_message = fmt::format("Using soundfont {}", sf_path);
		return true;
	}

	pending_global_synth.reset();
	status_message = "Could not load soundfont.";
	return false;
}

int FluidSynthDecoder::FillBuffer(uint8_t* buffer, int length) {
	auto* instance_synth = GetSynthInstance();

	if (!instance_synth) {
		return -1;
	}

	if (fluid_synth_write_s16(instance_synth, length / 4, buffer, 0, 2, buffer, 1, 2) == FLUID_FAILED) {
		return -1;
	}

	return length;
}

void FluidSynthDecoder::SendMidiMessage(uint32_t message) {
	auto* instance_synth = GetSynthInstance();

	if (!instance_synth) {
		return;
	}

	unsigned int event = message & 0xF0;
	int channel = message & 0x0F;
	int param1 = (message >> 8) & 0x7F;
	int param2 = (message >> 16) & 0x7F;

	switch (event) {
		case MidiEvent_NoteOff:
			fluid_synth_noteoff(instance_synth, channel, param1);
			break;
		case MidiEvent_NoteOn:
			fluid_synth_noteon(instance_synth, channel, param1, param2);
			break;
		case MidiEvent_KeyPressure:
#if defined(HAVE_FLUIDSYNTH) && FLUIDSYNTH_VERSION_MAJOR == 1
			// unsupported
			return;
#else
			fluid_synth_key_pressure(instance_synth, channel, param1, param2);
#endif
			break;
		case MidiEvent_Controller:
			fluid_synth_cc(instance_synth, channel, param1, param2);
			break;
		case MidiEvent_ProgramChange:
			fluid_synth_program_change(instance_synth, channel, param1);
			break;
		case MidiEvent_ChannelPressure:
			fluid_synth_channel_pressure(instance_synth, channel, param1);
			break;
		case MidiEvent_PitchBend:
			fluid_synth_pitch_bend(instance_synth, channel, ((param2 & 0x7F) << 7) | (param1 & 0x7F));
			break;
		default:
			break;
	}
}

void FluidSynthDecoder::SendSysExMessage(const uint8_t* data, std::size_t size) {
	// FmMidi has F0 and F7 in SysEx, Fluidsynth wants them removed
	if (size <= 2) {
		return;
	}

	auto* instance_synth = GetSynthInstance();

	fluid_synth_sysex(instance_synth, reinterpret_cast<const char*>(data + 1), static_cast<int>(size - 2),
		nullptr, nullptr, nullptr, 0);
}

fluid_synth_t *FluidSynthDecoder::GetSynthInstance() {
	if (use_global_synth) {
		return global_synth.get();
	} else {
		return local_synth;
	}
}

void FluidSynthDecoder::OnNewMidi() {
	if (pending_global_synth) {
		global_synth = std::move(pending_global_synth);
	}
}

bool FluidSynthDecoder::NeedsSoftReset() {
	return true;
}

#endif


/*end of file .\decoder_fluidsynth.cpp*/

/*start of file .\decoder_fmmidi.cpp*/

/* ... license chunk ... */

#include "system.h"

#ifdef WANT_FMMIDI

// Headers
#include <cstdio>
#include <cassert>
#include "audio_decoder.h"
#include "output.h"
#include "decoder_fmmidi.h"

FmMidiDecoder::FmMidiDecoder() {
	note_factory.reset(new midisynth::fm_note_factory());
	synth.reset(new midisynth::synthesizer(note_factory.get()));

	load_programs();
}

int FmMidiDecoder::FillBuffer(uint8_t* buffer, int length) {
	size_t samples = (size_t)length / sizeof(int_least16_t) / 2;

	synth->synthesize(reinterpret_cast<int_least16_t*>(buffer), samples, static_cast<float>(frequency));

	return length;
}

void FmMidiDecoder::SendMidiMessage(uint32_t message) {
	synth->midi_event(message);
}

void FmMidiDecoder::SendSysExMessage(const uint8_t* data, std::size_t size) {
	synth->sysex_message(data, size);
}

void FmMidiDecoder::load_programs() {
	// beautiful
	#include "midiprogram.h"
}

#endif


/*end of file .\decoder_fmmidi.cpp*/

/*start of file .\decoder_libsndfile.cpp*/

/* ... license chunk ... */

#include "system.h"

#ifdef HAVE_LIBSNDFILE

// Headers
#include <cassert>
#include <sys/stat.h>
#include "decoder_libsndfile.h"
#include "output.h"

static sf_count_t sf_vio_get_filelen_impl(void*) {
	// Unknown. SF_COUNT_MAX is the size used by libsndfile for pipes.
	return SF_COUNT_MAX;
}

static sf_count_t sf_vio_read_impl(void *ptr, sf_count_t count, void* userdata){
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);
	return f->read(reinterpret_cast<char*>(ptr), count).gcount();
}

static sf_count_t sf_vio_write_impl(const void* /* ptr */, sf_count_t count, void* /* user_data */){
	//Writing of wav files is not necessary
	return count;
}

static sf_count_t sf_vio_seek_impl(sf_count_t offset, int seek_type, void *userdata) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);
	if (f->eof()) f->clear(); //emulate behaviour of fseek

	f->seekg(offset, Filesystem_Stream::CSeekdirToCppSeekdir(seek_type));

	return f->tellg();
}

static sf_count_t sf_vio_tell_impl(void* userdata){
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);
	return f->tellg();
}

static SF_VIRTUAL_IO vio = {
	sf_vio_get_filelen_impl,
	sf_vio_seek_impl,
	sf_vio_read_impl,
	sf_vio_write_impl,
	sf_vio_tell_impl
}; 

LibsndfileDecoder::LibsndfileDecoder() 
{
	music_type = "wav";
	soundfile=0;
}

LibsndfileDecoder::~LibsndfileDecoder() {
	if(soundfile != 0){
		sf_close(soundfile);
	}
}

bool LibsndfileDecoder::Open(Filesystem_Stream::InputStream stream) {
	this->stream = std::move(stream);
	soundfile=sf_open_virtual(&vio,SFM_READ,&soundinfo,&this->stream);
	sf_command(soundfile, SFC_SET_SCALE_FLOAT_INT_READ, NULL, SF_TRUE);
	output_format=Format::S16;
	finished=false;
	decoded_samples = 0;
	return soundfile!=0;
}

bool LibsndfileDecoder::Seek(std::streamoff offset, std::ios_base::seekdir origin) {
	finished = false;
	if(soundfile == 0)
		return false;

	// FIXME: Proper sample count for seek
	decoded_samples = 0;
	return sf_seek(soundfile, offset, Filesystem_Stream::CppSeekdirToCSeekdir(origin))!=-1;
}

bool LibsndfileDecoder::IsFinished() const {
	return finished;
}

void LibsndfileDecoder::GetFormat(int& frequency, AudioDecoder::Format& format, int& channels) const {
	if(soundfile==0) return;
	frequency = soundinfo.samplerate;
	channels = soundinfo.channels;
	format = output_format;
}

bool LibsndfileDecoder::SetFormat(int freq, AudioDecoder::Format fmt, int channels) {
	if(soundfile == 0)
		return false;

	switch(fmt){
		case Format::F32:
		case Format::S16:
		case Format::S32:
			output_format=fmt;
			break;
		default:
			return false;
	}
	return soundinfo.samplerate==freq && soundinfo.channels==channels && output_format==fmt;
}

int LibsndfileDecoder::FillBuffer(uint8_t* buffer, int length) {
	if(soundfile == 0)
		return -1;

	int decoded;
	switch(output_format){
		case Format::F32:
			{
				decoded=sf_read_float(soundfile,(float*)buffer,length/sizeof(float));
				if(!decoded)
					finished=true;
				decoded_samples += decoded;
				decoded *= sizeof(float);
			}
			break;
		case Format::S16:
			{
				decoded=sf_read_short(soundfile,(int16_t*)buffer,length/sizeof(int16_t));
				if(!decoded)
					finished=true;
				decoded_samples += decoded;
				decoded *= sizeof(int16_t);
			}
			break;
		case Format::S32:
			{
				// Uses int instead of int32_t because the 3ds toolchain typedefs
				// to long int which is an incompatible pointer type
				decoded=sf_read_int(soundfile,(int*)buffer,length/sizeof(int));

				if(!decoded)
					finished=true;

				decoded_samples += decoded;
				decoded *= sizeof(int);
			}
			break;
		default:
			decoded=-1;
			break;
	}

	return decoded;
}

int LibsndfileDecoder::GetTicks() const {
	if (soundfile == 0) {
		return 0;
	}

	return decoded_samples / (soundinfo.samplerate * soundinfo.channels);
}

#endif


/*end of file .\decoder_libsndfile.cpp*/

/*start of file .\decoder_mpg123.cpp*/

/* ... license chunk ... */

#include "system.h"

#ifdef HAVE_LIBMPG123

// Headers
#include <cassert>
#include <lcf/scope_guard.h>
#include "decoder_mpg123.h"
#include "output.h"

static bool init = false;
static void Mpg123Decoder_deinit(void) {
	mpg123_exit();
}

#ifdef _MSC_VER
using MPG123_SIZE_TYPE = ptrdiff_t;
#else
using MPG123_SIZE_TYPE = ssize_t;
#endif

static MPG123_SIZE_TYPE custom_read(void* io, void* buffer, size_t nbyte) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(io);
	return f->read(reinterpret_cast<char*>(buffer), nbyte).gcount();
}

static off_t custom_seek(void* io, off_t offset, int seek_type) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(io);
	if (f->eof()) f->clear(); //emulate behaviour of fseek

	f->seekg(offset, Filesystem_Stream::CSeekdirToCppSeekdir(seek_type));

	return f->tellg();
}

static void custom_close(void*) {
	// do nothing
}

Mpg123Decoder::Mpg123Decoder() :
	handle(nullptr, mpg123_delete)
{
	music_type = "mp3";

	// only initialize library once
	if (!init) {
		err = mpg123_init();
		if (err != MPG123_OK) {
			error_message = "mpg123: " + std::string(mpg123_plain_strerror(err));
			return;
		}
		// setup deinitialization
		atexit(Mpg123Decoder_deinit);
	}

	handle.reset(mpg123_new(nullptr, &err));
	mpg123_replace_reader_handle(handle.get(), custom_read, custom_seek, custom_close);

	if (!handle) {
		error_message = "mpg123: " + std::string(mpg123_plain_strerror(err));
		return;
	}

	init = true;
}

Mpg123Decoder::~Mpg123Decoder() {
}

bool Mpg123Decoder::WasInited() const {
	return init;
}

bool Mpg123Decoder::Open(Filesystem_Stream::InputStream stream) {
	if (!init) {
		return false;
	}
	
	finished = false;

	this->stream = std::move(stream);
	err = mpg123_open_handle(handle.get(), &this->stream);
	if (err != MPG123_OK) {
		error_message = "mpg123: " + std::string(mpg123_plain_strerror(err));
		return false;
	}
	// Samplerate cached, regularly needed for Ticks function
	int ch;
	int fmt;
	mpg123_getformat(handle.get(), &samplerate, &ch, &fmt);

	return true;
}

bool Mpg123Decoder::Seek(std::streamoff offset, std::ios_base::seekdir origin) {
	finished = false;
	mpg123_seek_frame(handle.get(), offset, Filesystem_Stream::CppSeekdirToCSeekdir(origin));

	return true;
}

bool Mpg123Decoder::IsFinished() const {
	return finished;
}

static int format_to_mpg123_format(AudioDecoder::Format format) {
	switch (format) {
		case AudioDecoder::Format::U8:
			return MPG123_ENC_UNSIGNED_8;
		case AudioDecoder::Format::S8:
			return MPG123_ENC_SIGNED_8;
		case AudioDecoder::Format::U16:
			return MPG123_ENC_UNSIGNED_16;
		case AudioDecoder::Format::S16:
			return MPG123_ENC_SIGNED_16;
		case AudioDecoder::Format::U32:
			return MPG123_ENC_UNSIGNED_32;
		case AudioDecoder::Format::S32:
			return MPG123_ENC_SIGNED_32;
		case AudioDecoder::Format::F32:
			return MPG123_ENC_FLOAT_32;
		default:
			assert(false);
	}

	return -1;
}

static AudioDecoder::Format mpg123_format_to_format(int format) {
	switch (format) {
		case MPG123_ENC_UNSIGNED_8:
			return AudioDecoder::Format::U8;
		case MPG123_ENC_SIGNED_8:
			return AudioDecoder::Format::S8;
		case MPG123_ENC_UNSIGNED_16:
			return AudioDecoder::Format::U16;
		case MPG123_ENC_SIGNED_16:
			return AudioDecoder::Format::S16;
		case MPG123_ENC_UNSIGNED_32:
			return AudioDecoder::Format::U32;
		case MPG123_ENC_SIGNED_32:
			return AudioDecoder::Format::S32;
		case MPG123_ENC_FLOAT_32:
			return AudioDecoder::Format::F32;
		default:
			assert(false);
	}

	return (AudioDecoder::Format)-1;
}

void Mpg123Decoder::GetFormat(int& frequency, AudioDecoder::Format& format, int& channels) const {
	long freq;
	int ch;
	int fmt;

	mpg123_getformat(handle.get(), &freq, &ch, &fmt);

	frequency = (int)freq;
	channels = ch;
	format = mpg123_format_to_format(fmt);
}

bool Mpg123Decoder::SetFormat(int freq, AudioDecoder::Format fmt, int channels) {
	// mpg123 has a built-in pseudo-resampler, not needing SDL_ConvertAudio later
	// Remove all available conversion formats
	// Add just one format to force mpg123 pseudo-resampler work
	mpg123_format_none(handle.get());

	err = mpg123_format(handle.get(), (long)freq, (int)channels, (int)format_to_mpg123_format(fmt));
	if (err != MPG123_OK) {
		err = mpg123_format(handle.get(), (long)44100, (int)channels, (int)format_to_mpg123_format(fmt));
		if (err != MPG123_OK) {
			mpg123_format(handle.get(), (long)44100, (int)2, (int)MPG123_ENC_SIGNED_16);
		}

		return false;
	}

	return err == MPG123_OK;
}

int Mpg123Decoder::GetTicks() const {
	if (samplerate == 0) {
		return 0;
	}

	off_t pos = mpg123_tell(handle.get());
	return pos / samplerate;
}

bool Mpg123Decoder::IsMp3(Filesystem_Stream::InputStream& stream) {
	Mpg123Decoder decoder;

	auto rescue_stream = lcf::makeScopeGuard([&]() {
		// Prevent closing of the stream, is used afterwards
		stream = std::move(decoder.stream);
	});

	// Prevent stream handle destruction
	mpg123_replace_reader_handle(decoder.handle.get(), custom_read, custom_seek, custom_close);
	// Prevent skipping of too many garbage, breaks heuristic
	mpg123_param(decoder.handle.get(), MPG123_RESYNC_LIMIT, 64, 0.0);
	if (!decoder.Open(std::move(stream))) {
		return false;
	}

	unsigned char buffer[1024];
	int err = 0;
	size_t done = 0;
	int err_count = 0;

	// Read beginning of assumed MP3 file and count errors as an heuristic to detect MP3
	for (int i = 0; i < 10; ++i) {
		err = mpg123_read(decoder.handle.get(), buffer, 1024, &done);
		if (err == MPG123_DONE && done != 0) {
			return err_count == 0;
		}
		if (err != MPG123_OK) {
			err_count += 1;
		}
		if (err_count >= 3) {
			break;
		}
	}

	return err_count < 3;
}

int Mpg123Decoder::FillBuffer(uint8_t* buffer, int length) {
	int err;
	size_t done = 0;
	size_t decoded = 0;

	// Skip invalid frames until getting a valid one
	do {
		err = mpg123_read(handle.get(), reinterpret_cast<unsigned char*>(buffer), length, &done);
		decoded += done;
	} while (done && err != MPG123_OK);

	if (err == MPG123_DONE) {
		finished = true;
	}

	return (int)decoded;
}

#endif


/*end of file .\decoder_mpg123.cpp*/

/*start of file .\decoder_oggvorbis.cpp*/

/* ... license chunk ... */

#include "system.h"

#if defined(HAVE_TREMOR) || defined(HAVE_OGGVORBIS)

// Headers
#include "audio_decoder.h"
#include "decoder_oggvorbis.h"
#include "filesystem_stream.h"

static size_t vio_read_func(void *ptr, size_t size,size_t nmemb,void* userdata) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);
	if (size == 0) return 0;
	return f->read(reinterpret_cast<char*>(ptr), size*nmemb).gcount()/size;
}

static int vio_seek_func(void* userdata, ogg_int64_t offset, int seek_type) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);
	if (f->eof()) f->clear(); //emulate behaviour of fseek

	f->seekg(offset, Filesystem_Stream::CSeekdirToCppSeekdir(seek_type));

	return f->tellg();
}

static long vio_tell_func(void* userdata) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);
	return f->tellg();
}

static ov_callbacks vio = {
	vio_read_func,
	vio_seek_func,
	nullptr, // close not supported by istream interface
	vio_tell_func
};

OggVorbisDecoder::OggVorbisDecoder() {
	music_type = "ogg";
}

OggVorbisDecoder::~OggVorbisDecoder() {
	if (ovf) {
		ov_clear(ovf);
		delete ovf;
	}
}

bool OggVorbisDecoder::Open(Filesystem_Stream::InputStream stream) {
	finished = false;
	this->stream = std::move(stream);
	if (ovf) {
		ov_clear(ovf);
		delete ovf;
	}
	ovf = new OggVorbis_File;

	int res = ov_open_callbacks(&this->stream, ovf, nullptr, 0,vio);
	if (res < 0) {
		error_message = "OggVorbis: Error reading file";
		delete ovf;
		return false;
	}

	vorbis_info *vi = ov_info(ovf, -1);
	if (!vi) {
		error_message = "OggVorbis: Error getting file information";
		ov_clear(ovf);
		delete ovf;
		return false;
	}

	frequency = vi->rate;
	channels = vi->channels;

	vorbis_comment* vc = ov_comment(ovf, -1);
	if (vc) {
		// RPG VX loop support
		// Workaround conversion of string constant to char warning because
		// of tremor using a different signature.
#if defined(HAVE_TREMOR)
		using char_type = char*;
#else
		using char_type = const char*;
#endif

		const char* str = vorbis_comment_query(vc, (char_type)"LOOPSTART", 0);
		if (str) {
			auto total = ov_pcm_total(ovf, -1) ;
			loop.start = std::min<int64_t>(atoi(str), total);
			if (loop.start >= 0) {
				loop.looping = true;
				loop.end = total;
				str = vorbis_comment_query(vc, (char_type)"LOOPLENGTH", 0);
				if (str) {
					int len = atoi(str);
					if (len >= 0) {
						loop.end = std::min<int64_t>(loop.start + len, total);
					}
				} else {
					str = vorbis_comment_query(vc, (char_type)"LOOPEND", 0);
					if (str) {
						int end = atoi(str);
						if (end >= 0) {
							loop.end = Utils::Clamp<int64_t>(end, loop.start, total);
						}
					}
				}

				if (loop.start == total) {
					loop.end = total;
				}
			}
		}
	}

	if (!loop.looping) {
		loop.start = 0;
		loop.end = -1;
	}

	return true;
}

bool OggVorbisDecoder::Seek(std::streamoff offset, std::ios_base::seekdir origin) {
	if (offset == 0 && origin == std::ios_base::beg) {
		finished = false;

		if (ovf) {
			// Seeks to 0 when not looping
			ov_pcm_seek(ovf, loop.start);
		}

		if (loop.looping && loop.start == loop.end) {
			loop.to_end = true;
		}

		return true;
	}

	return false;
}

bool OggVorbisDecoder::IsFinished() const {
	if (!ovf) {
		return false;
	}

	if (loop.to_end) {
		return false;
	}

	return finished;
}

void OggVorbisDecoder::GetFormat(int& freq, AudioDecoder::Format& format, int& chans) const {
	freq = frequency;
	format = Format::S16;
	chans = channels;
}

bool OggVorbisDecoder::SetFormat(int freq, AudioDecoder::Format format, int chans) {
	if (freq != frequency || chans != channels || format != Format::S16)
		return false;

	return true;
}

int OggVorbisDecoder::GetTicks() const {
	if (!ovf) {
		return 0;
	}

	return (int)ov_time_tell(ovf);
}

int OggVorbisDecoder::FillBuffer(uint8_t* buffer, int length) {
	if (!ovf)
		return -1;

	if (loop.to_end) {
		memset(buffer, '\0', length);
		return length;
	}

	static int section;
	int read = 0;
	int to_read = length;

	do {
#ifdef HAVE_TREMOR
		read = ov_read(ovf, reinterpret_cast<char*>(buffer + length - to_read), to_read, &section);
#else
#  if defined(__WIIU__)
		// FIXME: This is the endianess of the audio and not of the host but the byteswapping in ov_read does
		// not sound like it works
		int byte_order = 1; // BE
#  else
		int byte_order = 0; // LE
#endif
		read = ov_read(ovf, reinterpret_cast<char*>(buffer + length - to_read), to_read, byte_order, 2/*16bit*/, 1/*signed*/, &section);
#endif
		// stop decoding when error or end of file
		if (read <= 0)
			break;

		// stop when loop end is reached
		if (loop.looping) {
			auto pos = ov_pcm_tell(ovf);
			if (pos >= loop.end) {
				finished = true;
				break;
			}
		}

		to_read -= read;
	} while(to_read > 0);

	// end of file
	if (read == 0)
		finished = true;

	// error
	if (read < 0)
		return -1;

	return length - to_read;
}

#endif


/*end of file .\decoder_oggvorbis.cpp*/

/*start of file .\decoder_opus.cpp*/

/* ... license chunk ... */

#include "system.h"

#ifdef HAVE_OPUS

#include <cstring>
#include <opus/opusfile.h>
#include "audio_decoder.h"
#include "decoder_opus.h"

static int vio_read_func(void* stream, unsigned char* ptr, int nbytes) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(stream);
	if (nbytes == 0) return 0;
	return (int)(f->read(reinterpret_cast<char*>(ptr), nbytes).gcount());
}

static int vio_seek_func(void* stream, opus_int64 offset, int whence) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(stream);
	if (f->eof()) f->clear(); // emulate behaviour of fseek

	f->seekg(offset, Filesystem_Stream::CSeekdirToCppSeekdir(whence));

	return 0;
}

static opus_int64 vio_tell_func(void* stream) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(stream);
	return static_cast<opus_int64>(f->tellg());
}

static OpusFileCallbacks vio = {
		vio_read_func,
		vio_seek_func,
		vio_tell_func,
		nullptr // close not supported by istream interface
};

OpusAudioDecoder::OpusAudioDecoder() {
	music_type = "opus";
}

OpusAudioDecoder::~OpusAudioDecoder() {
	if (oof) {
		op_free(oof);
	}
}

bool OpusAudioDecoder::Open(Filesystem_Stream::InputStream stream) {
	this->stream = std::move(stream);
	finished = false;

	int res;

	oof = op_open_callbacks(&this->stream, &vio, nullptr, 0, &res);
	if (res != 0) {
		error_message = "Opus: Error reading file";
		op_free(oof);
		return false;
	}

	const OpusTags* ot = op_tags(oof, -1);
	if (ot) {
		// RPG VX loop support
		const char* str = opus_tags_query(ot, "LOOPSTART", 0);
		if (str) {
			auto total = op_pcm_total(oof, -1) ;
			loop.start = std::min<int64_t>(atoi(str), total);
			if (loop.start >= 0) {
				loop.looping = true;
				loop.end = total;
				str = opus_tags_query(ot, "LOOPLENGTH", 0);
				if (str) {
					int len = atoi(str);
					if (len >= 0) {
						loop.end = std::min<int64_t>(loop.start + len, total);
					}
				} else {
					str = opus_tags_query(ot, "LOOPEND", 0);
					if (str) {
						int end = atoi(str);
						if (end >= 0) {
							loop.end = Utils::Clamp<int64_t>(end, loop.start, total);
						}
					}
				}

				if (loop.start == total) {
					loop.end = total;
				}
			}
		}
	}

	if (!loop.looping) {
		loop.start = 0;
		loop.end = -1;
	}

	return true;
}

bool OpusAudioDecoder::Seek(std::streamoff offset, std::ios_base::seekdir origin) {
	if (offset == 0 && origin == std::ios::beg) {
		finished = false;

		if (oof) {
			// Seeks to 0 when not looping
			op_pcm_seek(oof, loop.start);
		}

		if (loop.looping && loop.start == loop.end) {
			loop.to_end = true;
		}

		return true;
	}

	return false;
}

bool OpusAudioDecoder::IsFinished() const {
	if (!oof) {
		return false;
	}

	if (loop.to_end) {
		return false;
	}

	return finished;
}

void OpusAudioDecoder::GetFormat(int& freq, AudioDecoder::Format& format, int& chans) const {
	freq = frequency;
	format = Format::S16;
	chans = channels;
}

bool OpusAudioDecoder::SetFormat(int freq, AudioDecoder::Format format, int chans) {
	if (freq != frequency || chans != channels || format != Format::S16)
		return false;

	return true;
}

int OpusAudioDecoder::GetTicks() const {
	if (!oof) {
		return 0;
	}

	// According to the docs it is number of samples at 48 kHz
	return op_pcm_tell(oof) / 48000;
}

int OpusAudioDecoder::FillBuffer(uint8_t* buffer, int length) {
	if (!oof)
		return -1;

	if (loop.to_end) {
		memset(buffer, '\0', length);
		return length;
	}

	// op_read_stereo doesn't overwrite the buffer completely, must be cleared to prevent noise
	memset(buffer, '\0', length);

	// Use a 16bit buffer because op_read_stereo works on one
	int length_16 = length / 2;
	opus_int16* buffer_16 = reinterpret_cast<opus_int16*>(buffer);

	int read = 0;
	int to_read = length_16;

	do {
		read = op_read_stereo(oof, buffer_16 + (length_16 - to_read), to_read);

		// stop decoding when error or end of file
		if (read <= 0)
			break;

		// stop when loop end is reached
		if (loop.looping) {
			auto pos = op_pcm_tell(oof);
			if (pos >= loop.end) {
				finished = true;
				break;
			}
		}

		// "read" contains number of samples per channel and the function filled 2 channels
		to_read -= read * 2;
	} while (to_read > 0);

	if (read == 0)
		finished = true;

	if (read < 0) {
		return -1;
	}

	// Return amount of read bytes in the 8 bit what the audio decoder expects
	return (length_16 - to_read) * 2;
}

#endif


/*end of file .\decoder_opus.cpp*/

/*start of file .\decoder_wildmidi.cpp*/

/* ... license chunk ... */

#include "system.h"

#ifdef HAVE_LIBWILDMIDI

// Headers
#include <cassert>
#include <stdlib.h>
#include <wildmidi_lib.h>
#include "audio_decoder.h"
#include "output.h"
#include "filefinder.h"
#include "utils.h"
#include "decoder_wildmidi.h"

#ifdef USE_LIBRETRO
#  include "platform/libretro/ui.h"
#endif

/* possible options include: WM_MO_REVERB|WM_MO_ENHANCED_RESAMPLING
 * however, they cause high cpu usage, so not using them for now.
 */
#define WILDMIDI_OPTS 0

namespace {
	bool once = false;
	bool init = false;
}

static void WildMidiDecoder_deinit() {
	if (init) {
		WildMidi_Shutdown();
		init = false;
	}
}

#if LIBWILDMIDI_VERSION >= 1027 // at least 0.4.3
static void* vio_allocate_file_func(const char* filename, uint32_t* size) {
	auto stream = FileFinder::Root().OpenInputStream(filename);
	if (!stream) {
		Output::Warning("WildMidi: vio_allocate_file_func failed for {}", filename);
		return nullptr;
	}

	auto buf = Utils::ReadStream(stream);

	*size = static_cast<uint32_t>(buf.size());

	// Make buffer one byte larger, otherwise MSVC CRT detects a Heap Corruption (Wildmidi bug?)
	char* buffer = reinterpret_cast<char*>(malloc(*size + 1));
	memcpy(buffer, buf.data(), buf.size());

	return buffer;
}

static void vio_free_file_func(void* buffer) {
	free(buffer);
}

static struct _WM_VIO vio = {
	vio_allocate_file_func,
	vio_free_file_func
};
#endif

WildMidiDecoder::~WildMidiDecoder() {
	if (handle)
		WildMidi_Close(handle);
}

bool WildMidiDecoder::Initialize(std::string& status_message) {
	std::string config_file;
	bool found = false;

	// only initialize once until a new game starts
	if (once)
		return init;
	once = true;

	/* find the configuration file in different paths on different platforms
	 * FIXME: move this logic into some configuration class
	 */
#if defined(USE_LIBRETRO)
	const char *dir = NULL;

	// Game directory
	if (LibretroUi::environ_cb(RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY, &dir) && dir) {
		config_file = std::string(dir) + "/wildmidi.cfg";
		found = FileFinder::Root().Exists(config_file);
	}

	// Content downloader
	if (!found) {
		if (LibretroUi::environ_cb(RETRO_ENVIRONMENT_GET_CORE_ASSETS_DIRECTORY, &dir) && dir) {
			config_file = std::string(dir) + "/wildmidi/wildmidi.cfg";
			found = FileFinder::Root().Exists(config_file);
		}
	}
#elif defined(__wii__)
	// preferred under /data
	config_file = "usb:/data/wildmidi/wildmidi.cfg";
	found = FileFinder::Root().Exists(config_file);
	if (!found) {
		config_file = "sd:/data/wildmidi/wildmidi.cfg";
		found = FileFinder::Root().Exists(config_file);
	}

	// app directory
	if (!found) {
		config_file = "wildmidi.cfg";
		found = FileFinder::Root().Exists(config_file);
	}

	// same, but legacy from SDL_mixer's timidity
	if (!found) {
		config_file = "usb:/data/timidity/timidity.cfg";
		found = FileFinder::Root().Exists(config_file);
	}
	if (!found) {
		config_file = "sd:/data/timidity/timidity.cfg";
		found = FileFinder::Root().Exists(config_file);
	}
	if (!found) {
		config_file = "timidity.cfg";
		found = FileFinder::Root().Exists(config_file);
	}
#elif defined(__WIIU__)
	// preferred SD card directory
	config_file = "fs:/vol/external01/wiiu/data/easyrpg-player/wildmidi.cfg";
	found = FileFinder::Root().Exists(config_file);

	// shipped
	if (!found) {
		config_file = "fs:/vol/content/wildmidi.cfg";
		found = FileFinder::Root().Exists(config_file);
	}
	// Current directory
	if (!found) {
		config_file = "wildmidi.cfg";
		found = FileFinder::Root().Exists(config_file);
	}
#elif defined(__3DS__)
	// Only wildmidi paths, no timidity because there was never timidity used on 3DS

	// Shipped in a romfs (for CIA and newer 3dsx files)
	config_file = "romfs:/wildmidi.cfg";
	found = FileFinder::Root().Exists(config_file);

	// preferred SD card directory
	if (!found) {
		config_file = "sdmc:/3ds/easyrpg-player/wildmidi.cfg";
		found = FileFinder::Root().Exists(config_file);
	}

	// Current directory
	if (!found) {
		config_file = "wildmidi.cfg";
		found = FileFinder::Root().Exists(config_file);
	}
#elif defined(__SWITCH__)
	// Only wildmidi paths, no timidity because it was never used on Switch
	config_file = "./wildmidi.cfg";
	found = FileFinder::Root().Exists(config_file);
	if (!found) {
		config_file = "/switch/easyrpg-player/wildmidi.cfg";
		found = FileFinder::Root().Exists(config_file);
	}
#elif defined(__vita__)
	// Only wildmidi paths, no timidity because it was never used on PSVita

	// Shipped
	config_file = "app0:/wildmidi.cfg";
	found = FileFinder::Root().Exists(config_file);

	// Preferred global directory
	if (!found) {
		config_file = "ux0:/data/easyrpg-player/wildmidi.cfg";
		found = FileFinder::Root().Exists(config_file);
	}

	// Current directory
	if (!found) {
		config_file = "wildmidi.cfg";
		found = FileFinder::Root().Exists(config_file);
	}
#elif defined(__MORPHOS__)
	// Shipped with library
	config_file = "LIBS:timidity/timidity.cfg";
	found = FileFinder::Root().Exists(config_file);

	// Current directory
	if (!found) {
		config_file = "wildmidi.cfg";
		found = FileFinder::Root().Exists(config_file);
	}
#else
	// Prefer wildmidi in current directory
	config_file = "wildmidi.cfg";
	found = FileFinder::Root().Exists(config_file);

	// wildmidi command line player default config
	if (!found) {
		config_file = "/etc/wildmidi/wildmidi.cfg";
		found = FileFinder::Root().Exists(config_file);
	}

	// Use Timidity strategy used in SDL mixer

	// Environment variable
	if (!found) {
		const char *env = getenv("TIMIDITY_CFG");
		if (env) {
			config_file = env;
			found = FileFinder::Root().Exists(config_file);
		}
	}

	if (!found) {
		config_file = "timidity.cfg";
		found = FileFinder::Root().Exists(config_file);
	}

#  ifdef _WIN32
	// Probably not too useful
	if (!found) {
		config_file = "C:\\TIMIDITY\\timidity.cfg";
		found = FileFinder::Root().Exists(config_file);
	}

	// TODO: We need some installer which creates registry keys for wildmidi

#  elif defined(PLAYER_AMIGA)
	if (!found) {
		config_file = "timidity/timidity.cfg";
		found = FileFinder::Root().Exists(config_file);
	}
#  else
	if (!found) {
		config_file = "/etc/timidity.cfg";
		found = FileFinder::Root().Exists(config_file);
	}

	if (!found) {
		// Folders used in timidity code
		const std::vector<std::string> folders = {
				"/etc/timidity",
				"/usr/share/timidity",
				"/usr/local/share/timidity",
				"/usr/local/lib/timidity"
		};

		for (const std::string& s : folders) {
			config_file = s + "/timidity.cfg";
			found = FileFinder::Root().Exists(config_file);

			if (found) {
				break;
			}

			// Some distributions have it in timidity++
			config_file = s + "++/timidity.cfg";
			found = FileFinder::Root().Exists(config_file);

			if (found) {
				break;
			}
		}
	}
#  endif
#endif

	// bail, if nothing found
	if (!found) {
		status_message = "Could not find configuration file.";
		return false;
	}

	status_message = fmt::format("Using {} as configuration file...", config_file);

#if LIBWILDMIDI_VERSION >= 1027 // at least 0.4.3
	init = (WildMidi_InitVIO(&vio, config_file.c_str(), EP_MIDI_FREQ, WILDMIDI_OPTS) == 0);
#else
	init = (WildMidi_Init(config_file.c_str(), EP_MIDI_FREQ, WILDMIDI_OPTS) == 0);
#endif

	if (!init) {
		status_message = std::string("WildMidi_Init() failed: ") + WildMidi_GetError();
		return false;
	}

#if defined(PLAYER_AMIGA)
	// the default volume is way too quiet with the SDL_mixer patches
	WildMidi_MasterVolume(127);
#endif

	// setup deinitialization
	static bool atexit_once = false;
	if (!atexit_once) {
		atexit_once = true;
		atexit(WildMidiDecoder_deinit);
	}

	return true;
}

void WildMidiDecoder::ResetState() {
	once = false;
	WildMidiDecoder_deinit();
}

bool WildMidiDecoder::Open(std::vector<uint8_t>& data) {
	// this should not happen
	if (handle) {
		WildMidi_Close(handle);
		Output::Debug("WildMidi: Previous handle was not closed.");
	}

	handle = WildMidi_OpenBuffer(data.data(), data.size());

	return handle != nullptr;
}

bool WildMidiDecoder::Seek(std::streamoff offset, std::ios_base::seekdir origin) {
	if (origin == std::ios_base::beg) {
		if (handle) {
			unsigned long int pos = offset;
			WildMidi_FastSeek(handle, &pos);
		}
		return true;
	}

	return false;
}

int WildMidiDecoder::FillBuffer(uint8_t* buffer, int length) {
	if (!handle)
		return -1;

	return WildMidi_GetOutput(handle, reinterpret_cast<int8_t*>(buffer), length);
}

#endif


/*end of file .\decoder_wildmidi.cpp*/

/*start of file .\decoder_xmp.cpp*/

/* ... license chunk ... */

#include "system.h"

#ifdef HAVE_LIBXMP

// Headers
#include "xmp.h"
#include "audio_decoder.h"
#include "decoder_xmp.h"

static unsigned long xmp_vio_read_impl(void* ptr, unsigned long size, unsigned long count, void* userdata){
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);
	char* ptrc = reinterpret_cast<char*>(ptr);
	for (unsigned long i = 0; i < count; ++i) {
		f->read(reinterpret_cast<char*>(ptrc + i * size), size);
		if (f->gcount() != static_cast<std::streamsize>(size)) {
			return i;
		}
	}
	return count;
}

static int xmp_vio_seek_impl(void* userdata, long offset, int seek_type) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);
	if (f->eof()) f->clear(); //emulate behaviour of fseek

	f->seekg(offset, Filesystem_Stream::CSeekdirToCppSeekdir(seek_type));

	return 0;
}

static long xmp_vio_tell_impl(void* userdata){
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(userdata);
	return f->tellg();
}

struct xmp_callbacks vio = {
	xmp_vio_read_impl,
	xmp_vio_seek_impl,
	xmp_vio_tell_impl,
	nullptr
};

XMPDecoder::XMPDecoder() {
	music_type = "mod";

	ctx = xmp_create_context();
}

XMPDecoder::~XMPDecoder() {
	if (ctx) {
		xmp_end_player(ctx);
		xmp_release_module(ctx);
		xmp_free_context(ctx);
	}
}

bool XMPDecoder::Open(Filesystem_Stream::InputStream stream) {
	finished = false;

	if (!ctx)
		return false;

	int res = xmp_load_module_from_callbacks(ctx, &stream, vio);
	if (res != 0) {
		error_message = "XMP: Error loading file";
		return false;
	}

	xmp_start_player(ctx, frequency, 0);

	int player_interpolation = 0;
	int player_effects = 0;
#if defined(PSP) || defined(__3DS__) || defined(__wii__)
	// disable filtering and use low quality interpolation
	player_interpolation = XMP_INTERP_NEAREST;
#else
	player_interpolation = XMP_INTERP_SPLINE;
	player_effects = XMP_DSP_ALL;
#endif
	xmp_set_player(ctx, XMP_PLAYER_INTERP, player_interpolation);
	xmp_set_player(ctx, XMP_PLAYER_DSP, player_effects);

	return true;
}

bool XMPDecoder::Seek(std::streamoff offset, std::ios_base::seekdir origin) {
	if (!ctx)
		return false;

	if (offset == 0 && origin == std::ios_base::beg) {
		xmp_restart_module(ctx);
		finished = false;
		return true;
	}

	// TODO: maybe use xmp_set_position(ctx, int pos) or xmp_seek_time(ctx, int time)
	return false;
}

bool XMPDecoder::IsFinished() const {
	if (!ctx)
		return false;

	return finished;
}

void XMPDecoder::GetFormat(int& freq, AudioDecoder::Format& frmt, int& chans) const {
	freq = frequency;
	frmt = format;
	chans = channels;
}

bool XMPDecoder::SetFormat(int freq, AudioDecoder::Format frmt, int chans) {
	// shortcut
	if (chans == channels && frmt == format && freq == frequency)
		return true;

	// unsupported formats
	if (chans > 2 || frmt > Format::U16)
		return false;

	// restart the player, apply new format flags
	xmp_end_player(ctx);

	channels = chans;
	format = frmt;
	frequency = freq;

	int player_flags = 0;
	if (channels == 1)
		player_flags |= XMP_FORMAT_MONO;
	if (format == Format::U8 || format == Format::U16)
		player_flags |= XMP_FORMAT_UNSIGNED;
	if (format == Format::S8 || format == Format::U8)
		player_flags |= XMP_FORMAT_8BIT;

	return xmp_start_player(ctx, frequency, player_flags) == 0;
}

int XMPDecoder::GetTicks() const {
	if (!ctx) {
		return 0;
	}

	xmp_frame_info info;
	xmp_get_frame_info(ctx, &info);

	return info.time / 1000;
}

bool XMPDecoder::IsModule(Filesystem_Stream::InputStream& stream) {
	int res = xmp_test_module_from_callbacks(&stream, vio, nullptr);
	stream.clear();
	stream.seekg(0, std::ios_base::beg);
	return res == 0;
}

int XMPDecoder::FillBuffer(uint8_t* buffer, int length) {
	if (!ctx)
		return -1;

	/* FIXME: `xmp_play_buffer()` is a loop around `xmp_play_frame()` that may add
	 * silence at the end of the buffer, when there is not enough audio data left.
	 * We may need to use the latter directly, to have no gap between two loops.
	 */
	int ret = xmp_play_buffer(ctx, buffer, length, 1);

	// end of file
	if (ret == -XMP_END)
		finished = true;

	// error
	if (ret == -XMP_ERROR_STATE)
		return -1;

	return length;
}

#endif


/*end of file .\decoder_xmp.cpp*/

/*start of file .\directory_tree.cpp*/

/* ... license chunk ... */

#include "directory_tree.h"
#include "filefinder.h"
#include "filesystem.h"
#include "output.h"
#include "platform.h"
#include "player.h"
#include <lcf/reader_util.h>

//#define EP_DEBUG_DIRECTORYTREE
#ifdef EP_DEBUG_DIRECTORYTREE
template <typename... Args>
static void DebugLog(const char* fmt, Args&&... args) {
	Output::Debug(fmt, std::forward<Args>(args)...);
}
#else
template <typename... Args>
static void DebugLog(const char*, Args&&...) {}
#endif

namespace {
	std::string make_key(std::string_view n) {
		return lcf::ReaderUtil::Normalize(n);
	};
}

std::unique_ptr<DirectoryTree> DirectoryTree::Create() {
	return std::make_unique<DirectoryTree>();
}

std::unique_ptr<DirectoryTree> DirectoryTree::Create(Filesystem& fs) {
	std::unique_ptr<DirectoryTree> tree = std::make_unique<DirectoryTree>();
	tree->fs = &fs;

	return tree;
}

bool DirectoryTree::WildcardMatch(const std::string_view& pattern, const std::string_view& text) {
	// Limitations: * and ? cannot be mixed, * only at beginning and end of string
	// Pattern and text are already normalized
	if (pattern.empty() && text.empty()) {
		return true;
	}

	bool begin_wildcard = StartsWith(pattern, '*');
	bool end_wildcard = EndsWith(pattern, '*');

	if ((begin_wildcard || end_wildcard) && text.size() > 0) {
		// * handling
		bool found = false;
		if (begin_wildcard) {
			found |= EndsWith(text, pattern.substr(1));
		}
		if (end_wildcard) {
			found |= StartsWith(text, pattern.substr(0, pattern.size() - 1));
		}
		return found;
	} else {
		// ? handling
		if (pattern.length() != text.length()) {
			return false;
		}

		return std::equal(pattern.begin(), pattern.end(),
						text.begin(),
						[](char p, char t) {
							return p == '?' || p == t;
						});
	}
}

DirectoryTree::DirectoryListType* DirectoryTree::ListDirectory(std::string_view path) const {
	std::vector<Entry> entries;
	std::string fs_path = ToString(path);

	DebugLog("ListDirectory: {}", fs_path);

	auto dir_key = make_key(fs_path);

	auto dir_it = Find(dir_cache, dir_key);
	if (dir_it != dir_cache.end()) {
		// Already cached
		DebugLog("ListDirectory Cache Hit: {}", dir_key);
		auto file_it = Find(fs_cache, dir_key);
		assert(file_it != fs_cache.end());
		return &file_it->second;
	}

	auto dir_missing_it = std::find(dir_missing_cache.begin(), dir_missing_cache.end(), dir_key);
	if (dir_missing_it != dir_missing_cache.end()) {
		// Cached and known to be missing
		DebugLog("ListDirectory Cache Hit Dir Missing: {}", dir_key);
		return nullptr;
	}

	assert(Find(fs_cache, dir_key) == fs_cache.end());

	if (!fs->Exists(fs_path)) {
		std::string parent_dir, child_dir;
		std::tie(parent_dir, child_dir) = FileFinder::GetPathAndFilename(fs_path);

		if (parent_dir == fs_path) {
			// When the path stays we are in a non-existant root -> give up
			DebugLog("ListDirectory Bad root: {} | {}", fs_path, parent_dir);
			dir_missing_cache.push_back(make_key(parent_dir));
			return nullptr;
		}

		// Go up and determine the proper casing of the folder
		auto* parent_tree = ListDirectory(parent_dir);
		if (!parent_tree) {
			DebugLog("ListDirectory No parent: {} | {}", fs_path, parent_dir);
			dir_missing_cache.push_back(make_key(parent_dir));
			return nullptr;
		}

		auto parent_key = make_key(parent_dir);
		auto parent_it = Find(dir_cache, parent_key);
		assert(parent_it != dir_cache.end());

		auto child_key = make_key(child_dir);
		auto child_it = Find(*parent_tree, child_key);
		if (child_it != parent_tree->end()) {
			fs_path = FileFinder::MakePath(parent_it->second, child_it->second.name);
		} else {
			DebugLog("ListDirectory Child not in Parent: {} | {} | {}", fs_path, parent_dir, child_dir);
			dir_missing_cache.push_back(FileFinder::MakePath(parent_key, child_key));
			return nullptr;
		}
	}

	if (!fs->GetDirectoryContent(fs_path, entries)) {
		DebugLog("ListDirectory GetDirectoryContent Failed: {}", fs_path);
		dir_missing_cache.push_back(make_key(fs_path));
		return nullptr;
	}

	InsertSorted(dir_cache, dir_key, std::move(fs_path));

	DirectoryListType fs_cache_entry;

#ifdef EP_DEBUG_DIRECTORYTREE
	std::stringstream ss;
#endif

	for (auto& entry : entries) {
		std::string new_entry_key = make_key(entry.name);

		if (entry.type == FileType::Directory) {
			if (Find(fs_cache_entry, new_entry_key) != fs_cache_entry.end()) {
				Output::Warning("The folder \"{}\" exists twice.", entry.name);
				Output::Warning("This can lead to file not found errors. Merge the directories manually in a file browser.");
			}
		}
		fs_cache_entry.emplace_back(std::make_pair(std::move(new_entry_key), entry));

#ifdef EP_DEBUG_DIRECTORYTREE
		std::string t = entry.type == FileType::Regular ? "" :
				entry.type == FileType::Directory ? "(d)" : "(?)";
		ss << entry.name << t << ", ";
#endif
	}

	std::sort(fs_cache_entry.begin(), fs_cache_entry.end(), [](auto& left, auto& right) {
		return left.first < right.first;
	});

#ifdef EP_DEBUG_DIRECTORYTREE
	DebugLog("ListDirectory Content: {}", ss.str());
#endif

	InsertSorted(fs_cache, dir_key, std::move(fs_cache_entry));

	return &Find(fs_cache, dir_key)->second;
}

void DirectoryTree::ClearCache(std::string_view path) const {
	DebugLog("ClearCache: {}", path);

	if (path.empty()) {
		fs_cache.clear();
		dir_cache.clear();
		dir_missing_cache.clear();
		return;
	}

	auto dir_key = make_key(path);
	auto fs_it = Find(fs_cache, dir_key);
	if (fs_it != fs_cache.end()) {
		fs_cache.erase(fs_it);
	}
	auto dir_it = Find(dir_cache, dir_key);
	if (dir_it != dir_cache.end()) {
		dir_cache.erase(dir_it);
	}
	dir_missing_cache.erase(std::remove_if(dir_missing_cache.begin(), dir_missing_cache.end(), [&path] (const auto& dir) {
		return StartsWith(dir, path);
	}), dir_missing_cache.end());
}

std::string DirectoryTree::FindFile(std::string_view filename, const Span<const std::string_view> exts) const {
	return FindFile({ ToString(filename), exts });
}

std::string DirectoryTree::FindFile(std::string_view directory, std::string_view filename, const Span<const std::string_view> exts) const {
	return FindFile({ FileFinder::MakePath(directory, filename), exts });
}

std::string DirectoryTree::FindFile(const DirectoryTree::Args& args) const {
	std::string dir, name, canonical_path;
	// Few games (e.g. Yume2kki) use path traversal (..) in the filenames to point
	// to files outside of the actual directory.
	canonical_path = FileFinder::MakeCanonical(args.path, args.canonical_initial_deepness);

	std::tie(dir, name) = FileFinder::GetPathAndFilename(canonical_path);

	DebugLog("FindFile: {} | {} | {} | {}", args.path, canonical_path, dir, name);

	auto* entries = ListDirectory(dir);
	if (!entries) {
		if (args.file_not_found_warning) {
			Output::Debug("Cannot find: {}/{}", dir, name);
		}
		DebugLog("FindFile ListDirectory Failed: {} | {}", dir, name);
		return "";
	}

	std::string dir_key = make_key(dir);
	auto dir_it = Find(dir_cache, dir_key, args.process_wildcards);
	assert(dir_it != dir_cache.end());

	std::string name_key = make_key(name);
	if (args.exts.empty()) {
		auto entry_it = Find(*entries, name_key, args.process_wildcards);
		if (entry_it != entries->end() && entry_it->second.type == FileType::Regular) {
			auto full_path = FileFinder::MakePath(dir_it->second, entry_it->second.name);
			DebugLog("FindFile Found: {} | {} | {}", dir, name, full_path);
			return full_path;
		}
	} else {
		for (const auto& ext : args.exts) {
			auto full_name_key = name_key + ToString(ext);
			auto entry_it = Find(*entries, full_name_key, args.process_wildcards);
			if (entry_it != entries->end() && entry_it->second.type == FileType::Regular) {
				auto full_path = FileFinder::MakePath(dir_it->second, entry_it->second.name);
				DebugLog("FindFile Found: {} | {} | {}", dir, name, full_path);
				return full_path;
			}
		}
	}

	if (args.file_not_found_warning) {
		Output::Debug("Cannot find: {}/{}", dir, name);
	}
	DebugLog("FindFile Not Found: {} | {}", dir, name);

	return "";
}


/*end of file .\directory_tree.cpp*/

/*start of file .\drawable.cpp*/

/* ... license chunk ... */

#include "drawable.h"
#include <lcf/rpg/savepicture.h>
#include "drawable_mgr.h"

Drawable::~Drawable() {
	DrawableMgr::Remove(this);
}

void Drawable::SetZ(Z_t nz) {
	if (_z != nz) DrawableMgr::OnUpdateZ(this);
	_z = nz;
}

Drawable::Z_t Drawable::GetPriorityForMapLayer(int which) {
	Z_t layer = 0;

	switch (which) {
		case lcf::rpg::SavePicture::MapLayer_parallax:
			layer = Priority_Background;
			break;
		case lcf::rpg::SavePicture::MapLayer_tilemap_below:
			layer = Priority_TilesetBelow;
			break;
		case lcf::rpg::SavePicture::MapLayer_events_below:
			layer = Priority_EventsBelow;
			break;
		case lcf::rpg::SavePicture::MapLayer_events_same_as_player:
			layer = Priority_Player;
			break;
		case lcf::rpg::SavePicture::MapLayer_tilemap_above:
			layer = Priority_TilesetAbove;
			break;
		case lcf::rpg::SavePicture::MapLayer_events_above:
			layer = Priority_EventsFlying;
			break;
		case lcf::rpg::SavePicture::MapLayer_weather:
			layer = Priority_PictureNew;
			break;
		case lcf::rpg::SavePicture::MapLayer_animations:
			layer = Priority_BattleAnimation;
			break;
		case lcf::rpg::SavePicture::MapLayer_windows:
			layer = Priority_Window;
			break;
		case lcf::rpg::SavePicture::MapLayer_timers:
			layer = Priority_Timer;
			break;
		default:
			return layer;
	}

	return layer + (1ULL << z_offset);
}

Drawable::Z_t Drawable::GetPriorityForBattleLayer(int which) {
	Z_t layer = 0;

	switch (which) {
		case lcf::rpg::SavePicture::BattleLayer_background:
			layer = Priority_Background;
			break;
		case lcf::rpg::SavePicture::BattleLayer_battlers_and_animations:
			layer = Priority_Battler;
			break;
		case lcf::rpg::SavePicture::BattleLayer_weather:
			layer = Priority_PictureNew;
			break;
		case lcf::rpg::SavePicture::BattleLayer_windows_and_status:
			layer = Priority_Window;
			break;
		case lcf::rpg::SavePicture::BattleLayer_timers:
			layer = Priority_Timer;
			break;
		default:
			return layer;
	}

	return layer + (1ULL << z_offset);
}


/*end of file .\drawable.cpp*/

/*start of file .\drawable_list.cpp*/

/* ... license chunk ... */

// Headers
#include "drawable_list.h"
#include "drawable_mgr.h"
#include <algorithm>
#include <cassert>

static bool DrawCmp(Drawable* l, Drawable* r) {
	return l->GetZ() < r->GetZ();
}

DrawableList::~DrawableList() {
	if (DrawableMgr::GetLocalListPtr() == this) {
		DrawableMgr::SetLocalList(nullptr);
	}
}

void DrawableList::Clear() {
	_list.clear();
	SetClean();
}

bool DrawableList::IsSorted() const {
	return std::is_sorted(_list.begin(), _list.end(), DrawCmp);
}

void DrawableList::Sort() {
	// stable sort to work around a flickering event sprite issue when
	// the map is scrolling (have same Z value)
	std::stable_sort(_list.begin(), _list.end(), DrawCmp);
	SetClean();
}

void DrawableList::Append(Drawable* ptr) {
	assert(ptr != nullptr);
	assert(_list.end() == std::find(_list.begin(), _list.end(), ptr));

	const bool ordered = _list.empty() || !DrawCmp(ptr, _list.back());

	_list.push_back(ptr);

	if (!ordered) {
		SetDirty();
	}
}

Drawable* DrawableList::Take(Drawable* ptr) {
	auto iter = std::find(_list.begin(), _list.end(), ptr);
	if (iter == _list.end()) {
		return nullptr;
	}

	auto ret = *iter;
	// FIXME: Can we remove this O(N) operation here?
	_list.erase(iter);
	return ret;

	// Removing doesn't change sorted order, so not dirty flag.
}

void DrawableList::TakeFrom(DrawableList& other) noexcept {
	if (&other == this) { return; }

	auto& olist = other._list;

	if (olist.empty()) {
		return;
	}

	_list.insert(_list.end(), olist.begin(), olist.end());
	olist.clear();

	SetDirty();
	other.SetClean();
}

void DrawableList::Draw(Bitmap& dst, Drawable::Z_t min_z, Drawable::Z_t max_z) {
	if (IsDirty()) {
		Sort();
	} else {
		assert(IsSorted());
	}

	for (auto* drawable : _list) {
		auto z = drawable->GetZ();
		if (z < min_z) {
			continue;
		}
		if (z > max_z) {
			break;
		}
		if (drawable->IsVisible()) {
			drawable->Draw(dst);
		}
	}
}



/*end of file .\drawable_list.cpp*/

/*start of file .\drawable_mgr.cpp*/

/* ... license chunk ... */

// Headers
#include "drawable_mgr.h"

DrawableList* DrawableMgr::_local = nullptr;

void DrawableMgr::SetLocalList(DrawableList* list) {
	if (list) {
		// If a Drawable that is was attached to list changed it's Z value when list
		// was not set as the current local list, the wrong list would have been set as dirty.
		// To prevent this
		// Always ensure local list gets sorted. When the list was used externally
		// we have no guarantee that changes to it's contents keep it sorted.
		list->SetDirty();
	}

	_local = list;
}

void DrawableMgr::Register(Drawable* drawable) {
	GetLocalList().Append(drawable);
}

void DrawableMgr::Remove(Drawable* drawable) {
	auto* list = GetLocalListPtr();
	// Global drawables can be singletons, which may get destroyed after all scenes due
	// static initialization order. Non-global drawables we assume are all gone before
	// all lists are destroyed.
	assert(list || drawable->IsGlobal());
	if (list) {
		list->Take(drawable);
	}
}



/*end of file .\drawable_mgr.cpp*/

/*start of file .\dynrpg_easyrpg.cpp*/

/* ... license chunk ... */

// Headers
#include <map>

#include "dynrpg_easyrpg.h"
#include "main_data.h"
#include "game_variables.h"
#include "utils.h"
#include "version.h"

static bool EasyOput(dyn_arg_list args) {
	auto func = "output";
	bool okay = false;
	std::string mode;
	std::tie(mode, std::ignore) = DynRpg::ParseArgs<std::string, std::string>(func, args, &okay);
	if (!okay)
		return true;
	mode = Utils::LowerCase(mode);

	auto msg = DynRpg::ParseVarArg(func, args, 1, okay);

	if (mode == "debug") {
		Output::DebugStr(msg);
	} else if (mode == "info") {
		Output::InfoStr(msg);
	} else if (mode == "warning") {
		Output::WarningStr(msg);
	} else if (mode == "error") {
		Output::ErrorStr(msg);
	}

	return true;
}

bool DynRpg::EasyRpgPlugin::EasyCall(dyn_arg_list args, bool& do_yield, Game_Interpreter* interpreter) {
	auto func_name = std::get<0>(DynRpg::ParseArgs<std::string>("call", args));

	if (func_name.empty()) {
		// empty function name
		Output::Warning("call: Empty RPGSS function name");

		return true;
	}

	for (auto& plugin: instance.plugins) {
		if (plugin->Invoke(func_name, args.subspan(1), do_yield, interpreter)) {
			return true;
		}
	}

	return false;
}

static bool EasyAdd(dyn_arg_list args) {
	auto func = "easyrpg_add";
	bool okay = false;

	int target_var;
	int val;
	std::tie(target_var, val) = DynRpg::ParseArgs<int, int>(func, args, &okay);
	if (!okay)
		return true;

	for (size_t i = 2; i < args.size(); ++i) {
		val += std::get<0>(DynRpg::ParseArgs<int>(func, args.subspan(i), &okay));
		if (!okay)
			return true;
	}

	Main_Data::game_variables->Set(target_var, val);

	return true;
}

bool DynRpg::EasyRpgPlugin::Invoke(std::string_view func, dyn_arg_list args, bool& do_yield, Game_Interpreter* interpreter) {
	if (func == "call") {
		return EasyCall(args, do_yield, interpreter);
	} else if (func == "easyrpg_output") {
		return EasyOput(args);
	} else if (func == "easyrpg_add") {
		return EasyAdd(args);
	}
	return false;
}

void DynRpg::EasyRpgPlugin::Load(const std::vector<uint8_t>& buffer) {
	if (buffer.size() < 4) {
		Output::Warning("EasyRpgPlugin: Bad savegame data");
	} else {
		uint32_t ver;
		memcpy(&ver, buffer.data(), 4);
		Utils::SwapByteOrder(ver);
		Output::Debug("DynRpg Savegame version {}", ver);
	}
}

std::vector<uint8_t> DynRpg::EasyRpgPlugin::Save() {
	std::vector<uint8_t> save_data;
	save_data.resize(4);

	uint32_t version = PLAYER_SAVEGAME_VERSION;
	Utils::SwapByteOrder(version);
	memcpy(&save_data[0], reinterpret_cast<char*>(&version), 4);

	return save_data;
}


/*end of file .\dynrpg_easyrpg.cpp*/

/*start of file .\dynrpg_textplugin.cpp*/

/* ... license chunk ... */

// Headers
#include <map>
#include <memory>
#include <lcf/reader_util.h>

#include "dynrpg_textplugin.h"
#include "baseui.h"
#include "bitmap.h"
#include "drawable.h"
#include "drawable_mgr.h"
#include "game_map.h"
#include "game_message.h"
#include "game_pictures.h"
#include "game_variables.h"
#include "main_data.h"
#include "pending_message.h"
#include "text.h"

class DynRpgText;

namespace {
	std::map<std::string, std::unique_ptr<DynRpgText>> graphics;
}

class DynRpgText : public Drawable {
public:
	DynRpgText(int pic_id, int x, int y, const std::string& text) : Drawable(0), pic_id(pic_id), x(x), y(y) {
		DrawableMgr::Register(this);

		AddLine(text);
	}

	DynRpgText(int pic_id, int x, int y, const std::vector<std::string>& text) : Drawable(0), pic_id(pic_id), x(x), y(y) {
		DrawableMgr::Register(this);

		for (auto& s : text) {
			AddLine(s);
		}
	}

	void AddLine(const std::string& text) {
		texts.push_back(text);

		Refresh();
	}

	void AddText(const std::string& text) {
		if (texts.empty()) {
			texts.push_back(text);
		} else {
			texts.back() += text;
		}

		Refresh();
	}

	void ClearText() {
		texts.clear();

		Refresh();
	}

	void SetPosition(int new_x, int new_y) {
		x = new_x;
		y = new_y;
	}

	void SetColor(int new_color) {
		color = new_color;

		Refresh();
	}

	void SetPictureId(int new_pic_id) {
		pic_id = new_pic_id;

		const Game_Pictures::Picture* pic = Main_Data::game_pictures->GetPicturePtr(pic_id);
		if (!pic) {
			return;
		}
		const Sprite_Picture* sprite = pic->sprite.get();
		if (!sprite) {
			return;
		}

		SetZ(sprite->GetZ() + 1);
	}

	void SetFixed(bool fixed) {
		this->fixed = fixed;
	}

	void Draw(Bitmap& dst) override {
		if (!bitmap) {
			return;
		}

		const Game_Pictures::Picture* pic = Main_Data::game_pictures->GetPicturePtr(pic_id);
		if (!pic) {
			return;
		}
		const Sprite_Picture* sprite = pic->sprite.get();
		if (!sprite) {
			return;
		}

		// For unknown reasons the official plugin has an y-offset of 2
		if (fixed) {
			dst.Blit(x - Game_Map::GetDisplayX() / 16, y - Game_Map::GetDisplayY() / 16 + 2, *bitmap, bitmap->GetRect(), sprite->GetOpacity());
		} else {
			dst.Blit(x, y + 2, *bitmap, bitmap->GetRect(), sprite->GetOpacity());
		}
	};

	void Update() {
		if (GetZ() == 0) {
			SetPictureId(pic_id);
		}
	}

	std::vector<uint8_t> Save(const std::string& id) {
		std::stringstream ss;
		ss << x << "," << y << ",";
		for (int i = 0; i < static_cast<int>(texts.size()); ++i) {
			std::string t = texts[i];
			// Replace , with a sentinel 0x01 to not mess up the tokenizer
			std::replace(t.begin(), t.end(), ',', '\1');
			ss << t;
			if (i < static_cast<int>(texts.size()) - 1) {
				ss << "\n";
			}

		}
		ss << "," << color << "," << id;

		ss << "," << 255 << "," << (fixed ? "1" : "0") << "," << pic_id;

		std::vector<uint8_t> data;

		std::string s = ss.str();
		size_t slen = s.size();

		data.resize(slen);
		data.insert(data.end(), s.begin(), s.end());

		return data;
	}

	static DynRpgText* GetTextHandle(const std::string& id, bool silent = false) {
		PendingMessage pm(CommandCodeInserter);
		pm.PushLine(id);
		std::string new_id = pm.GetLines().front();

		auto it = graphics.find(new_id);
		if (it == graphics.end()) {
			if (!silent) {
				Output::Warning("No text with ID %s found", new_id.c_str());
			}
			return nullptr;
		}

		return (*it).second.get();
	}

	static std::optional<std::string> CommandCodeInserter(char ch, const char** iter, const char* end, uint32_t escape_char) {
		if (ch == 'I' || ch == 'i') {
			auto parse_ret = Game_Message::ParseParam('I', 'i', *iter, end, escape_char, true);
			*iter = parse_ret.next;
			int value = parse_ret.value;
			const auto* item = lcf::ReaderUtil::GetElement(lcf::Data::items, value);
			if (!item) {
				Output::Warning("Invalid Item Id {} in DynTextPlugin text", value);
				return "";
			} else{
				return ToString(ch == 'i' ? item->name : item->description);
			}
		} else if (ch == 'T' || ch == 't') {
			auto parse_ret = Game_Message::ParseParam('T', 't', *iter, end, escape_char, true);
			*iter = parse_ret.next;
			int value = parse_ret.value;
			const auto* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, value);
			if (!skill) {
				Output::Warning("Invalid Item Id {} in DynTextPlugin text", value);
				return "";
			} else{
				return ToString(ch == 't' ? skill->name : skill->description);
			}
		} else if (ch == 'x' || ch == 'X') {
			auto parse_ret = Game_Message::ParseStringParam('X', 'x', *iter, end, escape_char, true);
			*iter = parse_ret.next;
			std::string value = parse_ret.value;
			auto* handle = GetTextHandle(value);
			if (handle) {
				return handle->texts[0];
			} else {
				return "";
			}
		}

		return PendingMessage::DefaultCommandInserter(ch, iter, end, escape_char);
	}

private:
	void Refresh() {
		if (texts.empty()) {
			bitmap.reset();
			return;
		}

		int width = 0;
		int height = 0;

		const FontRef& font = Font::Default();

		for (auto& t : texts) {
			PendingMessage pm(CommandCodeInserter);
			pm.PushLine(t);
			t = pm.GetLines().front();

			Rect r = Text::GetSize(*font, t);
			width = std::max(width, r.width);
			height += r.height + 2;
		}

		bitmap = Bitmap::Create(width, height, true);

		height = 0;
		for (auto& t : texts) {
			bitmap->TextDraw(0, height, color, t);
			height += Text::GetSize(*font, t).height + 2;
		}

		SetPictureId(pic_id);
	}

	std::vector<std::string> texts;
	BitmapRef bitmap;
	int pic_id = 1;
	int x = 0;
	int y = 0;
	int color = 0;
	bool fixed = false;
};

static bool WriteText(dyn_arg_list args) {
	auto func = "write_text";
	bool okay;
	std::string id, text;
	int x, y;

	std::tie(id, x, y, text) = DynRpg::ParseArgs<std::string, int, int, std::string>(func, args, &okay);
	if (!okay)
		return true;

	PendingMessage pm(DynRpgText::CommandCodeInserter);
	pm.PushLine(id);
	std::string new_id = pm.GetLines().front();
	graphics[new_id] = std::make_unique<DynRpgText>(1, x, y, text);

	if (args.size() > 4) {
		std::string fixed = std::get<0>(DynRpg::ParseArgs<std::string>(func, args.subspan(4), &okay));
		if (!okay)
			return true;
		graphics[new_id]->SetFixed(fixed == "fixed");
	}

	if (args.size() > 5) {
		int color = std::get<0>(DynRpg::ParseArgs<int>(func, args.subspan(5), &okay));
		if (!okay)
			return true;
		graphics[new_id]->SetColor(color);
	}

	if (args.size() > 6) {
		int pic_id = std::get<0>(DynRpg::ParseArgs<int>(func, args.subspan(6), &okay));
		if (!okay)
			return true;
		graphics[new_id]->SetPictureId(pic_id);
	}

	return true;
}

static bool AppendLine(dyn_arg_list args) {
	auto func = "append_line";
	bool okay;
	std::string id, text;

	std::tie(id, text) = DynRpg::ParseArgs<std::string, std::string>(func, args, &okay);
	if (!okay)
		return true;

	DynRpgText* handle = DynRpgText::GetTextHandle(id);
	if (!handle) {
		return true;
	}

	handle->AddLine(text);
	return true;
}

static bool AppendText(dyn_arg_list args) {
	auto func = "append_line";
	bool okay;
	std::string id, text;

	std::tie(id, text) = DynRpg::ParseArgs<std::string, std::string>(func, args, &okay);
	if (!okay)
		return true;

	DynRpgText* handle = DynRpgText::GetTextHandle(id);
	if (!handle) {
		return true;
	}

	handle->AddText(text);
	return true;
}

static bool ChangeText(dyn_arg_list args) {
	auto func = "change_text";
	bool okay;
	std::string id, text, color;

	// Color can be a string (usually "end") or a number
	std::tie(id, text, color) = DynRpg::ParseArgs<std::string, std::string, std::string>(func, args, &okay);
	if (!okay)
		return true;

	DynRpgText* handle = DynRpgText::GetTextHandle(id);
	if (!handle) {
		return true;
	}

	handle->ClearText();
	if (color != "end") {
		handle->SetColor(atoi(color.c_str()));
	}
	handle->AddText(text);
	return true;
}

static bool ChangePosition(dyn_arg_list args) {
	auto func = "change_position";
	bool okay;
	std::string id;
	int x, y;

	std::tie(id, x, y) = DynRpg::ParseArgs<std::string, int, int>(func, args, &okay);
	if (!okay)
		return true;

	DynRpgText* handle = DynRpgText::GetTextHandle(id);
	if (!handle) {
		return true;
	}

	handle->SetPosition(x, y);
	return true;
}

static bool RemoveText(dyn_arg_list args) {
	auto func = "remove_text";
	bool okay;
	std::string id;

	std::tie(id) = DynRpg::ParseArgs<std::string>(func, args, &okay);
	if (!okay)
		return true;

	DynRpgText* handle = DynRpgText::GetTextHandle(id, true);
	if (!handle) {
		return true;
	}

	handle->ClearText();
	return true;
}

static bool RemoveAll(dyn_arg_list) {
	graphics.clear();
	return true;
}

bool DynRpg::TextPlugin::Invoke(std::string_view func, dyn_arg_list args, bool&, Game_Interpreter*) {
	if (func == "write_text") {
		return WriteText(args);
	} else if (func == "append_line") {
		return AppendLine(args);
	} else if (func == "append_text") {
		return AppendText(args);
	} else if (func == "change_text") {
		return ChangeText(args);
	} else if (func == "change_position") {
		return ChangePosition(args);
	} else if (func == "remove_text") {
		return RemoveText(args);
	} else if (func == "remove_all") {
		return RemoveAll(args);
	}
	return false;
}

void DynRpg::TextPlugin::Update() {
	for (auto& g : graphics) {
		g.second->Update();
	}
}

DynRpg::TextPlugin::~TextPlugin() {
	graphics.clear();
}

void DynRpg::TextPlugin::Load(const std::vector<uint8_t>& in_buffer) {
	size_t counter = 0;

	std::string str((char*)in_buffer.data(), in_buffer.size());

	std::vector<std::string> tokens = Utils::Tokenize(str, [&] (char32_t c) { return c == ','; });

	int x = 0;
	int y = 0;
	std::vector<std::string> texts;
	int color = 0;
	std::string id = "";
	bool fixed = false;
	int pic_id = 1;

	for (auto& t : tokens) {
		switch (counter) {
			case 0:
				x = atoi(t.c_str());
				break;
			case 1:
				y = atoi(t.c_str());
				break;
			case 2:
			{
				// Replace sentinel \1 with ,
				std::replace(t.begin(), t.end(), '\1', ',');

				texts = Utils::Tokenize(t, [&] (char32_t c) { return c == '\n'; });
			}
				break;
			case 3:
				color = atoi(t.c_str());
				break;
			case 4:
				// ignore transparency, the picture defines this
				break;
			case 5:
				fixed = t == "1";
				break;
			case 6:
				pic_id = atoi(t.c_str());
				break;
			case 7:
				id = t.c_str();
				break;
			default:
				break;
		}

		++counter;

		if (counter == 8) {
			counter = 0;

			graphics[id] = std::make_unique<DynRpgText>(pic_id, x, y, texts);
			texts.clear();
			graphics[id]->SetColor(color);
			graphics[id]->SetFixed(fixed);
		}
	}
}

std::vector<uint8_t> DynRpg::TextPlugin::Save() {
	std::vector<uint8_t> save_data;
	std::stringstream ss;

	for (auto& g : graphics) {
		std::vector<uint8_t> res = g.second->Save(g.first);
		save_data.reserve(save_data.size() + res.size() + 1);
		save_data.insert(save_data.end(), res.begin(), res.end());

		save_data.push_back(',');
	}
	save_data.pop_back();

	return DynRpgPlugin::Save();
}


/*end of file .\dynrpg_textplugin.cpp*/

/*start of file .\enemyai.cpp*/

/* ... license chunk ... */
#include "enemyai.h"
#include "game_actor.h"
#include "game_enemy.h"
#include "game_enemyparty.h"
#include "game_party.h"
#include "game_switches.h"
#include "game_battlealgorithm.h"
#include "game_battle.h"
#include "algo.h"
#include "player.h"
#include "output.h"
#include "rand.h"
#include <lcf/reader_util.h>
#include <lcf/data.h>

namespace EnemyAi {

#ifdef EP_DEBUG_ENEMYAI
template <typename... Args>
static void DebugLog(const char* fmt, Args&&... args) {
	Output::Debug(fmt, std::forward<Args>(args)...);
}
#else
template <typename... Args>
static void DebugLog(const char*, Args&&...) {}
#endif

static std::shared_ptr<Game_BattleAlgorithm::AlgorithmBase> MakeAttack(Game_Enemy& enemy, int hits) {
	return std::make_shared<Game_BattleAlgorithm::Normal>(&enemy, Main_Data::game_party->GetRandomActiveBattler(), hits);
}

static std::shared_ptr<Game_BattleAlgorithm::AlgorithmBase> MakeAttackAllies(Game_Enemy& enemy, int hits) {
	return std::make_shared<Game_BattleAlgorithm::Normal>(&enemy, Main_Data::game_enemyparty->GetRandomActiveBattler(), hits);
}


std::unique_ptr<AlgorithmBase> CreateAlgorithm(std::string_view name) {
	if (Utils::StrICmp(name, RpgRtImproved::name) == 0) {
		return std::make_unique<RpgRtImproved>();
	}
	if (Utils::StrICmp(name, RpgRtCompat::name) != 0) {
		static bool warned = false;
		if (!warned) {
			Output::Debug("Invalid AutoBattle algo name `{}' falling back to {} ...", name, RpgRtCompat::name);
			warned = true;
		}
	}
	return std::make_unique<RpgRtCompat>();
}

void AlgorithmBase::SetEnemyAiAction(Game_Enemy& source) {
	vSetEnemyAiAction(source);
	if (source.GetBattleAlgorithm() == nullptr) {
		source.SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::None>(&source));
	}
}

void RpgRtCompat::vSetEnemyAiAction(Game_Enemy& source) {
	SelectEnemyAiActionRpgRtCompat(source, true);
}

void RpgRtImproved::vSetEnemyAiAction(Game_Enemy& source) {
	SelectEnemyAiActionRpgRtCompat(source, false);
}

static std::shared_ptr<Game_BattleAlgorithm::AlgorithmBase> MakeBasicAction(Game_Enemy& enemy, const lcf::rpg::EnemyAction& action) {
	switch (action.basic) {
		case lcf::rpg::EnemyAction::Basic_attack:
			return MakeAttack(enemy, 1);
		case lcf::rpg::EnemyAction::Basic_dual_attack:
			return MakeAttack(enemy, 2);
		case lcf::rpg::EnemyAction::Basic_defense:
			return std::make_shared<Game_BattleAlgorithm::Defend>(&enemy);
		case lcf::rpg::EnemyAction::Basic_observe:
			return std::make_shared<Game_BattleAlgorithm::Observe>(&enemy);
		case lcf::rpg::EnemyAction::Basic_charge:
			return std::make_shared<Game_BattleAlgorithm::Charge>(&enemy);
		case lcf::rpg::EnemyAction::Basic_autodestruction:
			return std::make_shared<Game_BattleAlgorithm::SelfDestruct>(&enemy, Main_Data::game_party.get());
		case lcf::rpg::EnemyAction::Basic_escape:
			return std::make_shared<Game_BattleAlgorithm::Escape>(&enemy);
		case lcf::rpg::EnemyAction::Basic_nothing:
			return std::make_shared<Game_BattleAlgorithm::DoNothing>(&enemy);
	}
	return nullptr;
}

static Game_Battler* GetRandomSkillTarget(Game_Party_Base& party, const lcf::rpg::Skill& skill, bool emulate_bugs) {
	std::vector<Game_Battler*> battlers;
	party.GetBattlers(battlers);
	for (auto iter = battlers.begin(); iter != battlers.end();) {
		if (IsSkillEffectiveOn(skill, **iter, emulate_bugs)) {
			++iter;
		} else {
			iter = battlers.erase(iter);
		}
	}
	auto choice = Rand::GetRandomNumber(0, battlers.size() - 1);
	return battlers[choice];
}

static std::shared_ptr<Game_BattleAlgorithm::AlgorithmBase> MakeSkillAction(Game_Enemy& enemy, const lcf::rpg::EnemyAction& action, bool emulate_bugs) {
	const auto* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, action.skill_id);
	if (!skill) {
		Output::Warning("EnemyAi::MakeSkillAction: Enemy can't use invalid skill {}", action.skill_id);
		return nullptr;
	}

	switch (skill->scope) {
		case lcf::rpg::Skill::Scope_enemy:
			return std::make_shared<Game_BattleAlgorithm::Skill>(&enemy, Main_Data::game_party->GetRandomActiveBattler(), *skill);
		case lcf::rpg::Skill::Scope_ally:
			return std::make_shared<Game_BattleAlgorithm::Skill>(&enemy, GetRandomSkillTarget(*Main_Data::game_enemyparty, *skill, emulate_bugs), *skill);
		case lcf::rpg::Skill::Scope_enemies:
			return std::make_shared<Game_BattleAlgorithm::Skill>(&enemy, Main_Data::game_party.get(), *skill);
		case lcf::rpg::Skill::Scope_self:
			return std::make_shared<Game_BattleAlgorithm::Skill>(&enemy, &enemy, *skill);
		case lcf::rpg::Skill::Scope_party:
			return std::make_shared<Game_BattleAlgorithm::Skill>(&enemy, Main_Data::game_enemyparty.get(), *skill);
	}
	return nullptr;
}

static std::shared_ptr<Game_BattleAlgorithm::AlgorithmBase> MakeAction(Game_Enemy& enemy, const lcf::rpg::EnemyAction& action, bool emulate_bugs) {
	switch (action.kind) {
		case lcf::rpg::EnemyAction::Kind_basic:
			return MakeBasicAction(enemy, action);
		case lcf::rpg::EnemyAction::Kind_skill:
			return MakeSkillAction(enemy, action, emulate_bugs);
		case lcf::rpg::EnemyAction::Kind_transformation:
			return std::make_shared<Game_BattleAlgorithm::Transform>(&enemy, action.enemy_id);
	}
	return nullptr;
}

void SetEnemyAction(Game_Enemy& enemy, const lcf::rpg::EnemyAction& action, bool emulate_bugs) {
	auto algo = MakeAction(enemy, action, emulate_bugs);

	if (algo) {
		if (action.switch_on) {
			algo->SetSwitchEnable(action.switch_on_id);
		}
		if (action.switch_off) {
			algo->SetSwitchDisable(action.switch_off_id);
		}
	}

	enemy.SetBattleAlgorithm(std::move(algo));
}


bool IsSkillEffectiveOn(const lcf::rpg::Skill& skill,
		const Game_Battler& target,
		bool emulate_bugs) {

	if (skill.type == lcf::rpg::Skill::Type_switch) {
		return true;
	}

	if (!Algo::IsNormalOrSubskill(skill)) {
		return false;
	}

	if (Algo::SkillTargetsEnemies(skill)) {
		return target.Exists();
	}

	if (!target.Exists()) {
		// RPG_RT Bug: Ignores reverse_state_effects_flag
		// RPG_RT Bug: Allows revival to target hidden enemies
		return (skill.state_effects.size() > 0 && skill.state_effects[0])
			&& (emulate_bugs || (!skill.reverse_state_effect && target.IsDead()));
	}

	if (skill.affect_hp
			|| skill.affect_sp
			|| skill.affect_attack
			|| skill.affect_defense
			|| skill.affect_spirit
			|| skill.affect_agility) {
		return true;
	}

	for (int id = 1; id <= static_cast<int>(skill.state_effects.size()); ++id) {
		// RPG_RT Bug: Ignores reverse_state_effects_flag
		if (skill.state_effects[id - 1] && (target.HasState(id) || (skill.reverse_state_effect && !emulate_bugs))) {
			return true;
		}
	}

	if (skill.affect_attr_defence) {
		for (auto& attr: skill.attribute_effects) {
			if (attr) {
				return true;
			}
		}
	}

	return false;
}

bool IsActionValid(const Game_Enemy& source, const lcf::rpg::EnemyAction& action) {
	if (action.kind == action.Kind_skill) {
		if (!source.IsSkillUsable(action.skill_id)) {
			return false;
		}
	}

	switch (action.condition_type) {
	case lcf::rpg::EnemyAction::ConditionType_always:
		return true;
	case lcf::rpg::EnemyAction::ConditionType_switch:
		return Main_Data::game_switches->Get(action.switch_id);
	case lcf::rpg::EnemyAction::ConditionType_turn:
		{
			int turns = Game_Battle::GetTurn();
			return Game_Battle::CheckTurns(turns, action.condition_param2, action.condition_param1);
		}
	case lcf::rpg::EnemyAction::ConditionType_actors:
		{
			std::vector<Game_Battler*> battlers;
			Main_Data::game_enemyparty->GetActiveBattlers(battlers);
			int count = (int)battlers.size();
			return count >= action.condition_param1 && count <= action.condition_param2;
		}
	case lcf::rpg::EnemyAction::ConditionType_hp:
		{
			int hp_percent = source.GetHp() * 100 / source.GetMaxHp();
			return hp_percent >= action.condition_param1 && hp_percent <= action.condition_param2;
		}
	case lcf::rpg::EnemyAction::ConditionType_sp:
		{
			int sp_percent = source.GetSp() * 100 / source.GetMaxSp();
			return sp_percent >= action.condition_param1 && sp_percent <= action.condition_param2;
		}
	case lcf::rpg::EnemyAction::ConditionType_party_lvl:
		{
			int party_lvl = Main_Data::game_party->GetAverageLevel();
			return party_lvl >= action.condition_param1 && party_lvl <= action.condition_param2;
		}
	case lcf::rpg::EnemyAction::ConditionType_party_fatigue:
		{
			int party_exh = Main_Data::game_party->GetFatigue();
			return party_exh >= action.condition_param1 && party_exh <= action.condition_param2;
		}
	default:
		return true;
	}
}

static bool IsSkillEffectiveOnAnyTarget(Game_Enemy& source, int skill_id, bool emulate_bugs) {
	const auto* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, skill_id);
	assert(skill);
	if (!Algo::IsNormalOrSubskill(*skill)) {
		return true;
	}

	switch (skill->scope) {
		case lcf::rpg::Skill::Scope_enemy:
		case lcf::rpg::Skill::Scope_enemies:
			break;
		case lcf::rpg::Skill::Scope_self:
			return IsSkillEffectiveOn(*skill, source, emulate_bugs);
		case lcf::rpg::Skill::Scope_ally:
		case lcf::rpg::Skill::Scope_party:
			for (auto* enemy: Main_Data::game_enemyparty->GetEnemies()) {
				if (IsSkillEffectiveOn(*skill, *enemy, emulate_bugs)) {
					return true;
				}
			}
			return false;
	}

	return true;
}

void SelectEnemyAiActionRpgRtCompat(Game_Enemy& source, bool emulate_bugs) {
	const auto& actions = source.GetDbEnemy().actions;
	std::vector<int> prios(actions.size(), 0);
	int max_prio = 0;
	for (int i = 0; i < static_cast<int>(actions.size()); ++i) {
		const auto& action = actions[i];
		if (IsActionValid(source, action)) {
			prios[i] = action.rating;
			max_prio = std::max<int>(max_prio, action.rating);
			DebugLog("ENEMYAI: Enemy {}({}) Allow Action id={} kind={} basic={} rating={}", source.GetName(), source.GetTroopMemberId(), action.ID, action.kind, action.basic, action.rating);
		} else {
			DebugLog("ENEMYAI: Enemy {}({}) Discard Action id={} kind={} basic={} rating={}", source.GetName(), source.GetTroopMemberId(), action.ID, action.kind, action.basic, action.rating);
		}
	}

	DebugLog("ENEMYAI: Enemy {}({}) max_prio={}", source.GetName(), source.GetTroopMemberId(), max_prio);

	if (max_prio) {
		for (auto& pr: prios) {
			if (pr > 0) {
				pr = std::max<int>(0, pr - max_prio + 10);
			}
		}
	}

	for (int i = 0; i < static_cast<int>(actions.size()); ++i) {
		const auto& action = actions[i];
		if (action.kind == lcf::rpg::EnemyAction::Kind_skill) {
			if (prios[i] > 0 && !IsSkillEffectiveOnAnyTarget(source, action.skill_id, emulate_bugs)) {
				DebugLog("ENEMYAI: Enemy {}({}) Discard Action id={} kind={} basic={}, rating={}: No effective targets!", source.GetName(), source.GetTroopMemberId(), action.ID, action.kind, action.basic, action.rating);
				prios[i] = 0;
			}
		}
	}

	int sum_prios = 0;
	for (auto& pr: prios) {
		sum_prios += pr;
	}


	if (sum_prios == 0) {
		DebugLog("ENEMYAI: Enemy {}({}) No Available Actions!", source.GetName(), source.GetTroopMemberId());
		return;
	}

	int which = Rand::GetRandomNumber(0, sum_prios - 1);
	DebugLog("ENEMYAI: Enemy {}({}) sum_prios={} which={}", source.GetName(), source.GetTroopMemberId(), sum_prios, which);
	const lcf::rpg::EnemyAction* selected_action = nullptr;
	for (int i = 0; i < static_cast<int>(actions.size()); ++i) {
		auto& action = actions[i];
		selected_action = &action;
		which -= prios[i];
		if (which < 0) {
			break;
		}
	}

	if (selected_action) {
		DebugLog("ENEMYAI: Enemy {}({}) Selected Action id={} kind={} basic={}, rating={}", source.GetName(), source.GetTroopMemberId(), selected_action->ID, selected_action->kind, selected_action->basic, selected_action->rating);
		SetEnemyAction(source, *selected_action, emulate_bugs);
	} else {
		DebugLog("ENEMYAI: Enemy {}({}) No Selected Action!", source.GetName(), source.GetTroopMemberId());
	}
}

bool SetStateRestrictedAction(Game_Enemy& source) {
	if (!source.CanAct()) {
		source.SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::None>(&source));
		return true;
	}

	if (source.GetSignificantRestriction() == lcf::rpg::State::Restriction_attack_ally) {
		source.SetBattleAlgorithm(MakeAttackAllies(source, 1));
		return true;
	}

	if (source.GetSignificantRestriction() == lcf::rpg::State::Restriction_attack_enemy) {
		source.SetBattleAlgorithm(MakeAttack(source, 1));
		return true;
	}

	if (source.IsCharged()) {
		source.SetBattleAlgorithm(MakeAttack(source, 1));
		return true;
	}

	return false;
}

} // namespace EnemyAi


/*end of file .\enemyai.cpp*/

/*start of file .\exe_reader.cpp*/

/* ... license chunk ... */

// All of this code is unused on EMSCRIPTEN. *Do not use it*!
#ifndef EMSCRIPTEN

#include "exe_reader.h"
#include "image_bmp.h"
#include "output.h"
#include <algorithm>
#include <iostream>
#include <fstream>
#include <zlib.h>

namespace {
	// hashes of known RPG_RT startup logos
	constexpr std::array logo_crc32 {
		0xdf3d86a7u, 0x2ece66f9u, 0x2fe0de56u, 0x25c4618fu, 0x91b2635au,

		/*
		The values below have been extracted from a wide range of
		bootleg versions of RPG_RT.exe that have historically been in
		circulation in various communities (either as part of an Editor
		translation or patch). The specified version strings here refer
		to the info given in either the recovered Installer packages
		or is taken from accompanying Readme files & do not necessarily
		give reliable information about the actual, original RPG_RT
		version on which these translations & patches were based on!
		*/
		// Recompressed, unaltered RPG2000 logos
		0x6a88587eu, 0x4beedd9au, 0x1c7f224bu,
		// Hellsoft's bootleg "RPG Maker PRO 1.05"
		0x5ae12b1cu, 0x3d1cb5f1u, 0x04a7f11au,
		// Hellsoft's bootleg "RPG Maker PRO 1.10"
		0x9307807fu, 0x652529ecu, 0x5e73987bu,
		// Hellsoft's bootleg "RPG Maker PRO 1.15"
		0x2e8271cbu,
		// Hellsoft's translation of Rm2k3: "1.0.2"
		0x4e3f7560u,
		// Hellsoft's translation of Rm2k3: "1.0.4" & "1.0.7"
		0x59ab3986u,
		// Hellsoft's translation of Rm2k3: "1.0.8" & "1.0.9"
		0xd333b2ddu,
		// French "Rabbi-Bodom" translation of Rm2k3-1.0.9.1
		0x476138cbu,
		// "Thaiware" translation of Rm2k
		0x29efaf6au, 0xfeb8f6b2u, 0x265855adu,
		// Thai "House of the Dev" translation of Rm2k
		0xa8be4ed3u, 0xc75ccc6du, 0xcea40e5fu,
		// Thai "Somprasongk Team" translation of Rm2k3-1.0.6
		0xc9b2e174u,
		// Italian Translation of Rm2k (Matteo S.& Christian C.)
		0x1a1ed6ddu, 0xad73ccf5u, 0x4ad55e84u,
		// Italian "RPG Maker 4.0" Patch of Rm2k
		0x8afe1239u,
		// Spanish version of Rm2k3-1.0.9.1
		0x089fb7d8u,
		// Spanish version of Rm2k (SoLaCe)
		0x544ffca8u, 0x4fbc0849u, 0x7420f415u,
		// Spezial-Patch by Rikku2000 (1.51 with swapped logo)
		0x806b6877u,
		// Gnaf's Picture Patch (1.50 with swapped logo)
		0xc5e846a7u
	};
}

EXEReader::EXEReader(Filesystem_Stream::InputStream core) : corefile(std::move(core)) {
	// The Incredibly Dumb PE parser (tm)
	// Extracts data from the resource section for engine detection and can read ExFont.
	uint32_t ofs = GetU32(0x3C); // PE header offset
	uint16_t machine = GetU16(ofs + 4);

	switch (machine) {
		case 0x14c:
			file_info.machine_type = MachineType::x86;
			break;
		case 0x8664:
			file_info.machine_type = MachineType::amd64;
			break;
		default:
			Output::Debug("EXEReader: Unsupported machine type ({:#x})", machine);
			file_info.machine_type = MachineType::Unknown;
			return;
	}

	// The largest known exe has 11 segments, guard against bogus section data here
	uint16_t sections = std::min<uint16_t>(GetU16(ofs + 6), 11);
	uint32_t optional_header = ofs + 0x18;
	uint32_t oh_magic = GetU16(optional_header);

	bool format_pe32;

	switch (oh_magic) {
		case 0x10b:
			format_pe32 = true;
			break;
		case 0x20b:
			// PE32+ (for 64 bit executables)
			format_pe32 = false;
			break;
		default:
			Output::Debug("EXEReader: Unknown PE header magic ({:#x})", oh_magic);
			file_info.machine_type = MachineType::Unknown;
			return;
	}

	uint32_t sectionsOfs = optional_header + GetU16(ofs + 0x14); // skip opt header
	uint32_t data_directory_ofs = (format_pe32 ? 0x60 : 0x70);
	resource_rva = GetU32(optional_header + data_directory_ofs + 16);
	if (!resource_rva) {
		// Is some kind of encrypted EXE -> Give up
		return;
	}
	while (sections) {
		uint32_t secName = GetU32(sectionsOfs);
		uint32_t sectVs = GetU32(sectionsOfs + 0x08);
		uint32_t sectRs = GetU32(sectionsOfs + 0x10);

		if (sectRs > sectVs) {
			// Actually a problem in some files.
			sectVs = sectRs;
		}

		if (secName == 0x45444F43) { // CODE
			file_info.code_size = sectVs;
		} else if (secName == 0x52454843) { // CHER(RY)
			file_info.cherry_size = sectVs;
		} else if (secName == 0x50454547) { // GEEP
			file_info.geep_size = sectVs;
		} else if (secName == 0x30585055) { // UPX0
			Output::Debug("EXEReader: EXE is UPX compressed. Engine detection could be incorrect.");
		}

		uint32_t sectRva = GetU32(sectionsOfs + 0x0C);
		uint32_t sectRdptr = GetU32(sectionsOfs + 0x14);
		if (resource_ofs == 0 && (sectRva <= resource_rva) && ((sectRva + sectVs) > resource_rva)) {
			// Resources located.
			resource_ofs = sectRdptr + (resource_rva - sectRva);
		}
		sections--;
		sectionsOfs += 0x28;
	}
}

static std::vector<uint8_t> ExtractExFont(Filesystem_Stream::InputStream& corefile, uint32_t position, uint32_t len) {
	std::vector<uint8_t> exfont;
	constexpr int header_size = 14; // Size of BITMAPFILEHEADER
	exfont.resize(len + header_size);

	corefile.seekg(position, std::ios_base::beg);
	corefile.read(reinterpret_cast<char*>(exfont.data()) + header_size, len);
	if (corefile.gcount() != len) {
		Output::Debug("EXEReader: ExFont: Error reading resource (read {}, expected {})", corefile.gcount(), len);
		return {};
	}

	auto* exfont_data = reinterpret_cast<const uint8_t*>(exfont.data()) + header_size;
	auto* e = exfont_data + len;
	auto header = ImageBMP::ParseHeader(exfont_data, e);

	// As it turns out, EXFONTs appear to operate on all the same restrictions as an ordinary BMP.
	// Bitmap resources lack the BITMAPFILEHEADER. This header must be generated based on the BITMAPINFOHEADER.
	// And the header that's going to be prepended.
	int header_len = header_size + header.size;
	if (header.depth != 8) {
		Output::Debug("EXEReader: ExFont: Unsupported depth {}", header.depth);
		return {};
	}
	header_len += header.num_colors * 4;

	// 0 (these are in decimal)
	int pos = 0;
	exfont[pos++] = 'B';
	exfont[pos++] = 'M';
	// 2
	uint32_t totallen = exfont.size();
	exfont[pos++] = (totallen) & 0xFF;
	exfont[pos++] = (totallen >> 8) & 0xFF;
	exfont[pos++] = (totallen >> 16) & 0xFF;
	exfont[pos++] = (totallen >> 24) & 0xFF;
	// 6 - Reserved data
	exfont[pos++] = 'E';
	exfont[pos++] = 'x';
	exfont[pos++] = 'F';
	exfont[pos++] = 'n';
	// 10
	exfont[pos++] = (header_len) & 0xFF;
	exfont[pos++] = (header_len >> 8) & 0xFF;
	exfont[pos++] = (header_len >> 16) & 0xFF;
	exfont[pos++] = (header_len >> 24) & 0xFF;

	// Check if the ExFont is the original through a fast hash function
	auto crc = crc32(0, exfont.data() + header_size, exfont.size() - header_size);
	if (crc != 0x86bc6c68) {
		Output::Debug("EXEReader: Custom ExFont found");
	}
	return exfont;
}

static uint32_t exe_reader_roffset(uint32_t bas, uint32_t ofs) {
	return bas + (ofs ^ 0x80000000);
}

std::vector<uint8_t> EXEReader::GetExFont() {
	corefile.clear();

	auto bitmapDBase = ResOffsetByType(2);
	if (bitmapDBase == 0) {
		Output::Debug("EXEReader: BITMAP not found.");
		return {};
	}

	// Looking for a named entry.
	uint16_t resourcesNDEs = GetU16(bitmapDBase + 0x0C) + (uint32_t) GetU16(bitmapDBase + 0x0E);
	uint32_t resourcesNDEbase = bitmapDBase + 0x10;
	while (resourcesNDEs) {
		uint32_t name = GetU32(resourcesNDEbase);
		// Actually a name?
		if (name & 0x80000000) {
			name = exe_reader_roffset(resource_ofs, name);

			if (ResNameCheck(name, "EXFONT")) {
				uint32_t dataent = GetU32(resourcesNDEbase + 4);
				if (dataent & 0x80000000) {
					dataent = exe_reader_roffset(resource_ofs, dataent);
					dataent = resource_ofs + GetU32(dataent + 0x14);
				}
				uint32_t filebase = (GetU32(dataent) - resource_rva) + resource_ofs;
				uint32_t filesize = GetU32(dataent + 0x04);
				Output::Debug("EXEReader: EXFONT resource found (DE {:#x}; {:#x}; len {:#x})", dataent, filebase, filesize);
				return ExtractExFont(corefile, filebase, filesize);
			}
		}
		resourcesNDEbase += 8;
		resourcesNDEs--;
	}
	Output::Debug("EXEReader: EXFONT not found in dbase at {:#x}", bitmapDBase);
	return {};
}

std::vector<std::vector<uint8_t>> EXEReader::GetLogos() {
	corefile.clear();

	if (!resource_ofs) {
		return {};
	}

	if (Player::player_config.show_startup_logos.Get() == ConfigEnum::StartupLogos::None) {
		return {};
	}

	std::vector<std::vector<uint8_t>> logos;

	uint32_t resourcesIDEs = GetU16(resource_ofs + 0x0C);
	if (resourcesIDEs == 1) {
		uint32_t resourcesIDEbase = resource_ofs + 0x10;
		if (ResNameCheck(exe_reader_roffset(resource_ofs, GetU32(resourcesIDEbase)), "XYZ")) {
			uint32_t xyz_base = exe_reader_roffset(resource_ofs, GetU32(resourcesIDEbase + 4));
			uint16_t xyz_logos = std::min<uint16_t>(GetU16(xyz_base + 0x0C), 9);
			uint32_t xyz_logo_base = xyz_base + 0x10;

			bool only_custom_logos = (Player::player_config.show_startup_logos.Get() == ConfigEnum::StartupLogos::Custom);
			std::string res_name = "LOGOX";

			for (int i = 0; i <= xyz_logos; ++i) {
				uint32_t name = GetU32(xyz_logo_base);
				// Actually a name?
				if (name & 0x80000000) {
					name = exe_reader_roffset(resource_ofs, name);
					res_name.back() = '1' + i;

					if (ResNameCheck(name, res_name.c_str()) || (i == 0 && ResNameCheck(name, "LOGO"))) {
						uint32_t dataent = GetU32(xyz_logo_base + 4);
						if (dataent & 0x80000000) {
							dataent = exe_reader_roffset(resource_ofs, dataent);
							dataent = resource_ofs + GetU32(dataent + 0x14);
						}
						uint32_t filebase = (GetU32(dataent) - resource_rva) + resource_ofs;
						uint32_t filesize = GetU32(dataent + 0x04);
						Output::Debug("EXEReader: {} resource found (DE {:#x}; {:#x}; len {:#x})", res_name, dataent, filebase, filesize);
						std::vector<uint8_t> logo;
						logo.resize(filesize);

						corefile.seekg(filebase, std::ios_base::beg);
						corefile.read(reinterpret_cast<char*>(logo.data()), filesize);
						if (logo.size() < 8 || strncmp(reinterpret_cast<char*>(logo.data()), "XYZ1", 4) != 0) {
							Output::Debug("EXEReader: {}: Not a XYZ image", res_name);
							return {};
						}

						if (corefile.gcount() != filesize) {
							Output::Debug("EXEReader: {}: Error reading resource (read {}, expected {})", res_name, corefile.gcount(), filesize);
							return {};
						}

						if (only_custom_logos) {
							auto crc = static_cast<uint32_t>(crc32(0, logo.data(), logo.size()));
							if (std::find(logo_crc32.begin(), logo_crc32.end(), crc) == logo_crc32.end()) {
								logos.push_back(logo);
							}
						} else {
							logos.push_back(logo);
						}
					}
				}

				xyz_logo_base += 8;
			}
		}
	}

	return logos;
}

const EXEReader::FileInfo& EXEReader::GetFileInfo() {
	corefile.clear();

	file_info.logos = GetLogoCount();

	auto versionDBase = ResOffsetByType(16);
	if (versionDBase == 0) {
		return file_info;
	}

	uint16_t resourcesNDEs = GetU16(versionDBase + 0x0C) + (uint32_t) GetU16(versionDBase + 0x0E);
	uint32_t resourcesNDEbase = versionDBase + 0x10;
	while (resourcesNDEs) {
		uint32_t id = GetU32(resourcesNDEbase);
		if (id == 1) {
			id = exe_reader_roffset(resource_ofs, id);

			uint32_t dataent = GetU32(resourcesNDEbase + 4);
			if (dataent & 0x80000000) {
				dataent = exe_reader_roffset(resource_ofs, dataent);
				dataent = resource_ofs + GetU32(dataent + 0x14);
			}
			uint32_t filebase = (GetU32(dataent) - resource_rva) + resource_ofs;
			uint32_t filesize = GetU32(dataent + 0x04);

			std::vector<uint8_t> version_info(filesize);
			corefile.seekg(filebase, std::ios_base::beg);
			corefile.read(reinterpret_cast<char*>(version_info.data()), filesize);

			// The start of VS_FIXEDFILEINFO structure is aligned on a 32 bit boundary
			// Instead of calculating search for the signature
			std::array<uint8_t, 4> signature = {0xBD, 0x04, 0xEF, 0xFE};

			auto sig_it = std::search(version_info.begin(), version_info.end(), signature.begin(), signature.end());
			if (sig_it != version_info.end()) {
				uint32_t product_version_off = std::distance(version_info.begin(), sig_it + 16);
				uint32_t version_high = GetU32(filebase + product_version_off);
				uint32_t version_low = GetU32(filebase + product_version_off + 4);

				file_info.version = (static_cast<uint64_t>(version_high) << 32) | version_low;
				file_info.version_str = fmt::format("{}.{}.{}.{}", (version_high >> 16) & 0xFFFF, version_high & 0xFFFF, (version_low >> 16) & 0xFFFF, version_low & 0xFFFF);
			}

			std::array<uint8_t, 30> easyrpg_player_str = {
				0x45, 0x00, 0x61, 0x00, 0x73, 0x00, 0x79, 0x00, 0x52, 0x00, 0x50, 0x00, 0x47, 0x00, 0x20, 0x00,
				0x50, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x79, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00
			};
			auto ep_it = std::search(version_info.begin(), version_info.end(), easyrpg_player_str.begin(), easyrpg_player_str.end());
			file_info.is_easyrpg_player = ep_it != version_info.end();

			Output::Debug("EXEReader: VERSIONINFO resource found (DE {:#x}; {:#x}; len {:#x})", dataent, filebase, filesize);
			return file_info;
		}
		resourcesNDEbase += 8;
		resourcesNDEs--;
	}
	Output::Debug("EXEReader: VERSIONINFO not found in dbase at {:#x}", versionDBase);
	return file_info;
}

uint8_t EXEReader::GetU8(uint32_t i) {
	corefile.seekg(i, std::ios_base::beg);
	int ch = corefile.get();
	if (ch == -1)
		ch = 0;
	return (uint8_t) ch;
}

uint16_t EXEReader::GetU16(uint32_t i) {
	uint16_t v = GetU8(i);
	v |= ((uint32_t) GetU8(i + 1)) << 8;
	return v;
}

uint32_t EXEReader::GetU32(uint32_t i) {
	uint32_t v = GetU16(i);
	v |= ((uint32_t) GetU16(i + 2)) << 16;
	return v;
}

uint32_t EXEReader::ResOffsetByType(uint32_t type) {
	// Part 2 of the resource grabber.
	if (!resource_ofs) {
		return 0;
	}
	// For each ID/Name entry in the outer...
	uint32_t resourcesIDEs = GetU16(resource_ofs + 0x0C) + (uint32_t) GetU16(resource_ofs + 0x0E);
	uint32_t resourcesIDEbase = resource_ofs + 0x10;
	while (resourcesIDEs) {
		if (GetU32(resourcesIDEbase) == type) {
			return exe_reader_roffset(resource_ofs, GetU32(resourcesIDEbase + 4));
		}
		resourcesIDEbase += 8;
		resourcesIDEs--;
	}
	return 0;
}

uint32_t EXEReader::GetLogoCount() {
	if (!resource_ofs) {
		return 0;
	}

	uint32_t resourcesIDEs = GetU16(resource_ofs + 0x0C);
	if (resourcesIDEs == 1) {
		uint32_t resourcesIDEbase = resource_ofs + 0x10;
		if (ResNameCheck(exe_reader_roffset(resource_ofs, GetU32(resourcesIDEbase)), "XYZ")) {
			uint32_t xyz_logo_base = exe_reader_roffset(resource_ofs, GetU32(resourcesIDEbase + 4));
			return static_cast<uint32_t>(GetU16(xyz_logo_base + 0x0C));
		}
	}
	return 0;
}

bool EXEReader::ResNameCheck(uint32_t i, const char* p) {
	if (GetU16(i) != strlen(p))
		return false;
	while (*p) {
		i += 2;
		if (GetU16(i) != *p)
			return false;
		p++;
	}
	return true;
}

void EXEReader::FileInfo::Print() const {
	Output::Debug("RPG_RT information: version={} logos={} code={:#x} cherry={:#x} geep={:#x} arch={} easyrpg={}", version_str, logos, code_size, cherry_size, geep_size, kMachineTypes[machine_type], is_easyrpg_player);
}

int EXEReader::FileInfo::GetEngineType(bool& is_maniac_patch) const {
	is_maniac_patch = false;

	if (is_easyrpg_player || machine_type == MachineType::Unknown) {
		return Player::EngineNone;
	}

	if (version_str.empty()) {
		// RPG2k and Rpg2k3 < 1.0.2.1 has no VERSIONINFO
		if (logos == 3) {
			// three logos only appear in old RPG2k
			return Player::EngineRpg2k;
		} else if (logos == 1) {
			// VALUE! or Rpg2k3 < 1.0.2.1
			// Check CODE segment size to be sure
			if (code_size > 0xB0000) {
				if (code_size >= 0xC7400) {
					// Code segment size for >= 1.0.5.0
					// In theory this check is unnecessary because this version has a VERSIONINFO.
					// However the modified exe shipped with Ahriman's Prophecy is a 1.0.8.0 without a VERSIONINFO.
					return Player::EngineRpg2k3 | Player::EngineMajorUpdated;
				} else {
					return Player::EngineRpg2k3;
				}
			}

			return Player::EngineRpg2k | Player::EngineMajorUpdated;
		}

		return Player::EngineNone;
	}

	std::array<decltype(version), 4> ver = {
		(version >> 48) & 0xFF,
		(version >> 32) & 0xFF,
		(version >> 16) & 0xFF,
		(version & 0xFF)};

	if (logos == 0) {
		// New version of Maniac Patch is version 1.1.2.1 and is an rewrite of the engine
		// Has no logos, no CODE segment and no CHERRY segment
		if (ver[0] == 1 && ver[1] == 1 && ver[2] == 2 && ver[3] == 1 && code_size == 0 && cherry_size == 0) {
			is_maniac_patch = true;
			return Player::EngineRpg2k3 | Player::EngineMajorUpdated | Player::EngineEnglish;
		}

		return Player::EngineNone;
	}

	// Everything else with a VERSIONINFO must have one logo
	if (logos != 1) {
		return Player::EngineNone;
	}

	if (ver[0] == 1) {
		if (ver[1] == 6) {
			// English release of RPG Maker 2000 has a version info (thanks Cherry!)
			return Player::EngineRpg2k | Player::EngineMajorUpdated | Player::EngineEnglish;
		} else if (ver[1] == 0) {
			// Everything else with a version info is RPG Maker 2003
			if (ver[2] < 5) {
				return Player::EngineRpg2k3;
			} else {
				return Player::EngineRpg2k3 | Player::EngineMajorUpdated;
			}
		} else if (ver[1] == 1) {
			if (ver[2] == 2 && ver[3] == 1) {
				// Old versions of Maniac Patch are a hacked 1.1.2.1
				// The first versions have a GEEP segment (No idea what this abbreviation means)
				// Later versions have no GEEP segment but an enlarged CHERRY segment
				is_maniac_patch = (geep_size > 0 || cherry_size > 0x10000);
			}

			return Player::EngineRpg2k3 | Player::EngineMajorUpdated | Player::EngineEnglish;
		}
	}

	return Player::EngineNone;
}

#endif


/*end of file .\exe_reader.cpp*/

/*start of file .\feature.cpp*/

/* ... license chunk ... */

// Headers
#include "feature.h"
#include "player.h"
#include "game_interpreter_shared.h"
#include <lcf/data.h>

bool Feature::HasRpg2kBattleSystem() {
	if (Player::IsRPG2k()) {
		return true;
	}
#ifdef ENABLE_DYNAMIC_INTERPRETER_CONFIG
	using Flags = lcf::rpg::SaveEventExecState::EasyRpgStateRuntime_Flags;
	if (auto f = Player::GetRuntimeFlag(&Flags::use_rpg2k_battle_system_on, &Flags::use_rpg2k_battle_system_off)) {
		return *f;
	}
#endif
	return lcf::Data::system.easyrpg_use_rpg2k_battle_system;
}

bool Feature::HasRpg2k3BattleSystem() {
	return !HasRpg2kBattleSystem();
}

bool Feature::HasRow() {
	if (HasRpg2k3BattleSystem() && !lcf::Data::battlecommands.easyrpg_disable_row_feature) {
		return true;
	}

	return false;
}

bool Feature::HasPlaceholders() {
	if (Player::IsRPG2kE()) {
		return true;
	}

	return Player::IsRPG2k3() && HasRpg2kBattleSystem() && lcf::Data::system.easyrpg_battle_use_rpg2ke_strings;
}

bool Feature::HasFixedActorFacingDirection() {
	return HasRpg2k3BattleSystem() && lcf::Data::battlecommands.easyrpg_fixed_actor_facing_direction > 0;
}

bool Feature::HasFixedEnemyFacingDirection() {
	return HasRpg2k3BattleSystem() && lcf::Data::battlecommands.easyrpg_fixed_enemy_facing_direction > 0;
}



/*end of file .\feature.cpp*/

/*start of file .\fileext_guesser.cpp*/

/* ... license chunk ... */

// Headers

#include "filefinder.h"
#include "fileext_guesser.h"
#include "meta.h"
#include "output.h"
#include "string_view.h"
#include <sstream>

namespace {
	const std::string RtPrefix = "rpg_rt.";
	const std::string MapPrefix = "map";
	const size_t MapPrefixLength = 8; // mapXXXX.
}


FileExtGuesser::RPG2KNonStandardFilenameGuesser FileExtGuesser::GetRPG2kProjectWithRenames(const FilesystemView& fs) {
	// Try to rescue and determine file extensions.
	// We need to figure out the names of the map tree and the DB (maps come later).
	std::vector<RPG2KNonStandardFilenameGuesser::ExtAndSize> candidates;
	const auto* entries = fs.ListDirectory();
	if (entries) {
		for (const auto &item: *entries) {
			if (item.second.type != DirectoryTree::FileType::Regular) {
				continue;
			}

			if (item.first.length() == RtPrefix.length() + 3 && StartsWith(item.first, RtPrefix)) {
				std::string ext = item.first.substr(RtPrefix.length());
				if (ext != "exe" && ext != "ini") {
					candidates.emplace_back(item.second.name, ext, fs.GetFilesize(fs.FindFile(item.second.name)));
				}
			}

			// Avoid needless scanning if we can't figure it out
			if (candidates.size() > 2) {
				break;
			}
		}

		// Return only if we matched exactly two files.
		if (candidates.size() == 2) {
			RPG2KNonStandardFilenameGuesser res;
			res.rpgRTs.first = candidates[0];
			res.rpgRTs.second = candidates[1];
			return res;
		}
	}

	return RPG2KNonStandardFilenameGuesser();
}

void FileExtGuesser::GuessAndAddLmuExtension(const FilesystemView& fs, Meta const& meta, RPG2KFileExtRemap& mapping)
{
	// If metadata is provided, rely on that.
	std::string metaLmu = meta.GetLmuAlias();
	if (!metaLmu.empty()) {
		mapping.extMap[SUFFIX_LMU] = metaLmu;
		Output::Debug("Metadata-provided non-standard extension for LMU({})", metaLmu);
	} else {
		// Try to rescue and determine file extensions.
		// Without metadata, scan for matching files. Stop after you find a few;
		//   we can't just pick the first since there may be some backup files on disk.
		std::unordered_map<std::string, int> extCounts; // ext => count

		const auto* entries = fs.ListDirectory();
		if (entries) {
			for (const auto &item: *entries) {
				if (item.second.type != DirectoryTree::FileType::Regular) {
					continue;
				}

				if (item.first.length() == MapPrefixLength + 3 &&
					StartsWith(item.first, MapPrefix)) {
					std::string ext = item.first.substr(MapPrefixLength);
					extCounts[ext] += 1;
					if (extCounts[ext] >= 5) {
						mapping.extMap[SUFFIX_LMU] = ext;
						Output::Debug("Guessing non-standard extension for LMU({})", ext);
						break;
					}
				}
			}
		}
	}
}

FileExtGuesser::RPG2KFileExtRemap FileExtGuesser::RPG2KNonStandardFilenameGuesser::guessExtensions(Meta& meta)
{
	RPG2KFileExtRemap res;

	// Since the file extensions are non-standard, we
	// won't have CRCs for them, so we need to guess more
	if (!this->Empty()) {
		meta.ReInitForNonStandardExtensions(rpgRTs.first.fname, rpgRTs.second.fname);
	}

	// If metadata exists, we don't need to guess
	std::string metaLdb = meta.GetLdbAlias();
	std::string metaLmt = meta.GetLmtAlias();
	if (!metaLdb.empty()) {
		res.extMap[SUFFIX_LDB] = metaLdb;
	}
	if (!metaLmt.empty()) {
		res.extMap[SUFFIX_LMT] = metaLmt;
	}

	// If neither exists, we have to fall back to guessing.
	if (!(metaLdb.empty() && metaLmt.empty())) {
		Output::Debug("Metadata-provided non-standard extension for LDB({}) and LMT({})", metaLdb, metaLmt);
	} else {
		// With no metadata, just assume the largest file is the database
		// It's usually bigger by a factor of 10.
		auto first = rpgRTs.first;
		auto second = rpgRTs.second;
		if (first.sz > second.sz) {
			res.extMap[SUFFIX_LDB] = first.ext;
			res.extMap[SUFFIX_LMT] = second.ext;
		} else {
			res.extMap[SUFFIX_LDB] = second.ext;
			res.extMap[SUFFIX_LMT] = first.ext;
		}

		Output::Debug("Guessing non-standard extensions for LDB({}) and LMT({})", res.extMap[SUFFIX_LDB], res.extMap[SUFFIX_LMT]);
	}

	return res;
}

bool FileExtGuesser::RPG2KNonStandardFilenameGuesser::Empty() const {
	return rpgRTs.first.ext.empty() || rpgRTs.second.ext.empty();
}

std::string FileExtGuesser::RPG2KFileExtRemap::MakeFilename(std::string_view prefix, std::string_view suffix)
{
	std::stringstream res;
	res <<prefix <<".";

	auto it = extMap.find(ToString(suffix));
	if (it != extMap.end()) {
		res << it->second;
	} else {
		res << suffix;
	}
	return res.str();
}


/*end of file .\fileext_guesser.cpp*/

/*start of file .\filefinder.cpp*/

/* ... license chunk ... */

// Headers
#include <cassert>
#include <cerrno>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <fstream>
#include <string>
#include <vector>
#include <sstream>

#ifdef _WIN32
#  include <windows.h>
#  include <shlobj.h>
#endif

#include "system.h"
#include "options.h"
#include "utils.h"
#include "directory_tree.h"
#include "filefinder.h"
#include "filefinder_rtp.h"
#include "filesystem.h"
#include "filesystem_root.h"
#include "fileext_guesser.h"
#include "output.h"
#include "player.h"
#include "registry.h"
#include "main_data.h"
#include <lcf/reader_util.h>
#include "platform.h"

// MinGW shlobj.h does not define this
#ifndef SHGFP_TYPE_CURRENT
#define SHGFP_TYPE_CURRENT 0
#endif

namespace {
#ifdef SUPPORT_MOVIES
	auto MOVIE_TYPES = { ".avi", ".mpg" };
#endif

	std::shared_ptr<Filesystem> root_fs;
	FilesystemView game_fs;
	FilesystemView save_fs;
}

FilesystemView FileFinder::Game() {
	return game_fs;
}

void FileFinder::SetGameFilesystem(FilesystemView filesystem) {
	game_fs = filesystem;
}

FilesystemView FileFinder::Save() {
	if (save_fs) {
		// This means the save filesystem was overwritten
		if (!save_fs.IsFeatureSupported(Filesystem::Feature::Write)) {
			Output::Error("{} is not a valid save path (not writable)", GetFullFilesystemPath(save_fs));
		}
		return save_fs;
	}

	if (!game_fs) {
		// Filesystem not initialized yet (happens on startup)
		return {};
	}

	// Not overwritten, check if game fs is writable. If not redirect the write operation.
	if (!game_fs.IsFeatureSupported(Filesystem::Feature::Write)) {
		// When the Project path equals the Save path (this means the path was not configured)
		// and the filesystem has no write support do a redirection to a folder with ".save" appended
		FilesystemView parent = game_fs;
		FilesystemView redir;
		std::vector<std::string> comps;
		for (;;) {
			comps.emplace_back(parent.GetSubPath());
			comps.emplace_back(parent.GetBasePath());
			parent = parent.GetOwner().GetParent();
			if (!parent) {
				break;
			}
			if (parent.IsFeatureSupported(Filesystem::Feature::Write)) {
				comps.back() += ".save";
				std::reverse(comps.begin(), comps.end());
				std::string save_path = MakePath(lcf::MakeSpan(comps));
				if (!parent.IsDirectory(save_path, true)) {
					parent.MakeDirectory(save_path, true);
				}
				redir = parent.Subtree(save_path);

				if (!redir) {
					Output::Error("Invalid save directory {}", save_path);
				}

				break;
			}
		}

		if (!redir) {
			Output::Error("No suitable save directory found");
		}

		return redir;
	}

	return game_fs;
}

void FileFinder::SetSaveFilesystem(FilesystemView filesystem) {
	save_fs = filesystem;
}

FilesystemView FileFinder::Root() {
	if (!root_fs) {
		root_fs = std::make_unique<RootFilesystem>();
	}

	return root_fs->Subtree("");
}

std::string FileFinder::MakePath(std::string_view dir, std::string_view name) {
	std::string str;
	if (dir.empty()) {
		str = ToString(name);
	} else if (name.empty()) {
		str = ToString(dir);
	} else if (EndsWith(dir, '/')) {
		str = ToString(dir) + ToString(name);
	} else {
		str = ToString(dir) + "/" + ToString(name);
	}

	ConvertPathDelimiters(str);

	return str;
}

std::string FileFinder::MakeCanonical(std::string_view path, int initial_deepness) {
	std::string_view ns;
	// Check if the path contains a namespace and prevent that the :// is replaced with :/
	auto ns_pos = path.find("://");
	if (ns_pos != std::string::npos) {
		ns = path.substr(0, ns_pos + 3);
		path = path.substr(ns_pos + 3);
	}

	std::string root_slash = (!path.empty() && path[0] == '/') ? "/" : "";

	std::vector<std::string> path_components = SplitPath(path);
	std::vector<std::string> path_can;

	for (const std::string& path_comp : path_components) {
		if (path_comp == "..") {
			if (path_can.size() > 0) {
				path_can.pop_back();
			} else if (initial_deepness > 0) {
				// Ignore, we are in root
				--initial_deepness;
			} else {
				Output::Debug("Path traversal out of game directory: {}", path);
			}
		} else if (path_comp.empty() || path_comp == ".") {
			// ignore
		} else {
			path_can.push_back(path_comp);
		}
	}

	std::string ret;
	for (std::string_view s : path_can) {
		ret = MakePath(ret, s);
	}

	// Determine if the slash of a filesystem root (drive:/) was removed and readd it
	auto psize = path.size();
	std::string drive_slash;
	if (psize >= 2 && path[psize - 1] == '/' && path[psize - 2] == ':') {
		drive_slash = "/";
	}

	return ToString(ns) + root_slash + ret + drive_slash;
}

std::vector<std::string> FileFinder::SplitPath(std::string_view path) {
	// Tokens are path delimiters ("/" and encoding aware "\")
	std::function<bool(char32_t)> f = [](char32_t t) {
		char32_t escape_char_back = '\0';
		if (!Player::escape_symbol.empty()) {
			escape_char_back = Utils::DecodeUTF32(Player::escape_symbol).front();
		} else {
			escape_char_back = Utils::DecodeUTF32("\\").front();
		}
		char32_t escape_char_forward = Utils::DecodeUTF32("/").front();
		return t == escape_char_back || t == escape_char_forward;
	};
	return Utils::Tokenize(path, f);
}

std::pair<std::string, std::string> FileFinder::GetPathAndFilename(std::string_view path) {
	if (path.empty()) {
		return {"", ""};
	}

	std::string path_copy = ToString(path);
	ConvertPathDelimiters(path_copy);

	const size_t last_slash_idx = path_copy.find_last_of('/');
	if (last_slash_idx == std::string::npos) {
		return {"", path_copy};
	}

	// Determine if the file is located at the filesystem root (e.g. / or drive:/)
	// In that case do not remove the slash
	std::string root_slash;
	const size_t first_slash_idx = path_copy.find_first_of('/');
	if (first_slash_idx == last_slash_idx &&
		(first_slash_idx == 0 || path[first_slash_idx - 1] == ':')) {
		root_slash = "/";
	}

	return {
		path_copy.substr(0, last_slash_idx) + root_slash,
		path_copy.substr(last_slash_idx + 1)
	};
}

void FileFinder::ConvertPathDelimiters(std::string& path) {
	auto replace = [&](const std::string& esc_ch) {
		std::size_t escape_pos = path.find(esc_ch);
		while (escape_pos != std::string::npos) {
			path.erase(escape_pos, esc_ch.length());
			path.insert(escape_pos, "/");
			escape_pos = path.find(esc_ch);
		}
	};

	replace("\\");
	if (!Player::escape_symbol.empty() && Player::escape_symbol != "\\") {
		replace(Player::escape_symbol);
	}
}

std::string FileFinder::GetPathInsidePath(std::string_view path_to, std::string_view path_in) {
	if (!StartsWith(path_in, path_to)) {
		return ToString(path_in);
	}

	std::string_view path_out = path_in.substr(path_to.size());
	if (!path_out.empty() && (path_out[0] == '/' || path_out[0] == '\\')) {
		path_out = path_out.substr(1);
	}

	return ToString(path_out);
}

std::string FileFinder::GetPathInsideGamePath(std::string_view path_in) {
	return FileFinder::GetPathInsidePath(Game().GetFullPath(), path_in);
}

bool FileFinder::IsSupportedArchiveExtension(std::string path) {
	Utils::LowerCaseInPlace(path);
	std::string_view pv = path;

#ifdef HAVE_LHASA
	if (EndsWith(pv, ".lzh")) {
		return true;
	}
#endif

	return EndsWith(pv, ".zip") || EndsWith(pv, ".easyrpg");
}

void FileFinder::Quit() {
	root_fs.reset();
}

bool FileFinder::IsValidProject(const FilesystemView& fs) {
	return IsRPG2kProject(fs) || IsEasyRpgProject(fs) || IsRPG2kProjectWithRenames(fs);
}

bool FileFinder::IsRPG2kProject(const FilesystemView& fs) {
	return !fs.FindFile(DATABASE_NAME).empty() &&
		!fs.FindFile(TREEMAP_NAME).empty();
}

bool FileFinder::IsEasyRpgProject(const FilesystemView& fs){
	return !fs.FindFile(DATABASE_NAME_EASYRPG).empty() &&
		   !fs.FindFile(TREEMAP_NAME_EASYRPG).empty();
}

bool FileFinder::IsRPG2kProjectWithRenames(const FilesystemView& fs) {
	return !FileExtGuesser::GetRPG2kProjectWithRenames(fs).Empty();
}

FileFinder::ProjectType FileFinder::GetProjectType(const FilesystemView &fs) {
	if (IsValidProject(fs)) {
		return FileFinder::ProjectType::Supported;
	}

	DirectoryTree::Args args;
	args.process_wildcards = true;
	args.path = "RGSS10??.dll";

	if (!fs.FindFile(args).empty()) {
		return FileFinder::ProjectType::RpgMakerXp;
	}

	args.path = "RGSS20??.dll";
	if (!fs.FindFile(args).empty()) {
		return FileFinder::ProjectType::RpgMakerVx;
	}

	args.path = "System/RGSS30?.dll";
	if (!fs.FindFile(args).empty()) {
		return FileFinder::ProjectType::RpgMakerVxAce;
	}

	if (!fs.FindFile("nw.dll").empty()) {
		return FileFinder::ProjectType::RpgMakerMvMz;
	}

	if (!fs.FindFile("GuruGuruSMF4.dll").empty()) {
		return FileFinder::ProjectType::WolfRpgEditor;
	}

	if (!fs.FindFile("RPG_RT.rs1").empty()) {
		return FileFinder::ProjectType::Encrypted2k3Maniacs;
	}

	if (!fs.FindFile("SWNAME.DAT").empty()) {
		if (!fs.FindFile("GEOLOGY.DAT").empty()) {
			return FileFinder::ProjectType::SimRpgMaker95;
		} else if (args.path = "*.RPG"; !fs.FindFile(args).empty()) {
			return FileFinder::ProjectType::RpgMaker95;
		}
	}

	return FileFinder::ProjectType::Unknown;
}

bool FileFinder::OpenViewToEasyRpgFile(FilesystemView& fs) {
	auto files = fs.ListDirectory();
	if (!files) {
		return false;
	}

	int items = 0;
	std::string filename;

	for (auto& file : *files) {
		if (EndsWith(file.second.name, ".easyrpg")) {
			++items;
			if (items == 2) {
				// Contains more than one game
				return false;
			}
			filename = file.second.name;
		}
	}

	if (filename.empty()) {
		return false;
	}

	// One candidate to check
	auto ep_fs = fs.Create(filename);
	if (FileFinder::IsValidProject(ep_fs)) {
		fs = ep_fs;
		return true;
	} else {
		return false;
	}
}

bool FileFinder::HasSavegame() {
	return GetSavegames() > 0;
}

int FileFinder::GetSavegames() {
	auto fs = Save();

	for (int i = 1; i <= 15; i++) {
		std::stringstream ss;
		ss << "Save" << (i <= 9 ? "0" : "") << i << ".lsd";
		std::string filename = fs.FindFile(ss.str());

		if (!filename.empty()) {
			return true;
		}
	}
	return false;
}

std::string find_generic(const DirectoryTree::Args& args) {
	if (!Tr::GetCurrentTranslationId().empty()) {
		auto tr_fs = Tr::GetCurrentTranslationFilesystem();
		auto translated_file = tr_fs.FindFile(args);
		if (!translated_file.empty()) {
			return translated_file;
		}
	}

	return FileFinder::Game().FindFile(args);
}

std::string find_generic_with_fallback(DirectoryTree::Args& args) {
	// Searches first in the Save directory (because the game could have written
	// files there, then in the Game directory.
	// Disable this behaviour when Game and Save are shared as this breaks the
	// translation redirection.
	if (Player::shared_game_and_save_directory) {
		return find_generic(args);
	}

	std::string found = FileFinder::Save().FindFile(args);
	if (found.empty()) {
		return find_generic(args);
	}

	return found;
}

std::string FileFinder::FindImage(std::string_view dir, std::string_view name) {
	DirectoryTree::Args args = { MakePath(dir, name), IMG_TYPES, 1, false };
	return find_generic(args);
}

std::string FileFinder::FindMusic(std::string_view name) {
	DirectoryTree::Args args = { MakePath("Music", name), MUSIC_TYPES, 1, false };
	return find_generic(args);

}

std::string FileFinder::FindSound(std::string_view name) {
	DirectoryTree::Args args = { MakePath("Sound", name), SOUND_TYPES, 1, false };
	return find_generic(args);
}

std::string FileFinder::FindFont(std::string_view name) {
	DirectoryTree::Args args = { MakePath("Font", name), FONTS_TYPES, 1, true };
	return find_generic(args);
}

Filesystem_Stream::InputStream open_generic(std::string_view dir, std::string_view name, DirectoryTree::Args& args) {
	if (!Tr::GetCurrentTranslationId().empty()) {
		auto tr_fs = Tr::GetCurrentTranslationFilesystem();
		auto is = tr_fs.OpenFile(args);
		if (is) {
			return is;
		}
	}

	auto is = FileFinder::Game().OpenFile(args);
	if (!is && Main_Data::filefinder_rtp) {
		is = Main_Data::filefinder_rtp->Lookup(dir, name, args.exts);
		if (!is) {
			Output::Debug("Cannot find: {}/{}", dir, name);
		}
	}
	return is;
}

Filesystem_Stream::InputStream open_generic_with_fallback(std::string_view dir, std::string_view name, DirectoryTree::Args& args) {
	if (!Tr::GetCurrentTranslationId().empty()) {
		auto tr_fs = Tr::GetCurrentTranslationFilesystem();
		auto is = tr_fs.OpenFile(args);
		if (is) {
			return is;
		}
	}

	auto is = FileFinder::Save().OpenFile(args);
	if (!is) { is = open_generic(dir, name, args); }
	if (!is) {
		Output::Debug("Unable to open in either Game or Save: {}/{}", dir, name);
	}

	return is;
}

Filesystem_Stream::InputStream FileFinder::OpenImage(std::string_view dir, std::string_view name) {
	DirectoryTree::Args args = { MakePath(dir, name), IMG_TYPES, 1, false };
	return open_generic(dir, name, args);
}

Filesystem_Stream::InputStream FileFinder::OpenMusic(std::string_view name) {
	DirectoryTree::Args args = { MakePath("Music", name), MUSIC_TYPES, 1, false };
	return open_generic("Music", name, args);
}

Filesystem_Stream::InputStream FileFinder::OpenSound(std::string_view name) {
	DirectoryTree::Args args = { MakePath("Sound", name), SOUND_TYPES, 1, false };
	return open_generic("Sound", name, args);
}

Filesystem_Stream::InputStream FileFinder::OpenFont(std::string_view name) {
	DirectoryTree::Args args = { MakePath("Font", name), FONTS_TYPES, 1, false };
	return open_generic("Font", name, args);
}

Filesystem_Stream::InputStream FileFinder::OpenText(std::string_view name) {
	DirectoryTree::Args args = { MakePath("Text", name), TEXT_TYPES, 1, false };
	return open_generic_with_fallback("Text", name, args);
}

bool FileFinder::IsMajorUpdatedTree() {
	auto fs = Game();
	assert(fs);

	// Find an MP3 music file only when official Harmony.dll exists
	// in the gamedir or the file doesn't exist because
	// the detection doesn't return reliable results for games created with
	// "RPG2k non-official English translation (older engine) + MP3 patch"
	bool find_mp3 = true;
	std::string harmony = Game().FindFile("Harmony.dll");
	if (!harmony.empty()) {
		auto size = fs.GetFilesize(harmony);
		if (size != -1 && size != KnownFileSize::OFFICIAL_HARMONY_DLL) {
			Output::Debug("Non-official Harmony.dll found, skipping MP3 test");
			find_mp3 = false;
		}
	}

	if (find_mp3) {
		auto entries = fs.ListDirectory("music");
		if (entries) {
			for (const auto& entry : *entries) {
				if (entry.second.type == DirectoryTree::FileType::Regular && EndsWith(entry.first, ".mp3")) {
					Output::Debug("MP3 file ({}) found", entry.second.name);
					return true;
				}
			}
		}
	}

	// Compare the size of RPG_RT.exe with threshold
	std::string rpg_rt = Game().FindFile("RPG_RT.exe");
	if (!rpg_rt.empty()) {
		auto size = fs.GetFilesize(rpg_rt);
		if (size != -1) {
			return size > (Player::IsRPG2k() ? RpgrtMajorUpdateThreshold::RPG2K : RpgrtMajorUpdateThreshold::RPG2K3);
		}
	}
	Output::Debug("Could not get the size of RPG_RT.exe");

	// Assume the most popular version
	// Japanese or RPG2k3 games: newer engine
	// non-Japanese RPG2k games: older engine
	bool assume_newer = Player::IsCP932() || Player::IsRPG2k3();
	Output::Debug("Assuming {} engine", assume_newer ? "newer" : "older");
	return assume_newer;
}

std::string FileFinder::GetFullFilesystemPath(FilesystemView fs) {
	FilesystemView cur_fs = fs;
	std::string full_path;
	while (cur_fs) {
		full_path = MakePath(cur_fs.GetFullPath(), full_path);
		cur_fs = cur_fs.GetOwner().GetParent();
	}
	return full_path;
}

void FileFinder::DumpFilesystem(FilesystemView fs) {
	FilesystemView cur_fs = fs;
	int i = 1;
	while (cur_fs) {
		Output::Debug("{}: {}", i++, cur_fs.Describe());
		cur_fs = cur_fs.GetOwner().GetParent();
	}
}

std::vector<FileFinder::FsEntry> FileFinder::FindGames(FilesystemView fs, int recursion_limit, int game_limit) {
	std::vector<FileFinder::FsEntry> games;

	std::function<void(FilesystemView, int)> find_recursive = [&](FilesystemView subfs, int rec_limit) -> void {
		if (!subfs || rec_limit == 0 || static_cast<int>(games.size()) >= game_limit) {
			return;
		}

		auto project_type = GetProjectType(subfs);
		if (project_type != ProjectType::Unknown) {
			games.push_back({ subfs, project_type });
			return;
		}

		auto entries = subfs.ListDirectory();

		for (auto& [name_lower, entry]: *entries) {
			if (entry.type == DirectoryTree::FileType::Directory) {
				find_recursive(subfs.Subtree(entry.name), rec_limit - 1);
			} else if (entry.type == DirectoryTree::FileType::Regular && IsSupportedArchiveExtension(entry.name)) {
				find_recursive(fs.Create(entry.name), rec_limit - 1);
			}
		}
	};

	find_recursive(fs, recursion_limit);

	return games;
}


/*end of file .\filefinder.cpp*/

/*start of file .\filefinder_rtp.cpp*/

/* ... license chunk ... */

#include "filefinder_rtp.h"
#include "output.h"
#include "player.h"
#include "registry.h"

#include <lcf/reader_util.h>

#ifdef USE_LIBRETRO
#  include "platform/libretro/ui.h"
#endif

#if defined(USE_SDL) && defined(__ANDROID__)
#  include <jni.h>
#  include <SDL_system.h>
#endif

FileFinder_RTP::FileFinder_RTP(bool no_rtp, bool no_rtp_warnings, std::string rtp_path) {
#ifdef EMSCRIPTEN
	// No RTP support for emscripten at the moment.
	disable_rtp = true;
#else
	disable_rtp = no_rtp;
#endif
	game_has_full_package_flag = no_rtp_warnings;

	if (disable_rtp) {
		Output::Debug("RTP support is disabled.");
		return;
	}

	std::string const version_str =	Player::GetEngineVersion();
	assert(!version_str.empty());

#ifdef __wii__
	AddPath("sd:/data/rtp/" + version_str);
	AddPath("usb:/data/rtp/" + version_str);
#elif defined(__WIIU__)
	AddPath("fs:/vol/content/rtp/" + version_str); // shipped
	AddPath("rtp/" + version_str);
	AddPath("fs:/vol/external01/wiiu/data/easyrpg-player/rtp/" + version_str);
#elif defined(__SWITCH__)
	AddPath("./rtp/" + version_str);
	AddPath("/switch/easyrpg-player/rtp/" + version_str);
#elif defined(__3DS__)
	AddPath("romfs:/data/rtp/" + version_str);
	AddPath("sdmc:/data/rtp/" + version_str);
#elif defined(__vita__)
	AddPath("ux0:/data/easyrpg-player/rtp/" + version_str);
#elif defined(__MORPHOS__)
	AddPath("PROGDIR:rtp/" + version_str);
#elif defined(USE_LIBRETRO)
	const char* dir = nullptr;
	if (LibretroUi::environ_cb(RETRO_ENVIRONMENT_GET_CORE_ASSETS_DIRECTORY, &dir) && dir) {
		AddPath(std::string(dir) + "/rtp/" + version_str);
	}
	if (LibretroUi::environ_cb(RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY, &dir) && dir) {
		AddPath(std::string(dir) + "/rtp/" + version_str);
	}
#elif defined(__ANDROID__)
	// Invoke "String getRtpPath()" in EasyRPG Activity via JNI
	JNIEnv* env = (JNIEnv*)SDL_AndroidGetJNIEnv();
	jobject sdl_activity = (jobject)SDL_AndroidGetActivity();
	jclass cls = env->GetObjectClass(sdl_activity);
	jmethodID jni_getRtpPath = env->GetMethodID(cls , "getRtpPath", "()Ljava/lang/String;");
	jstring return_string = (jstring)env->CallObjectMethod(sdl_activity, jni_getRtpPath);

	const char *js = env->GetStringUTFChars(return_string, NULL);
	std::string cs(js);

	env->ReleaseStringUTFChars(return_string, js);
	env->DeleteLocalRef(sdl_activity);
	env->DeleteLocalRef(cls);
	AddPath(cs + "/" + version_str);
#elif defined(USE_WINE_REGISTRY) || defined(_WIN32)
	std::string const product = "RPG" + version_str;
	if (Player::IsRPG2k()) {
		// Prefer original 2000 RTP over Kadokawa, because there is no
		// reliable way to detect this engine and much more 2k games
		// use the non-English version
		ReadRegistry("ASCII", product, "RuntimePackagePath");
		ReadRegistry("KADOKAWA", product, "RuntimePackagePath");
	}
	else if (Player::IsRPG2k3E()) {
		// Prefer Kadokawa RTP over Enterbrain for new RPG2k3
		ReadRegistry("KADOKAWA", product, "RuntimePackagePath");
		ReadRegistry("Enterbrain", product, "RUNTIMEPACKAGEPATH");
	}
	else if (Player::IsRPG2k3()) {
		// Original 2003 RTP installer registry key is upper case
		// and Wine registry is case insensitive but new 2k3v1.10 installer is not
		// Prefer Enterbrain RTP over Kadokawa for old RPG2k3 (search order)
		ReadRegistry("Enterbrain", product, "RUNTIMEPACKAGEPATH");
		ReadRegistry("KADOKAWA", product, "RuntimePackagePath");
	}

	// Our RTP is for all engines
	ReadRegistry("EasyRPG", "RTP", "path");
#else
	// Fallback for unknown platforms
	AddPath("/data/rtp/" + version_str);
#endif

#if (defined(PLAYER_NINTENDO) || defined(__vita__) || defined(__ANDROID__))
	// skip environment paths
	return;
#endif

	std::vector<std::string> env_paths;

	// Windows paths are split by semicolon, Unix paths by colon
	std::function<bool(char32_t)> f = [](char32_t t) {
#ifdef _WIN32
		return t == ';';
#else
		return t == ':' || t == ';';
#endif
	};

	if (Player::IsRPG2k() && getenv("RPG2K_RTP_PATH"))
		env_paths = Utils::Tokenize(getenv("RPG2K_RTP_PATH"), f);
	else if (Player::IsRPG2k3() && getenv("RPG2K3_RTP_PATH"))
		env_paths = Utils::Tokenize(getenv("RPG2K3_RTP_PATH"), f);

	if (getenv("RPG_RTP_PATH")) {
		std::vector<std::string> tmp = Utils::Tokenize(getenv("RPG_RTP_PATH"), f);
		env_paths.insert(env_paths.end(), tmp.begin(), tmp.end());
	}

	// If custom RTP paths are set, use these with highest precedence
	if (!rtp_path.empty()) {
		std::vector<std::string> tmp = Utils::Tokenize(rtp_path, f);
		env_paths.insert(env_paths.begin(), tmp.begin(), tmp.end());
	}

#ifdef USE_XDG_RTP
	std::string xdg_rtp;

	// Search in the local data directory
	xdg_rtp = getenv("XDG_DATA_HOME") ? std::string(getenv("XDG_DATA_HOME")) :
			  std::string(getenv("HOME")) + "/.local/share";
	xdg_rtp += "/rtp/" + version_str;
	if (FileFinder::Root().Exists(xdg_rtp)) {
		env_paths.push_back(xdg_rtp);
	}

	// Search in the global data directories
	xdg_rtp = getenv("XDG_DATA_DIRS") ? std::string(getenv("XDG_DATA_DIRS")) :
			  std::string("/usr/local/share/:/usr/share/");
	std::vector<std::string> tmp = Utils::Tokenize(xdg_rtp, f);
	for (std::string_view p : tmp) {
		xdg_rtp = ToString(p) + (p.back() == '/' ? "" : "/") + "rtp/" + version_str;
		if (FileFinder::Root().Exists(xdg_rtp)) {
			env_paths.push_back(xdg_rtp);
		}
	}
#endif

	// Add all found paths from the environment
	for (std::string_view p : env_paths) {
		AddPath(p);
	}
}

void FileFinder_RTP::AddPath(std::string_view p) {
	using namespace FileFinder;
	auto fs = FileFinder::Root().Create(FileFinder::MakeCanonical(p));
	if (fs) {
		auto files = fs.ListDirectory();
		if (files->size() == 0) {
			Output::Debug("RTP path {} is empty, not adding", p);
			return;
		}

		Output::Debug("Adding {} to RTP path", p);

		auto hit_info = RTP::Detect(fs, Player::EngineVersion());

		search_paths.push_back(fs);

		if (hit_info.empty()) {
			Output::Debug("The folder does not contain a known RTP!");
		}

		// Only consider the best RTP hits (usually 100% if properly installed)
		float best = 0.0;
		for (const auto& hit : hit_info) {
			float rate = static_cast<float>(hit.hits) / hit.max;
			if (rate >= best) {
				Output::Debug("RTP is \"{}\" ({}/{})", hit.name, hit.hits, hit.max);
				detected_rtp.emplace_back(hit);
				best = rate;
			}
		}
	} else {
		Output::Debug("RTP path {} is invalid, not adding", p);
	}
}

void FileFinder_RTP::ReadRegistry(std::string_view company, std::string_view product, std::string_view key) {
#if defined(USE_WINE_REGISTRY) || defined(_WIN32)
	std::string rtp_path = Registry::ReadStrValue(
			HKEY_CURRENT_USER, "Software\\" + ToString(company) + "\\" + ToString(product), key, KEY32);
	if (!rtp_path.empty()) {
		AddPath(rtp_path);
	}

	rtp_path = Registry::ReadStrValue(
			HKEY_LOCAL_MACHINE, "Software\\" + ToString(company) + "\\" + ToString(product), key, KEY32);
	if (!rtp_path.empty()) {
		AddPath(rtp_path);
	}
#else
	(void)company;
	(void)product;
	(void)key;
#endif
}

Filesystem_Stream::InputStream FileFinder_RTP::LookupInternal(std::string_view dir, std::string_view name, const Span<const std::string_view> exts, bool& is_rtp_asset) const {
	int version = Player::EngineVersion();

	auto normal_search = [&]() {
		is_rtp_asset = false;
		for (const auto& path : search_paths) {
			const std::string ret = path.FindFile(dir, name, exts);
			if (!ret.empty()) {
				return path.OpenInputStream(ret);
			}
		}
		return Filesystem_Stream::InputStream();
	};

	// Detect the RTP version the game uses, when only one candidate is left the RTP is known
	if (game_rtp.size() != 1) {
		auto candidates = RTP::LookupAnyToRtp(dir, name, version);

		// Prevent Don Miguel RTP addon data from being detected as game RTP because a game can only have one RTP
		// and using this one will break the whole lookup table logic.
		auto addon_it = std::find(candidates.begin(), candidates.end(), RTP::Type::RPG2000_DonMiguelAddon);
		if (addon_it != candidates.end()) {
			candidates.erase(addon_it);
		}

		// when empty the requested asset does not belong to any (known) RTP
		if (!candidates.empty()) {
			if (game_rtp.empty()) {
				game_rtp = candidates;
			} else {
				// Strategy: Remove all RTP that are not candidates by comparing with all previous candidates
				// as the used RTP can only be the one that contains all by now requested assets
				for (auto it = game_rtp.begin(); it != game_rtp.end();) {
					if (std::find(candidates.begin(), candidates.end(), *it) == candidates.end()) {
						it = game_rtp.erase(it);
					} else {
						++it;
					}
				}
			}

			if (game_rtp.size() == 1) {
				// From now on the RTP lookups should be perfect
				Output::Debug("Game uses RTP \"{}\"", RTP::kTypes[(int) game_rtp[0]]);
			}
		}
	}

	if (game_rtp.empty()) {
		// The game RTP is currently unknown because all requested assets by now were not in any RTP
		// -> fallback to direct search
		is_rtp_asset = false;
		return normal_search();
	}

	// Search across all RTP
	for (const auto& rtp : detected_rtp) {
		for (RTP::Type grtp : game_rtp) {
			std::string rtp_entry = RTP::LookupRtpToRtp(dir, name, grtp, rtp.type, &is_rtp_asset);
			if (!rtp_entry.empty()) {
				std::string ret = rtp.tree.FindFile(dir, rtp_entry, exts);
				if (!ret.empty()) {
					is_rtp_asset = true;
					return rtp.tree.OpenInputStream(ret);
				}
			}
		}
	}

	// Asset is missing or not a RTP asset -> fallback to direct search
	return normal_search();
}

Filesystem_Stream::InputStream FileFinder_RTP::Lookup(std::string_view dir, std::string_view name, const Span<const std::string_view> exts) const {
	if (!disable_rtp) {
		bool is_rtp_asset;
		auto is = LookupInternal(lcf::ReaderUtil::Normalize(dir), lcf::ReaderUtil::Normalize(name), exts, is_rtp_asset);

		std::string lcase = lcf::ReaderUtil::Normalize(dir);
		bool is_audio_asset = lcase == "music" || lcase == "sound";

		if (is_rtp_asset) {
			if (is && game_has_full_package_flag && !warning_broken_rtp_game_shown && !is_audio_asset) {
				warning_broken_rtp_game_shown = true;
				Output::Warning("This game claims it does not need the RTP, but actually uses files from it!");
			} else if (!is && !game_has_full_package_flag && !is_audio_asset) {
				std::string msg = "Cannot find: {}/{}. " +
								  std::string(search_paths.empty() ?
											  "Install RTP {} to resolve this warning." : "RTP {} was probably not installed correctly.");
				Output::Warning(msg, dir, name, Player::EngineVersion());
			}
		}
		return is;
	}

	return Filesystem_Stream::InputStream();
}


/*end of file .\filefinder_rtp.cpp*/

/*start of file .\filesystem.cpp*/

/* ... license chunk ... */

#include "filesystem.h"
#include "filesystem_native.h"
#include "filesystem_lzh.h"
#include "filesystem_zip.h"
#include "filesystem_stream.h"
#include "filefinder.h"
#include "utils.h"
#include "output.h"
#include "player.h"
#include <lcf/reader_util.h>
#include <algorithm>
#include <cassert>
#include <utility>

Filesystem::Filesystem(std::string base_path, FilesystemView parent_fs) : base_path(std::move(base_path)) {
	this->parent_fs = std::make_unique<FilesystemView>(parent_fs);
	tree = DirectoryTree::Create(*this);
};

Filesystem_Stream::InputStream Filesystem::OpenInputStream(std::string_view name, std::ios_base::openmode m) const {
	if (name.empty()) {
		return Filesystem_Stream::InputStream();
	}

	std::streambuf* buf = CreateInputStreambuffer(name, m | std::ios_base::in);

	if (!buf) {
		return Filesystem_Stream::InputStream();
	}

	Filesystem_Stream::InputStream is(buf, ToString(name));
	return is;
}

Filesystem_Stream::InputStream Filesystem::OpenOrCreateInputStream(std::string_view name, std::ios_base::openmode m) const {
	auto is = OpenInputStream(name, m);

	if (!is) {
		auto os = OpenOutputStream(name, (std::ios_base::openmode)0);
		if (!os) {
			return Filesystem_Stream::InputStream();
		}
	}

	return OpenInputStream(name, m);
}

Filesystem_Stream::OutputStream Filesystem::OpenOutputStream(std::string_view name, std::ios_base::openmode m) const {
	if (name.empty()) {
		return Filesystem_Stream::OutputStream();
	}

	std::streambuf* buf = CreateOutputStreambuffer(name, m | std::ios_base::out);

	if (!buf) {
		return Filesystem_Stream::OutputStream();
	}

	std::string path;
	std::tie(path, std::ignore) = FileFinder::GetPathAndFilename(name);
	Filesystem_Stream::OutputStream os(buf, Subtree(path), ToString(name));

	return os;
}

void Filesystem::ClearCache(std::string_view path) const {
	tree->ClearCache(path);
}

FilesystemView Filesystem::Create(std::string_view path) const {
	// Determine the proper file system to use

	// When the path doesn't exist check if the path contains a file that can
	// be handled by another filesystem
	if (!IsDirectory(path, true)) {
		std::string dir_of_file;
		std::string path_prefix;
		std::vector<std::string> components = FileFinder::SplitPath(path);

		// TODO this should probably move to a static function in the FS classes
		// Search for the deepest directory
		int i = 0;
		for (const auto& comp : components) {
			// Do not check stuff that looks like drives, such as C:, ux0: or sd:
			// Some systems do not consider them directories
			if (i > 0 || (!comp.empty() && comp.back() != ':')) {
				if (!IsDirectory(FileFinder::MakePath(dir_of_file, comp), true)) {
					break;
				}
			}
			dir_of_file += comp + "/";
			++i;
		}

		if (!dir_of_file.empty()) {
			dir_of_file.pop_back();
		}

		// The next component must be a file
		// search for known file extensions and "do magic"
		std::string internal_path;
		bool handle_internal = false;
		for (const auto& comp : lcf::MakeSpan(components).subspan(i)) {
			if (handle_internal) {
				internal_path += comp + "/";
			} else {
				path_prefix += comp + "/";
				if (FileFinder::IsSupportedArchiveExtension(comp)) {
					path_prefix.pop_back();
					handle_internal = true;
				}
			}
		}

		if (!internal_path.empty()) {
			internal_path.pop_back();
		}

		std::shared_ptr<Filesystem> filesystem = std::make_shared<ZipFilesystem>(path_prefix, Subtree(dir_of_file));
		if (!filesystem->IsValid()) {
#if HAVE_LHASA
			filesystem = std::make_shared<LzhFilesystem>(path_prefix, Subtree(dir_of_file));
#endif
			if (!filesystem->IsValid()) {
				return {};
			}
		}
		if (!internal_path.empty()) {
			auto fs_view = filesystem->Create(internal_path);
			if (!fs_view) {
				return {};
			}
			return fs_view;
		}
		// This is the root of a new Filesystem
		// Check if it only contains a single folder and if yes enter that folder
		// This way archives with structure "archive/game_folder" launch the game directly
		auto fs_view = filesystem->Subtree("");
		if (!fs_view) {
			return {};
		}
		auto entries = fs_view.ListDirectory("");
		if (entries->size() == 1 && entries->begin()->second.type == DirectoryTree::FileType::Directory) {
			return fs_view.Subtree(entries->begin()->second.name);
		}
		return fs_view;
	} else {
		if (!(Exists(path) || !IsDirectory(path, true))) {
			return {};
		}

		// Handle as a normal path in the current filesystem
		return Subtree(ToString(path));
	}
}

FilesystemView Filesystem::Subtree(std::string sub_path) const {
	return FilesystemView(shared_from_this(), sub_path);
}

bool Filesystem::MakeDirectory(std::string_view, bool) const {
	return false;
}

bool Filesystem::IsValid() const {
	// FIXME: better way to do this?
	return Exists("");
}

std::string Filesystem::FindFile(std::string_view filename, const Span<const std::string_view> exts) const {
	return tree->FindFile(filename, exts);
}

std::string Filesystem::FindFile(std::string_view directory, std::string_view filename, const Span<const std::string_view> exts) const {
	return tree->FindFile(directory, filename, exts);
}

std::string Filesystem::FindFile(const DirectoryTree::Args& args) const {
	return tree->FindFile(args);
}

Filesystem_Stream::InputStream Filesystem::OpenFile(std::string_view filename, const Span<const std::string_view> exts) const {
	return OpenInputStream(tree->FindFile(filename, exts));
}

Filesystem_Stream::InputStream Filesystem::OpenFile(std::string_view directory, std::string_view filename, const Span<const std::string_view> exts) const {
	return OpenInputStream(tree->FindFile(directory, filename, exts));
}

Filesystem_Stream::InputStream Filesystem::OpenFile(const DirectoryTree::Args& args) const {
	return OpenInputStream(tree->FindFile(args));
}

FilesystemView::FilesystemView(const std::shared_ptr<const Filesystem>& fs, std::string sub_path) :
	fs(fs), sub_path(std::move(sub_path)) {
	valid = (fs->ListDirectory(this->sub_path) != nullptr);
}

std::string FilesystemView::GetBasePath() const {
	assert(fs);
	return fs->GetPath();
}

std::string FilesystemView::GetSubPath() const {
	assert(fs);
	return sub_path;
}

std::string FilesystemView::GetFullPath() const {
	assert(fs);
	return FileFinder::MakePath(GetBasePath(), GetSubPath());
}

const Filesystem& FilesystemView::GetOwner() const {
	assert(fs);
	return *fs;
}

void FilesystemView::ClearCache() const {
	assert(fs);
	fs->ClearCache(GetSubPath());
}

std::string FilesystemView::FindFile(std::string_view name, const Span<const std::string_view> exts) const {
	assert(fs);
	std::string found = fs->FindFile(MakePath(name), exts);
	if (!found.empty() && !sub_path.empty()) {
		assert(StartsWith(found, sub_path));
		// substr calculation must consider if the subpath is / or drive:/
		return found.substr(sub_path.size() + (sub_path.back() == '/' ? 0 : 1));
	}
	return found;
}

std::string FilesystemView::FindFile(std::string_view dir, std::string_view name, const Span<const std::string_view> exts) const {
	assert(fs);
	std::string found = fs->FindFile(MakePath(dir), name, exts);
	if (!found.empty() && !sub_path.empty()) {
		assert(StartsWith(found, sub_path));
		// substr calculation must consider if the subpath is / or drive:/
		return found.substr(sub_path.size() + (sub_path.back() == '/' ? 0 : 1));
	}
	return found;
}

std::string FilesystemView::FindFile(const DirectoryTree::Args& args) const {
	assert(fs);
	auto args_cp = args;
	std::string path = MakePath(args.path);
	args_cp.path = path;
	std::string found = fs->FindFile(args_cp);
	if (!found.empty() && !sub_path.empty()) {
		assert(StartsWith(found, sub_path));
		// substr calculation must consider if the subpath is / or drive:/
		return found.substr(sub_path.size() + (sub_path.back() == '/' ? 0 : 1));
	}
	return found;
}

Filesystem_Stream::InputStream FilesystemView::OpenFile(std::string_view name, const Span<const std::string_view> exts) const {
	assert(fs);
	return fs->OpenFile(MakePath(name), exts);
}

Filesystem_Stream::InputStream FilesystemView::OpenFile(std::string_view dir, std::string_view name, const Span<const std::string_view> exts) const {
	assert(fs);
	return fs->OpenFile(MakePath(dir), name, exts);
}

Filesystem_Stream::InputStream FilesystemView::OpenFile(const DirectoryTree::Args &args) const {
	assert(fs);
	auto args_cp = args;
	std::string path = MakePath(args.path);
	args_cp.path = path;
	return fs->OpenFile(args_cp);
}

std::string FilesystemView::MakePath(std::string_view subdir) const {
	assert(fs);
	return FileFinder::MakePath(sub_path, subdir);
}

bool FilesystemView::IsFile(std::string_view path) const {
	assert(fs);
	return fs->IsFile(MakePath(path));
}

bool FilesystemView::IsDirectory(std::string_view path, bool follow_symlinks) const {
	assert(fs);
	return fs->IsDirectory(MakePath(path), follow_symlinks);
}

bool FilesystemView::Exists(std::string_view path) const {
	assert(fs);
	return fs->Exists(MakePath(path));
}

int64_t FilesystemView::GetFilesize(std::string_view path) const {
	assert(fs);
	return fs->GetFilesize(MakePath(path));
}

DirectoryTree::DirectoryListType* FilesystemView::ListDirectory(std::string_view path) const {
	assert(fs);
	return fs->ListDirectory(MakePath(path));
}

Filesystem_Stream::InputStream FilesystemView::OpenInputStream(std::string_view name, std::ios_base::openmode m) const {
	assert(fs);

	if (name.empty()) {
		return Filesystem_Stream::InputStream();
	}

	return fs->OpenInputStream(MakePath(name), m);
}

Filesystem_Stream::InputStream FilesystemView::OpenOrCreateInputStream(std::string_view name, std::ios_base::openmode m) const {
	assert(fs);

	if (name.empty()) {
		return Filesystem_Stream::InputStream();
	}

	return fs->OpenOrCreateInputStream(MakePath(name), m);
}

Filesystem_Stream::OutputStream FilesystemView::OpenOutputStream(std::string_view name, std::ios_base::openmode m) const {
	assert(fs);

	if (name.empty()) {
		return Filesystem_Stream::OutputStream();
	}

	return fs->OpenOutputStream(MakePath(name), m);
}

std::streambuf* FilesystemView::CreateInputStreambuffer(std::string_view path, std::ios_base::openmode mode) const {
	assert(fs);
	return fs->CreateInputStreambuffer(MakePath(path), mode);
}

std::streambuf* FilesystemView::CreateOutputStreambuffer(std::string_view path, std::ios_base::openmode mode) const {
	assert(fs);
	return fs->CreateOutputStreambuffer(MakePath(path), mode);
}

FilesystemView FilesystemView::Create(std::string_view p) const {
	assert(fs);
	return fs->Create(MakePath(p));
}

bool FilesystemView::MakeDirectory(std::string_view dir, bool follow_symlinks) const {
	assert(fs);
	return fs->MakeDirectory(MakePath(dir), follow_symlinks);
}

bool FilesystemView::IsFeatureSupported(Filesystem::Feature f) const {
	assert(fs);
	return fs->IsFeatureSupported(f);
}

FilesystemView FilesystemView::Subtree(std::string_view sub_path) const {
	assert(fs);
	return FilesystemView(fs, MakePath(sub_path));
}

std::string FilesystemView::Describe() const {
	assert(fs);
	if (GetSubPath().empty()) {
		return fs->Describe();
	} else {
		return fs->Describe() + " -> " + GetSubPath();
	}
}


/*end of file .\filesystem.cpp*/

/*start of file .\filesystem_hook.cpp*/

/* ... license chunk ... */

#include "filesystem_hook.h"
#include "filesystem_stream.h"
#include "options.h"

#include <cassert>
#include <cstdio>
#include <streambuf>

class CaesarStreamBuf : public std::streambuf {
public:
	CaesarStreamBuf(std::streambuf* parent_sb, int n) : parent_sb(parent_sb), n(n) {
		setg(&buf, &buf + 1, &buf + 1);
	}
	CaesarStreamBuf(CaesarStreamBuf const& other) = delete;
	CaesarStreamBuf const& operator=(CaesarStreamBuf const& other) = delete;
	~CaesarStreamBuf() {
		delete parent_sb;
	}

protected:
	int_type underflow() override {
		auto byte = parent_sb->sbumpc();

		if (byte == traits_type::eof()) {
			return byte;
		}

		buf = traits_type::to_char_type(byte);
		buf -= n;

		setg(&buf, &buf, &buf + 1);

		return byte;
	}

	std::streambuf::pos_type seekoff(std::streambuf::off_type offset, std::ios_base::seekdir dir, std::ios_base::openmode) override {
		return parent_sb->pubseekoff(offset, dir);
	}

	std::streambuf::pos_type seekpos(std::streambuf::pos_type pos, std::ios_base::openmode) override {
		return parent_sb->pubseekpos(pos);
	}

private:
	std::streambuf* parent_sb;

	char buf;
	int n;
};


HookFilesystem::HookFilesystem(FilesystemView parent_fs, Hook hook) : Filesystem("", parent_fs), active_hook(hook) {
	// no-op
}

FilesystemView HookFilesystem::Detect(FilesystemView fs) {
	auto lmt = fs.OpenInputStream(TREEMAP_NAME);
	if (lmt) {
		std::array<char, 11> buf;

		lmt.ReadIntoObj(buf);

		if (!memcmp(buf.data(), "\xbMdgNbqUsff", 11)) {
			auto hook_fs = std::make_shared<HookFilesystem>(fs, Hook::SacredTears);
			return hook_fs->Subtree("");
		}
	}

	return fs;
}

bool HookFilesystem::IsFile(std::string_view path) const {
	return GetParent().IsFile(path);
}

bool HookFilesystem::IsDirectory(std::string_view path, bool follow_symlinks) const {
	return GetParent().IsDirectory(path, follow_symlinks);
}

bool HookFilesystem::Exists(std::string_view path) const {
	return GetParent().Exists(path);
}

int64_t HookFilesystem::GetFilesize(std::string_view path) const {
	return GetParent().GetFilesize(path);
}

bool HookFilesystem::MakeDirectory(std::string_view dir, bool follow_symlinks) const {
	return GetParent().MakeDirectory(dir, follow_symlinks);
}

bool HookFilesystem::IsFeatureSupported(Feature f) const {
	return GetParent().IsFeatureSupported(f);
}

std::streambuf* HookFilesystem::CreateInputStreambuffer(std::string_view path, std::ios_base::openmode mode) const {
	auto parent_sb = GetParent().CreateInputStreambuffer(path, mode);

	if (active_hook == Hook::SacredTears) {
		if (path == TREEMAP_NAME) {
			return new CaesarStreamBuf(parent_sb, 1);
		}
	}

	return parent_sb;
}

std::streambuf* HookFilesystem::CreateOutputStreambuffer(std::string_view path, std::ios_base::openmode mode) const {
	return GetParent().CreateOutputStreambuffer(path, mode);
}

bool HookFilesystem::GetDirectoryContent(std::string_view path, std::vector<DirectoryTree::Entry>& tree) const {
	auto dir_tree = GetParent().ListDirectory(path);

	if (!dir_tree) {
		return false;
	}

	for (auto& item: *dir_tree) {
		tree.push_back(item.second);
	}

	return true;
}

std::string HookFilesystem::Describe() const {
	assert(active_hook == Hook::SacredTears);

	return fmt::format("[Hook] ({})", "Sacred Tears");
}


/*end of file .\filesystem_hook.cpp*/

/*start of file .\filesystem_lzh.cpp*/

/* ... license chunk ... */

#include "system.h"

#ifdef HAVE_LHASA

#include "filesystem_lzh.h"
#include "filefinder.h"
#include "output.h"
#include "utils.h"

#include <lcf/encoder.h>
#include <lcf/reader_util.h>
#include <lcf/scope_guard.h>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <fmt/format.h>

#include "lhasa.h"

static std::string normalize_path(std::string_view path) {
	if (path == "." || path == "/" || path.empty()) {
		return "";
	};
	std::string inner_path = FileFinder::MakeCanonical(path, 1);
	std::replace(inner_path.begin(), inner_path.end(), '\\', '/');
	if (inner_path.front() == '.') {
		inner_path = inner_path.substr(1, inner_path.size() - 1);
	}
	if (inner_path.front() == '/') {
		inner_path = inner_path.substr(1, inner_path.size() - 1);
	}
	return inner_path;
}

static int vio_read_func(void* handle, void* buf, size_t buf_len) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(handle);
	if (buf_len == 0) return 0;
	return f->read(reinterpret_cast<char*>(buf), buf_len).gcount();
}

static int vio_skip_func(void* handle, size_t bytes) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(handle);
	f->seekg(bytes, std::ios_base::cur);
	return 1;
}

static size_t vio_read_dec_func(void* buf, size_t buf_len, void* user_data) {
	auto* f = reinterpret_cast<Filesystem_Stream::InputStream*>(user_data);
	if (buf_len == 0) return 0;
	f->read(reinterpret_cast<char*>(buf), buf_len);
	return f->gcount();
}

static LHAInputStreamType vio = {
	vio_read_func,
	vio_skip_func,
	nullptr // close not supported by istream interface
};

LzhFilesystem::LzhFilesystem(std::string base_path, FilesystemView parent_fs, std::string_view enc) :
	Filesystem(base_path, parent_fs) {
	is = parent_fs.OpenInputStream(GetPath());
	if (!is) {
		return;
	}

	lha_is.reset(lha_input_stream_new(&vio, &is));

	lha_reader.reset(lha_reader_new(lha_is.get()));

	if (!lha_reader) {
		Output::Debug("LzhFS: {} is not a valid archive", GetPath());
		return;
	}

	encoding = ToString(enc);
	LHAFileHeader* header;

	LzhEntry entry;
	std::vector<std::string> paths;

	// Read one file, when it fails consider it not an Lzh archive
	if (lha_reader_next_file(lha_reader.get()) == nullptr) {
		Output::Debug("LzhFS: {} is not a valid archive", GetPath());
		return;
	}

	Rewind();

	// Guess the encoding
	if (encoding.empty()) {
		std::stringstream filename_guess;
		int items = 0;

		while ((header = lha_reader_next_file(lha_reader.get())) != nullptr) {
			std::string filepath;

			// Only consider Non-ASCII and skip directories
			if (strcmp(header->compress_method, LHA_COMPRESS_TYPE_DIR) != 0) {
				filepath = header->filename;
				if (Utils::StringIsAscii(filepath)) {
					continue;
				}
				filename_guess << filepath;

				++items;
				if (items == 10) {
					break;
				}
			}
		}

		if (items == 0) {
			// Only ASCII text (UTF-8 compatible)
			encoding = "UTF-8";
		} else {
			std::vector<std::string> encodings = lcf::ReaderUtil::DetectEncodings(filename_guess.str());
			for (const auto &enc_ : encodings) {
				lcf::Encoder lcf_encoder(enc_);
				if (!lcf_encoder.IsOk()) {
					// Bad encoding
					Output::Debug("Bad encoding: {}. Trying next.", enc_);
					continue;
				}
				encoding = enc_;
				break;
			}
		}
		Output::Debug("Detected LZH encoding: {}", encoding);

		Rewind();

		if (!lha_reader) {
			Output::Debug("LzhFS: {} is not a valid archive", GetPath());
			return;
		}
	}

	// Read the archive
	lcf::Encoder lzh_encoder(encoding);

	// Compressed data offset is manually calculated to reduce calls to tellg()
	auto last_offset = is.tellg();

	while ((header = lha_reader_next_file(lha_reader.get())) != nullptr) {
		std::string filepath;

		if (!strcmp(header->compress_method, LHA_COMPRESS_TYPE_DIR)) {
			last_offset += header->raw_data_len;

			filepath = header->path;
			lzh_encoder.Encode(filepath);
			if (filepath.back() == '/') {
				filepath.pop_back();
			}
			paths.push_back(filepath);
		} else {
			entry.uncompressed_size = header->length;
			entry.compressed_size = header->compressed_length;
			entry.fileoffset = last_offset + static_cast<std::streamoff>(header->raw_data_len);
			last_offset = entry.fileoffset + entry.compressed_size;

			entry.is_directory = false;
			entry.compress_method = header->compress_method;
			if (header->path != nullptr) {
				// File is not in the root
				filepath = header->path;
				lzh_encoder.Encode(filepath);

				// Safety check: Directories should end with a /
				if (filepath.back() == '/') {
					paths.push_back(filepath);
					paths.back().pop_back();
				} else {
					paths.push_back(filepath);
					filepath += '/';
				}
			}
			std::string fname = header->filename;
			lzh_encoder.Encode(fname);
			filepath += fname;

			lzh_entries.emplace_back(filepath, entry);
		}

		// Determine intermediate directories
		for (;;) {
			filepath = std::get<0>(FileFinder::GetPathAndFilename(filepath));
			if (filepath.empty()) {
				break;
			}
			paths.push_back(filepath);
		}
	}

	// Build directories
	entry = {};
	entry.is_directory = true;

	// add root path
	paths.emplace_back("");

	std::sort(paths.begin(), paths.end());
	auto paths_del_it = std::unique(paths.begin(), paths.end());
	paths.erase(paths_del_it, paths.end());
	for (const auto& e : paths) {
		lzh_entries.emplace_back(e, entry);
	}

	// entries can be duplicated in the archive, e.g. when creating a game disk the RTP is embedded, followed by
	// the game entries. Use a stable sort to preserve this order.
	std::stable_sort(lzh_entries.begin(), lzh_entries.end(), [](auto& a, auto& b) {
		return a.first < b.first;
	});

	// Then remove all duplicates but keep the last
	auto entries_del_it = std::unique(lzh_entries.rbegin(), lzh_entries.rend(), [](auto& a, auto& b) {
		return a.first == b.first;
	});
	lzh_entries.erase(lzh_entries.begin(), entries_del_it.base());
}

bool LzhFilesystem::IsFile(std::string_view path) const {
	std::string path_normalized = normalize_path(path);
	auto entry = Find(path);
	if (entry) {
		return !entry->is_directory;
	}
	return false;
}

bool LzhFilesystem::IsDirectory(std::string_view path, bool) const {
	std::string path_normalized = normalize_path(path);
	auto entry = Find(path);
	if (entry) {
		return entry->is_directory;
	}
	return false;
}

bool LzhFilesystem::Exists(std::string_view path) const {
	std::string path_normalized = normalize_path(path);
	auto entry = Find(path);
	return entry != nullptr;
}

int64_t LzhFilesystem::GetFilesize(std::string_view path) const {
	std::string path_normalized = normalize_path(path);
	auto entry = Find(path);
	if (entry) {
		return entry->uncompressed_size;
	}
	return 0;
}

std::streambuf* LzhFilesystem::CreateInputStreambuffer(std::string_view path, std::ios_base::openmode) const {
	std::string path_normalized = normalize_path(path);
	auto entry = Find(path);
	if (entry && !entry->is_directory) {
		// Determine compression method
		auto* decoder_type = lha_decoder_for_name(const_cast<char*>(entry->compress_method.c_str()));

		if (!decoder_type) {
			Output::Warning("LzhFS: Unsupported compression method {} for {}", entry->compress_method, path_normalized);
			return nullptr;
		}

		// Seek to the compressed data
		is.clear();
		is.seekg(entry->fileoffset, std::ios_base::beg);

		// Create a suitable decoder for the compression method
		std::unique_ptr<LHADecoder, LhasaDeleter> decoder;
		decoder.reset(lha_decoder_new(decoder_type, vio_read_dec_func, &is, entry->uncompressed_size));

		// Decompress
		auto dec_buf = std::vector<uint8_t>(entry->uncompressed_size);
		size_t res = lha_decoder_read(decoder.get(), dec_buf.data(), dec_buf.size());

		if (res != entry->uncompressed_size) {
			Output::Warning("LzhFS: Less data compressed than expected ({})", path_normalized);
			return nullptr;
		}

		return new Filesystem_Stream::InputMemoryStreamBuf(std::move(dec_buf));
	}

	return nullptr;
}

bool LzhFilesystem::GetDirectoryContent(std::string_view path, std::vector<DirectoryTree::Entry>& entries) const {
	if (!IsDirectory(path, false)) {
		return false;
	}

	std::string path_normalized = normalize_path(path);
	if (!path_normalized.empty() && path_normalized.back() != '/') {
		path_normalized += "/";
	}

	auto check = [&](auto& it) {
		if (StartsWith(it.first, path_normalized) &&
			it.first.substr(path_normalized.size(), it.first.size() - path_normalized.size()).find_last_of('/') == std::string::npos) {
			// Everything that starts with the path but isn't the path and does contain no slash
			auto filename = it.first.substr(path_normalized.size(), it.first.size() - path_normalized.size());
			if (filename.empty()) {
				return;
			}

			entries.emplace_back(
					it.first.substr(path_normalized.size(), it.first.size() - path_normalized.size()),
					it.second.is_directory ? DirectoryTree::FileType::Directory : DirectoryTree::FileType::Regular);
		}
	};

	for (const auto& it : lzh_entries) {
		check(it);
	}

	return true;
}

const LzhFilesystem::LzhEntry* LzhFilesystem::Find(std::string_view what) const {
	auto it = std::lower_bound(lzh_entries.begin(), lzh_entries.end(), what, [](const auto& e, const auto& w) {
		return e.first < w;
	});
	if (it != lzh_entries.end() && it->first == what) {
		return &it->second;
	}

	return nullptr;
}

void LzhFilesystem::Rewind() {
	is.clear();
	is.seekg(0);

	// Cannot figure out how to rewind the reader: Creating a new one instead
	lha_reader.reset(lha_reader_new(lha_is.get()));
}

std::string LzhFilesystem::Describe() const {
	return fmt::format("[LZH] {} ({})", GetPath(), encoding);
}

#endif


/*end of file .\filesystem_lzh.cpp*/

/*start of file .\filesystem_native.cpp*/

/* ... license chunk ... */

#include "filesystem_native.h"
#include <cerrno>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <ios>
#include <string>
#include <vector>
#include <fmt/format.h>

#include "filesystem_stream.h"
#include "system.h"
#include "output.h"
#include "platform.h"

#ifdef USE_CUSTOM_FILEBUF
#  include <sys/stat.h>
#  include <fcntl.h>
#endif

NativeFilesystem::NativeFilesystem(std::string base_path, FilesystemView parent_fs) : Filesystem(std::move(base_path), parent_fs) {
}

bool NativeFilesystem::IsFile(std::string_view path) const {
	return Platform::File(ToString(path)).IsFile(false);
}

bool NativeFilesystem::IsDirectory(std::string_view dir, bool follow_symlinks) const {
	return Platform::File(ToString(dir)).IsDirectory(follow_symlinks);
}

bool NativeFilesystem::Exists(std::string_view filename) const {
	return Platform::File(ToString(filename)).Exists();
}

int64_t NativeFilesystem::GetFilesize(std::string_view path) const {
	return Platform::File(ToString(path)).GetSize();
}

std::streambuf* NativeFilesystem::CreateInputStreambuffer(std::string_view path, std::ios_base::openmode mode) const {
#ifdef USE_CUSTOM_FILEBUF
	(void)mode;
	int fd = open(ToString(path).c_str(), O_RDONLY);
	if (fd < 0) {
		return nullptr;
	}

	return new Filesystem_Stream::FdStreamBuf(fd, true);
#else
	auto buf = new std::filebuf();

	buf->open(
#ifdef _MSC_VER
		Utils::ToWideString(path),
#else
		ToString(path),
#endif
		mode);

	if (!buf->is_open()) {
		delete buf;
		return nullptr;
	}

	return buf;
#endif
}

std::streambuf* NativeFilesystem::CreateOutputStreambuffer(std::string_view path, std::ios_base::openmode mode) const {
#ifdef USE_CUSTOM_FILEBUF
	int flags = O_TRUNC;

	if ((mode & std::ios_base::app) == std::ios_base::app) {
		flags = O_APPEND;
	}

	int fd = open(ToString(path).c_str(), O_WRONLY | O_CREAT | flags, S_IRUSR | S_IWUSR);
	if (fd < 0) {
		return nullptr;
	}

	return new Filesystem_Stream::FdStreamBuf(fd, false);
#else
	auto* buf = new std::filebuf();
	buf->open(
#ifdef _MSC_VER
		Utils::ToWideString(path),
#else
		ToString(path),
#endif
		mode);

	if (!buf->is_open()) {
		delete buf;
		return nullptr;
	}

	return buf;
#endif
}

bool NativeFilesystem::GetDirectoryContent(std::string_view path, std::vector<DirectoryTree::Entry>& entries) const {
	std::string p = ToString(path);

	Platform::Directory dir(p);
	if (!dir) {
		Output::Debug("Error opening dir {}: {}", p, ::strerror(errno));
		return false;
	}

	while (dir.Read()) {
		const auto& name = dir.GetEntryName();
		Platform::FileType type = dir.GetEntryType();

		if (name == "." || name == "..") {
			continue;
		}

		bool is_directory = false;
		if (type == Platform::FileType::Directory) {
			is_directory = true;
		} else if (type == Platform::FileType::Unknown) {
			is_directory = IsDirectory(name, true);
		}

		entries.emplace_back(
			name,
			is_directory ? DirectoryTree::FileType::Directory : DirectoryTree::FileType::Regular);
	}

	return true;
}

bool NativeFilesystem::MakeDirectory(std::string_view path, bool follow_symlinks) const {
	return Platform::File(ToString(path)).MakeDirectory(follow_symlinks);
}

bool NativeFilesystem::IsFeatureSupported(Feature f) const {
	return f == Filesystem::Feature::Write;
}

std::string NativeFilesystem::Describe() const {
	return fmt::format("[Native] {}", GetPath());
}


/*end of file .\filesystem_native.cpp*/

/*start of file .\filesystem_root.cpp*/

/* ... license chunk ... */

#include "filesystem_root.h"
#include "output.h"

#if defined(__ANDROID__) && !defined(USE_LIBRETRO)
#  include "platform/android/filesystem_apk.h"
#  include "platform/android/filesystem_saf.h"
#endif

constexpr const std::string_view root_ns = "root://";

RootFilesystem::RootFilesystem() : Filesystem("", FilesystemView()) {
	// Add platform specific namespaces here
#if defined(__ANDROID__) && !defined(USE_LIBRETRO)
	fs_list.push_back(std::make_pair("apk", std::make_unique<ApkFilesystem>()));
	fs_list.push_back(std::make_pair("content", std::make_unique<SafFilesystem>("", FilesystemView())));
#endif

	// IMPORTANT: This must be the last filesystem in the list, do not push anything to fs_list afterwards!
	fs_list.push_back(std::make_pair("file", std::make_unique<NativeFilesystem>("", FilesystemView())));

	assert(fs_list.back().first == "file" && "File namespace must be last!");
}

FilesystemView RootFilesystem::Create(std::string_view path) const {
	if (StartsWith(path, root_ns)) {
		// Debug feature: root:// is a pseudo namespace
		// Shows a list of all namespaces in the Game Browser
		if (path.size() > root_ns.size()) {
			Output::Error("root:// does not support any path suffix");
		}
		return Subtree("");
	}

	const auto& fs = FilesystemForPath(path);
	// Strip namespace from path
	auto ns_pos = path.find("://");
	if (ns_pos != std::string::npos) {
		path = path.substr(ns_pos + 3);
	}
	return fs.Create(path);
}

bool RootFilesystem::IsFile(std::string_view path) const {
	return FilesystemForPath(path).IsFile(path);
}

bool RootFilesystem::IsDirectory(std::string_view path, bool follow_symlinks) const {
	return FilesystemForPath(path).IsDirectory(path, follow_symlinks);
}

bool RootFilesystem::Exists(std::string_view path) const {
	return FilesystemForPath(path).Exists(path);
}

int64_t RootFilesystem::GetFilesize(std::string_view  path) const {
	return FilesystemForPath(path).GetFilesize(path);
}

std::streambuf* RootFilesystem::CreateInputStreambuffer(std::string_view path, std::ios_base::openmode mode) const {
	return FilesystemForPath(path).CreateInputStreambuffer(path, mode);
}

std::streambuf* RootFilesystem::CreateOutputStreambuffer(std::string_view path, std::ios_base::openmode mode) const {
	return FilesystemForPath(path).CreateOutputStreambuffer(path, mode);

}

bool RootFilesystem::GetDirectoryContent(std::string_view path, std::vector<DirectoryTree::Entry>& tree) const {
	if (path.empty()) {
		// Debug feature: Return all available namespaces as a directory list
		for (const auto& p : fs_list) {
			tree.emplace_back(p.first + "://", DirectoryTree::FileType::Directory);
		}
		return true;
	}

	return FilesystemForPath(path).GetDirectoryContent(path, tree);
}

bool RootFilesystem::MakeDirectory(std::string_view path, bool follow_symlinks) const {
	return FilesystemForPath(path).MakeDirectory(path, follow_symlinks);
}

std::string RootFilesystem::Describe() const {
	return "[Root]";
}

const Filesystem& RootFilesystem::FilesystemForPath(std::string_view path) const {
	assert(!fs_list.empty());

	std::string_view ns;
	// Check if the path contains a namespace
	auto ns_pos = path.find("://");
	if (ns_pos != std::string::npos) {
		ns = path.substr(0, ns_pos);
		path = path.substr(ns_pos + 3);
	}

	if (ns.empty()) {
		// No namespace returns the last fs which is the NativeFilesystem
		return *fs_list.back().second;
	}

	auto it = std::find_if(fs_list.begin(), fs_list.end(), [&ns] (const auto& p) {
		return p.first == ns;
	});

	if (it == fs_list.end()) {
		// Only possible to trigger via commandline or bogus code, always user/dev error -> abort
		Output::Error("Unsupported namespace {}://{}", ns, path);
	}

	return *it->second;
}


/*end of file .\filesystem_root.cpp*/

/*start of file .\filesystem_stream.cpp*/

/* ... license chunk ... */

#include "filesystem_stream.h"

#include <utility>

#ifdef USE_CUSTOM_FILEBUF
#  include <unistd.h>
#endif

Filesystem_Stream::InputStream::InputStream(std::streambuf* sb, std::string name) :
	std::istream(sb), name(std::move(name)) {}

Filesystem_Stream::InputStream::~InputStream() {
	Close();
}

Filesystem_Stream::InputStream::InputStream(InputStream&& is) noexcept : std::istream(std::move(is)) {
	set_rdbuf(is.rdbuf());
	is.set_rdbuf(nullptr);
	name = std::move(is.name);
}

Filesystem_Stream::InputStream& Filesystem_Stream::InputStream::operator=(InputStream&& is) noexcept {
	if (this == &is) return *this;
	set_rdbuf(is.rdbuf());
	is.set_rdbuf(nullptr);
	name = std::move(is.name);
	std::istream::operator=(std::move(is));
	return *this;
}

std::string_view Filesystem_Stream::InputStream::GetName() const {
	return name;
}

std::streampos Filesystem_Stream::InputStream::GetSize() const {
	if (!size_cached) {
		size_cached = true;
		auto cur_pos = GetPosition();
		size = rdbuf()->pubseekoff(0, std::ios_base::end, std::ios_base::in);
		rdbuf()->pubseekoff(cur_pos, std::ios_base::beg, std::ios_base::in);
	}
	return size;
}

std::streampos Filesystem_Stream::InputStream::GetPosition() const {
	return rdbuf()->pubseekoff(0, std::ios_base::cur, std::ios_base::in);
}

void Filesystem_Stream::InputStream::Close() {
	delete rdbuf();
	set_rdbuf(nullptr);
}

Filesystem_Stream::OutputStream::OutputStream(std::streambuf* sb, FilesystemView fs, std::string name) :
	std::ostream(sb), fs(std::move(fs)), name(std::move(name)) {};

Filesystem_Stream::OutputStream::~OutputStream() {
	Close();
	if (fs) {
		fs.ClearCache();
	}
}

Filesystem_Stream::OutputStream::OutputStream(OutputStream&& os) noexcept : std::ostream(std::move(os)) {
	set_rdbuf(os.rdbuf());
	os.set_rdbuf(nullptr);
	name = std::move(os.name);
}

Filesystem_Stream::OutputStream& Filesystem_Stream::OutputStream::operator=(OutputStream&& os) noexcept {
	if (this == &os) return *this;
	set_rdbuf(os.rdbuf());
	os.set_rdbuf(nullptr);
	name = std::move(os.name);
	std::ostream::operator=(std::move(os));
	return *this;
}

std::string_view Filesystem_Stream::OutputStream::GetName() const {
	return name;
}

void Filesystem_Stream::OutputStream::Close() {
	delete rdbuf();
	set_rdbuf(nullptr);
}

Filesystem_Stream::InputMemoryStreamBufView::InputMemoryStreamBufView(Span<uint8_t> buffer_view)
		: std::streambuf(), buffer_view(buffer_view) {
	char* cbuffer = reinterpret_cast<char*>(buffer_view.data());
	setg(cbuffer, cbuffer, cbuffer + buffer_view.size());
}

std::streambuf::pos_type Filesystem_Stream::InputMemoryStreamBufView::seekoff(std::streambuf::off_type offset, std::ios_base::seekdir dir, std::ios_base::openmode mode) {
	std::streambuf::pos_type off;
	if (dir == std::ios_base::beg) {
		off = offset;
	} else if (dir == std::ios_base::cur) {
		off = gptr() - eback() + offset;
	} else {
		off = buffer_view.size() + offset;
	}
	return seekpos(off, mode);
}

std::streambuf::pos_type Filesystem_Stream::InputMemoryStreamBufView::seekpos(std::streambuf::pos_type pos, std::ios_base::openmode) {
	auto off = Utils::Clamp<std::streambuf::pos_type>(pos, 0, buffer_view.size());
	setg(eback(), eback() + off, egptr());
	return off;
}

Filesystem_Stream::InputMemoryStreamBuf::InputMemoryStreamBuf(std::vector<uint8_t> buffer)
		: InputMemoryStreamBufView(buffer), buffer(std::move(buffer)) {

}

#ifdef USE_CUSTOM_FILEBUF

Filesystem_Stream::FdStreamBuf::FdStreamBuf(int fd, bool is_read) : fd(fd), is_read(is_read) {
	if (is_read) {
		clear_buffer();
	} else {
		setp(buffer.end(), buffer.end());
	}
}

Filesystem_Stream::FdStreamBuf::~FdStreamBuf() {
	if (!is_read) {
		sync();
	}

	close(fd);
}

Filesystem_Stream::FdStreamBuf::int_type Filesystem_Stream::FdStreamBuf::underflow() {
	assert(gptr() == egptr());

	auto bytes_read = read(fd, buffer.begin(), buffer.size());
	if (bytes_read <= 0) {
		return traits_type::eof();
	}
	file_offset += bytes_read;

	setg(buffer.begin(), buffer.begin(), buffer.begin() + bytes_read);

	return traits_type::to_int_type(*gptr());
}

std::streambuf::pos_type Filesystem_Stream::FdStreamBuf::seekoff(std::streambuf::off_type offset, std::ios_base::seekdir dir, std::ios_base::openmode mode) {
	// Not implemented for writing
	assert(is_read);

	if (dir == std::ios_base::beg) {
		offset = offset - file_offset + bytes_remaining();
		dir = std::ios_base::cur;
	}

	if (dir == std::ios_base::cur) {
		if (offset < 0) {
			auto dist = std::distance(gptr(), gptr() - offset);
			if (gptr() + offset < eback()) {
				// Not cached: Outside of the buffer: Reposition the stream
				file_offset = lseek(fd, -dist - bytes_remaining(), SEEK_CUR);
				clear_buffer();
			} else {
				setg(buffer.begin(), gptr() - dist, egptr());
			}
		} else if (offset > 0) {
			auto dist = std::distance(gptr(), gptr() + offset);
			if (gptr() + offset > egptr()) {
				// Not cached: Outside of the buffer: Reposition the stream
				file_offset = lseek(fd, dist - bytes_remaining(), SEEK_CUR);
				clear_buffer();
			} else {
				setg(buffer.begin(), gptr() + dist, egptr());
			}
		}
		return file_offset - bytes_remaining();
	} else {
		// Not cached: Seek to end
		clear_buffer();
		file_offset = lseek(fd, offset, SEEK_END);

		if (file_offset < 0) {
			file_offset = 0;
			return -1;
		}

		return file_offset;
	}

	assert(false);
}

std::streambuf::pos_type Filesystem_Stream::FdStreamBuf::seekpos(std::streambuf::pos_type pos, std::ios_base::openmode mode) {
	return seekoff(pos, std::ios_base::beg, mode);
}


Filesystem_Stream::FdStreamBuf::int_type Filesystem_Stream::FdStreamBuf::overflow(int c) {
	assert(pptr() == epptr());

	if (c == traits_type::eof() || sync() == -1) {
		return traits_type::eof();
	}

	*pptr() = traits_type::to_char_type(c);

	pbump(1);
	return c;
}

int Filesystem_Stream::FdStreamBuf::sync() {
	char *p = pbase();
	while (p < pptr()) {
		int written = write(fd, p, pptr() - p);
		if (written <= 0) {
			return -1;
		}
		p += written;
	}

	setp(buffer.begin(), buffer.end());
	return 0;
}

void Filesystem_Stream::FdStreamBuf::clear_buffer() {
	setg(buffer.begin(), buffer.end(), buffer.end());
}

ssize_t Filesystem_Stream::FdStreamBuf::bytes_remaining() const {
	return egptr() - gptr();
}

#endif


/*end of file .\filesystem_stream.cpp*/

/*start of file .\filesystem_zip.cpp*/

/* ... license chunk ... */

#include "filesystem_zip.h"
#include "filefinder.h"
#include "output.h"
#include "utils.h"

#include <zlib.h>
#include <lcf/encoder.h>
#include <lcf/reader_util.h>
#include <lcf/scope_guard.h>
#include <iostream>
#include <sstream>
#include <cassert>
#include <algorithm>
#include <fmt/format.h>

constexpr char end_of_central_directory[] = "\x50\x4b\x05\x06";
constexpr int32_t end_of_central_directory_size = 18;

constexpr uint32_t central_directory_entry = 0x02014b50;
constexpr uint32_t local_header = 0x04034b50;
constexpr uint32_t local_header_size = 30;

static std::string normalize_path(std::string_view path) {
	if (path == "." || path == "/" || path.empty()) {
		return "";
	};
	std::string inner_path = FileFinder::MakeCanonical(path, 1);
	std::replace(inner_path.begin(), inner_path.end(), '\\', '/');
	if (inner_path.front() == '.') {
		inner_path = inner_path.substr(1, inner_path.size() - 1);
	}
	if (inner_path.front() == '/') {
		inner_path = inner_path.substr(1, inner_path.size() - 1);
	}
	return inner_path;
}

ZipFilesystem::ZipFilesystem(std::string base_path, FilesystemView parent_fs, std::string_view enc) :
	Filesystem(base_path, parent_fs) {
	zip_is = parent_fs.OpenInputStream(GetPath());
	if (!zip_is) {
		return;
	}

	uint16_t central_directory_entries = 0;
	uint32_t central_directory_size = 0;
	uint32_t central_directory_offset = 0;

	ZipEntry entry = {};
	entry.is_directory = false;
	std::string filepath;
	std::string filepath_cp437;
	bool is_utf8;

	encoding = ToString(enc);
	if (!FindCentralDirectory(zip_is, central_directory_offset, central_directory_size, central_directory_entries)) {
		Output::Debug("ZipFS: {} is not a valid archive", GetPath());
		return;
	}

	if (encoding.empty()) {
		zip_is.seekg(central_directory_offset);
		std::stringstream filename_guess;

		// Guess the encoding first
		int items = 0;
		while (ReadCentralDirectoryEntry(zip_is, filepath, entry, is_utf8)) {
			// Only consider Non-ASCII & Non-UTF8 for encoding detection
			// Directories are skipped as most of them are usually ASCII and do not help with the detection
			if (is_utf8 || filepath.back() == '/' || Utils::StringIsAscii(std::get<1>(FileFinder::GetPathAndFilename(filepath)))) {
				continue;
			}
			// Codepath will be only entered by Windows "compressed folder" ZIPs (uses local encoding) and
			// 7zip (uses CP932 for Western European filenames)

			auto pos = filepath.find_last_of('/');
			if (pos == std::string::npos) {
				filename_guess << filepath;
			} else {
				filename_guess << filepath.substr(pos + 1);
			}

			++items;

			if (items == 10) {
				break;
			}
		}

		if (items == 0) {
			// Only ASCII or UTF-8 flags set
			encoding = "UTF-8";
		} else {
			std::vector<std::string> encodings = lcf::ReaderUtil::DetectEncodings(filename_guess.str());
			for (const auto &enc_ : encodings) {
				lcf::Encoder lcf_encoder(enc_);
				if (!lcf_encoder.IsOk()) {
					// Bad encoding
					Output::Debug("Bad encoding: {}. Trying next.", enc_);
					continue;
				}
				encoding = enc_;
				break;
			}
		}
		Output::Debug("Detected ZIP encoding: {}", encoding);
	}
	bool enc_is_utf8 = encoding == "UTF-8";

	zip_is.clear();
	zip_is.seekg(central_directory_offset);

	lcf::Encoder detected_encoder(encoding);
	lcf::Encoder cp437_encoder("437");
	std::vector<std::string> paths;
	while (ReadCentralDirectoryEntry(zip_is, filepath, entry, is_utf8)) {
		if (is_utf8 || enc_is_utf8 || Utils::StringIsAscii(filepath)) {
			// No reencoding necessary
			filepath_cp437.clear();
		} else {
			// also store CP437 to ensure files inside 7zip zip archives are found
			filepath_cp437 = filepath;
			cp437_encoder.Encode(filepath_cp437);
			detected_encoder.Encode(filepath);
		}

		// Workaround ZIP archives containing invalid "\" paths created by .net or Powershell
		std::replace(filepath_cp437.begin(), filepath_cp437.end(), '\\', '/');
		std::replace(filepath.begin(), filepath.end(), '\\', '/');

		// check if the entry is an directory or not (indicated by trailing /)
		// this will fail when the (game) directory has cp437, but the users can rename it before
		if (filepath.back() == '/') {
			filepath = filepath.substr(0, filepath.size() - 1);

			// Determine intermediate directories
			while (!filepath.empty()) {
				paths.push_back(filepath);
				filepath = std::get<0>(FileFinder::GetPathAndFilename(filepath));
			}
		} else {
			zip_entries.emplace_back(filepath, entry);
			if (!filepath_cp437.empty()) {
				zip_entries_cp437.emplace_back(filepath_cp437, entry);
			}

			// Determine intermediate directories
			for (;;) {
				filepath = std::get<0>(FileFinder::GetPathAndFilename(filepath));
				if (filepath.empty()) {
					break;
				}
				paths.push_back(filepath);
			}
		}
	}
	// Build directories
	entry = {};
	entry.is_directory = true;

	// add root path
	paths.emplace_back("");

	std::sort(paths.begin(), paths.end());
	auto del = std::unique(paths.begin(), paths.end());
	paths.erase(del, paths.end());
	for (const auto& e : paths) {
		zip_entries.emplace_back(e, entry);
	}

	// entries can be duplicated in the archive, e.g. when appending to the archive.
	// Use a stable sort to preserve this order.
	std::stable_sort(zip_entries.begin(), zip_entries.end(), [](auto& a, auto& b) {
		return a.first < b.first;
	});
	std::stable_sort(zip_entries_cp437.begin(), zip_entries_cp437.end(), [](auto& a, auto& b) {
		return a.first < b.first;
	});

	// Then remove all duplicates but keep the last
	// The archive of the game "Steamed Hams" has a file with the same name as a folder. This filtering also helps against this issue.
	auto entries_del_it = std::unique(zip_entries.rbegin(), zip_entries.rend(), [](auto& a, auto& b) {
		return a.first == b.first;
	});
	zip_entries.erase(zip_entries.begin(), entries_del_it.base());

	entries_del_it = std::unique(zip_entries_cp437.rbegin(), zip_entries_cp437.rend(), [](auto& a, auto& b) {
		return a.first == b.first;
	});
	zip_entries_cp437.erase(zip_entries_cp437.begin(), entries_del_it.base());
}

bool ZipFilesystem::FindCentralDirectory(std::istream& zipfile, uint32_t& offset, uint32_t& size, uint16_t& num_entries) const {
	uint32_t magic = 0;
	bool found = false;

	// seek to the first position where the end_of_central_directory Signature may occur
	zipfile.seekg(-end_of_central_directory_size - UINT16_MAX, std::ios_base::end);
	zipfile.clear();

	// The only variable length field in the end of central directory is the comment which
	// has a maximum length of UINT16_MAX - so if we seek longer, this is no zip file
	std::vector<char> items(UINT16_MAX);
	zipfile.read(items.data(), items.size());
	zipfile.clear();

	items.resize(zipfile.gcount());
	if (items.size() < sizeof(magic)) {
		return false;
	}

	int i = static_cast<int>(items.size()) - sizeof(magic);
	// The data is read once and then scanned backwards in memory (faster)
	for (; i >= 0 && !found; --i) {
		if (!memcmp(items.data() + i, end_of_central_directory, 4)) {
			found = true;
			break;
		}
	}

	if (found) {
		zipfile.seekg(-(static_cast<int>(items.size()) - i - 4), std::ios_base::cur); // Move right after the magic
		zipfile.seekg(6, std::ios_base::cur); // Jump over multiarchive related fields
		zipfile.read(reinterpret_cast<char*>(&num_entries), sizeof(uint16_t));
		Utils::SwapByteOrder(num_entries);
		zipfile.read(reinterpret_cast<char*>(&size), sizeof(uint32_t));
		Utils::SwapByteOrder(size);
		zipfile.read(reinterpret_cast<char*>(&offset), sizeof(uint32_t));
		Utils::SwapByteOrder(offset);
		return true;
	}
	else {
		return false;
	}
}

bool ZipFilesystem::ReadCentralDirectoryEntry(std::istream& zipfile, std::string& filename, ZipEntry& entry, bool& is_utf8) const {
	uint32_t magic = 0;
	uint16_t flags;
	uint16_t filepath_length;
	uint16_t extra_field_length;
	uint16_t comment_length;

	zipfile.read(reinterpret_cast<char*>(&magic), sizeof(magic));
	Utils::SwapByteOrder(magic); // Take care of big endian systems
	if (magic != central_directory_entry) return false;
	zipfile.seekg(4, std::ios_base::cur); // Jump over currently not needed entries
	zipfile.read(reinterpret_cast<char*>(&flags), sizeof(uint16_t));
	Utils::SwapByteOrder(flags);
	is_utf8 = (flags & 0x800) == 0x800;
	zipfile.seekg(10, std::ios_base::cur); // Jump over currently not needed entries
	zipfile.read(reinterpret_cast<char*>(&entry.compressed_size), sizeof(uint32_t));
	Utils::SwapByteOrder(entry.compressed_size);
	zipfile.read(reinterpret_cast<char*>(&entry.uncompressed_size), sizeof(uint32_t));
	Utils::SwapByteOrder(entry.uncompressed_size);
	zipfile.read(reinterpret_cast<char*>(&filepath_length), sizeof(uint16_t));
	Utils::SwapByteOrder(filepath_length);
	zipfile.read(reinterpret_cast<char*>(&extra_field_length), sizeof(uint16_t));
	Utils::SwapByteOrder(extra_field_length);
	zipfile.read(reinterpret_cast<char*>(&comment_length), sizeof(uint16_t));
	Utils::SwapByteOrder(comment_length);
	zipfile.seekg(8, std::ios_base::cur); // Jump over currently not needed entries
	zipfile.read(reinterpret_cast<char*>(&entry.fileoffset), sizeof(uint32_t));
	Utils::SwapByteOrder(entry.fileoffset);
	if (filename_buffer.capacity() < filepath_length + 1u) {
		filename_buffer.resize(filepath_length + 1u);
	}
	zipfile.read(reinterpret_cast<char*>(filename_buffer.data()), filepath_length);
	filename = std::string(filename_buffer.data(), filepath_length);
	// Jump over currently not needed entries
	zipfile.seekg(comment_length + extra_field_length, std::ios_base::cur);
	return true;
}

bool ZipFilesystem::ReadLocalHeader(std::istream& zipfile, StorageMethod& method, ZipEntry& entry) const {
	uint32_t magic = 0;
	uint16_t filepath_length;
	uint16_t extra_field_length;
	uint16_t flags;
	uint16_t compression;

	zipfile.read(reinterpret_cast<char*>(&magic), sizeof(magic));
	Utils::SwapByteOrder(magic); // Take care of big endian systems
	if (magic != local_header) return false;
	zipfile.seekg(2, std::ios_base::cur); // Jump over currently not needed entries
	zipfile.read(reinterpret_cast<char*>(&flags), sizeof(uint16_t));
	Utils::SwapByteOrder(flags);
	zipfile.read(reinterpret_cast<char*>(&compression), sizeof(uint16_t));
	Utils::SwapByteOrder(compression);
	zipfile.seekg(8, std::ios_base::cur); // Jump over currently not needed entries
	zipfile.read(reinterpret_cast<char*>(&entry.compressed_size), sizeof(uint32_t));
	Utils::SwapByteOrder(entry.compressed_size);
	zipfile.read(reinterpret_cast<char*>(&entry.uncompressed_size), sizeof(uint32_t));
	Utils::SwapByteOrder(entry.uncompressed_size);
	zipfile.read(reinterpret_cast<char*>(&filepath_length), sizeof(uint16_t));
	Utils::SwapByteOrder(filepath_length);
	zipfile.read(reinterpret_cast<char*>(&extra_field_length), sizeof(uint16_t));
	Utils::SwapByteOrder(extra_field_length);

	switch (compression) {
	case 0:
		method = StorageMethod::Plain;
		break;
	case 8:
		method = StorageMethod::Deflate;
		break;
	default:
		method = StorageMethod::Unknown;
		break;
	}
	entry.fileoffset = local_header_size + filepath_length + extra_field_length;
	return true;
}

bool ZipFilesystem::IsFile(std::string_view path) const {
	std::string path_normalized = normalize_path(path);
	auto entry = Find(path);
	if (entry) {
		return !entry->is_directory;
	}
	return false;
}

bool ZipFilesystem::IsDirectory(std::string_view path, bool) const {
	std::string path_normalized = normalize_path(path);
	auto entry = Find(path);
	if (entry) {
		return entry->is_directory;
	}
	return false;
}

bool ZipFilesystem::Exists(std::string_view path) const {
	std::string path_normalized = normalize_path(path);
	auto entry = Find(path);
	return entry != nullptr;
}

int64_t ZipFilesystem::GetFilesize(std::string_view path) const {
	std::string path_normalized = normalize_path(path);
	auto entry = Find(path);
	if (entry) {
		return entry->uncompressed_size;
	}
	return 0;
}

std::streambuf* ZipFilesystem::CreateInputStreambuffer(std::string_view path, std::ios_base::openmode) const {
	std::string path_normalized = normalize_path(path);
	auto central_entry = Find(path);
	if (central_entry && !central_entry->is_directory) {
		zip_is.clear();
		zip_is.seekg(central_entry->fileoffset);
		StorageMethod method;
		ZipEntry local_entry = {};
		if (ReadLocalHeader(zip_is, method, local_entry)) {
			if (central_entry->compressed_size != local_entry.compressed_size) {
				if (local_entry.compressed_size == 0) {
					local_entry.compressed_size = central_entry->compressed_size;
				} else {
					Output::Warning("ZipFS: Compressed size mismatch {}: {} != {}", path_normalized, central_entry->compressed_size, local_entry.compressed_size);
					return nullptr;
				}
			}

			if (central_entry->uncompressed_size != local_entry.uncompressed_size) {
				if (local_entry.uncompressed_size == 0) {
					local_entry.uncompressed_size = central_entry->uncompressed_size;
				} else {
					Output::Warning("ZipFS: Uncompressed size mismatch {}: {} != {}", path_normalized, central_entry->uncompressed_size, local_entry.uncompressed_size);
					return nullptr;
				}
			}

			if (local_entry.compressed_size == 0xffffffff || local_entry.uncompressed_size == 0xffffffff) {
				Output::Warning("ZipFS: Zip64 is not supported {}", path_normalized);
				return nullptr;
			}

			zip_is.seekg(central_entry->fileoffset + local_entry.fileoffset);
			if (method == StorageMethod::Plain) {
				auto data = std::vector<uint8_t>(local_entry.uncompressed_size);
				zip_is.read(reinterpret_cast<char*>(data.data()), data.size());
				return new Filesystem_Stream::InputMemoryStreamBuf(std::move(data));
			} else if (method == StorageMethod::Deflate) {
				std::vector<uint8_t> comp_buf;
				comp_buf.resize(local_entry.compressed_size);
				zip_is.read(reinterpret_cast<char*>(comp_buf.data()), comp_buf.size());
				auto dec_buf = std::vector<uint8_t>(local_entry.uncompressed_size);
				z_stream zlib_stream = {};
				zlib_stream.next_in = reinterpret_cast<Bytef*>(comp_buf.data());
				zlib_stream.avail_in = static_cast<uInt>(comp_buf.size());
				zlib_stream.next_out = reinterpret_cast<Bytef*>(dec_buf.data());
				zlib_stream.avail_out = static_cast<uInt>(dec_buf.size());
				inflateInit2(&zlib_stream, -MAX_WBITS);
				auto inflate_sg = lcf::makeScopeGuard([&]() {
					inflateEnd(&zlib_stream);
				});

				int zlib_error = inflate(&zlib_stream, Z_NO_FLUSH);
				if (zlib_error == Z_OK) {
					Output::Warning("ZipFS: zlib failed for {}: More data available (Archive corrupted?)", path_normalized);
					return nullptr;
				}
				else if (zlib_error != Z_STREAM_END) {
					Output::Warning("ZipFS: zlib failed for {}: {} ({})", path_normalized, zlib_error, zlib_stream.msg ? zlib_stream.msg : "No error message");
					return nullptr;
				}
				return new Filesystem_Stream::InputMemoryStreamBuf(std::move(dec_buf));
			} else {
				Output::Warning("ZipFS: {} has unsupported compression format. Only Deflate is supported", path_normalized);
				return nullptr;
			}
		}
	}
	return nullptr;
}

bool ZipFilesystem::GetDirectoryContent(std::string_view path, std::vector<DirectoryTree::Entry>& entries) const {
	if (!IsDirectory(path, false)) {
		return false;
	}

	std::string path_normalized = normalize_path(path);
	if (!path_normalized.empty() && path_normalized.back() != '/') {
		path_normalized += "/";
	}

	auto check = [&](auto& it) {
		if (StartsWith(it.first, path_normalized) &&
			it.first.substr(path_normalized.size(), it.first.size() - path_normalized.size()).find_last_of('/') == std::string::npos) {
			// Everything that starts with the path but isn't the path and does contain no slash
			auto filename = it.first.substr(path_normalized.size(), it.first.size() - path_normalized.size());
			if (filename.empty()) {
				return;
			}

			entries.emplace_back(
					it.first.substr(path_normalized.size(), it.first.size() - path_normalized.size()),
					it.second.is_directory ? DirectoryTree::FileType::Directory : DirectoryTree::FileType::Regular);
		}
	};

	for (const auto& it : zip_entries) {
		check(it);
	}

	for (const auto& it : zip_entries_cp437) {
		check(it);
	}

	return true;
}

const ZipFilesystem::ZipEntry* ZipFilesystem::Find(std::string_view what) const {
	auto it = std::lower_bound(zip_entries.begin(), zip_entries.end(), what, [](const auto& e, const auto& w) {
		return e.first < w;
	});
	if (it != zip_entries.end() && it->first == what) {
		return &it->second;
	}

	it = std::lower_bound(zip_entries_cp437.begin(), zip_entries_cp437.end(), what, [](const auto& e, const auto& w) {
		return e.first < w;
	});
	if (it != zip_entries_cp437.end() && it->first == what) {
		return &it->second;
	}

	return nullptr;
}

std::string ZipFilesystem::Describe() const {
	return fmt::format("[Zip] {} ({})", GetPath(), encoding);
}


/*end of file .\filesystem_zip.cpp*/

/*start of file .\font.cpp*/

/* ... license chunk ... */

// Headers
#include <cstdint>
#include <map>
#include <type_traits>
#include <vector>
#include <iterator>

#include "filesystem_stream.h"
#include "system.h"
#include "game_system.h"
#include "main_data.h"

#ifdef HAVE_FREETYPE
#  include <ft2build.h>
#  include FT_FREETYPE_H
#  include FT_BITMAP_H
#  include FT_MODULE_H
#  include FT_TRUETYPE_TABLES_H
#endif

#ifdef HAVE_HARFBUZZ
#   include <hb-ft.h>
#endif

#include <lcf/reader_util.h>
#include "bitmapfont.h"

#include "filefinder.h"
#include "output.h"
#include "font.h"
#include "bitmap.h"
#include "utils.h"
#include "cache.h"
#include "player.h"
#include "compiler.h"

// Static variables.
namespace {
	template <typename T>
	BitmapFontGlyph const* find_glyph(const T& glyphset, char32_t code) {
		auto iter = std::lower_bound(std::begin(glyphset), std::end(glyphset), code);
		if(iter != std::end(glyphset) && iter->code == code) {
			return &*iter;
		} else {
			return NULL;
		}
	}

	// This is the last-resort function for finding a glyph, all the other fonts should fallback on it.
	// It tries to display a WenQuanYi glyph, and if it's not found, returns a replacement glyph.
	BitmapFontGlyph const* find_fallback_glyph(char32_t code) {
		auto* wqy = find_glyph(BITMAPFONT_WQY, code);
		if (wqy != NULL) {
			return wqy;
		}
		else {
			Output::Debug("glyph not found: {:#x}", uint32_t(code));
			return &BITMAPFONT_REPLACEMENT_GLYPH;
		}
	}

	BitmapFontGlyph const* find_baekmuk_glyph(char32_t code) {
		// Korean
		auto* baekmuk = find_glyph(BITMAPFONT_BAEKMUK, code);
		return baekmuk != NULL ? baekmuk : find_fallback_glyph(code);
	}

	BitmapFontGlyph const* find_gothic_glyph(char32_t code) {
		if (Player::IsCP936()) {
			// For simplified chinese prefer WQY
			auto* wqy = find_glyph(BITMAPFONT_WQY, code);
			if (wqy != NULL) {
				return wqy;
			}
		}
		// Shinonome Gothic -> Baekmuk (Korean) -> Fallback (WQY)
		auto* gothic = find_glyph(SHINONOME_GOTHIC, code);
		return gothic != NULL ? gothic : find_baekmuk_glyph(code);
	}

	BitmapFontGlyph const* find_mincho_glyph(char32_t code) {
		if (Player::IsCP936()) {
			// For simplified chinese prefer WQY
			auto* wqy = find_glyph(BITMAPFONT_WQY, code);
			if (wqy != NULL) {
				return wqy;
			}
		}
		// Shinonome Mincho -> Shinonome Gothic (see above)
		auto* mincho = find_glyph(SHINONOME_MINCHO, code);
		return mincho == NULL ? find_gothic_glyph(code) : mincho;
	}

	BitmapFontGlyph const* find_rmg2000_glyph(char32_t code) {
		// rmg2000 -> ttyp0 -> Shinonome Mincho (see above)
		auto* rmg2000 = find_glyph(BITMAPFONT_RMG2000, code);
		if (rmg2000 != NULL) {
			return rmg2000;
		}

		auto* ttyp0 = find_glyph(BITMAPFONT_TTYP0, code);
		return ttyp0 != NULL ? ttyp0 : find_mincho_glyph(code);
	}

	BitmapFontGlyph const* find_ttyp0_glyph(char32_t code) {
		// ttyp0 -> Shinonome Gothic (see above)
		auto* ttyp0 = find_glyph(BITMAPFONT_TTYP0, code);
		return ttyp0 != NULL ? ttyp0 : find_gothic_glyph(code);
	}

	struct BitmapFont final : public Font {
		enum { HEIGHT = 12, FULL_WIDTH = HEIGHT, HALF_WIDTH = FULL_WIDTH / 2 };

		using function_type = BitmapFontGlyph const*(*)(char32_t);

		BitmapFont(std::string_view name, function_type func);

		Rect vGetSize(char32_t glyph) const override;
		GlyphRet vRender(char32_t glyph) const override;

	private:
		function_type func;
		mutable BitmapRef glyph_bm;
	}; // class BitmapFont

#ifdef HAVE_FREETYPE
	FT_Library library = nullptr;

	struct FTFont final : public Font  {
		FTFont(Filesystem_Stream::InputStream is, int size, bool bold, bool italic);
		~FTFont() override;

		bool IsOk() const;
		Rect vGetSize(char32_t glyph) const override;
		GlyphRet vRender(char32_t glyph) const override;
		GlyphRet vRenderShaped(char32_t glyph) const override;
		bool vCanShape() const override;
#ifdef HAVE_HARFBUZZ
		std::vector<ShapeRet> vShape(std::u32string_view txt) const override;
#endif
		void vApplyStyle(const Style& style) override;

	private:
		void SetSize(int height, bool create);

		FT_Face face = nullptr;
		std::vector<uint8_t> ft_buffer;
		// Freetype uses the baseline as 0 and the built-in fonts the top
		// baseline_offset is subtracted from the baseline to get a proper rendering position
		int baseline_offset = 0;
		/** Workaround for bad kerning in RM2000 and RMG2000 fonts */
		bool rm2000_workaround = false;

#ifdef HAVE_HARFBUZZ
		hb_buffer_t* hb_buffer = nullptr;
		hb_font_t* hb_font = nullptr;
#endif
	}; // class FTFont
#endif

	/* Bitmap fonts used for the official Japanese version.
	   Compatible with MS Gothic and MS Mincho. Feature a closing quote in place of straight quote,
	   double-width Cyrillic letters (unusable for Russian, only useful for smileys and things like that)
	   and ellipsis in the middle of the line.
	*/
	FontRef const gothic = std::make_shared<BitmapFont>("Shinonome Gothic", &find_gothic_glyph);
	FontRef const mincho = std::make_shared<BitmapFont>("Shinonome Mincho", &find_mincho_glyph);

	/* Bitmap fonts used for non-Japanese games.
	   Compatible with RMG2000 and RM2000 shipped with Don Miguel's unofficial translation.
	   Feature a half-width Cyrillic and half-width ellipsis at the bottom of the line.
	*/
	FontRef const rmg2000 = std::make_shared<BitmapFont>("RMG2000-compatible", &find_rmg2000_glyph);
	FontRef const ttyp0 = std::make_shared<BitmapFont>("ttyp0", &find_ttyp0_glyph);

	FontRef default_gothic;
	FontRef default_mincho;

	struct ExFont final : public Font {
		public:
			enum { HEIGHT = 12, WIDTH = 12 };
			ExFont();
			Rect vGetSize(char32_t glyph) const override;
			GlyphRet vRender(char32_t glyph) const override;
		private:
			mutable BitmapRef bm;
	};

	/** FreeType Font Cache */
	struct CacheItem {
		FontRef font;
		Game_Clock::time_point last_access;
	};

	using key_type = std::string;
	std::unordered_map<key_type, CacheItem> ft_cache;

	// Hard to track the size of a font
	// Instead limit the cache to the last 3 referenced fonts
	constexpr int cache_limit = 3;
	size_t cache_size = 0;

	using namespace std::chrono_literals;

	void FreeFontMemory() {
		auto cur_ticks = Game_Clock::GetFrameTime();

		for (auto it = ft_cache.begin(); it != ft_cache.end();) {
			if (it->second.font.use_count() != 1) {
				// Font is referenced
				++it;
				continue;
			}

			auto last_access = cur_ticks - it->second.last_access;
			bool cache_exhausted = cache_size > cache_limit;
			if (cache_exhausted) {
				if (last_access <= 50ms) {
					// Used during the last 3 frames, must be important, keep it.
					++it;
					continue;
				}
			} else if (last_access <= 3s) {
				++it;
				continue;
			}
			cache_size -= 1;

			it = ft_cache.erase(it);
		}
	}
} // anonymous namespace

BitmapFont::BitmapFont(std::string_view name, function_type func)
	: Font(name, HEIGHT, false, false), func(func)
{}

Rect BitmapFont::vGetSize(char32_t glyph) const {
	auto bm_glyph = func(glyph);
	size_t units = bm_glyph->is_full ? 2 : 1;
	return {0, 0, static_cast<int>(units * HALF_WIDTH), HEIGHT};
}

Font::GlyphRet BitmapFont::vRender(char32_t glyph) const {
	std::vector<Font::GlyphRet> glyphs;

	if (EP_UNLIKELY(!glyph_bm)) {
		glyph_bm = Bitmap::Create(nullptr, FULL_WIDTH, HEIGHT, 0, DynamicFormat(8, 8, 0, 8, 0, 8, 0, 8, 0, PF::Alpha));
	}
	auto bm_glyph = func(glyph);
	auto width = bm_glyph->is_full ? FULL_WIDTH : HALF_WIDTH;

	glyph_bm->Clear();
	uint8_t* data = reinterpret_cast<uint8_t*>(glyph_bm->pixels());
	int pitch = glyph_bm->pitch();
	for (size_t y_ = 0; y_ < HEIGHT; ++y_)
		for (size_t x_ = 0; x_ < width; ++x_)
			data[y_ * pitch + x_] = (bm_glyph->data[y_] & (0x1 << x_)) ? 255 : 0;

	return { glyph_bm, {width, 0}, {0, 0} };
}

#ifdef HAVE_FREETYPE
FTFont::FTFont(Filesystem_Stream::InputStream is, int size, bool bold, bool italic)
	: Font(is.GetName(), size, bold, italic) {

	if (!library) {
		if (FT_Init_FreeType(&library) != FT_Err_Ok) {
			Output::Error("Couldn't initialize FreeType");
			return;
		}
	}

	assert(is);

	ft_buffer = Utils::ReadStream(is);

	FT_New_Memory_Face(library, ft_buffer.data(), ft_buffer.size(), 0, &face);

	if (face == nullptr) {
		return;
	}

	if (face->num_charmaps > 0) {
		// Force unicode charmap
		if (FT_Select_Charmap(face, FT_ENCODING_UNICODE) != 0) {
			// If this fails, force the first for legacy fonts (FON, BDF, etc.)
			FT_Set_Charmap(face, face->charmaps[0]);
		}
	}

	SetSize(size, true);

	if (!strcmp(face->family_name, "RM2000") || !strcmp(face->family_name, "RMG2000")) {
		// Workaround for bad kerning in RM2000 and RMG2000 fonts
		rm2000_workaround = true;
	}
}

FTFont::~FTFont() {
	if (!library) {
		// Freetype already shut down because of Player cleanup
		return;
	}

#ifdef HAVE_HARFBUZZ
	if (hb_buffer) {
		hb_buffer_destroy(hb_buffer);
	}

	if (hb_font) {
		hb_font_destroy(hb_font);
	}
#endif

	if (face) {
		FT_Done_Face(face);
	}
}

bool FTFont::IsOk() const {
	return face;
}

Rect FTFont::vGetSize(char32_t glyph) const {
	auto glyph_index = FT_Get_Char_Index(face, glyph);

	if (glyph_index == 0) {
		if (fallback_font) {
			return fallback_font->vGetSize(glyph);
		} else {
			return {0, 0, 0, current_style.size};
		}
	}

	auto load_glyph = [&](auto flags) {
		if (FT_Load_Glyph(face, glyph_index, flags) != FT_Err_Ok) {
			Output::Debug("Couldn't load FreeType character {:#x}", uint32_t(glyph));
			return false;
		}
		return true;
	};

	if (FT_HAS_COLOR(face)) {
		if (!load_glyph(FT_LOAD_COLOR)) {
			Output::Error("Broken color font for glyph {:#x}", uint32_t(glyph));
		}

		// When it is a color font check if the glyph is a color glyph
		// If it is not then reload the glyph monochrome
		if (face->glyph->bitmap.pixel_mode != FT_PIXEL_MODE_BGRA) {
			load_glyph(FT_LOAD_MONOCHROME | FT_LOAD_TARGET_MONO);
		}
	} else {
		if (!load_glyph(FT_LOAD_MONOCHROME | FT_LOAD_TARGET_MONO)) {
			if (fallback_font) {
				return fallback_font->vGetSize(glyph);
			} else {
				return {0, 0, 0, current_style.size};
			}
		}
	}

	FT_GlyphSlot slot = face->glyph;

	Point advance;
	advance.x = Utils::RoundTo<int>(slot->advance.x / 64.0);
	advance.y = Utils::RoundTo<int>(slot->advance.y / 64.0);

	if (EP_UNLIKELY(rm2000_workaround)) {
		advance.x = 6;
	}

	return {0, 0, advance.x, advance.y};
}

Font::GlyphRet FTFont::vRender(char32_t glyph) const {
	auto glyph_index = FT_Get_Char_Index(face, glyph);

	if (glyph_index == 0) {
		if (fallback_font) {
			return fallback_font->vRender(glyph);
		} else {
			return { {}, {0, current_style.size}, {0, 0}, false };
		}
	}

	return vRenderShaped(glyph_index);
}

Font::GlyphRet FTFont::vRenderShaped(char32_t glyph) const {
	if (glyph == 0) {
		if (fallback_font) {
			return fallback_font->vRender(glyph);
		} else {
			return { {}, {0, current_style.size}, {0, 0}, false };
		}
	}

	auto render_glyph = [&](auto flags, auto mode) {
		if (FT_Load_Glyph(face, glyph, flags) != FT_Err_Ok) {
			Output::Debug("Couldn't load FreeType character {:#x}", uint32_t(glyph));
			return false;
		}

		if (FT_Render_Glyph(face->glyph, mode) != FT_Err_Ok) {
			Output::Debug("Couldn't render FreeType character {:#x}", uint32_t(glyph));
			return false;
		}

		return true;
	};

	if (FT_HAS_COLOR(face)) {
		if (!render_glyph(FT_LOAD_COLOR, FT_RENDER_MODE_NORMAL)) {
			Output::Error("Broken color font for glyph {:#x}", uint32_t(glyph));
		}

		// When it is a color font check if the glyph is a color glyph
		// If it is not then rerender the glyph monochrome
		// FIXME: This is inefficient
		if (face->glyph->bitmap.pixel_mode != FT_PIXEL_MODE_BGRA) {
			render_glyph(FT_LOAD_MONOCHROME | FT_LOAD_TARGET_MONO, FT_RENDER_MODE_MONO);
		}
	} else {
		if (!render_glyph(FT_LOAD_MONOCHROME | FT_LOAD_TARGET_MONO, FT_RENDER_MODE_MONO)) {
			if (fallback_font) {
				return fallback_font->vRender(glyph);
			} else {
				return { {}, {0, current_style.size}, {0, 0}, false };
			}
		}
	}

	FT_GlyphSlot slot = face->glyph;
	FT_Bitmap* ft_bitmap = &slot->bitmap;

	assert(ft_bitmap->pixel_mode == FT_PIXEL_MODE_MONO || ft_bitmap->pixel_mode == FT_PIXEL_MODE_BGRA);

	size_t const pitch = std::abs(ft_bitmap->pitch);
	const int width = ft_bitmap->width;
	const int height = ft_bitmap->rows;

	BitmapRef bm;
	bool has_color = false;

	if (ft_bitmap->pixel_mode == FT_PIXEL_MODE_BGRA) {
		bm = Bitmap::Create(ft_bitmap->buffer, width, height, 0, format_B8G8R8A8_a().format());
		has_color = true;
	} else {
		bm = Bitmap::Create(width, height);
		auto* data = reinterpret_cast<uint32_t*>(bm->pixels());

		for (int row = 0; row < height; ++row) {
			for (int col = 0; col < width; ++col) {
				unsigned c = ft_bitmap->buffer[pitch * row + (col / 8)];
				unsigned bit = 7 - (col % 8);
				c = c & (0x01 << bit) ? 255 : 0;
				data[row * width + col] = (c << 24) + (c << 16) + (c << 8) + c;
			}
		}
	}

	Point advance;
	Point offset;

	advance.x = Utils::RoundTo<int>(slot->advance.x / 64.0);
	advance.y = Utils::RoundTo<int>(slot->advance.y / 64.0);
	offset.x = slot->bitmap_left;
	offset.y = slot->bitmap_top - baseline_offset;

	if (EP_UNLIKELY(rm2000_workaround)) {
		advance.x = 6;
	}

	return { bm, advance, offset, has_color };
}

bool FTFont::vCanShape() const {
#ifdef HAVE_HARFBUZZ
	return FT_IS_SFNT(face);
#else
	return false;
#endif
}

#ifdef HAVE_HARFBUZZ
std::vector<Font::ShapeRet> FTFont::vShape(std::u32string_view txt) const {
	hb_buffer_clear_contents(hb_buffer);

	hb_buffer_add_utf32(hb_buffer, reinterpret_cast<const uint32_t*>(txt.data()), txt.size(), 0, txt.size());
	hb_buffer_guess_segment_properties(hb_buffer);

	hb_shape(hb_font, hb_buffer, nullptr, 0);

	unsigned int glyph_count;
	hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(hb_buffer, &glyph_count);
	hb_glyph_position_t* glyph_pos = hb_buffer_get_glyph_positions(hb_buffer, &glyph_count);

	std::vector<Font::ShapeRet> ret;
	Point advance;
	Point offset;

	for (unsigned int i = 0; i < glyph_count; ++i) {
		auto& info = glyph_info[i];
		auto& pos = glyph_pos[i];

		if (info.codepoint == 0) {
			auto s = vGetSize(txt[info.cluster]);
			advance.x = s.width;
			advance.y = s.height;
			ret.push_back({txt[info.cluster], advance, offset, true});
		} else {
			advance.x = Utils::RoundTo<int>(pos.x_advance / 64.0);
			advance.y = Utils::RoundTo<int>(pos.y_advance / 64.0);
			offset.x = Utils::RoundTo<int>(pos.x_offset / 64.0);
			offset.y = Utils::RoundTo<int>(pos.y_offset / 64.0);
			ret.push_back({static_cast<char32_t>(info.codepoint), advance, offset, false});
		}
	}

	return ret;
}
#endif

void FTFont::vApplyStyle(const Style& style) {
	if (current_style.size == style.size) {
		return;
	}

	SetSize(style.size, false);
}

void FTFont::SetSize(int height, bool create) {
	if (FT_HAS_COLOR(face)) {
		// FIXME: Find the best size
		FT_Select_Size(face, 0);
	} else if (FT_IS_SCALABLE(face)) {
		// Calculate the pt size from px
		auto table_os2 = static_cast<TT_OS2*>(FT_Get_Sfnt_Table(face, ft_sfnt_os2));
		auto table_hori = static_cast<TT_HoriHeader*>(FT_Get_Sfnt_Table(face, ft_sfnt_hhea));

		if (table_os2 && table_hori) {
			int units;
			if (table_os2->usWinAscent + table_os2->usWinDescent == 0) {
				units = table_hori->Ascender - table_hori->Descender;
			} else {
				units = table_os2->usWinAscent + table_os2->usWinDescent;
			}

			int pt = FT_MulDiv(face->units_per_EM, height, units);
			if (FT_MulDiv(units, pt, face->units_per_EM) > height) {
				--pt;
			}

			height = std::max<int>(1, pt);
		}

		FT_Set_Pixel_Sizes(face, 0, height);
	} else {
		FT_Set_Pixel_Sizes(face, 0, face->available_sizes->height);
	}

#ifdef HAVE_HARFBUZZ
	if (create) {
		hb_buffer = hb_buffer_create();
	} else {
		// Without this the sizes become desynchronized
		hb_font_destroy(hb_font);
	}
	hb_font = hb_ft_font_create_referenced(face);
	hb_ft_font_set_funcs(hb_font);
#endif

	baseline_offset = static_cast<int>(FT_MulFix(face->ascender, face->size->metrics.y_scale) / 64);
	if (baseline_offset == 0) {
		// FIXME: Becomes 0 for FON files. How is the baseline calculated for them?
		baseline_offset = static_cast<int>(height * (10.0 / 12.0));
	}
}
#endif

FontRef Font::Default() {
	const bool m = (Main_Data::game_system && Main_Data::game_system->GetFontId() == lcf::rpg::System::Font_mincho);
	return Default(m);
}

FontRef Font::Default(bool const use_mincho) {
	if (use_mincho && default_mincho) {
		return default_mincho;
	} else if (!use_mincho && default_gothic) {
		return default_gothic;
	}

	return DefaultBitmapFont(use_mincho);
}

FontRef Font::DefaultBitmapFont() {
	const bool m = (Main_Data::game_system && Main_Data::game_system->GetFontId() == lcf::rpg::System::Font_mincho);
	return DefaultBitmapFont(m);
}

FontRef Font::DefaultBitmapFont(bool use_mincho) {
	if (Player::IsCJK()) {
		return use_mincho ? mincho : gothic;
	}
	else {
		return use_mincho ? rmg2000 : ttyp0;
	}
}

void Font::SetDefault(FontRef new_default, bool use_mincho) {
	if (use_mincho) {
		default_mincho = new_default;
	} else {
		default_gothic = new_default;
	}

	if (new_default) {
		new_default->SetFallbackFont(DefaultBitmapFont(use_mincho));
	}
}

FontRef Font::CreateFtFont(Filesystem_Stream::InputStream is, int size, bool bold, bool italic) {
#ifdef HAVE_FREETYPE
	if (!is) {
		return nullptr;
	}

	FreeFontMemory();

	std::string key = ToString(is.GetName()) + ":" + std::to_string(size) + ":" + (bold ? "T" : "F") + (italic ? "T" : "F");

	auto it = ft_cache.find(key);

	if (it == ft_cache.end()) {
		auto ft_font = std::make_shared<FTFont>(std::move(is), size, bold, italic);
		if (!ft_font || !ft_font->IsOk()) {
			return nullptr;
		}

		++cache_size;

		return (ft_cache[key] = {ft_font, Game_Clock::GetFrameTime()}).font;
	} else {
		it->second.last_access = Game_Clock::GetFrameTime();
		return it->second.font;
	}
#else
	return nullptr;
#endif
}

void Font::ResetDefault() {
	SetDefault(nullptr, true);
	SetDefault(nullptr, false);

#ifdef HAVE_FREETYPE
	auto& cfg = Player::player_config;
	if (!cfg.font1.Get().empty()) {
		auto is = FileFinder::Root().OpenInputStream(cfg.font1.Get());
		SetDefault(CreateFtFont(std::move(is), cfg.font1_size.Get(), false, false), false);
	}

	if (!cfg.font2.Get().empty()) {
		auto is = FileFinder::Root().OpenInputStream(cfg.font2.Get());
		SetDefault(CreateFtFont(std::move(is), cfg.font2_size.Get(), false, false), true);
	}

	cfg.font1.SetLocked(false);
	cfg.font2.SetLocked(false);
#endif
}

void Font::Dispose() {
	SetDefault(nullptr, true);
	SetDefault(nullptr, false);

#ifdef HAVE_FREETYPE
	if (library) {
		FT_Done_Library(library);
		library = nullptr;
	}
#endif
}

// Constructor.
Font::Font(std::string_view name, int size, bool bold, bool italic)
	: name(ToString(name))
{
	original_style.size = size;
	original_style.bold = bold;
	original_style.italic = italic;
	current_style = original_style;
}

std::string_view Font::GetName() const {
	return name;
}

Rect Font::GetSize(char32_t glyph) const {
	if (EP_UNLIKELY(Utils::IsControlCharacter(glyph))) {
		if (glyph == '\n') {
			return {0, 0, 0, static_cast<int>(current_style.size)};
		}

		return {};
	}

	Rect size = vGetSize(glyph);
	size.width += current_style.letter_spacing;
	size.height = current_style.size;

	return size;
}

Rect Font::GetSize(const ShapeRet& shape_ret) const {
	int width = shape_ret.advance.x + current_style.letter_spacing;
	int height = current_style.size;
	return {0, 0, width, height};
}

Point Font::Render(Bitmap& dest, int const x, int const y, const Bitmap& sys, int color, char32_t glyph) const {
	if (EP_UNLIKELY(Utils::IsControlCharacter(glyph))) {
		return {};
	}

	auto gret = vRender(glyph);

	if (EP_UNLIKELY(!RenderImpl(dest, x, y, sys, color, gret))) {
		return {};
	}

	gret.advance.x += current_style.letter_spacing;

	return gret.advance;
}

Point Font::Render(Bitmap& dest, int const x, int const y, const Bitmap& sys, int color, const Font::ShapeRet& shape) const {
	if (shape.not_found) {
		return Render(dest, x, y, sys, color, shape.code);
	}

	auto gret = vRenderShaped(shape.code);

	if (EP_UNLIKELY(!RenderImpl(dest, x, y, sys, color, gret))) {
		return {};
	}

	Point advance = { shape.advance.x + current_style.letter_spacing, shape.advance.y };
	return advance;
}

bool Font::RenderImpl(Bitmap& dest, int const x, int const y, const Bitmap& sys, int color, const GlyphRet& gret) const {
	if (EP_UNLIKELY(gret.bitmap == nullptr)) {
		return false;
	}

	auto rect = Rect(x, y, gret.bitmap->width(), gret.bitmap->height());
	if (EP_UNLIKELY(rect.width == 0)) {
		return false;
	}

	// Drawing position of the glyph
	rect.x += gret.offset.x;
	rect.y -= gret.offset.y;

	unsigned src_x = 0;
	unsigned src_y = 0;

	int glyph_height = gret.bitmap->height() - gret.offset.y;

	// Adjust how the mask is applied depending on the glyph size to prevent that
	// pixels from outside of the mask color are read
	// When <= 12: Will work fine
	// When <= 16: Slightly adjusted (see ~20 lines below)
	if (glyph_height > 16) {
		// Too large for the existing mask: Resize the masks (slow)
		// The mask is too small and the system graphic must be resized
		// This is usually an exception and requires a custom font
		const Rect shadow_color_rect = { 16, 32, 16, 16 };
		const Rect mask_color_rect = { color % 10 * 16, color / 10 * 16 + 48, 16, 16 };
		auto sys_large = Bitmap::Create(current_style.size * 2, current_style.size, false);
		double zoom = current_style.size / 16.0;
		// Left half of the image is the shadow, right half the mask
		if (color != ColorShadow && current_style.draw_shadow) {
			sys_large->ZoomOpacityBlit(0, 0, 0, 0, sys, shadow_color_rect, zoom, zoom, Opacity::Opaque());
		}
		if (!gret.has_color) {
			sys_large->ZoomOpacityBlit(current_style.size, 0, 0, 0, sys, mask_color_rect, zoom, zoom, Opacity::Opaque());
		}

		if (color != ColorShadow) {
			// First draw the shadow, offset by one
			if (!gret.has_color && current_style.draw_shadow) {
				auto shadow_rect = Rect(rect.x + 1, rect.y + 1, rect.width, rect.height);
				dest.MaskedBlit(shadow_rect, *gret.bitmap, 0, 0, *sys_large, 0, 0);
			}

			src_x = current_style.size;
			src_y -= gret.offset.y;
		}

		if (!gret.has_color) {
			if (current_style.draw_gradient) {
				dest.MaskedBlit(rect, *gret.bitmap, 0, 0, *sys_large, src_x, src_y);
			} else {
				auto col = sys.GetColorAt(current_style.color_offset.x + src_x, current_style.color_offset.y + src_y);
				auto col_bm = Bitmap::Create(gret.bitmap->width(), gret.bitmap->height(), col);
				dest.MaskedBlit(rect, *gret.bitmap, 0, 0, *col_bm, 0, 0);
			}
		} else {
			// Color glyphs, emojis etc.
			dest.Blit(rect.x, rect.y, *gret.bitmap, gret.bitmap->GetRect(), Opacity::Opaque());
		}

		return true;
	}

	// Glyph fits in the mask
	if (color != ColorShadow) {
		// First draw the shadow, offset by one
		if (!gret.has_color && current_style.draw_shadow) {
			auto shadow_rect = Rect(rect.x + 1, rect.y + 1, rect.width, rect.height);
			dest.MaskedBlit(shadow_rect, *gret.bitmap, 0, 0, sys, 16, 32);
		}

		src_x = color % 10 * 16 + 2;
		src_y = color / 10 * 16 + 48 + 16 - 12 - gret.offset.y;
	} else {
		// When the color is the shadow color do not render twice
		src_x = 16;
		src_y = 32;
	}

	if (!gret.has_color) {
		if (current_style.draw_gradient) {
			// When the glyph is large the system graphic color mask will be outside the rectangle
			// Move the mask slightly up to avoid this
 			if (glyph_height > 12) {
				// Slightly too large -> Apply an offset
				src_y -= glyph_height - 12;
			}

			dest.MaskedBlit(rect, *gret.bitmap, 0, 0, sys, src_x, src_y);
		} else {
			auto col = sys.GetColorAt(current_style.color_offset.x + src_x, current_style.color_offset.y + src_y);
			auto col_bm = Bitmap::Create(gret.bitmap->width(), gret.bitmap->height(), col);
			dest.MaskedBlit(rect, *gret.bitmap, 0, 0, *col_bm, 0, 0);
		}
	} else {
		// Color glyphs, emojis etc.
		dest.Blit(rect.x, rect.y, *gret.bitmap, gret.bitmap->GetRect(), Opacity::Opaque());
	}

	return true;
}

Point Font::Render(Bitmap& dest, int x, int y, Color const& color, char32_t glyph) const {
	if (EP_UNLIKELY(Utils::IsControlCharacter(glyph))) {
		return {};
	}

	auto gret = vRender(glyph);
	if (EP_UNLIKELY(gret.bitmap == nullptr)) {
		return {};
	}

	auto rect = Rect(x, y, gret.bitmap->width(), gret.bitmap->height());
	dest.MaskedBlit(rect, *gret.bitmap, 0, 0, color);

	gret.advance.x += current_style.letter_spacing;

	return gret.advance;
}

bool Font::CanShape() const {
	return vCanShape();
}

std::vector<Font::ShapeRet> Font::Shape(std::u32string_view text) const {
	assert(vCanShape());

	return vShape(text);
}

void Font::SetFallbackFont(FontRef fallback_font) {
	this->fallback_font = fallback_font;
}

bool Font::IsStyleApplied() const {
	return style_applied;
}

Font::Style Font::GetCurrentStyle() const {
	return current_style;
}

Font::StyleScopeGuard Font::ApplyStyle(Style new_style) {
	vApplyStyle(new_style);
	current_style = new_style;
	style_applied = true;

	return lcf::ScopeGuard<std::function<void()>>([&]() {
		vApplyStyle(original_style);
		current_style = original_style;
		style_applied = false;
	});
}

ExFont::ExFont() : Font("exfont", HEIGHT, false, false) {
}

FontRef Font::exfont = std::make_shared<ExFont>();

Font::GlyphRet ExFont::vRender(char32_t glyph) const {
	if (EP_UNLIKELY(!bm)) { bm = Bitmap::Create(WIDTH, HEIGHT, true); }
	auto exfont = Cache::Exfont();

	bool is_lower = (glyph >= 'a' && glyph <= 'z');
	bool is_upper = (glyph >= 'A' && glyph <= 'Z');

	if (!is_lower && !is_upper) {
		// Invalid ExFont
		return { bm, {WIDTH, 0}, {0, 0}, false };
	}

	glyph = is_lower ? (glyph - 'a' + 26) : (glyph - 'A');

	Rect const rect((glyph % 13) * WIDTH, (glyph / 13) * HEIGHT, WIDTH, HEIGHT);
	bm->Clear();
	bm->Blit(0, 0, *exfont, rect, Opacity::Opaque());

	// EasyRPG Extension: Support for colored ExFont
	bool has_color = false;
	const auto* pixels = reinterpret_cast<uint8_t*>(bm->pixels());
	// For performance reasons only check the red channel of every 4th pixel (16 = 4 * 4 RGBA pixel) for color
	for (int i = 0; i < bm->pitch() * bm->height(); i += 16) {
		auto pixel = pixels[i];
		if (pixel != 0 && pixel != 255) {
			has_color = true;
			break;
		}
	}

	return { bm, {WIDTH, 0}, {0, 0}, has_color };
}

Rect ExFont::vGetSize(char32_t) const {
	return Rect(0, 0, WIDTH, HEIGHT);
}


/*end of file .\font.cpp*/

/*start of file .\fps_overlay.cpp*/

/* ... license chunk ... */

#include <sstream>

#include "fps_overlay.h"
#include "game_clock.h"
#include "bitmap.h"
#include "utils.h"
#include "input.h"
#include "font.h"
#include "drawable_mgr.h"

using namespace std::chrono_literals;

static constexpr auto refresh_frequency = 1s;

FpsOverlay::FpsOverlay() :
	Drawable(Priority_Overlay + 100, Drawable::Flags::Global)
{
	DrawableMgr::Register(this);

	UpdateText();
}

void FpsOverlay::UpdateText() {
	auto fps = Utils::RoundTo<int>(Game_Clock::GetFPS());
	text = "FPS: " + std::to_string(fps);
	fps_dirty = true;
}

bool FpsOverlay::Update() {
	int mod = static_cast<int>(Game_Clock::GetGameSpeedFactor());
	if (mod != last_speed_mod) {
		speedup_dirty = true;
		last_speed_mod = mod;
	}

	auto now = Game_Clock::GetFrameTime();
	auto dt = now - last_refresh_time;
	if (dt < refresh_frequency) {
		return false;
	}
	last_refresh_time = now;

	UpdateText();

	return true;
}

void FpsOverlay::Draw(Bitmap& dst) {
	if (draw_fps) {
		if (fps_dirty) {
			std::string text = GetFpsString();
			Rect rect = Text::GetSize(*Font::DefaultBitmapFont(), text);

			if (!fps_bitmap || fps_bitmap->GetWidth() < rect.width + 1) {
				// Height never changes
				fps_bitmap = Bitmap::Create(rect.width + 1, rect.height - 1, true);
			}
			fps_bitmap->Clear();
			fps_bitmap->Fill(Color(0, 0, 0, 128));
			Text::Draw(*fps_bitmap, 1, 0, *Font::DefaultBitmapFont(), Color(255, 255, 255, 255), text);

			fps_rect = Rect(0, 0, rect.width + 1, rect.height - 1);

			fps_dirty = false;
		}

		dst.Blit(1, 2, *fps_bitmap, fps_rect, 255);
	}

	// Always drawn when speedup is on independent of FPS
	if (last_speed_mod > 1) {
		if (speedup_dirty) {
			std::string text = "> x" + std::to_string(last_speed_mod);

			Rect rect = Text::GetSize(*Font::DefaultBitmapFont(), text);

			if (!speedup_bitmap || speedup_bitmap->GetWidth() < rect.width + 1) {
				// Height never changes
				speedup_bitmap = Bitmap::Create(rect.width + 1, rect.height - 1, true);
			}
			speedup_bitmap->Clear();
			speedup_bitmap->Fill(Color(0, 0, 0, 128));
			Text::Draw(*speedup_bitmap, 1, 0, *Font::DefaultBitmapFont(), Color(255, 255, 255, 255), text);

			speedup_rect = Rect(0, 0, rect.width + 1, rect.height - 1);

			speedup_dirty = false;
		}

		int dwidth = dst.GetWidth();
		dst.Blit(dwidth - speedup_rect.width - 1, 2, *speedup_bitmap, speedup_rect, 255);
	}
}



/*end of file .\fps_overlay.cpp*/

/*start of file .\frame.cpp*/

/* ... license chunk ... */

// Headers
#include <string>
#include <vector>
#include "cache.h"
#include "bitmap.h"
#include "main_data.h"
#include "frame.h"
#include "drawable_mgr.h"

Frame::Frame() :
	Drawable(Priority_Frame)
{
	if (!lcf::Data::system.frame_name.empty() && lcf::Data::system.show_frame) {
		FileRequestAsync* request = AsyncHandler::RequestFile("Frame", lcf::Data::system.frame_name);
		request->SetGraphicFile(true);
		request_id = request->Bind(&Frame::OnFrameGraphicReady, this);
		request->Start();
	}

	DrawableMgr::Register(this);
}

void Frame::Update() {
	// no-op
}

void Frame::Draw(Bitmap& dst) {
	if (frame_bitmap) {
		dst.Blit(0, 0, *frame_bitmap, frame_bitmap->GetRect(), 255);
	}
}

void Frame::OnFrameGraphicReady(FileRequestResult* result) {
	frame_bitmap = Cache::Frame(result->file);
}


/*end of file .\frame.cpp*/

/*start of file .\game_actor.cpp*/

/* ... license chunk ... */

// Headers
#include <algorithm>
#include <sstream>
#include <iterator>
#include "game_actor.h"
#include "game_battle.h"
#include "game_party.h"
#include "sprite_actor.h"
#include "main_data.h"
#include "output.h"
#include "player.h"
#include <lcf/reader_util.h>
#include <lcf/rpg/skill.h>
#include "util_macro.h"
#include "utils.h"
#include "pending_message.h"
#include "attribute.h"
#include "rand.h"
#include "algo.h"
#include "game_message_terms.h"

constexpr int max_level_2k = 50;
constexpr int max_level_2k3 = 99;

int Game_Actor::MaxHpValue() const {
	auto& val = lcf::Data::system.easyrpg_max_actor_hp;
	if (val == -1) {
		return Player::IsRPG2k() ? 999 : 9999;
	}
	return val;
}

int Game_Actor::MaxSpValue() const {
	auto& val = lcf::Data::system.easyrpg_max_actor_sp;
	if (val == -1) {
		return 999;
	}
	return val;
}

int Game_Actor::MaxStatBattleValue() const {
	auto& val = lcf::Data::system.easyrpg_max_stat_battle_value;
	if (val == -1) {
		return 9999;
	}
	return val;
}

int Game_Actor::MaxStatBaseValue() const {
	auto& val = lcf::Data::system.easyrpg_max_stat_base_value;
	if (val == -1) {
		return 999;
	}
	return val;
}

int Game_Actor::MaxExpValue() const {
	auto& val = lcf::Data::system.easyrpg_max_exp;
	if (val == -1) {
		return Player::IsRPG2k() ? 999999 : 9999999;
	}
	return val;
}

Game_Actor::Game_Actor(int actor_id) {
	data.ID = actor_id;
	if (actor_id == 0) {
		return;
	}
	ReloadDbActor();

	data.two_weapon = dbActor->two_weapon;
	data.lock_equipment = dbActor->lock_equipment;
	data.auto_battle = dbActor->auto_battle;
	data.super_guard = dbActor->super_guard;

	data.hp_mod = 0;
	data.sp_mod = 0;
	data.attack_mod = 0;
	data.defense_mod = 0;
	data.spirit_mod = 0;
	data.agility_mod = 0;

	MakeExpList();
	SetBattlePosition(GetOriginalPosition());

	data.level = 0;
	if (dbActor->initial_level > 0) {
		// For games like COLORS: Lost Memories which use level 0, don't change level because it'll clamp to 1.
		ChangeLevel(dbActor->initial_level, nullptr);
	}
	SetHp(GetMaxHp());
	SetSp(GetMaxSp());

	// Remove items that do not exist in the database anymore
	std::array<int, 5> ids = {{
		dbActor->initial_equipment.weapon_id,
		dbActor->initial_equipment.shield_id,
		dbActor->initial_equipment.armor_id,
		dbActor->initial_equipment.helmet_id,
		dbActor->initial_equipment.accessory_id }};
	std::replace_if(ids.begin(), ids.end(), [] (const int& item_id) {
		return lcf::ReaderUtil::GetElement(lcf::Data::items, item_id) == nullptr;
	}, 0);

	for (int i = 0; i <= 4; i++) {
		SetEquipment(i + 1, ids[i]);
	}

	data.status.resize(lcf::Data::states.size(), 0);

	Fixup();
}

void Game_Actor::SetSaveData(lcf::rpg::SaveActor save) {
	if (data.ID != save.ID) {
		Output::Debug("Game_Actor: Fixing actor ID mismatch {} != {}", save.ID, data.ID);
		save.ID = data.ID;
	}

	data = std::move(save);

	if (Player::IsRPG2k()) {
		data.two_weapon = dbActor->two_weapon;
		data.lock_equipment = dbActor->lock_equipment;
		data.auto_battle = dbActor->auto_battle;
		data.super_guard = dbActor->super_guard;
	}

	MakeExpList();
	Fixup();
}

void Game_Actor::ReloadDbActor() {
	dbActor = lcf::ReaderUtil::GetElement(lcf::Data::actors, GetId());
}

lcf::rpg::SaveActor Game_Actor::GetSaveData() const {
	auto save = data;
	if (Player::IsRPG2k()) {
		// RPG_RT doesn't save these chunks in rm2k as they are meaningless
		save.two_weapon = false;
		save.lock_equipment = false;
		save.auto_battle = false;
		save.super_guard = false;
	}
	return save;
}

void Game_Actor::Fixup() {
	RemoveInvalidData();
	ResetEquipmentStates(false);
}

bool Game_Actor::UseItem(int item_id, const Game_Battler* source) {
	const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
	if (!item) {
		Output::Warning("UseItem: Can't use invalid item {}", item_id);
		return false;
	}

	if (!IsDead()) {
		if (item->type == lcf::rpg::Item::Type_book) {
			return LearnSkill(item->skill_id, nullptr);
		}

		if (item->type == lcf::rpg::Item::Type_material) {
			SetBaseMaxHp(GetBaseMaxHp() + item->max_hp_points);
			SetBaseMaxSp(GetBaseMaxSp() + item->max_sp_points);
			SetBaseAtk(GetBaseAtk() + item->atk_points2);
			SetBaseDef(GetBaseDef() + item->def_points2);
			SetBaseAgi(GetBaseAgi() + item->agi_points2);
			SetBaseSpi(GetBaseSpi() + item->spi_points2);

			return true;
		}
	}

	return Game_Battler::UseItem(item_id, source);
}

bool Game_Actor::IsItemUsable(int item_id) const {
	const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
	if (!item) {
		Output::Warning("IsItemUsable: Invalid item ID {}", item_id);
		return false;
	}

	int query_idx = GetId() - 1;
	auto* query_set = &item->actor_set;
	if (Player::IsRPG2k3() && lcf::Data::system.equipment_setting == lcf::rpg::System::EquipmentSetting_class) {
		auto* cls = GetClass();

		// Class index. If there's no class, in the "class_set" it's equal to 0. The first class is 1, not 0
		query_idx = cls ? cls->ID : 0;
		query_set = &item->class_set;
	}

	// If the actor or class ID is out of range this is an optimization in the ldb file
	// (all actors or classes missing can equip the item)
	if (query_set->size() <= (unsigned)(query_idx)) {
		return true;
	}
	return (*query_set)[query_idx];
}

bool Game_Actor::IsSkillLearned(int skill_id) const {
	return std::find(data.skills.begin(), data.skills.end(), skill_id) != data.skills.end();
}

bool Game_Actor::IsSkillUsable(int skill_id) const {
	const lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, skill_id);
	if (!skill) {
		Output::Warning("IsSkillUsable: Invalid skill ID {}", skill_id);
		return false;
	}

	if (!skill->affect_attr_defence) {
		// Actor must have all attributes of the skill equipped as weapons
		const auto* w1 = GetWeapon();
		const auto* w2 = Get2ndWeapon();

		for (size_t i = 0; i < skill->attribute_effects.size(); ++i) {
			bool required = skill->attribute_effects[i] && lcf::Data::attributes[i].type == lcf::rpg::Attribute::Type_physical;
			if (required) {
				if (w1 && i < w1->attribute_set.size() && w1->attribute_set[i]) {
					continue;
				}
				if (w2 && i < w2->attribute_set.size() && w2->attribute_set[i]) {
					continue;
				}
				return false;
			}
		}
	}

	return Game_Battler::IsSkillUsable(skill_id);
}

int Game_Actor::CalculateSkillCost(int skill_id) const {
	const lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, skill_id);
	if (!skill) {
		Output::Warning("CalculateSkillCost: Invalid skill ID {}", skill_id);
		return 0;
	}
	return Algo::CalcSkillCost(*skill, GetMaxSp(), HasHalfSpCost());
}

bool Game_Actor::LearnSkill(int skill_id, PendingMessage* pm) {
	if (skill_id > 0 && !IsSkillLearned(skill_id)) {
		const lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, skill_id);
		if (!skill) {
			Output::Warning("Actor {}: Can't learn invalid skill {}", GetId(), skill_id);
			return false;
		}

		data.skills.push_back((int16_t)skill_id);
		std::sort(data.skills.begin(), data.skills.end());

		if (pm) {
			pm->PushLine(ActorMessage::GetLearningMessage(*this, *skill));
		}

		return true;
	}
	return false;
}

int Game_Actor::LearnLevelSkills(int min_level, int max_level, PendingMessage* pm) {
	auto& skills = data.class_id > 0 ? GetClass()->skills : dbActor->skills;

	int count = 0;

	// Learn new skills
	for (const lcf::rpg::Learning& learn : skills) {
		// Skill learning, up to current level
		if (learn.level >= min_level && learn.level <= max_level) {
			const auto* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, learn.skill_id);
			if (!skill) {
				Output::Debug("Actor {}: Level up (level={}). Ignoring invalid skill {}", GetId(), learn.level, learn.skill_id);
			} else {
				count += LearnSkill(learn.skill_id, pm);
			}
		}
	}
	return count;
}

bool Game_Actor::UnlearnSkill(int skill_id) {
	std::vector<int16_t>::iterator it = std::find(data.skills.begin(), data.skills.end(), skill_id);
	if (it != data.skills.end()) {
		data.skills.erase(it);
		return true;
	}
	return false;
}

void Game_Actor::UnlearnAllSkills() {
	data.skills.clear();
}

void Game_Actor::SetFace(const std::string& file_name, int index) {
	if (file_name == dbActor->face_name && index == dbActor->face_index) {
		data.face_name = "";
		data.face_id = 0;
	} else {
		data.face_name.assign(file_name);
		data.face_id = index;
	}
}

const lcf::rpg::Item* Game_Actor::GetEquipment(int equip_type) const {
	if (equip_type <= 0 || equip_type > (int)data.equipped.size())
		return nullptr;

	int item_id = data.equipped[equip_type - 1];
	return lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
}

int Game_Actor::SetEquipment(int equip_type, int new_item_id) {
	if (equip_type <= 0 || equip_type > (int) data.equipped.size())
		return -1;

	int old_item_id = data.equipped[equip_type - 1];
	const lcf::rpg::Item* old_item = lcf::ReaderUtil::GetElement(lcf::Data::items, old_item_id);

	const lcf::rpg::Item* new_item = lcf::ReaderUtil::GetElement(lcf::Data::items, new_item_id);
	if (new_item_id != 0 && !new_item) {
		Output::Warning("SetEquipment: Can't equip item with invalid ID {}", new_item_id);
		new_item_id = 0;
	}

	data.equipped[equip_type - 1] = (short)new_item_id;

	AdjustEquipmentStates(old_item, false, false);
	AdjustEquipmentStates(new_item, true, false);

	return old_item_id;
}

void Game_Actor::ChangeEquipment(int equip_type, int item_id) {
	if (item_id != 0 && !IsItemUsable(item_id)) {
		return;
	}

	int prev_item = SetEquipment(equip_type, item_id);

	if (prev_item != 0) {
		Main_Data::game_party->AddItem(prev_item, 1);
	}
	if (item_id != 0) {
		Main_Data::game_party->RemoveItem(item_id, 1);
	}

	// In case you have a two_handed weapon equipped, the other weapon is removed.
	const lcf::rpg::Item* item = GetWeapon();
	const lcf::rpg::Item* item2 = Get2ndWeapon();
	if (item2 == nullptr) {
		item2 = GetShield();
	}
	if (item && item2 && ((item->type == lcf::rpg::Item::Type_weapon && item->two_handed) || (item2->type == lcf::rpg::Item::Type_weapon && item2->two_handed))) {
		ChangeEquipment(equip_type == lcf::rpg::Item::Type_weapon ? equip_type + 1 : equip_type - 1, 0);
	}
}

bool Game_Actor::IsEquipped(int equip_id) const {
	for (auto equip : GetWholeEquipment()) {
		if (equip == equip_id) {
			return true;
		}
	}
	return false;
}

void Game_Actor::RemoveWholeEquipment() {
	for (int i = 1; i <= 5; ++i) {
		ChangeEquipment(i, 0);
	}
}

int Game_Actor::GetItemCount(int item_id) {
	int number = 0;

	// quirk: 0 is "no item in slot"
	// This can be used to count how many slots are empty
	if (item_id >= 0) {
		for (int16_t i : GetWholeEquipment()) {
			if (item_id == i) {
				++number;
			}
		}
	}

	return number;
}

void Game_Actor::FullHeal() {
	RemoveAllStates();
	SetHp(GetMaxHp());
	SetSp(GetMaxSp());
	// Emulates RPG_RT behavior of resetting even battle equipment states on full heal.
	ResetEquipmentStates(true);
}

int Game_Actor::GetBaseMaxHp(bool mod) const {
	int n = 0;
	// Special handling for games that use a level of 0 -> Return 0 Hp
	// Same applies for other stats
	if (GetLevel() > 0) {
		// Looks like RPG_RT only applies Class changes (class_id > 0 - 20kdc)
		// when the class was changed by the ChangeClass event, otherwise it uses
		// the normal actor attributes.
		n = data.class_id > 0
			? *lcf::ReaderUtil::GetElement(GetClass()->parameters.maxhp, GetLevel())
			: *lcf::ReaderUtil::GetElement(dbActor->parameters.maxhp, GetLevel());
	}

	if (mod)
		n += data.hp_mod;

	return Utils::Clamp(n, 1, MaxHpValue());
}

int Game_Actor::GetBaseMaxHp() const {
	return GetBaseMaxHp(true);
}

int Game_Actor::GetBaseMaxSp(bool mod) const {
	int n = 0;
	if (GetLevel() > 0) {
		n = data.class_id > 0
			? *lcf::ReaderUtil::GetElement(GetClass()->parameters.maxsp, GetLevel())
			: *lcf::ReaderUtil::GetElement(dbActor->parameters.maxsp, GetLevel());
	}

	if (mod)
		n += data.sp_mod;

	return Utils::Clamp(n, 0, MaxSpValue());
}

int Game_Actor::GetBaseMaxSp() const {
	return GetBaseMaxSp(true);
}

static bool IsArmorType(const lcf::rpg::Item* item) {
	return item->type == lcf::rpg::Item::Type_shield
		|| item->type == lcf::rpg::Item::Type_armor
		|| item->type == lcf::rpg::Item::Type_helmet
		|| item->type == lcf::rpg::Item::Type_accessory;
}

template <bool allow_weapon, bool allow_armor, typename F>
void ForEachEquipment(Span<const short> equipped, F&& f, Game_Battler::Weapon weapon = Game_Battler::WeaponAll) {
	for (int slot = 0; slot < static_cast<int>(equipped.size()); ++slot) {
		const auto item_id = equipped[slot];
		if (item_id <= 0) {
			continue;
		}

		auto* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
		// Invalid equipment was removed
		assert(item != nullptr);

		if (item->type == lcf::rpg::Item::Type_weapon) {
			if (!allow_weapon || (weapon != Game_Battler::WeaponAll && weapon != slot + 1)) {
				continue;
			}
		} else if (IsArmorType(item)) {
			if (!allow_armor) {
				continue;
			}
		} else {
			assert(false && "Invalid item type equipped!");
			continue;
		}

		f(*item);
	}
}

int Game_Actor::GetBaseAtk(Weapon weapon, bool mod, bool equip) const {
	int n = 0;
	if (GetLevel() > 0) {
		n = data.class_id > 0
			? *lcf::ReaderUtil::GetElement(GetClass()->parameters.attack, GetLevel())
			: *lcf::ReaderUtil::GetElement(dbActor->parameters.attack, GetLevel());
	}

	if (mod) {
		n += data.attack_mod;
	}

	if (equip) {
		ForEachEquipment<true,true>(GetWholeEquipment(), [&](auto& item) { n += item.atk_points1; }, weapon);
	}

	return Utils::Clamp(n, 1, MaxStatBaseValue());
}

int Game_Actor::GetBaseAtk(Weapon weapon) const {
	return GetBaseAtk(weapon, true, true);
}

int Game_Actor::GetBaseDef(Weapon weapon, bool mod, bool equip) const {
	int n = 0;
	if (GetLevel() > 0) {
		n = data.class_id > 0
			? *lcf::ReaderUtil::GetElement(GetClass()->parameters.defense, GetLevel())
			: *lcf::ReaderUtil::GetElement(dbActor->parameters.defense, GetLevel());
	}

	if (mod) {
		n += data.defense_mod;
	}

	if (equip) {
		ForEachEquipment<true,true>(GetWholeEquipment(), [&](auto& item) { n += item.def_points1; }, weapon);
	}

	return Utils::Clamp(n, 1, MaxStatBaseValue());
}

int Game_Actor::GetBaseDef(Weapon weapon) const {
	return GetBaseDef(weapon, true, true);
}

int Game_Actor::GetBaseSpi(Weapon weapon, bool mod, bool equip) const {
	int n = 0;
	if (GetLevel() > 0) {
		n = data.class_id > 0
			? *lcf::ReaderUtil::GetElement(GetClass()->parameters.spirit, GetLevel())
			: *lcf::ReaderUtil::GetElement(dbActor->parameters.spirit, GetLevel());
	}

	if (mod) {
		n += data.spirit_mod;
	}

	if (equip) {
		ForEachEquipment<true,true>(GetWholeEquipment(), [&](auto& item) { n += item.spi_points1; }, weapon);
	}

	return Utils::Clamp(n, 1, MaxStatBaseValue());
}

int Game_Actor::GetBaseSpi(Weapon weapon) const {
	return GetBaseSpi(weapon, true, true);
}

int Game_Actor::GetBaseAgi(Weapon weapon, bool mod, bool equip) const {
	int n = 0;
	if (GetLevel() > 0) {
		n = data.class_id > 0
			? *lcf::ReaderUtil::GetElement(GetClass()->parameters.agility, GetLevel())
			: *lcf::ReaderUtil::GetElement(dbActor->parameters.agility, GetLevel());
	}

	if (mod) {
		n += data.agility_mod;
	}

	if (equip) {
		ForEachEquipment<true,true>(GetWholeEquipment(), [&](auto& item) { n += item.agi_points1; }, weapon);
	}

	return Utils::Clamp(n, 1, MaxStatBaseValue());
}

int Game_Actor::GetBaseAgi(Weapon weapon) const {
	return GetBaseAgi(weapon, true, true);
}

int Game_Actor::CalculateExp(int level) const {
	const lcf::rpg::Class* klass = lcf::ReaderUtil::GetElement(lcf::Data::classes, data.class_id);

	int exp_curve = Player::IsRPG2k() ? 1 : 2;
	if (lcf::Data::system.easyrpg_alternative_exp > 0) {
		exp_curve = lcf::Data::system.easyrpg_alternative_exp;
	}

	double base, inflation, correction;
	if (klass) {
		base = klass->exp_base;
		inflation = klass->exp_inflation;
		correction = klass->exp_correction;
	}
	else {
		const lcf::rpg::Actor& actor = *lcf::ReaderUtil::GetElement(lcf::Data::actors, GetId());
		base = actor.exp_base;
		inflation = actor.exp_inflation;
		correction = actor.exp_correction;
	}

	int result = 0;
	if (exp_curve == 1) {
		inflation = 1.5 + (inflation * 0.01);

		for (int i = level; i >= 1; i--)
		{
			result = result + (int)(correction + base);
			base = base * inflation;
			inflation = ((level+1) * 0.002 + 0.8) * (inflation - 1) + 1;
		}
	} else /*Rpg2k3*/ {
		for (int i = 1; i <= level; i++)
		{
			result += (int)base;
			result += i * (int)inflation;
			result += (int)correction;
		}
	}
	return min(result, MaxExpValue());
}

void Game_Actor::MakeExpList() {
	exp_list.resize((size_t)GetMaxLevel());
	for (int i = 1; i < (int)exp_list.size(); ++i) {
		exp_list[i] = CalculateExp(i);
	}
}

std::string Game_Actor::GetExpString(bool status_scene) const {
	(void)status_scene;
	// RPG_RT displays dashes for max level. As a customization
	// we always display the amount of EXP.
	// if (GetNextExp() == -1) { return (MaxExpValue() >= 1000000 || status_scene) ? "-------" : "------"; }
	return std::to_string(GetExp());
}

std::string Game_Actor::GetNextExpString(bool status_scene) const {
	if (GetNextExp() == -1) {
		return (MaxExpValue() >= 1000000 || status_scene) ? "-------" : "------";
	}
	return std::to_string(GetNextExp());
}

int Game_Actor::GetBaseExp() const {
	return GetBaseExp(GetLevel());
}

int Game_Actor::GetBaseExp(int level) const {
	return GetNextExp(level - 1);
}

int Game_Actor::GetNextExp() const {
	return GetNextExp(GetLevel());
}

int Game_Actor::GetNextExp(int level) const {
	if (level >= GetMaxLevel() || level <= -1) {
		return -1;
	} else if (level == 0) {
		return 0;
	} else {
		return exp_list[level];
	}
}

int Game_Actor::GetStateProbability(int state_id) const {
	int rate = 2, mul = 100; // C - default

	const uint8_t* r = lcf::ReaderUtil::GetElement(dbActor->state_ranks, state_id);
	if (r) {
		rate = *r;
	}

	// This takes the armor of the character with the most resistance for that particular state
	for (const auto equipment : GetWholeEquipment()) {
		lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, equipment);
		if (item != nullptr
				&& !(Player::IsRPG2k3() && item->reverse_state_effect)
				&& (item->type == lcf::rpg::Item::Type_shield || item->type == lcf::rpg::Item::Type_armor
			|| item->type == lcf::rpg::Item::Type_helmet || item->type == lcf::rpg::Item::Type_accessory)
			&& state_id  <= static_cast<int>(item->state_set.size()) && item->state_set[state_id - 1]) {
			mul = std::min<int>(mul, 100 - item->state_chance);
		}
	}

	// GetStateRate verifies the state_id
	return GetStateRate(state_id, rate) * mul / 100;
}

int Game_Actor::GetBaseAttributeRate(int attribute_id) const {
	int rate = 2; // C - default

	const auto* r = lcf::ReaderUtil::GetElement(dbActor->attribute_ranks, attribute_id);
	if (r) {
		rate = *r;
	}

	bool boost = false;
	ForEachEquipment<false,true>(GetWholeEquipment(), [&](auto& item) {
			boost |= attribute_id >= 1 && attribute_id <= static_cast<int>(item.attribute_set.size()) && item.attribute_set[attribute_id - 1];
			});
	rate += boost;

	return Utils::Clamp(rate, 0, 4);
}

bool Game_Actor::IsImmuneToAttributeDownshifts() const {
	return dbActor->easyrpg_immune_to_attribute_downshifts;
}

int Game_Actor::GetWeaponId() const {
	int item_id = GetWholeEquipment()[0];
	return item_id <= (int)lcf::Data::items.size() ? item_id : 0;
}

int Game_Actor::GetShieldId() const {
	int item_id = GetWholeEquipment()[1];
	return item_id <= (int)lcf::Data::items.size() ? item_id : 0;
}

int Game_Actor::GetArmorId() const {
	int item_id = GetWholeEquipment()[2];
	return item_id <= (int)lcf::Data::items.size() ? item_id : 0;
}

int Game_Actor::GetHelmetId() const {
	int item_id = GetWholeEquipment()[3];
	return item_id <= (int)lcf::Data::items.size() ? item_id : 0;
}

int Game_Actor::GetAccessoryId() const {
	int item_id = GetWholeEquipment()[4];
	return item_id <= (int)lcf::Data::items.size() ? item_id : 0;
}

int Game_Actor::GetMaxLevel() const {
	int max_level = Player::IsRPG2k() ? max_level_2k : max_level_2k3;
	if (lcf::Data::system.easyrpg_max_level > -1) {
		max_level = lcf::Data::system.easyrpg_max_level;
	}
	return Utils::Clamp<int32_t>(max_level, 1, dbActor->final_level);
}

void Game_Actor::SetExp(int _exp) {
	data.exp = Utils::Clamp<int32_t>(_exp, 0, MaxExpValue());
}

void Game_Actor::ChangeExp(int exp, PendingMessage* pm) {
	int new_level = GetLevel();
	int new_exp = Utils::Clamp<int>(exp, 0, MaxExpValue());

	if (new_exp > GetExp()) {
		for (int i = GetLevel() + 1; i <= GetMaxLevel(); ++i) {
			if (GetNextExp(new_level) != -1 && GetNextExp(new_level) > new_exp) {
				break;
			}
			new_level++;
		}
	} else if (new_exp < GetExp()) {
		for (int i = GetLevel(); i > 1; --i) {
			if (new_exp >= GetNextExp(i - 1)) {
				break;
			}
			new_level--;
		}
	}

	SetExp(new_exp);

	if (new_level != GetLevel()) {
		ChangeLevel(new_level, pm);
	}
}

void Game_Actor::SetLevel(int _level) {
	data.level = Utils::Clamp(_level, 1, GetMaxLevel());
	// Ensure current HP/SP remain clamped if new Max HP/SP is less.
	SetHp(GetHp());
	SetSp(GetSp());

}

void Game_Actor::ChangeLevel(int new_level, PendingMessage* pm) {
	int old_level = GetLevel();
	SetLevel(new_level);
	new_level = GetLevel(); // Level adjusted to max

	if (new_level > old_level) {
		if (pm) {
			pm->PushLine(ActorMessage::GetLevelUpMessage(*this, new_level));
		}

		// Learn new skills
		LearnLevelSkills(old_level + 1, new_level, pm);

		if (pm) {
			pm->PushPageEnd();
		}

		// Experience adjustment:
		// At least level minimum
		SetExp(max(GetBaseExp(), GetExp()));
	} else if (new_level < old_level) {
		// Experience adjustment:
		// Level minimum if higher then Level maximum
		if (GetExp() >= GetNextExp()) {
			SetExp(GetBaseExp());
		}
	}
}

bool Game_Actor::IsEquippable(int item_id) const {
	const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
	if (!item) {
		Output::Warning("IsEquippable: Invalid item ID {}", item_id);
		return false;
	}

	if (HasTwoWeapons() &&
		item->type == lcf::rpg::Item::Type_shield) {
			return false;
	}

	return IsItemUsable(item_id);
}

bool Game_Actor::IsEquipmentFixed(bool check_states) const {
	if (data.lock_equipment) {
		return true;
	}

	if (check_states) {
		for (auto state_id: GetInflictedStates()) {
			auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, state_id);
			if (state && state->cursed) {
				return true;
			}
		}
	}
	return false;
}

const lcf::rpg::Skill* Game_Actor::GetRandomSkill() const {
	const std::vector<int16_t>& skills = GetSkills();
	if (skills.empty()) {
		return nullptr;
	}

	// Skills are guaranteed to be valid
	return lcf::ReaderUtil::GetElement(lcf::Data::skills, skills[Rand::GetRandomNumber(0, skills.size() - 1)]);
}

Point Game_Actor::GetOriginalPosition() const {
	return { dbActor->battle_x, dbActor->battle_y };
}

std::string_view Game_Actor::GetSkillName() const {
	return dbActor->rename_skill ? std::string_view(dbActor->skill_name) : std::string_view(lcf::Data::terms.command_skill);
}

void Game_Actor::SetSprite(const std::string &file, int index, bool transparent) {
	if (file == dbActor->character_name
			&& index == dbActor->character_index
			&& transparent == dbActor->transparent) {
		data.sprite_name = "";
		data.sprite_id = 0;
		data.transparency = 0;
	} else {
		data.sprite_name = file;
		data.sprite_id = index;
		data.transparency = transparent ? 3 : 0;
	}
}

void Game_Actor::ChangeBattleCommands(bool add, int id) {
	auto& cmds = data.battle_commands;

	// If changing battle commands, that is when RPG_RT will replace the -1 list with a 'true' list.
	// Fetch original command array.
	if (!data.changed_battle_commands) {
		cmds = lcf::Data::actors[GetId() - 1].battle_commands;
		data.changed_battle_commands = true;
	}

	// The battle commands array always has a size of 7 padded with -1. The last element before the padding is 0 which
	// stands for the Row command
	if (add) {
		const lcf::rpg::BattleCommand* cmd = lcf::ReaderUtil::GetElement(lcf::Data::battlecommands.commands, id);
		if (!cmd) {
			Output::Warning("ChangeBattleCommands: Can't add invalid battle command {}", id);
			return;
		}

		if (std::find(cmds.begin(), cmds.end(), id)	== cmds.end()) {
			std::vector<int32_t> new_cmds;
			std::copy_if(cmds.begin(), cmds.end(),
						 std::back_inserter(new_cmds), [](int32_t i) { return i != 0 && i != -1; });
			// Needs space for at least 2 more commands (new command and row)
			if (new_cmds.size() >= 6) {
				return;
			}
			new_cmds.push_back(id);
			new_cmds.push_back(0);
			cmds = new_cmds;
		}
	} else if (id == 0) {
		cmds.clear();
		cmds.push_back(0);
	} else {
		std::vector<int32_t>::iterator it;
		it = std::find(cmds.begin(), cmds.end(), id);
		if (it != cmds.end())
			cmds.erase(it);
	}

	cmds.resize(7, -1);
}

const lcf::rpg::BattleCommand* Game_Actor::GetBattleCommand(int idx) const {
	Span<const int32_t> commands;
	if (data.changed_battle_commands) {
		commands = data.battle_commands;
	} else if (dbActor) {
		commands = dbActor->battle_commands;
	}
	int cmd_id = 0;
	if (idx >= 0 && idx < static_cast<int>(commands.size())) {
		cmd_id = commands[idx];
	}
	return lcf::ReaderUtil::GetElement(lcf::Data::battlecommands.commands, cmd_id);
}

const std::vector<const lcf::rpg::BattleCommand*> Game_Actor::GetBattleCommands() const {
	std::vector<const lcf::rpg::BattleCommand*> commands;
	std::vector<int32_t> obc = data.battle_commands;
	if (!data.changed_battle_commands) {
		// In this case, get it straight from the LDB.
		obc = lcf::Data::actors[GetId() - 1].battle_commands;
	}

	for (int command_index : obc) {
		if (command_index == 0) {
			// Row command -> not impl
			continue;
		}

		if (command_index == -1) {
			// Empty slot
			continue;
		}

		const lcf::rpg::BattleCommand* cmd = lcf::ReaderUtil::GetElement(lcf::Data::battlecommands.commands, command_index);
		if (!cmd) {
			Output::Warning("GetBattleCommands: Invalid battle command ID {}", command_index);
			continue;
		}

		commands.push_back(cmd);
	}

	return commands;
}

const lcf::rpg::Class* Game_Actor::GetClass() const {
	int id = data.class_id;

	if (id < 0) {
		// This means class ID hasn't been changed yet.
		id = dbActor->class_id;
	}

	return lcf::ReaderUtil::GetElement(lcf::Data::classes, id);
}

void Game_Actor::ChangeClass(int new_class_id,
		int new_level,
		ClassChangeSkillMode new_skill,
		ClassChangeParamMode new_param,
		PendingMessage* pm
		)
{
	const auto* cls = lcf::ReaderUtil::GetElement(lcf::Data::classes, new_class_id);
	if (new_class_id != 0 && cls == nullptr) {
		Output::Warning("Actor {}: Can't change to invalid class {}", GetId(), new_class_id);
		return;
	}

	// RPG_RT always removes all equipment on level change.
	RemoveWholeEquipment();

	const auto prev_level = GetLevel();
	const auto hp = GetHp();
	const auto sp = GetSp();

	auto max_hp = GetBaseMaxHp();
	auto max_sp = GetBaseMaxSp();
	auto atk = GetBaseAtk();
	auto def = GetBaseDef();
	auto spi = GetBaseSpi();
	auto agi = GetBaseAgi();

	SetLevel(1);
	data.hp_mod = 0;
	data.sp_mod = 0;
	data.attack_mod = 0;
	data.defense_mod = 0;
	data.spirit_mod = 0;
	data.agility_mod = 0;

	data.class_id = new_class_id;
	data.changed_battle_commands = true; // Any change counts as a battle commands change.

	// The class settings are not applied when the actor has a class on startup
	// but only when the "Change Class" event command is used.

	if (cls) {
		data.super_guard = cls->super_guard;
		data.lock_equipment = cls->lock_equipment;
		data.two_weapon = cls->two_weapon;
		data.auto_battle = cls->auto_battle;

		data.battler_animation = cls->battler_animation;

		data.battle_commands = cls->battle_commands;
	} else {
		data.super_guard = dbActor->super_guard;
		data.lock_equipment = dbActor->lock_equipment;
		data.two_weapon = dbActor->two_weapon;
		data.auto_battle = dbActor->auto_battle;

		data.battler_animation = 0;

		data.battle_commands = dbActor->battle_commands;
	}

	MakeExpList();

	switch (new_param) {
		case eParamNoChange:
			break;
		case eParamHalf:
			max_hp /= 2;
			max_sp /= 2;
			atk /= 2;
			def /= 2;
			spi /= 2;
			agi /= 2;
			break;
		case eParamResetLevel1:
			max_hp = GetBaseMaxHp();
			max_sp = GetBaseMaxSp();
			atk = GetBaseAtk();
			def = GetBaseDef();
			spi = GetBaseSpi();
			agi = GetBaseAgi();
			break;
		case eParamReset:
			break;
	}

	SetLevel(new_level);
	if (pm && new_level > 1 && (new_level > prev_level || new_skill != eSkillNoChange)) {
		pm->PushLine(ActorMessage::GetLevelUpMessage(*this, new_level));
	}

	// RPG_RT always resets EXP when class is changed, even if level unchanged.
	SetExp(GetBaseExp());

	if (new_param != eParamReset) {
		SetBaseMaxHp(max_hp);
		SetBaseMaxSp(max_sp);
		SetBaseAtk(atk);
		SetBaseDef(def);
		SetBaseSpi(spi);
		SetBaseAgi(agi);
	}

	SetHp(hp);
	SetSp(sp);

	switch (new_skill) {
		case eSkillNoChange:
			break;
		case eSkillReset:
			// RPG_RT has a bug where if (new_level == 1 && new_class_id == prev_class_id) no skills are removed.
			UnlearnAllSkills();
			// fall through
		case eSkillAdd:
			// RPG_RT has a bug where if (new_class_id == prev_class_id) level 1 skills are not learned.
			LearnLevelSkills(1, new_level, pm);
			break;
	}
}

std::string_view Game_Actor::GetClassName() const {
	if (!GetClass()) {
		return {};
	}
	return GetClass()->name;
}

static int ClampMaxHpMod(int hp, const Game_Actor* actor) {
	auto limit = actor->MaxHpValue();
	return Utils::Clamp(hp, -limit, limit);
}

static int ClampMaxSpMod(int sp, const Game_Actor* actor) {
	auto limit = actor->MaxSpValue();
	return Utils::Clamp(sp, -limit, limit);
}

static int ClampStatMod(int value, const Game_Actor* actor) {
	auto limit = actor->MaxStatBaseValue();
	return Utils::Clamp(value, -limit, limit);
}

void Game_Actor::SetBaseMaxHp(int maxhp) {
	int new_hp_mod = data.hp_mod + (maxhp - GetBaseMaxHp());
	data.hp_mod = ClampMaxHpMod(new_hp_mod, this);

	SetHp(data.current_hp);
}

void Game_Actor::SetBaseMaxSp(int maxsp) {
	int new_sp_mod = data.sp_mod + (maxsp - GetBaseMaxSp());
	data.sp_mod = ClampMaxSpMod(new_sp_mod, this);

	SetSp(data.current_sp);
}

int Game_Actor::SetHp(int hp) {
	data.current_hp = Utils::Clamp(hp, 0, GetMaxHp());
	return data.current_hp;
}

int Game_Actor::SetSp(int sp) {
	data.current_sp = Utils::Clamp(sp, 0, GetMaxSp());
	return data.current_sp;
}

void Game_Actor::SetBaseAtk(int atk) {
	int new_attack_mod = data.attack_mod + (atk - GetBaseAtk());
	data.attack_mod = ClampStatMod(new_attack_mod, this);
}

void Game_Actor::SetBaseDef(int def) {
	int new_defense_mod = data.defense_mod + (def - GetBaseDef());
	data.defense_mod = ClampStatMod(new_defense_mod, this);
}

void Game_Actor::SetBaseSpi(int spi) {
	int new_spirit_mod = data.spirit_mod + (spi - GetBaseSpi());
	data.spirit_mod = ClampStatMod(new_spirit_mod, this);
}

void Game_Actor::SetBaseAgi(int agi) {
	int new_agility_mod = data.agility_mod + (agi - GetBaseAgi());
	data.agility_mod = ClampStatMod(new_agility_mod, this);
}

Game_Actor::RowType Game_Actor::GetBattleRow() const {
	return RowType(data.row);
}

void Game_Actor::SetBattleRow(RowType battle_row) {
	data.row = int(battle_row);
}

int Game_Actor::GetBattleAnimationId() const {
	if (Player::IsRPG2k()) {
		return 0;
	}

	int anim = 0;

	if (data.battler_animation <= 0) {
		// Earlier versions of EasyRPG didn't save this value correctly

		// The battle animation of the class only matters when the class was
		// changed by event "Change Class"
		if ((data.class_id > 0) && GetClass()) {
			anim = GetClass()->battler_animation;
		} else {
			const lcf::rpg::BattlerAnimation* anima = lcf::ReaderUtil::GetElement(lcf::Data::battleranimations, dbActor->battler_animation);
			if (!anima) {
				Output::Warning("Actor {}: Invalid battle animation ID {}", GetId(), dbActor->battler_animation);
				return 0;
			}

			anim = anima->ID;
		}
	} else {
		anim = data.battler_animation;
	}

	if (anim == 0) {
		// Chunk was missing, set to proper default
		return 1;
	}

	return anim;
}

int Game_Actor::GetHitChance(Weapon weapon) const {
	int hit = INT_MIN;
	ForEachEquipment<true, false>(GetWholeEquipment(), [&](auto& item) { hit = std::max(hit, static_cast<int>(item.hit)); }, weapon);

	if (hit != INT_MIN) {
		return hit;
	} else {
		if (dbActor->easyrpg_unarmed_hit != -1) {
			return dbActor->easyrpg_unarmed_hit;
		} else {
			return 90;
		}
	}
}

float Game_Actor::GetCriticalHitChance(Weapon weapon) const {
	float crit_chance = dbActor->critical_hit ? 1.0f / dbActor->critical_hit_chance : 0.0f;

	float bonus = 0;
	ForEachEquipment<true, false>(GetWholeEquipment(), [&](auto& item) { bonus = std::max(bonus, static_cast<float>(item.critical_hit)); }, weapon);
	return crit_chance + (bonus / 100.0f);
}

int Game_Actor::IsControllable() const {
	return GetSignificantRestriction() == lcf::rpg::State::Restriction_normal && !GetAutoBattle();
}


void Game_Actor::RemoveInvalidData() {
	/*
	 The following actor data is cleaned up:
	 - Invalid equipment is removed
	 - An invalid class is removed
	 - Invalid states are removed
	 - Level is between 0 and 99, and does not exceed MaxLevel

	 For "external data" (not from LCF Actor or LSD SaveActor) the data is
	 verified in the corresponding functions.
	*/

	// Filter out invalid equipment
	int eq_types[] = { lcf::rpg::Item::Type_weapon,
		HasTwoWeapons() ? lcf::rpg::Item::Type_weapon : lcf::rpg::Item::Type_shield,
		lcf::rpg::Item::Type_armor,
		lcf::rpg::Item::Type_helmet,
		lcf::rpg::Item::Type_accessory
	};

	auto& equipment = GetWholeEquipment();
	for (size_t i = 0; i < equipment.size(); ++i) {
		int eq_id = equipment[i];
		lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, eq_id);

		if (!item && eq_id != 0) {
			Output::Debug("Actor {}: Removing invalid item {} from equipment slot {}",
			GetId(), eq_id, eq_types[i]);
			SetEquipment(i + 1, 0);
		} else if (item && item->type != eq_types[i]) {
			Output::Debug("Actor {}: Removing item {} (of type {}) from equipment slot {} (needs type {})",
			GetId(), item->ID, item->type, i + 1, eq_types[i]);
			SetEquipment(i + 1, 0);
		} else if (item && !IsItemUsable(item->ID)) {
			Output::Debug("Actor {}: Removing item {} from equipment slot {} (Not equippable by this actor)",
			GetId(), item->ID, i + 1);
			SetEquipment(i + 1, 0);
		}
	}

	// Remove invalid class
	if (data.class_id > 0) {
		const lcf::rpg::Class* cls = lcf::ReaderUtil::GetElement(lcf::Data::classes, data.class_id);
		if (!cls) {
			Output::Warning("Actor {}: Removing invalid class {}", GetId(), data.class_id);
			ChangeClass(0, GetLevel(), eSkillNoChange, eParamNoChange, nullptr);
		}
	}

	// Remove invalid skills
	for (int16_t skill_id : GetSkills()) {
		const lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, skill_id);
		if (!skill) {
			Output::Warning("Actor {}: Removing invalid skill {}", GetId(), skill_id);
			UnlearnSkill(skill_id);
		}
	}

	// Remove invalid states
	if (GetStates().size() > lcf::Data::states.size()) {
		Output::Warning("Actor {}: State array contains invalid states ({} > {})", GetId(), GetStates().size(), lcf::Data::states.size());
		GetStates().resize(lcf::Data::states.size());
	}

	// Remove invalid levels
	// Special handling for the game COLORS: Lost Memories which uses level 0
	// through database editing. Hopefully no game uses negative levels.
	if (GetLevel() == 0) {
		Output::Debug("Actor {}: Special handling for level 0", GetId());
	} else if (GetLevel() < 0) {
		Output::Warning("Actor {}: Invalid level {}, changed to 1", GetId(), GetLevel());
		SetLevel(1);
	} else if (GetLevel() > GetMaxLevel()) {
		Output::Warning("Actor {}: Invalid level {}, changed to {}", GetId(), GetLevel(), GetMaxLevel());
		SetLevel(GetMaxLevel());
	}
}

const lcf::rpg::Item* Game_Actor::GetWeapon() const {
	auto* weapon = GetEquipment(lcf::rpg::Item::Type_weapon);
	if (weapon && weapon->type == lcf::rpg::Item::Type_weapon) {
		return weapon;
	}
	return nullptr;
}

const lcf::rpg::Item* Game_Actor::Get2ndWeapon() const {
	// Checking of HasTwoWeapons() not neccessary. If true, the
	// item equipped in this slot will never be a weapon from
	// legitimate means.
	auto* weapon = GetEquipment(lcf::rpg::Item::Type_shield);
	if (weapon && weapon->type == lcf::rpg::Item::Type_weapon) {
		return weapon;
	}
	return nullptr;
}

const lcf::rpg::Item* Game_Actor::GetShield() const {
	auto* shield = GetEquipment(lcf::rpg::Item::Type_shield);
	if (shield && shield->type == lcf::rpg::Item::Type_shield) {
		return shield;
	}
	return nullptr;
}

const lcf::rpg::Item* Game_Actor::GetArmor() const {
	auto* armor = GetEquipment(lcf::rpg::Item::Type_armor);
	if (armor && armor->type == lcf::rpg::Item::Type_armor) {
		return armor;
	}
	return nullptr;
}

const lcf::rpg::Item* Game_Actor::GetHelmet() const {
	auto* helmet = GetEquipment(lcf::rpg::Item::Type_helmet);
	if (helmet && helmet->type == lcf::rpg::Item::Type_helmet) {
		return helmet;
	}
	return nullptr;
}

const lcf::rpg::Item* Game_Actor::GetAccessory() const {
	auto* accessory = GetEquipment(lcf::rpg::Item::Type_accessory);
	if (accessory && accessory->type == lcf::rpg::Item::Type_accessory) {
		return accessory;
	}
	return nullptr;
}

bool Game_Actor::HasPreemptiveAttack(Weapon weapon) const {
	bool rc = false;
	ForEachEquipment<true, false>(GetWholeEquipment(), [&](auto& item) { rc |= item.preemptive; }, weapon);
	return rc;
}

int Game_Actor::GetNumberOfAttacks(Weapon weapon) const {
	if (GetWeapon() == nullptr && Get2ndWeapon() == nullptr && dbActor->easyrpg_dual_attack) {
		return 2;
	}
	int hits = 1;
	ForEachEquipment<true, false>(GetWholeEquipment(), [&](auto& item) { hits = std::max(hits, Algo::GetNumberOfAttacks(GetId(), item)); }, weapon);
	return hits;
}

bool Game_Actor::HasAttackAll(Weapon weapon) const {
	if (GetWeapon() == nullptr && Get2ndWeapon() == nullptr) {
		return dbActor->easyrpg_attack_all;
	}
	bool rc = false;
	ForEachEquipment<true, false>(GetWholeEquipment(), [&](auto& item) { rc |= item.attack_all; }, weapon);
	return rc;
}

bool Game_Actor::AttackIgnoresEvasion(Weapon weapon) const {
	if (GetWeapon() == nullptr && Get2ndWeapon() == nullptr) {
		return dbActor->easyrpg_ignore_evasion;
	}
	bool rc = false;
	ForEachEquipment<true, false>(GetWholeEquipment(), [&](auto& item) { rc |= item.ignore_evasion; }, weapon);
	return rc;
}

bool Game_Actor::PreventsCritical() const {
	if (dbActor->easyrpg_prevent_critical) {
		return true;
	}
	bool rc = false;
	ForEachEquipment<false, true>(GetWholeEquipment(), [&](auto& item) { rc |= item.prevent_critical; });
	return rc;
}

bool Game_Actor::PreventsTerrainDamage() const {
	bool rc = false;
	ForEachEquipment<false, true>(GetWholeEquipment(), [&](auto& item) { rc |= item.no_terrain_damage; });
	return rc;
}

bool Game_Actor::HasPhysicalEvasionUp() const {
	if (dbActor->easyrpg_raise_evasion) {
		return true;
	}
	bool rc = false;
	ForEachEquipment<false, true>(GetWholeEquipment(), [&](auto& item) { rc |= item.raise_evasion; });
	return rc;
}

bool Game_Actor::HasHalfSpCost() const {
	bool rc = false;
	ForEachEquipment<false, true>(GetWholeEquipment(), [&](auto& item) { rc |= item.half_sp_cost; });
	return rc;
}

int Game_Actor::CalculateWeaponSpCost(Weapon weapon) const {
	int cost = 0;
	ForEachEquipment<true, false>(GetWholeEquipment(), [&](auto& item) { cost += item.sp_cost; }, weapon);
	if (HasHalfSpCost()) {
		cost = (cost + 1) / 2;
	}

	return cost;
}

void Game_Actor::AdjustEquipmentStates(const lcf::rpg::Item* item, bool add, bool allow_battle_states) {
	// All states inflicted by new armor get inflicted.
	if (Player::IsRPG2k3()
			&& item
			&& IsArmorType(item)
			&& item->reverse_state_effect)
	{
		auto& states = item->state_set;
		for (int i = 0; i < (int)states.size(); ++i) {
			if (states[i]) {
				if (add) {
					AddState(i + 1, allow_battle_states);
				} else {
					RemoveState(i + 1, false);
				}
			}
		}
	}
}


void Game_Actor::ResetEquipmentStates(bool allow_battle_states) {
	AdjustEquipmentStates(GetShield(), true, allow_battle_states);
	AdjustEquipmentStates(GetArmor(), true, allow_battle_states);
	AdjustEquipmentStates(GetHelmet(), true, allow_battle_states);
	AdjustEquipmentStates(GetAccessory(), true, allow_battle_states);
}

PermanentStates Game_Actor::GetPermanentStates() const {
	PermanentStates ps;
	if (!Player::IsRPG2k3()) {
		return ps;
	}

	auto addEquip = [&](const lcf::rpg::Item* item) {
		if (!item || !IsArmorType(item) || !item->reverse_state_effect) {
			return;
		}
		auto& states = item->state_set;
		// Invalid states in armor already reported earlier in
		// calls to AdjustEquipmentStates.
		int num_states = std::min<int>(states.size(), lcf::Data::states.size());
		for (int i = 0; i < num_states; ++i) {
			if (states[i]) {
				ps.Add(i + 1);
			}
		}
	};

	addEquip(GetShield());
	addEquip(GetArmor());
	addEquip(GetHelmet());
	addEquip(GetAccessory());

	return ps;
}

bool Game_Actor::IsInParty() const {
	return Main_Data::game_party->IsActorInParty(GetId());
}

std::array<const lcf::rpg::Item*, 2> Game_Actor::GetWeapons(Game_Battler::Weapon weapon) const {
	std::array<const lcf::rpg::Item*, 2> w = {{}};
	int i = 0;
	if (weapon == Game_Battler::WeaponPrimary || weapon == Game_Battler::WeaponAll) {
		w[i] = GetWeapon();
		if (w[i]) { ++i; }
	}
	if (weapon == Game_Battler::WeaponSecondary || weapon == Game_Battler::WeaponAll) {
		w[i] = Get2ndWeapon();
	}
	return w;
}


void Game_Actor::UpdateBattle() {
	Game_Battler::UpdateBattle();
	auto* sprite = GetActorBattleSprite();
	if (sprite) {
		sprite->Update();
	}
	auto* weapon = Game_Battler::GetWeaponSprite();
	if (weapon) {
		weapon->Update();
	}
}


/*end of file .\game_actor.cpp*/

/*start of file .\game_actors.cpp*/

/* ... license chunk ... */

// Headers
#include "system.h"
#include <vector>
#include "game_actors.h"
#include "main_data.h"
#include "output.h"

Game_Actors::Game_Actors() {
	data.reserve(lcf::Data::actors.size());
	for (size_t i = 0; i < lcf::Data::actors.size(); i++) {
		data.emplace_back(Game_Actor(i + 1));
	}
}

void Game_Actors::SetSaveData(std::vector<lcf::rpg::SaveActor> save) {
	// Ensure actor save data and LDB actors has correct size
	if (save.size() > data.size()) {
		Output::Warning("Game_Actors: Save game array size {} is larger than number of LDB actors {} : Dropping extras ...", save.size(), data.size());
	}

	for (size_t i = 0; i < std::min(save.size(), data.size()); ++i) {
		data[i].SetSaveData(std::move(save[i]));
	}
}

std::vector<lcf::rpg::SaveActor> Game_Actors::GetSaveData() const {
	std::vector<lcf::rpg::SaveActor> save;
	save.reserve(data.size());
	for (auto& actor: data) {
		save.push_back(actor.GetSaveData());
	}
	return save;
}

Game_Actor* Game_Actors::GetActor(int actor_id) {
	if (!ActorExists(actor_id)) {
		return nullptr;
	}

	return &data[actor_id - 1];
}

bool Game_Actors::ActorExists(int actor_id) {
	return actor_id > 0 && actor_id <= static_cast<int>(data.size());
}

void Game_Actors::ResetBattle() {
	for (auto& actor: data) {
		actor.ResetBattle();
	}
}

void Game_Actors::ReloadActors() {
	for (auto& actor: data) {
		actor.ReloadDbActor();
	}
}


/*end of file .\game_actors.cpp*/

/*start of file .\game_battle.cpp*/

/*
* This file is part of EasyRPG Player.
*
* EasyRPG Player is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* EasyRPG Player is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with EasyRPG Player. If not, see <http://www.gnu.org/licenses/>.
*/

#include <algorithm>
#include <cassert>
#include <lcf/data.h>
#include "player.h"
#include "game_actors.h"
#include "game_enemyparty.h"
#include "game_message.h"
#include "game_party.h"
#include "game_switches.h"
#include "game_system.h"
#include "game_variables.h"
#include "game_interpreter_battle.h"
#include "game_screen.h"
#include "game_pictures.h"
#include "battle_animation.h"
#include "game_battle.h"
#include <lcf/reader_util.h>
#include "spriteset_battle.h"
#include "output.h"
#include "utils.h"
#include "rand.h"

namespace Game_Battle {
	const lcf::rpg::Troop* troop = nullptr;

	std::string background_name;

	std::unique_ptr<Game_Interpreter_Battle> interpreter;
	/** Contains battle related sprites */
	std::unique_ptr<Spriteset_Battle> spriteset;

	std::unique_ptr<BattleAnimation> animation_actors;
	std::unique_ptr<BattleAnimation> animation_enemies;

	bool battle_running = false;

	struct BattleTest battle_test;
}

namespace {
	int terrain_id;
	lcf::rpg::System::BattleCondition battle_cond = lcf::rpg::System::BattleCondition_none;
	lcf::rpg::System::BattleFormation battle_form = lcf::rpg::System::BattleFormation_terrain;
}

void Game_Battle::Init(int troop_id) {
	// troop_id is guaranteed to be valid
	troop = lcf::ReaderUtil::GetElement(lcf::Data::troops, troop_id);
	assert(troop);
	Game_Battle::battle_running = true;
	Main_Data::game_party->ResetTurns();

	Main_Data::game_enemyparty->ResetBattle(troop_id);
	Main_Data::game_actors->ResetBattle();

	interpreter.reset(new Game_Interpreter_Battle(troop->pages));
	spriteset.reset(new Spriteset_Battle(background_name, terrain_id));
	spriteset->Update();
	animation_actors.reset();
	animation_enemies.reset();


	for (auto* actor: Main_Data::game_party->GetActors()) {
		actor->ResetEquipmentStates(true);
	}
}

void Game_Battle::Quit() {
	if (!IsBattleRunning()) {
		return;
	}

	interpreter.reset();
	spriteset.reset();
	animation_actors.reset();
	animation_enemies.reset();

	Game_Battle::battle_running = false;
	terrain_id = 0;

	std::vector<Game_Battler*> allies;
	Main_Data::game_party->GetBattlers(allies);

	// Remove conditions which end after battle
	for (std::vector<Game_Battler*>::iterator it = allies.begin(); it != allies.end(); it++) {
		(*it)->RemoveBattleStates();
		(*it)->SetBattleAlgorithm(BattleAlgorithmRef());
	}

	Main_Data::game_actors->ResetBattle();
	Main_Data::game_enemyparty->ResetBattle(0);
	Main_Data::game_pictures->OnBattleEnd();
}

void Game_Battle::UpdateAnimation() {
	if (animation_actors) {
		animation_actors->Update();
		if (animation_actors->IsDone()) {
			animation_actors.reset();
		}
	}
	if (animation_enemies) {
		animation_enemies->Update();
		if (animation_enemies->IsDone()) {
			animation_enemies.reset();
		}
	}
}

void Game_Battle::UpdateGraphics() {
	spriteset->Update();
}

bool Game_Battle::CheckWin() {
	return !Main_Data::game_enemyparty->IsAnyActive();
}

bool Game_Battle::CheckLose() {
	// If there are active characters, but all of them are in a state with Restriction "Do Nothing" and 0% recovery probability (including death), it's game over
	// Physical recovery doesn't matter in this case
	for (auto& actor : Main_Data::game_party->GetActors()) {
		if (!actor->IsHidden() && actor->CanActOrRecoverable()) {
			return false;
		}
	}

	return true;
}

Spriteset_Battle& Game_Battle::GetSpriteset() {
	assert(spriteset);
	return *spriteset;
}

int Game_Battle::ShowBattleAnimation(int animation_id, std::vector<Game_Battler*> targets, bool only_sound, int cutoff, bool invert) {
	const lcf::rpg::Animation* anim = lcf::ReaderUtil::GetElement(lcf::Data::animations, animation_id);
	if (!anim) {
		Output::Warning("ShowBattleAnimation Many: Invalid animation ID {}", animation_id);
		return 0;
	}

	const auto main_type = targets.empty() ? Game_Battler::Type_Ally : targets.front()->GetType();
	std::vector<Game_Battler*> alt_targets;

	for (auto iter = targets.begin(); iter != targets.end();) {
		if ((*iter)->GetType() == main_type) {
			++iter;
		} else {
			alt_targets.push_back(*iter);
			iter = targets.erase(iter);
		}
	}

	auto& main_anim = main_type == Game_Battler::Type_Ally ? animation_actors : animation_enemies;
	auto& alt_anim = main_type == Game_Battler::Type_Ally ? animation_enemies : animation_actors;

	main_anim.reset(new BattleAnimationBattle(*anim, std::move(targets), only_sound, cutoff, invert));
	auto main_frames = main_anim->GetFrames();
	main_frames = cutoff >= 0 ? std::min(main_frames, cutoff) : main_frames;

	auto alt_frames = 0;
	if (!alt_targets.empty()) {
		alt_anim.reset(new BattleAnimationBattle(*anim, std::move(alt_targets), only_sound, cutoff, invert));
		auto alt_frames = alt_anim->GetFrames();
		alt_frames = cutoff >= 0 ? std::min(alt_frames, cutoff) : alt_frames;
	}

	return std::max(main_frames, alt_frames);
}

bool Game_Battle::IsBattleAnimationWaiting() {
	return bool(animation_actors) || bool(animation_enemies);
}

void Game_Battle::UpdateAtbGauges() {
	std::vector<Game_Battler*> battlers;
	Main_Data::game_enemyparty->GetBattlers(battlers);
	Main_Data::game_party->GetBattlers(battlers);

	const auto use_2k3e_algo = Player::IsRPG2k3E();

	int sum_agi = 0;
	for (auto* bat: battlers) {
		// RPG_RT uses dead and state restricted battlers to contribute to the sum.
		if (!bat->IsHidden()) {
			sum_agi += bat->GetAgi();
		}
	}
	sum_agi *= 100;

	const int max_atb = Game_Battler::GetMaxAtbGauge();

	for (auto* bat: battlers) {
		// RPG_RT always updates atb for non-hidden enemies, even if they can't act.
		// We don't update ATB for battlers with a pending battle algo
		if (!bat->GetBattleAlgorithm() && bat->Exists() && (bat->CanAct() || bat->GetType() == Game_Battler::Type_Enemy))
		{
			const auto agi = bat->GetAgi();
			auto increment = max_atb / (sum_agi / (agi + 1));
			if (use_2k3e_algo) {
				const auto cur_atb = bat->GetAtbGauge();
				const auto multiplier = std::max(1.0, static_cast<double>(275000 - cur_atb) / 55000.0);
				increment = Utils::RoundTo<int>(multiplier * increment);
			}

			Game_Interpreter_Battle::ManiacBattleHook(
				Game_Interpreter_Battle::ManiacBattleHookType::AtbIncrement,
				bat->GetType() == Game_Battler::Type_Enemy,
				bat->GetPartyIndex(),
				bat->GetAtbGauge(),
				increment
			);

			int Var_ID = std::get<1>(Game_Interpreter_Battle::maniac_hooks[Game_Interpreter_Battle::ManiacBattleHookType::AtbIncrement]);
			if (Var_ID > 0) {
				increment = Main_Data::game_variables->Get(Var_ID + 3);
			}

			bat->IncrementAtbGauge(increment);
		}
	}
}

bool Game_Battle::ManiacBattleHook(Game_Interpreter_Battle::ManiacBattleHookType hook_type, int var1, int var2, int var3, int var4, int var5, int var6) {
	if (Player::IsPatchManiac() && interpreter) {
		return interpreter->ManiacBattleHook(hook_type, var1, var2, var3, var4, var5, var6);
	} else {
		return false;
	}
}

bool Game_Battle::ManiacProcessSubEvents() {
	return interpreter->ProcessManiacSubEvents();
}

void Game_Battle::ChangeBackground(const std::string& name) {
	background_name = name;
}

const std::string& Game_Battle::GetBackground() {
	return background_name;
}

int Game_Battle::GetTurn() {
	return Main_Data::game_party->GetTurns();
}

bool Game_Battle::CheckTurns(int turns, int base, int multiple) {
	if (multiple == 0) {
		return turns >= base && (turns - base) == 0;
	}
	else {
		return turns >= base && (turns - base) % multiple == 0;
	}
}

Game_Interpreter& Game_Battle::GetInterpreter() {
	assert(interpreter);
	return *interpreter;
}

Game_Interpreter_Battle& Game_Battle::GetInterpreterBattle() {
	assert(interpreter);
	return *interpreter;
}

void Game_Battle::SetTerrainId(int id) {
	terrain_id = id;
}

int Game_Battle::GetTerrainId() {
	return terrain_id;
}

void Game_Battle::SetBattleCondition(lcf::rpg::System::BattleCondition cond) {
	battle_cond = cond;
}

lcf::rpg::System::BattleCondition Game_Battle::GetBattleCondition() {
	return battle_cond;
}

void Game_Battle::SetBattleFormation(lcf::rpg::System::BattleFormation form) {
	battle_form = form;
}

lcf::rpg::System::BattleFormation Game_Battle::GetBattleFormation() {
	return battle_form;
}

bool Game_Battle::HasDeathHandler() {
	// RPG Maker Editor always sets both death_handler and death_handler_unused chunks.
	// However, RPG_RT will only trigger death handler based on the death_handler chunk.
	auto& db = lcf::Data::battlecommands;
	return Player::IsRPG2k3() && db.death_handler;
}

int Game_Battle::GetDeathHandlerCommonEvent() {
	auto& db = lcf::Data::battlecommands;
	if (HasDeathHandler()) {
		return db.death_event;
	}
	return 0;
}

TeleportTarget Game_Battle::GetDeathHandlerTeleport() {
	auto& db = lcf::Data::battlecommands;
	if (HasDeathHandler() && db.death_teleport) {
		return TeleportTarget(db.death_teleport_id, db.death_teleport_x, db.death_teleport_y, db.death_teleport_face -1, TeleportTarget::eParallelTeleport);
	}
	return {};
}

const lcf::rpg::Troop* Game_Battle::GetActiveTroop() {
	return IsBattleRunning() ? troop : nullptr;
}

static constexpr double grid_tables[4][8][8] = {
{
// In DynRPG 0x4CC16C
	{ 0.5, },
	{ 0.0, 1.0, },
	{ 0.0, 0.5, 1.0, },
	{ 0.0, 0.33, 0.66, 1.0, },
	{ 0.0, 0.25, 0.5, 0.75, 1.0, },
	{ 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, },
	{ 0.0, 0.25, 0.33, 0.5, 0.66, 0.75, 1.0, },
	{ 0.0, 0.0, 0.33, 0.33, 0.66, 0.66, 1.0, 1.0, },
}, {
// In DynRPG 0x4CC36C
	{ 0.5, },
	{ 0.0, 1.0, },
	{ 0.0, 1.0, 0.5, },
	{ 0.0, 0.75, 0.25, 1.0, },
	{ 0.0, 0.5, 1.0, 0.25, 0.75, },
	{ 0.0, 0.4, 0.8, 0.2, 0.6, 1.0, },
	{ 0.0, 0.33, 0.66, 1.0, 0.25, 0.5, 1.0, },
	{ 0.0, 0.28, 0.56, 0.84, 0.14, 0.42, 0.7, 0.98, }
}, {
// In DynRPG 0x4CC35C
	{ 0.5, },
	{ 0.5, 0.5, },
	{ 0.0, 0.5, 1.0, },
	{ 0.0, 0.0, 1.0, 1.0, },
	{ 0.0, 0.33, 0.5, 0.66, 1.0, },
	{ 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, },
	{ 0.0, 0.25, 0.33, 0.5, 0.66, 0.75, 1.0,},
	{ 0.0, 0.0, 0.33, 0.33, 0.66, 0.66, 1.0, 1.0, }
}, {
// In DynRPG 0x4CC76C
	{ },
	{ 24, },
	{ 48, 48, },
	{ 48, 48, },
	{ 56, 56, 56, 8, 8, },
	{ 56, 56, 56, 8, 8, },
	{ 64, 64, 64, 64, 16, 16, 16, },
	{ 64, 64, 64, 64, 16, 16, 16, 16 },
}};


Point Game_Battle::CalculateBaseGridPosition(
		int party_idx,
		int party_size,
		int table_x,
		int table_y,
		lcf::rpg::System::BattleFormation form,
		int terrain_id)
{
	Point pos;

	assert(party_idx >= 0);
	assert(party_idx < party_size);
	assert(party_size <= 8);

	int grid_top_y = 112;
	double grid_elongation = 392;
	double grid_inclination = 16000;
	if (terrain_id > 0) {
		const auto* terrain = lcf::ReaderUtil::GetElement(lcf::Data::terrains, Game_Battle::GetTerrainId());
		if (terrain) {
			grid_top_y = terrain->grid_top_y;
			grid_elongation = static_cast<double>(terrain->grid_elongation);
			grid_inclination = static_cast<double>(terrain->grid_inclination);
		}
	} else if (form == lcf::rpg::System::BattleFormation_tight) {
		grid_top_y = 132;
		grid_elongation = 196;
		grid_inclination = 24000;
	}

	const auto tdx = grid_tables[table_x][party_size - 1][party_idx];
	const auto tdy = grid_tables[table_y][party_size - 1][party_idx];

	pos.x = static_cast<int>((1.0 - tdx) * (grid_inclination / 1000.0));
	pos.y = grid_top_y + static_cast<int>(std::sin(grid_elongation / 1000.0) * 120.0 * tdy);

	return pos;
}


Point Game_Battle::Calculate2k3BattlePosition(const Game_Enemy& enemy) {
	assert(troop);

	const auto terrain_id = Game_Battle::GetTerrainId();
	const auto cond = Game_Battle::GetBattleCondition();
	const auto form = Game_Battle::GetBattleFormation();
	auto* sprite = enemy.GetBattleSprite();

	int half_height = 0;
	int half_width = 0;
	if (sprite) {
		half_height = sprite->GetHeight() / 2;
		half_width = sprite->GetWidth() / 2;
	}

	// Manual position case
	if (!troop->auto_alignment
			&& cond != lcf::rpg::System::BattleCondition_pincers
			&& cond != lcf::rpg::System::BattleCondition_surround) {
		auto position = enemy.GetOriginalPosition();
		if (cond == lcf::rpg::System::BattleCondition_back) {
			position.x = 320 - position.x;
		}

		// RPG_RT only clamps Y position for enemies
		position.y = Utils::Clamp(position.y, half_height, 240 - half_height);
		return position;
	}

	// Auto position case

	int party_size = 0;
	int idx = 0;
	bool found_myself = false;
	// Position is computed based on this monster's index relative to party size
	// If monster is hidden -> use real party idx / real party size
	// If monster is visible -> use visible party idx / visible party size
	for (auto& e: Main_Data::game_enemyparty->GetEnemies()) {
		if (e == &enemy) {
			found_myself = true;
		}
		if (enemy.IsHidden() || !e->IsHidden()) {
			party_size += 1;
			idx += !(found_myself);
		}
	}

	// RPG_RT has a bug where the pincer table is only used for enemies on terrain battles but not on non terrain battles.
	const int table_y_idx = (cond == lcf::rpg::System::BattleCondition_pincers && terrain_id >= 1) ? 2 : 1;
	const auto grid = CalculateBaseGridPosition(idx, party_size, 0, table_y_idx, form, terrain_id);
	const auto ti = grid_tables[3][party_size - 1][idx];

	Point position;

	const bool is_odd = (idx & 1);

	switch (cond) {
		case lcf::rpg::System::BattleCondition_none:
		case lcf::rpg::System::BattleCondition_initiative:
			position.x = grid.x + ti + half_width;
			break;
		case lcf::rpg::System::BattleCondition_back:
			position.x = 320 - (grid.x + ti + half_width);
			break;
		case lcf::rpg::System::BattleCondition_surround:
			position.x = 160 + (is_odd ? 16 : -16);
			break;
		case lcf::rpg::System::BattleCondition_pincers:
			position.x = grid.x + half_width + 16;
			if (!is_odd) {
				position.x = 320 - position.x;
			}
			break;
	}

	position.y = grid.y - half_height;

	// RPG_RT only clamps Y position for enemies
	position.y = Utils::Clamp(position.y, half_height, 240 - half_height);

	return position;
}

Point Game_Battle::Calculate2k3BattlePosition(const Game_Actor& actor) {
	assert(troop);

	const auto terrain_id = Game_Battle::GetTerrainId();
	const auto cond = Game_Battle::GetBattleCondition();
	const auto form = Game_Battle::GetBattleFormation();
	auto* sprite = actor.GetBattleSprite();

	int half_height = 0;
	int half_width = 0;
	if (sprite) {
		half_height = sprite->GetHeight() / 2;
		half_width = sprite->GetWidth() / 2;
	}

	int row_x_offset = 0;
	if (actor.GetBattleRow() == Game_Actor::RowType::RowType_front) {
		row_x_offset = half_width;
	}

	// Manual position case
	if (lcf::Data::battlecommands.placement == lcf::rpg::BattleCommands::Placement_manual) {
		auto position = actor.GetOriginalPosition();

		if (cond == lcf::rpg::System::BattleCondition_back) {
			position.x = 320 - (position.x + row_x_offset);
		} else {
			position.x = position.x - row_x_offset;
		}

		// RPG_RT doesn't clamp Y for actors
		position.x = Utils::Clamp(position.x, half_width, 320 - half_width);
		return position;
	}

	const auto idx = Main_Data::game_party->GetActorPositionInParty(actor.GetId());
	const auto party_size = Main_Data::game_party->GetBattlerCount();

	const int table_y_idx = (cond == lcf::rpg::System::BattleCondition_surround) ? 2 : 0;
	const auto grid = CalculateBaseGridPosition(idx, party_size, 0, table_y_idx, form, terrain_id);

	Point position;

	const bool is_odd = (idx & 1);

	switch (cond) {
		case lcf::rpg::System::BattleCondition_none:
		case lcf::rpg::System::BattleCondition_initiative:
			position.x = 320 - (grid.x + half_width + row_x_offset);
			break;
		case lcf::rpg::System::BattleCondition_back:
			position.x = grid.x + 2 * half_width - row_x_offset;
			break;
		case lcf::rpg::System::BattleCondition_surround:
			position.x = grid.x + half_width + row_x_offset;
			if (!is_odd) {
				position.x = 320 - position.x;
			}
			break;
		case lcf::rpg::System::BattleCondition_pincers:
			position.x = 160 + (half_width / 2) - row_x_offset;
			break;
	}

	position.y = grid.y - half_height;

	// RPG_RT doesn't clamp Y for actors
	position.x = Utils::Clamp(position.x, half_width, 320 - half_width);

	return position;
}



/*end of file .\game_battle.cpp*/

/*start of file .\game_battlealgorithm.cpp*/

/*
 *
 * This file is part of EasyRPG Player.
 *
 * EasyRPG Player is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * EasyRPG Player is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with EasyRPG Player. If not, see <http://www.gnu.org/licenses/>.
 */

#include <cassert>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include "game_actor.h"
#include "game_battle.h"
#include "game_battlealgorithm.h"
#include "game_battler.h"
#include "game_enemy.h"
#include "game_enemyparty.h"
#include "game_party.h"
#include "game_party_base.h"
#include "game_switches.h"
#include "game_system.h"
#include "main_data.h"
#include "game_message_terms.h"
#include "output.h"
#include "player.h"
#include <lcf/reader_util.h>
#include <lcf/rpg/animation.h>
#include <lcf/rpg/state.h>
#include <lcf/rpg/skill.h>
#include <lcf/rpg/item.h>
#include <lcf/rpg/battleranimation.h>
#include "sprite_battler.h"
#include "utils.h"
#include "rand.h"
#include "state.h"
#include "enemyai.h"
#include "algo.h"
#include "attribute.h"
#include "spriteset_battle.h"
#include "feature.h"
#include "game_variables.h"

static inline int MaxDamageValue() {
	return lcf::Data::system.easyrpg_max_damage == -1 ? (Player::IsRPG2k() ? 999 : 9999) : lcf::Data::system.easyrpg_max_damage;
}

Game_BattleAlgorithm::AlgorithmBase::AlgorithmBase(Type ty, Game_Battler* source, Game_Battler* target) :
	AlgorithmBase(ty, source, std::vector<Game_Battler*>{ target }) {}

Game_BattleAlgorithm::AlgorithmBase::AlgorithmBase(Type ty, Game_Battler* source, std::vector<Game_Battler*> in_targets) :
	type(ty), source(source), targets(std::move(in_targets))
{
	assert(source != nullptr);

	assert(std::none_of(targets.begin(), targets.end(), [](auto* t) {
		return t == nullptr;
	}));

	Reset();

	source->SetIsDefending(false);

	num_original_targets = targets.size();
	current_target = targets.end();
}

Game_BattleAlgorithm::AlgorithmBase::AlgorithmBase(Type ty, Game_Battler* source, Game_Party_Base* target) :
	type(ty), source(source)
{
	assert(source != nullptr);
	assert(target != nullptr);

	Reset();

	source->SetIsDefending(false);

	current_target = targets.end();
	party_target = target;
}

int Game_BattleAlgorithm::AlgorithmBase::GetActionType() {
	return -1;
}

int Game_BattleAlgorithm::AlgorithmBase::GetActionId() {
	return -1;
}

void Game_BattleAlgorithm::AlgorithmBase::Reset() {
	hp = 0;
	sp = 0;
	attack = 0;
	defense = 0;
	spirit = 0;
	agility = 0;
	switch_id = 0;
	flags = {};
	states.clear();
	attributes.clear();
}

int Game_BattleAlgorithm::AlgorithmBase::PlayAnimation(int anim_id, bool only_sound, int cutoff, bool invert) {
	if (anim_id == 0) {
		return 0;
	}

	auto anim_iter = targets.begin();
	auto anim_end = targets.end();
	// If targets were added, skip the originals and use the added one
	// Cases: reflect, retargeting, etc..
	if (num_original_targets < static_cast<int>(targets.size())) {
		anim_iter += num_original_targets;
	}

	std::vector<Game_Battler*> anim_targets;
	for (; anim_iter != anim_end; ++anim_iter) {
		auto* target = *anim_iter;
		if (!target->IsHidden() && (IsTargetValid(*target) || (target->GetType() == Game_Battler::Type_Ally && target->IsDead()))) {
			anim_targets.push_back(target);
		}
	}

	return Game_Battle::ShowBattleAnimation(anim_id, anim_targets, only_sound, cutoff, invert);
}

std::string Game_BattleAlgorithm::AlgorithmBase::GetFailureMessage() const {
	return BattleMessage::GetPhysicalFailureMessage(*GetSource(), *GetTarget());
}

Game_Battler* Game_BattleAlgorithm::AlgorithmBase::GetTarget() const {
	if (current_target == targets.end()) {
		return NULL;
	}

	return *current_target;
}

bool Game_BattleAlgorithm::AlgorithmBase::Execute() {
	Reset();
	return vExecute();
}

bool Game_BattleAlgorithm::AlgorithmBase::vExecute() {
	return SetIsSuccess();
}

void Game_BattleAlgorithm::AlgorithmBase::ApplyCustomEffect() {
}

int Game_BattleAlgorithm::AlgorithmBase::ApplySwitchEffect() {
	const auto sw = GetAffectedSwitch();
	if (sw > 0) {
		Main_Data::game_switches->Set(sw, true);
	}
	return sw;
}

int Game_BattleAlgorithm::AlgorithmBase::ApplyHpEffect() {
	auto* target = GetTarget();
	assert(target);

	if (target->IsDead()) {
		return 0;
	}
	int hp = GetAffectedHp();
	if (hp != 0) {
		hp = target->ChangeHp(hp, true);
		if (IsAbsorbHp()) {
			// Only absorb the hp that were left
			source->ChangeHp(-hp, true);
		}
	}
	return hp;
}

int Game_BattleAlgorithm::AlgorithmBase::ApplySpEffect() {
	auto* target = GetTarget();
	assert(target);
	auto sp = GetAffectedSp();
	if (sp != 0) {
		sp = target->ChangeSp(sp);
		if (IsAbsorbSp()) {
			// Only absorb the sp that were left
			source->ChangeSp(-sp);
		}

		Game_Battle::ManiacBattleHook(
			Game_Interpreter_Battle::ManiacBattleHookType::StatChange,
			target->GetType() == Game_Battler::Type_Enemy,
			target->GetPartyIndex(),
			target->GetDisplayX(),
			target->GetDisplayY(),
			3,
			sp
		);
	}

	return sp;
}

int Game_BattleAlgorithm::AlgorithmBase::ApplyAtkEffect() {
	auto* target = GetTarget();
	assert(target);
	auto atk = GetAffectedAtk();
	if (atk != 0) {
		atk = target->ChangeAtkModifier(atk);
		if (IsAbsorbAtk()) {
			source->ChangeAtkModifier(-atk);
		}

		Game_Battle::ManiacBattleHook(
			Game_Interpreter_Battle::ManiacBattleHookType::StatChange,
			target->GetType() == Game_Battler::Type_Enemy,
			target->GetPartyIndex(),
			target->GetDisplayX(),
			target->GetDisplayY(),
			4,
			atk
		);
	}
	return atk;
}

int Game_BattleAlgorithm::AlgorithmBase::ApplyDefEffect() {
	auto* target = GetTarget();
	assert(target);
	auto def = GetAffectedDef();
	if (def != 0) {
		def = target->ChangeDefModifier(def);
		if (IsAbsorbDef()) {
			source->ChangeDefModifier(-def);
		}

		Game_Battle::ManiacBattleHook(
			Game_Interpreter_Battle::ManiacBattleHookType::StatChange,
			target->GetType() == Game_Battler::Type_Enemy,
			target->GetPartyIndex(),
			target->GetDisplayX(),
			target->GetDisplayY(),
			5,
			def
		);
	}
	return def;
}

int Game_BattleAlgorithm::AlgorithmBase::ApplySpiEffect() {
	auto* target = GetTarget();
	assert(target);
	auto spi = GetAffectedSpi();
	if (spi) {
		spi = target->ChangeSpiModifier(spi);
		if (IsAbsorbSpi()) {
			source->ChangeSpiModifier(-spi);
		}

		Game_Battle::ManiacBattleHook(
			Game_Interpreter_Battle::ManiacBattleHookType::StatChange,
			target->GetType() == Game_Battler::Type_Enemy,
			target->GetPartyIndex(),
			target->GetDisplayX(),
			target->GetDisplayY(),
			6,
			spi
		);
	}
	return spi;
}

int Game_BattleAlgorithm::AlgorithmBase::ApplyAgiEffect() {
	auto* target = GetTarget();
	assert(target);
	auto agi = GetAffectedAgi();
	if (agi) {
		agi = target->ChangeAgiModifier(agi);
		if (IsAbsorbAgi()) {
			source->ChangeAgiModifier(-agi);
		}

		Game_Battle::ManiacBattleHook(
			Game_Interpreter_Battle::ManiacBattleHookType::StatChange,
			target->GetType() == Game_Battler::Type_Enemy,
			target->GetPartyIndex(),
			target->GetDisplayX(),
			target->GetDisplayY(),
			7,
			agi
		);
	}
	return agi;
}

bool Game_BattleAlgorithm::AlgorithmBase::ApplyStateEffect(StateEffect se) {
	auto* target = GetTarget();
	if (!target) {
		return false;
	}

	bool rc = false;
	bool was_dead = target->IsDead();

	// Apply states
	switch (se.effect) {
		case StateEffect::Inflicted:
			rc = target->AddState(se.state_id, true);
			break;
		case StateEffect::Healed:
		case StateEffect::HealedByAttack:
			rc = target->RemoveState(se.state_id, false);
			break;
		default:
			break;
	}

	// Apply revived hp healing
	if (was_dead && !target->IsDead()) {
		auto hp = GetAffectedHp();
		target->ChangeHp(hp - 1, false);
	}
	return rc;
}

void Game_BattleAlgorithm::AlgorithmBase::ApplyStateEffects() {
	// Apply states
	for (auto& se: states) {
		ApplyStateEffect(se);
	}
}

int Game_BattleAlgorithm::AlgorithmBase::ApplyAttributeShiftEffect(AttributeEffect ae) {
	auto* target = GetTarget();
	if (target) {
		return target->ShiftAttributeRate(ae.attr_id, ae.shift);
	}
	return 0;
}

void Game_BattleAlgorithm::AlgorithmBase::ApplyAttributeShiftEffects() {
	for (auto& ae: attributes) {
		ApplyAttributeShiftEffect(ae);
	}
}

void Game_BattleAlgorithm::AlgorithmBase::ApplyAll() {
	ApplyCustomEffect();
	ApplySwitchEffect();
	ApplyHpEffect();
	ApplySpEffect();
	ApplyAtkEffect();
	ApplyDefEffect();
	ApplySpiEffect();
	ApplyAgiEffect();
	ApplyStateEffects();
	ApplyAttributeShiftEffects();
}

void Game_BattleAlgorithm::AlgorithmBase::ProcessPostActionSwitches() {
	for (int s : switch_on) {
		Main_Data::game_switches->Set(s, true);
	}

	for (int s : switch_off) {
		Main_Data::game_switches->Set(s, false);
	}
}

bool Game_BattleAlgorithm::AlgorithmBase::IsTargetValid(const Game_Battler& target) const {
	return target.Exists();
}

int Game_BattleAlgorithm::AlgorithmBase::GetSourcePose() const {
	return lcf::rpg::BattlerAnimation::Pose_Idle;
}

int Game_BattleAlgorithm::AlgorithmBase::GetCBAMovement() const {
	return lcf::rpg::BattlerAnimationItemSkill::Movement_none;
}

int Game_BattleAlgorithm::AlgorithmBase::GetCBAAfterimage() const {
	return lcf::rpg::BattlerAnimationItemSkill::Afterimage_none;
}

const lcf::rpg::BattlerAnimationItemSkill* Game_BattleAlgorithm::AlgorithmBase::GetWeaponAnimationData() const {
	return nullptr;
}

const lcf::rpg::Item* Game_BattleAlgorithm::AlgorithmBase::GetWeaponData() const {
	return nullptr;
}

void Game_BattleAlgorithm::AlgorithmBase::Start() {
	reflect_target = nullptr;

	if (party_target) {
		targets.clear();
		party_target->GetBattlers(targets);
		num_original_targets = targets.size();
	} else {
		// Remove any previously set reflect targets
		targets.resize(num_original_targets);
	}
	current_target = targets.begin();

	// Call any custom start logic, then check if we need to retarget
	bool allow_retarget = vStart();

	if (!IsCurrentTargetValid()) {
		if (!TargetNext() && allow_retarget && !party_target && !targets.empty()) {
			auto* last_target = targets.back();
			auto* next_target = last_target->GetParty().GetNextActiveBattler(last_target);
			if (next_target) {
				current_target = targets.insert(targets.end(), next_target);
			}

			if (!IsCurrentTargetValid()) {
				TargetNext();
			}
		}
	}

	// This case must be true before returning.
	assert(current_target == targets.end() || IsCurrentTargetValid());

	source->SetCharged(false);
}

bool Game_BattleAlgorithm::AlgorithmBase::vStart() {
	return true;
}

void Game_BattleAlgorithm::AlgorithmBase::AddTarget(Game_Battler* target, bool set_current) {
	assert(target != nullptr);

	const auto idx = std::distance(targets.begin(), current_target);
	const auto size = targets.size();
	targets.push_back(target);
	current_target = targets.begin() + (set_current ? size : idx);
}

void Game_BattleAlgorithm::AlgorithmBase::AddTargets(Game_Party_Base* party, bool set_current) {
	assert(party != nullptr);
	const auto idx = std::distance(targets.begin(), current_target);
	const auto size = targets.size();
	party->GetBattlers(targets);
	current_target = targets.begin() + (set_current ? size : idx);
}

bool Game_BattleAlgorithm::AlgorithmBase::ReflectTargets() {
	auto iter = std::find_if(current_target, targets.end(), [this](auto* target) { return IsReflected(*target); });

	// No reflect
	if (iter == targets.end()) {
		return false;
	}

	reflect_target = *iter;

	if (party_target) {
		// Reflect back on source party
		AddTargets(&source->GetParty(), true);
	} else {
		// Reflect back on source
		AddTarget(source, true);
	}

	if (!IsCurrentTargetValid()) {
		TargetNext();
	}
	return true;
}

bool Game_BattleAlgorithm::AlgorithmBase::TargetNext() {
	return TargetNextInternal();
}

bool Game_BattleAlgorithm::AlgorithmBase::RepeatNext(bool require_valid) {
	++cur_repeat;
	if (cur_repeat >= repeat || (require_valid && !IsCurrentTargetValid())) {
		cur_repeat = 0;
		return false;
	}
	return true;
}

bool Game_BattleAlgorithm::AlgorithmBase::IsCurrentTargetValid() const {
	if (current_target == targets.end()) {
		return false;
	}
	return IsTargetValid(**current_target);
}

bool Game_BattleAlgorithm::AlgorithmBase::TargetNextInternal() {
	do {
		if (current_target == targets.end() || ++current_target == targets.end()) {
			return false;
		}
	} while (!IsCurrentTargetValid());

	return true;
}

void Game_BattleAlgorithm::AlgorithmBase::SetRepeat(int repeat) {
	this->repeat = std::max(1, repeat);
}

void Game_BattleAlgorithm::AlgorithmBase::SetSwitchEnable(int switch_id) {
	switch_on.push_back(switch_id);
}

void Game_BattleAlgorithm::AlgorithmBase::SetSwitchDisable(int switch_id) {
	switch_off.push_back(switch_id);
}

const lcf::rpg::Sound* Game_BattleAlgorithm::AlgorithmBase::GetStartSe() const {
	return NULL;
}

std::string Game_BattleAlgorithm::AlgorithmBase::GetStartMessage(int) const {
	return "";
}

const lcf::rpg::Sound* Game_BattleAlgorithm::AlgorithmBase::GetFailureSe() const {
	return &Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Evasion);
}

bool Game_BattleAlgorithm::AlgorithmBase::IsReflected(const Game_Battler&) const {
	return false;
}

void Game_BattleAlgorithm::AlgorithmBase::ApplyComboHitsMultiplier(int hits) {
	repeat *= hits;
}

void Game_BattleAlgorithm::AlgorithmBase::AddAffectedState(StateEffect se) {
	auto* target = GetTarget();
	if (se.state_id == lcf::rpg::State::kDeathID
			&& (se.effect == StateEffect::Healed || se.effect == StateEffect::HealedByAttack)
			&& target && target->IsDead()) {
		SetFlag(eRevived, true);
	}
	states.push_back(std::move(se));
}

void Game_BattleAlgorithm::AlgorithmBase::AddAffectedAttribute(AttributeEffect ae) {
	attributes.push_back(std::move(ae));
}

void Game_BattleAlgorithm::AlgorithmBase::BattlePhysicalStateHeal(int physical_rate, std::vector<int16_t>& target_states, const PermanentStates& ps) {
	if (physical_rate <= 0) {
		return;
	}

	for (int i = 0; i < (int)target_states.size(); ++i) {
		auto state_id = i + 1;
		if (!State::Has(state_id, target_states)) {
			continue;
		}

		auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, state_id);
		if (state == nullptr) {
			continue;
		}
		if (state->release_by_damage > 0) {
			int release_chance = state->release_by_damage * physical_rate / 100;

			if (!Rand::ChanceOf(release_chance, 100)) {
				continue;
			}

			if (State::Remove(state_id, target_states, ps)) {
				AddAffectedState(StateEffect{state_id, Game_BattleAlgorithm::StateEffect::HealedByAttack});
			}
		}
	}
}



Game_BattleAlgorithm::None::None(Game_Battler* source) :
AlgorithmBase(Type::None, source, source) {
	// no-op
}

int Game_BattleAlgorithm::None::GetActionId() {
	return lcf::rpg::EnemyAction::Basic_nothing;
}

int Game_BattleAlgorithm::None::GetActionType() {
	return lcf::rpg::EnemyAction::Kind_basic;
}

int Game_BattleAlgorithm::Normal::GetActionId() {
	if (IsDualAttack()) {
		return lcf::rpg::EnemyAction::Basic_dual_attack;
	}

	return lcf::rpg::EnemyAction::Basic_attack;
}

int Game_BattleAlgorithm::Normal::GetActionType() {
	return lcf::rpg::EnemyAction::Kind_basic;
}

Game_BattleAlgorithm::Normal::Normal(Game_Battler* source, Game_Battler* target, int hits_multiplier, Style style) :
	AlgorithmBase(Type::Normal, source, target), hits_multiplier(hits_multiplier)
{
	Init(style);
}

Game_BattleAlgorithm::Normal::Normal(Game_Battler* source, Game_Party_Base* target, int hits_multiplier, Style style) :
	AlgorithmBase(Type::Normal, source, target), hits_multiplier(hits_multiplier)
{
	Init(style);
}

Game_BattleAlgorithm::Normal::Style Game_BattleAlgorithm::Normal::GetDefaultStyle() {
	return Feature::HasRpg2k3BattleSystem() ? Style_MultiHit : Style_Combined;
}

Game_Battler::Weapon Game_BattleAlgorithm::Normal::GetWeapon() const {
	if (weapon_style < 0) {
		return Game_Battler::WeaponAll;
	}
	return GetCurrentRepeat() >= weapon_style ? Game_Battler::WeaponSecondary : Game_Battler::WeaponPrimary;
}

void Game_BattleAlgorithm::Normal::Init(Style style) {
	auto* source = GetSource();
	charged_attack = source->IsCharged();
	weapon_style = -1;
	if (source->GetType() == Game_Battler::Type_Ally && style == Style_MultiHit) {
		auto* ally = static_cast<Game_Actor*>(source);
		if (ally->GetWeapon() && ally->Get2ndWeapon()) {
			auto hits = hits_multiplier * ally->GetNumberOfAttacks(Game_Battler::WeaponPrimary);
			weapon_style = hits;
			hits += hits_multiplier * ally->GetNumberOfAttacks(Game_Battler::WeaponSecondary);
			SetRepeat(hits);
			return;
		}
	}
	SetRepeat(hits_multiplier * source->GetNumberOfAttacks(GetWeapon()));
}

void Game_BattleAlgorithm::Normal::ApplyComboHitsMultiplier(int hits) {
	AlgorithmBase::ApplyComboHitsMultiplier(hits);
	if (weapon_style > 0) {
		// For dual wield normal attack, the first weapon gets combo'd then the second weapon.
		weapon_style *= hits;
	}
}


bool Game_BattleAlgorithm::Normal::vStart() {
	// If this weapon attacks all, then attack all enemies regardless of original targetting.
	const auto weapon = GetWeapon();
	auto* source = GetSource();
	if (GetOriginalPartyTarget() == nullptr && source->HasAttackAll(weapon)) {
		auto* target = GetOriginalTargets().back();
		AddTargets(&target->GetParty(), true);
	}

	source->ChangeSp(-source->CalculateWeaponSpCost(weapon));

	return true;
}

int Game_BattleAlgorithm::Normal::GetAnimationId(int idx) const {
	const auto weapon = GetWeapon();
	auto* source = GetSource();
	if (source->GetType() == Game_Battler::Type_Ally) {
		Game_Actor* ally = static_cast<Game_Actor*>(source);
		auto weapons = ally->GetWeapons(weapon);
		auto* item = (idx >= 0 && idx < static_cast<int>(weapons.size()))
			? weapons[idx] : nullptr;
		if (item) {
			return item->animation_id;
		} else if (idx == 0) {
			return ally->GetUnarmedBattleAnimationId();
		}
		return 0;
	}
	if (source->GetType() == Game_Battler::Type_Enemy
			&& Feature::HasRpg2k3BattleSystem()
			&& !lcf::Data::animations.empty()) {
		Game_Enemy* enemy = static_cast<Game_Enemy*>(source);
		return enemy->GetUnarmedBattleAnimationId();
	}
	return 0;
}

bool Game_BattleAlgorithm::Normal::vExecute() {
	const auto weapon = GetWeapon();
	auto& source = *GetSource();
	auto& target = *GetTarget();

	auto to_hit = Algo::CalcNormalAttackToHit(source, target, weapon, Game_Battle::GetBattleCondition(), true);
	auto crit_chance = Algo::CalcCriticalHitChance(source, target, weapon, -1);

	// Damage calculation
	if (!Rand::PercentChance(to_hit)) {
		return SetIsFailure();
	}

	if (Rand::PercentChance(crit_chance)) {
		SetIsCriticalHit(true);
	}

	auto effect = Algo::CalcNormalAttackEffect(source, target, weapon, IsCriticalHit(), charged_attack, true, Game_Battle::GetBattleCondition(), treat_enemies_asif_in_front_row);
	effect = Algo::AdjustDamageForDefend(effect, target);

	effect = Utils::Clamp(effect, -MaxDamageValue(), MaxDamageValue());

	this->SetAffectedHp(-effect);

	// If target is killed, states not applied
	if (target.GetHp() + GetAffectedHp() <= 0) {
		return SetIsSuccess();
	}

	// Make a copy of the target's state set and see what we can apply.
	auto target_states = target.GetStates();
	auto target_perm_states = target.GetPermanentStates();

	// Conditions healed by physical attack:
	BattlePhysicalStateHeal(100, target_states, target_perm_states);

	auto easyrpg_state_set = [&](const auto& state_set, const auto& state_chance) {
		int num_states = static_cast<int>(state_set.size());
		for (int i = 0; i < num_states; ++i) {
			int inflict_pct = 0;
			if (i < static_cast<int>(num_states) && state_set[i]) {
				inflict_pct = static_cast<int>(state_chance);
			}
			auto state_id = (i + 1);

			if (inflict_pct > 0) {
				inflict_pct = inflict_pct * target.GetStateProbability(state_id) / 100;
				if (Rand::PercentChance(inflict_pct)) {
					if (!State::Has(state_id, target_states) && State::Add(state_id, target_states, target_perm_states, true)) {
						AddAffectedState(StateEffect{state_id, StateEffect::Inflicted});
					}
				}
				inflict_pct = 0;
			}
		}
	};

	// Conditions caused / healed by weapon.
	if (source.GetType() == Game_Battler::Type_Ally) {
		auto& ally = static_cast<Game_Actor&>(source);
		const bool is2k3 = Player::IsRPG2k3();
		auto weapons = ally.GetWeapons(weapon);

		if (weapons[0]) {
			int num_states = 0;
			for (auto* w: weapons) {
				if (w) {
					num_states = std::max(num_states, static_cast<int>(w->state_set.size()));
				}
			}

			for (int i = 0; i < num_states; ++i) {
				// EasyRPG extension: This logic allows heal/inflict to work properly with a combined weapon attack.
				// If the first weapon heals and the second inflicts, then this will do then in the right order.
				// If both heal or both inflict, we take the max probability as RPG_RT does.
				int heal_pct = 0;
				int inflict_pct = 0;
				for (auto* w: weapons) {
					if (w && i < static_cast<int>(w->state_set.size()) && w->state_set[i]) {
						if (is2k3 && w->reverse_state_effect) {
							heal_pct = std::max(heal_pct, static_cast<int>(w->state_chance));
						} else {
							inflict_pct = std::max(inflict_pct, static_cast<int>(w->state_chance));
						}
					}
				}
				auto state_id = (i + 1);

				for (auto* w: weapons) {
					if (is2k3 && w && w->reverse_state_effect) {
						if (heal_pct > 0 && Rand::PercentChance(heal_pct)) {
							if (State::Remove(state_id, target_states, target_perm_states)) {
								AddAffectedState(StateEffect{state_id, StateEffect::Healed});
							}
						}
						heal_pct = 0;
					} else if (inflict_pct > 0) {
						inflict_pct = inflict_pct * target.GetStateProbability(state_id) / 100;
						if (Rand::PercentChance(inflict_pct)) {
							// Unlike skills, weapons do not try to reinflict states already present
							if (!State::Has(state_id, target_states) && State::Add(state_id, target_states, target_perm_states, true)) {
								AddAffectedState(StateEffect{state_id, StateEffect::Inflicted});
							}
						}
						inflict_pct = 0;
					}
				}
			}
		} else {
			lcf::rpg::Actor* allydata = lcf::ReaderUtil::GetElement(lcf::Data::actors, ally.GetId());
			easyrpg_state_set(allydata->easyrpg_unarmed_state_set, allydata->easyrpg_unarmed_state_chance);
		}
	} else if (source.GetType() == Game_Battler::Type_Enemy) {
		auto& enemy = static_cast<Game_Enemy&>(source);
		lcf::rpg::Enemy* enemydata = lcf::ReaderUtil::GetElement(lcf::Data::enemies, enemy.GetId());
		easyrpg_state_set(enemydata->easyrpg_state_set, enemydata->easyrpg_state_chance);
	}

	return SetIsSuccess();
}

bool Game_BattleAlgorithm::Normal::IsDualAttack() const {
	return GetSource()->GetType() == Game_Battler::Type_Enemy && hits_multiplier == 2;
}

std::string Game_BattleAlgorithm::Normal::GetStartMessage(int line) const {
	if (line == 0) {
		if (Feature::HasRpg2kBattleSystem()) {
			return BattleMessage::GetNormalAttackStartMessage2k(*GetSource());
		}
		if (IsDualAttack()) {
			return BattleMessage::GetDoubleAttackStartMessage2k3(*GetSource());
		}
	}
	return "";
}

int Game_BattleAlgorithm::Normal::GetSourcePose() const {
	auto weapon = GetWeapon();
	return weapon == Game_Battler::WeaponSecondary
		? lcf::rpg::BattlerAnimation::Pose_AttackLeft
		: lcf::rpg::BattlerAnimation::Pose_AttackRight;
}

int Game_BattleAlgorithm::Normal::GetCBAMovement() const {
	const auto weapon = GetWeapon();
	auto* source = GetSource();
	if (source->GetType() == Game_Battler::Type_Ally) {
		auto* ally = static_cast<Game_Actor*>(source);
		auto weapons = ally->GetWeapons(weapon);
		auto* item = weapons[0];
		if (item) {
			if (static_cast<int>(item->animation_data.size()) > source->GetId() - 1) {
				return item->animation_data[source->GetId() - 1].movement;
			}
		}
	}

	return lcf::rpg::BattlerAnimationItemSkill::Movement_none;
}

int Game_BattleAlgorithm::Normal::GetCBAAfterimage() const {
	const auto weapon = GetWeapon();
	auto* source = GetSource();
	if (source->GetType() == Game_Battler::Type_Ally) {
		auto* ally = static_cast<Game_Actor*>(source);
		auto weapons = ally->GetWeapons(weapon);
		auto* item = weapons[0];
		if (item) {
			if (static_cast<int>(item->animation_data.size()) > source->GetId() - 1) {
				return item->animation_data[source->GetId() - 1].after_image;
			}
		}
	}

	return lcf::rpg::BattlerAnimationItemSkill::Afterimage_none;
}

const lcf::rpg::BattlerAnimationItemSkill* Game_BattleAlgorithm::Normal::GetWeaponAnimationData() const {
	const auto weapon = GetWeapon();
	auto* source = GetSource();
	if (source->GetType() == Game_Battler::Type_Ally) {
		auto* ally = static_cast<Game_Actor*>(source);
		auto weapons = ally->GetWeapons(weapon);
		auto* item = weapons[0];
		if (item) {
			if (static_cast<int>(item->animation_data.size()) > source->GetId() - 1) {
				return &item->animation_data[source->GetId() - 1];
			}
		}
	}

	return nullptr;
}

const lcf::rpg::Item* Game_BattleAlgorithm::Normal::GetWeaponData() const {
	const auto weapon = GetWeapon();
	auto* source = GetSource();
	if (source->GetType() == Game_Battler::Type_Ally) {
		auto* ally = static_cast<Game_Actor*>(source);
		auto weapons = ally->GetWeapons(weapon);
		auto* item = weapons[0];
		if (item) {
			return item;
		}
	}

	return nullptr;
}

const lcf::rpg::Sound* Game_BattleAlgorithm::Normal::GetStartSe() const {
	if (Feature::HasRpg2kBattleSystem() && GetSource()->GetType() == Game_Battler::Type_Enemy) {
		return &Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_EnemyAttacks);
	}
	return nullptr;
}

Game_BattleAlgorithm::Skill::Skill(Game_Battler* source, Game_Battler* target, const lcf::rpg::Skill& skill, const lcf::rpg::Item* item) :
	AlgorithmBase(Type::Skill, source, target), skill(skill), item(item)
{
	Init();
}

Game_BattleAlgorithm::Skill::Skill(Game_Battler* source, Game_Party_Base* target, const lcf::rpg::Skill& skill, const lcf::rpg::Item* item) :
	AlgorithmBase(Type::Skill, source, target), skill(skill), item(item)
{
	Init();
}

Game_BattleAlgorithm::Skill::Skill(Game_Battler* source, const lcf::rpg::Skill& skill, const lcf::rpg::Item* item) :
	Skill(source, source, skill, item)
{
}

int Game_BattleAlgorithm::Skill::GetActionType() {
	return lcf::rpg::EnemyAction::Kind_skill;
}

int Game_BattleAlgorithm::Skill::GetActionId() {
	return skill.ID;
}

void Game_BattleAlgorithm::Skill::Init() {
}

bool Game_BattleAlgorithm::Skill::vStart() {
	auto* source = GetSource();
	if (item) {
		Main_Data::game_party->ConsumeItemUse(item->ID);
	} else {
		source->ChangeSp(-source->CalculateSkillCost(skill.ID));
		source->ChangeHp(-source->CalculateSkillHpCost(skill.ID), false);
	}
	return true;
}

int Game_BattleAlgorithm::Skill::GetAnimationId(int idx) const {
	return idx == 0 && Algo::IsNormalOrSubskill(skill) ? skill.animation_id : 0;
}

bool Game_BattleAlgorithm::Skill::IsTargetValid(const Game_Battler& target) const {
	if (target.IsHidden()) {
		return false;
	}

	if (target.IsDead()) {
		// Cures death
		// NOTE: RPG_RT 2k3 also allows this targetting if reverse_state_effect.
		return Algo::SkillTargetsAllies(skill) && !skill.state_effects.empty() && skill.state_effects[0];
	}

	return true;
}


bool Game_BattleAlgorithm::Skill::vExecute() {
	if (item && item->skill_id != skill.ID) {
		assert(false && "Item skill mismatch");
	}
	auto* source = GetSource();
	assert(source);
	auto* target = GetTarget();
	assert(target);

	if (skill.type == lcf::rpg::Skill::Type_switch) {
		SetAffectedSwitch(skill.switch_id);
		return SetIsSuccess();
	}

	if (!Algo::IsNormalOrSubskill(skill)) {
		// Possible to trigger in RPG_RT by using a weapon which invokes a teleport or escape skills.
		// Silently does nothing.
		return SetIsSuccess();
	}

	SetIsPositive(Algo::SkillTargetsAllies(skill));

	auto to_hit = Algo::CalcSkillToHit(*source, *target, skill, Game_Battle::GetBattleCondition(), true);
	auto crit_chance = Algo::CalcCriticalHitChance(*source, *target, Game_Battler::WeaponAll, skill.easyrpg_critical_hit_chance);

	if (Rand::PercentChance(crit_chance)) {
		SetIsCriticalHit(true);
	}

	auto effect = Algo::CalcSkillEffect(*source, *target, skill, true, IsCriticalHit(), Game_Battle::GetBattleCondition(), treat_enemies_asif_in_front_row);
	effect = Utils::Clamp(effect, -MaxDamageValue(), MaxDamageValue());

	if (!IsPositive()) {
		effect = -effect;
	}

	const bool is_dead = target->IsDead();
	const bool cures_death = IsPositive()
		&& !skill.state_effects.empty()
		&& skill.state_effects[lcf::rpg::State::kDeathID - 1]
		&& is_dead;

	// Dead targets only allowed if this skill revives later
	if (is_dead && (!IsPositive() || !cures_death)) {
		return SetIsFailure();
	}

	// Absorb only works on offensive skills.
	const auto absorb = (skill.absorb_damage && !IsPositive());

	// Make a copy of the target's state set and see what we can apply.
	auto target_states = target->GetStates();
	auto target_perm_states = target->GetPermanentStates();

	if (skill.affect_hp && Rand::PercentChance(to_hit)) {
		const auto hp_effect = IsPositive()
			? effect
			: Algo::AdjustDamageForDefend(effect, *target);

		const auto hp_cost = (source == target) ? source->CalculateSkillHpCost(skill.ID) : 0;
		const auto cur_hp = target->GetHp() - hp_cost;

		if (absorb) {
			// Cannot aborb more hp than the target has.
			auto hp = std::max<int>(hp_effect, -cur_hp);
			if (hp != 0) {
				SetAffectedHp(hp);
				SetIsAbsorbHp(true);

				// Absorb requires damage to be successful
				SetIsSuccess();
			}
		} else {
			if (IsPositive()) {
				// RPG_RT attribute inverted healing effects are non-lethal
				auto hp = std::max(-(cur_hp - 1), hp_effect);
				if (hp != 0) {
					// HP recovery is sucessful if the effect is non-zero, even at full hp.
					SetAffectedHp(hp);
					SetIsSuccess();
				}
			} else {
				SetAffectedHp(hp_effect);

				if (cur_hp + GetAffectedHp() > 0) {
					// Conditions healed by physical attack, but only if target not killed.
					BattlePhysicalStateHeal(skill.physical_rate * 10, target_states, target_perm_states);
				}

				// Hp damage always successful, even if 0
				SetIsSuccess();
			}
		}
	}

	// If target will be killed, no further affects are applied.
	if (!is_dead && GetTarget()->GetHp() + this->GetAffectedHp() <= 0) {
		return IsSuccess();
	}

	if (skill.affect_sp && Rand::PercentChance(to_hit)) {
		const auto sp_cost = (source == target) ? source->CalculateSkillCost(skill.ID) : 0;
		const auto max_sp = target->GetMaxSp();
		const auto cur_sp = target->GetSp() - sp_cost;

		int sp = 0;
		if (absorb) {
			// Cannot aborb more sp than the target has.
			sp = std::max<int>(effect, -cur_sp);
		} else {
			sp = Utils::Clamp(cur_sp + effect, 0, max_sp) - cur_sp;
		}

		if (sp != 0) {
			SetAffectedSp(sp);
			SetIsAbsorbSp(absorb);
			SetIsSuccess();
		}
	}

	if (!IsPositive() && !IsSuccess() && (skill.affect_hp || skill.affect_sp)) {
		return IsSuccess();
	}

	if (skill.affect_attack && Rand::PercentChance(to_hit)) {
		const auto atk = target->CanChangeAtkModifier(effect);
		if (atk != 0) {
			SetAffectedAtk(atk);
			if (skill.easyrpg_enable_stat_absorbing) {
				SetIsAbsorbAtk(absorb);
			}
			SetIsSuccess();
		}
	}
	if (skill.affect_defense && Rand::PercentChance(to_hit)) {
		const auto def = target->CanChangeDefModifier(effect);
		if (def != 0) {
			SetAffectedDef(def);
			if (skill.easyrpg_enable_stat_absorbing) {
				SetIsAbsorbDef(absorb);
			}
			SetIsSuccess();
		}
	}
	if (skill.affect_spirit && Rand::PercentChance(to_hit)) {
		const auto spi = target->CanChangeSpiModifier(effect);
		if (spi != 0) {
			SetAffectedSpi(spi);
			if (skill.easyrpg_enable_stat_absorbing) {
				SetIsAbsorbSpi(absorb);
			}
			SetIsSuccess();
		}
	}
	if (skill.affect_agility && Rand::PercentChance(to_hit)) {
		const auto agi = target->CanChangeAgiModifier(effect);
		if (agi != 0) {
			SetAffectedAgi(agi);
			if (skill.easyrpg_enable_stat_absorbing) {
				SetIsAbsorbAgi(absorb);
			}
			SetIsSuccess();
		}
	}

	bool heals_states = IsPositive() ^ (Player::IsRPG2k3() && skill.reverse_state_effect);
	bool affected_death = false;
	int to_hit_states = (skill.easyrpg_state_hit != -1 ? skill.easyrpg_state_hit : to_hit);
	for (int i = 0; i < static_cast<int>(skill.state_effects.size()); i++) {
		if (!skill.state_effects[i])
			continue;
		auto state_id = i + 1;

		bool target_has_state = State::Has(state_id, target_states);

		if (!heals_states && target_has_state) {
			SetIsSuccess();
			AddAffectedState(StateEffect{state_id, StateEffect::AlreadyInflicted});
			continue;
		}

		if (!Rand::PercentChance(to_hit_states)) {
			continue;
		}

		if (heals_states) {
			if (target_has_state) {
				// RPG_RT 2k3 skills which fail due to permanent states don't "miss"
				SetIsSuccess();
				if (State::Remove(state_id, target_states, target_perm_states)) {
					AddAffectedState(StateEffect{state_id, StateEffect::Healed});
					affected_death |= (state_id == lcf::rpg::State::kDeathID);
				}
			}
		} else if (Rand::PercentChance(target->GetStateProbability(state_id))) {
			if (State::Add(state_id, target_states, target_perm_states, true)) {
				SetIsSuccess();
				AddAffectedState(StateEffect{state_id, StateEffect::Inflicted});
				affected_death |= (state_id == lcf::rpg::State::kDeathID);
			}
		}
	}

	if (IsRevived() && effect > 0) {
		// If resurrected and no HP selected, the effect value is a percentage:
		if (skill.affect_hp) {
			SetAffectedHp(std::max(0, effect));
		} else {
			SetAffectedHp(target->GetMaxHp() * effect / 100);
		}
	}

	// When a skill inflicts death state, other states can also be inflicted, but attributes will be skipped
	if (!heals_states && affected_death) {
		return SetIsSuccess();
	}

	// Attribute resistance / weakness + an attribute selected + can be modified
	int to_hit_attribute_shift = (skill.easyrpg_attribute_hit != -1 ? skill.easyrpg_attribute_hit : to_hit);
	if (skill.affect_attr_defence) {
		auto shift = IsPositive() ? 1 : -1;
		if (shift >= 0 || !GetTarget()->IsImmuneToAttributeDownshifts()) {
			for (int i = 0; i < static_cast<int>(skill.attribute_effects.size()); i++) {
				auto id = i + 1;
				if (skill.attribute_effects[i]
						&& GetTarget()->CanShiftAttributeRate(id, shift)
						&& Rand::PercentChance(to_hit_attribute_shift)
						)
				{
					AddAffectedAttribute({ id, shift});
					SetIsSuccess();
				}
			}
		}
	}

	return IsSuccess();
}

std::string Game_BattleAlgorithm::Skill::GetStartMessage(int line) const {
	if (item && item->using_message == 0) {
		if (line == 0) {
			if (Feature::HasRpg2kBattleSystem()) {
				return BattleMessage::GetItemStartMessage2k(*GetSource(), *item);
			} else {
				return BattleMessage::GetItemStartMessage2k3(*GetSource(), *item);
			}
		}
		return "";
	}

	const auto* target = GetOriginalSingleTarget();
	if (line == 0) {
		if (Feature::HasRpg2kBattleSystem()) {
			if (!skill.using_message1.empty()) {
				return BattleMessage::GetSkillFirstStartMessage2k(*GetSource(), target, skill);
			} else {
				return BattleMessage::GetSkillSecondStartMessage2k(*GetSource(), target, skill);
			}
		} else {
			return BattleMessage::GetSkillStartMessage2k3(*GetSource(), target, skill);
		}
	}
	if (line == 1 && Feature::HasRpg2kBattleSystem() && !skill.using_message2.empty()) {
		return BattleMessage::GetSkillSecondStartMessage2k(*GetSource(), target, skill);
	}
	return "";
}

int Game_BattleAlgorithm::Skill::GetSourcePose() const {
	auto* source = GetSource();
	if (source->GetType() == Game_Battler::Type_Ally) {
		if (static_cast<int>(skill.battler_animation_data.size()) > source->GetId() - 1) {
			return skill.battler_animation_data[source->GetId() - 1].pose;
		}
	}

	return lcf::rpg::BattlerAnimation::Pose_Skill;
}

int Game_BattleAlgorithm::Skill::GetCBAMovement() const {
	auto* source = GetSource();
	if (source->GetType() == Game_Battler::Type_Ally) {
		if (static_cast<int>(skill.battler_animation_data.size()) > source->GetId() - 1) {
			return skill.battler_animation_data[source->GetId() - 1].movement;
		}
	}

	return lcf::rpg::BattlerAnimationItemSkill::Movement_none;
}

int Game_BattleAlgorithm::Skill::GetCBAAfterimage() const {
	auto* source = GetSource();
	if (source->GetType() == Game_Battler::Type_Ally) {
		if (static_cast<int>(skill.battler_animation_data.size()) > source->GetId() - 1) {
			return skill.battler_animation_data[source->GetId() - 1].after_image;
		}
	}

	return lcf::rpg::BattlerAnimationItemSkill::Afterimage_none;
}

const lcf::rpg::Sound* Game_BattleAlgorithm::Skill::GetStartSe() const {
	if (skill.type == lcf::rpg::Skill::Type_switch) {
		return &skill.sound_effect;
	}
	return nullptr;
}

const lcf::rpg::Sound* Game_BattleAlgorithm::Skill::GetFailureSe() const {
	return skill.failure_message != 3
		? nullptr
		: &Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Evasion);
}

std::string Game_BattleAlgorithm::Skill::GetFailureMessage() const {
	return BattleMessage::GetSkillFailureMessage(*GetSource(), *GetTarget(), skill);
}

bool Game_BattleAlgorithm::Skill::IsReflected(const Game_Battler& target) const {
	if (item || skill.easyrpg_ignore_reflect) {
		return false;
	}
	return IsTargetValid(target) && target.HasReflectState() && target.GetType() != GetSource()->GetType();
}

bool Game_BattleAlgorithm::Skill::ActionIsPossible() const {
	auto* source = GetSource();
	if (item) {
		return Main_Data::game_party->GetItemTotalCount(item->ID) > 0;
	}
	if (!source->IsSkillUsable(skill.ID)) {
		return false;
	}
	// RPG_RT performs this check only for enemies and if skill is single target
	const auto* target = GetOriginalSingleTarget();
	if (source->GetType() == Game_Battler::Type_Enemy && target && target->GetType() == source->GetType()) {
		if (!EnemyAi::IsSkillEffectiveOn(skill, *target, true)) {
			return false;
		}
	}
	return true;
}

Game_BattleAlgorithm::Item::Item(Game_Battler* source, Game_Battler* target, const lcf::rpg::Item& item) :
	AlgorithmBase(Type::Item, source, target), item(item) {
		// no-op
}

Game_BattleAlgorithm::Item::Item(Game_Battler* source, Game_Party_Base* target, const lcf::rpg::Item& item) :
	AlgorithmBase(Type::Item, source, target), item(item) {
		// no-op
}

int Game_BattleAlgorithm::Item::GetActionType() {
	return 3;
}

int Game_BattleAlgorithm::Item::GetActionId() {
	return item.ID;
}

bool Game_BattleAlgorithm::Item::vStart() {
	Main_Data::game_party->ConsumeItemUse(item.ID);

	if (Player::IsPatchManiac()) {
		int CE_ID = std::get<0>(Game_Interpreter_Battle::maniac_hooks[Game_Interpreter_Battle::ManiacBattleHookType::Targetting]);
		if (CE_ID > 0) {
			int Var_ID = std::get<1>(Game_Interpreter_Battle::maniac_hooks[Game_Interpreter_Battle::ManiacBattleHookType::Targetting]);
			Main_Data::game_variables->Set(Var_ID + 2, 2); // Action Type: Item
			Main_Data::game_variables->Set(Var_ID + 3, item.ID);
		}
	}

	return true;
}

Game_BattleAlgorithm::Item::Item(Game_Battler* source, const lcf::rpg::Item& item) :
	Item(source, source, item) {}

bool Game_BattleAlgorithm::Item::IsTargetValid(const Game_Battler&) const {
	return item.type == lcf::rpg::Item::Type_medicine || item.type == lcf::rpg::Item::Type_switch;
}

bool Game_BattleAlgorithm::Item::vExecute() {
	auto* target = GetTarget();

	if (item.type == lcf::rpg::Item::Type_switch) {
		SetAffectedSwitch(item.switch_id);
		return SetIsSuccess();
	}

	if (item.type == lcf::rpg::Item::Type_medicine) {
		SetIsPositive(true);

		// RM2k3 BUG: In rm2k3 battle system, this IsItemUsable() check is only applied when equipment_setting == actor, not for class.
		if (GetTarget()->GetType() == Game_Battler::Type_Ally && !static_cast<Game_Actor*>(GetTarget())->IsItemUsable(item.ID)) {
			// No effect, but doesn't behave like a dodge or damage to set healing and success to true.
			return SetIsSuccess();
		}

		if (item.ko_only && !GetTarget()->IsDead()) {
			return SetIsSuccess();
		}

		// Make a copy of the target's state set and see what we can apply.
		auto target_states = target->GetStates();
		auto target_perm_states = target->GetPermanentStates();

		for (int i = 0; i < (int)item.state_set.size(); i++) {
			if (item.state_set[i]) {
				if (State::Remove(i + 1, target_states, target_perm_states)) {
					AddAffectedState(StateEffect(i+1, StateEffect::Healed));
				}
			}
		}

		// HP recovery
		if ((item.recover_hp != 0 || item.recover_hp_rate != 0) && (!target->IsDead() || IsRevived())) {
			SetAffectedHp(item.recover_hp_rate * GetTarget()->GetMaxHp() / 100 + item.recover_hp);
		}

		// SP recovery
		if (item.recover_sp != 0 || item.recover_sp_rate != 0) {
			SetAffectedSp(item.recover_sp_rate * GetTarget()->GetMaxSp() / 100 + item.recover_sp);
		}

		return SetIsSuccess();
	}

	assert("Unsupported battle item type");
	return SetIsFailure();
}

std::string Game_BattleAlgorithm::Item::GetStartMessage(int line) const {
	if (line == 0) {
		if (Feature::HasRpg2kBattleSystem()) {
			return BattleMessage::GetItemStartMessage2k(*GetSource(), item);
		} else {
			return BattleMessage::GetItemStartMessage2k3(*GetSource(), item);
		}
	}
	return "";
}

int Game_BattleAlgorithm::Item::GetSourcePose() const {
	return lcf::rpg::BattlerAnimation::Pose_Item;
}

int Game_BattleAlgorithm::Item::GetCBAMovement() const {
	auto* source = GetSource();
	if (source->GetType() == Game_Battler::Type_Ally) {
		if (static_cast<int>(item.animation_data.size()) > source->GetId() - 1) {
			return item.animation_data[source->GetId() - 1].movement;
		}
	}

	return lcf::rpg::BattlerAnimationItemSkill::Movement_none;
}

const lcf::rpg::Sound* Game_BattleAlgorithm::Item::GetStartSe() const {
	if (item.type == lcf::rpg::Item::Type_medicine || item.type == lcf::rpg::Item::Type_switch) {
		return &Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_UseItem);
	}
	return nullptr;
}

bool Game_BattleAlgorithm::Item::ActionIsPossible() const {
	return Main_Data::game_party->GetItemTotalCount(item.ID) > 0;
}

Game_BattleAlgorithm::Defend::Defend(Game_Battler* source) :
	AlgorithmBase(Type::Defend, source, source) {
		source->SetIsDefending(true);
}

int Game_BattleAlgorithm::Defend::GetActionType() {
	return lcf::rpg::EnemyAction::Kind_basic;
}

int Game_BattleAlgorithm::Defend::GetActionId() {
	return lcf::rpg::EnemyAction::Basic_defense;
}

std::string Game_BattleAlgorithm::Defend::GetStartMessage(int line) const {
	if (line == 0) {
		if (Feature::HasRpg2kBattleSystem()) {
			return BattleMessage::GetDefendStartMessage2k(*GetSource());
		} else if (GetSource()->GetType() == Game_Battler::Type_Enemy) {
			return BattleMessage::GetDefendStartMessage2k3(*GetSource());
		}
	}
	return "";
}

int Game_BattleAlgorithm::Defend::GetSourcePose() const {
	return lcf::rpg::BattlerAnimation::Pose_Defend;
}

Game_BattleAlgorithm::Observe::Observe(Game_Battler* source) :
AlgorithmBase(Type::Observe, source, source) {
	// no-op
}

int Game_BattleAlgorithm::Observe::GetActionType() {
	return lcf::rpg::EnemyAction::Kind_basic;
}

int Game_BattleAlgorithm::Observe::GetActionId() {
	return lcf::rpg::EnemyAction::Basic_observe;
}

std::string Game_BattleAlgorithm::Observe::GetStartMessage(int line) const {
	if (line == 0) {
		if (Feature::HasRpg2kBattleSystem()) {
			return BattleMessage::GetObserveStartMessage2k(*GetSource());
		} else if (GetSource()->GetType() == Game_Battler::Type_Enemy) {
			return BattleMessage::GetObserveStartMessage2k3(*GetSource());
		}
	}
	return "";
}

Game_BattleAlgorithm::Charge::Charge(Game_Battler* source) :
AlgorithmBase(Type::Charge, source, source) {
	// no-op
}

int Game_BattleAlgorithm::Charge::GetActionType() {
	return lcf::rpg::EnemyAction::Kind_basic;
}

int Game_BattleAlgorithm::Charge::GetActionId() {
	return lcf::rpg::EnemyAction::Basic_charge;
}

std::string Game_BattleAlgorithm::Charge::GetStartMessage(int line) const {
	if (line == 0) {
		if (Feature::HasRpg2kBattleSystem()) {
			return BattleMessage::GetChargeUpStartMessage2k(*GetSource());
		} else if (GetSource()->GetType() == Game_Battler::Type_Enemy) {
			return BattleMessage::GetChargeUpStartMessage2k3(*GetSource());
		}
	}
	return "";
}

void Game_BattleAlgorithm::Charge::ApplyCustomEffect() {
	GetTarget()->SetCharged(true);
}

Game_BattleAlgorithm::SelfDestruct::SelfDestruct(Game_Battler* source, Game_Party_Base* target) :
AlgorithmBase(Type::SelfDestruct, source, target) {
	// no-op
}

int Game_BattleAlgorithm::SelfDestruct::GetActionType() {
	return lcf::rpg::EnemyAction::Kind_basic;
}

int Game_BattleAlgorithm::SelfDestruct::GetActionId() {
	return lcf::rpg::EnemyAction::Basic_autodestruction;
}

std::string Game_BattleAlgorithm::SelfDestruct::GetStartMessage(int line) const {
	if (line == 0) {
		if (Feature::HasRpg2kBattleSystem()) {
			return BattleMessage::GetSelfDestructStartMessage2k(*GetSource());
		} else if (GetSource()->GetType() == Game_Battler::Type_Enemy) {
			return BattleMessage::GetSelfDestructStartMessage2k3(*GetSource());
		}
	}
	return "";
}

const lcf::rpg::Sound* Game_BattleAlgorithm::SelfDestruct::GetStartSe() const {
	return &Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_EnemyKill);
}

bool Game_BattleAlgorithm::SelfDestruct::vExecute() {
	auto& source = *GetSource();
	auto& target = *GetTarget();

	auto effect = Algo::CalcSelfDestructEffect(source, target, true);
	effect = Algo::AdjustDamageForDefend(effect, target);
	effect = Utils::Clamp(effect, -MaxDamageValue(), MaxDamageValue());

	SetAffectedHp(-effect);

	// Recover physical states only if not killed.
	if (target.GetHp() + GetAffectedHp() > 0) {
		// Make a copy of the target's state set and see what we can apply.
		auto target_states = target.GetStates();
		auto target_perm_states = target.GetPermanentStates();

		// Conditions healed by physical attack:
		BattlePhysicalStateHeal(100, target_states, target_perm_states);
	}

	return SetIsSuccess();
}

void Game_BattleAlgorithm::SelfDestruct::ApplyCustomEffect() {
	auto* source = GetSource();
	// Only monster can self destruct
	if (animate && source->GetType() == Game_Battler::Type_Enemy) {
		auto* enemy = static_cast<Game_Enemy*>(source);
		enemy->SetHidden(true);
		enemy->SetExplodeTimer();
	}
	animate = false;
}

Game_BattleAlgorithm::Escape::Escape(Game_Battler* source) :
	AlgorithmBase(Type::Escape, source, source) {
	// no-op
}

int Game_BattleAlgorithm::Escape::GetActionType() {
	return lcf::rpg::EnemyAction::Kind_basic;
}

int Game_BattleAlgorithm::Escape::GetActionId() {
	return lcf::rpg::EnemyAction::Basic_escape;
}

std::string Game_BattleAlgorithm::Escape::GetStartMessage(int line) const {
	if (line == 0) {
		if (Feature::HasRpg2kBattleSystem()) {
			return BattleMessage::GetEscapeStartMessage2k(*GetSource());
		} else if (GetSource()->GetType() == Game_Battler::Type_Enemy) {
			return BattleMessage::GetEscapeStartMessage2k3(*GetSource());
		}
	}
	return "";
}

int Game_BattleAlgorithm::Escape::GetSourcePose() const {
	return lcf::rpg::BattlerAnimation::Pose_WalkRight;
}

const lcf::rpg::Sound* Game_BattleAlgorithm::Escape::GetStartSe() const {
	auto* source = GetSource();
	if (source->GetType() == Game_Battler::Type_Ally) {
		return AlgorithmBase::GetStartSe();
	}
	return &Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Escape);
}

void Game_BattleAlgorithm::Escape::ApplyCustomEffect() {
	auto* source = GetSource();
	if (source->GetType() == Game_Battler::Type_Enemy) {
		auto* enemy = static_cast<Game_Enemy*>(source);
		enemy->SetHidden(true);
		enemy->SetDeathTimer();
	}
}

Game_BattleAlgorithm::Transform::Transform(Game_Battler* source, int new_monster_id) :
AlgorithmBase(Type::Transform, source, source), new_monster_id(new_monster_id) {
	// no-op
}

int Game_BattleAlgorithm::Transform::GetActionType() {
	return lcf::rpg::EnemyAction::Kind_transformation;
}

int Game_BattleAlgorithm::Transform::GetActionId() {
	return new_monster_id;
}

std::string Game_BattleAlgorithm::Transform::GetStartMessage(int line) const {
	if (line == 0 && Feature::HasRpg2kBattleSystem()) {
		auto* enemy = lcf::ReaderUtil::GetElement(lcf::Data::enemies, new_monster_id);
		return BattleMessage::GetTransformStartMessage(*GetSource(), *enemy);
	}
	return "";
}

void Game_BattleAlgorithm::Transform::ApplyCustomEffect() {
	auto* source = GetSource();
	if (source->GetType() == Game_Battler::Type_Enemy) {
		auto* enemy = static_cast<Game_Enemy*>(source);
		enemy->Transform(new_monster_id);
		enemy->Flash(31,31,31,31,20);
	}
}

Game_BattleAlgorithm::DoNothing::DoNothing(Game_Battler* source) :
AlgorithmBase(Type::DoNothing, source, source) {
	// no-op
}

int Game_BattleAlgorithm::DoNothing::GetActionType() {
	return lcf::rpg::EnemyAction::Kind_basic;
}

int Game_BattleAlgorithm::DoNothing::GetActionId() {
	return lcf::rpg::EnemyAction::Basic_nothing;
}



/*end of file .\game_battlealgorithm.cpp*/

/*start of file .\game_battler.cpp*/

/* ... license chunk ... */

// Headers
#include <algorithm>
#include <cassert>
#include <cmath>
#include <limits>
#include "player.h"
#include "game_battler.h"
#include "game_actor.h"
#include "game_enemyparty.h"
#include "game_battle.h"
#include "game_party.h"
#include "game_party_base.h"
#include "game_player.h"
#include "game_switches.h"
#include "game_system.h"
#include "game_targets.h"
#include "game_screen.h"
#include "util_macro.h"
#include "main_data.h"
#include "utils.h"
#include "output.h"
#include <lcf/reader_util.h>
#include "game_battlealgorithm.h"
#include "state.h"
#include "shake.h"
#include "attribute.h"
#include "algo.h"
#include "rand.h"

Game_Battler::Game_Battler() {
}

bool Game_Battler::HasState(int state_id) const {
	return State::Has(state_id, GetStates());
}

std::vector<int16_t> Game_Battler::GetInflictedStates() const {
	auto& states = GetStates();
	std::vector<int16_t> inf_states;
	for (size_t i = 0; i < states.size(); ++i) {
		if (states[i] > 0) {
			inf_states.push_back(i + 1);
		}
	}
	return inf_states;
}

PermanentStates Game_Battler::GetPermanentStates() const {
	return PermanentStates();
}

bool Game_Battler::EvadesAllPhysicalAttacks() const {
	for (auto state_id: GetInflictedStates()) {
		auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, state_id);
		if (state && state->avoid_attacks) {
			return true;
		}
	}
	return false;
}

lcf::rpg::State::Restriction Game_Battler::GetSignificantRestriction() const {
	return State::GetSignificantRestriction(GetStates());
}

bool Game_Battler::CanAct() const {
	const auto& states = GetStates();
	for (size_t i = 0; i < states.size(); ++i) {
		if (states[i] > 0) {
			const auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, i + 1);
			assert(state);
			if (state->restriction == lcf::rpg::State::Restriction_do_nothing) {
				return false;
			}
		}
	}
	return true;
}

bool Game_Battler::CanActOrRecoverable() const {
	const auto& states = GetStates();
	for (size_t i = 0; i < states.size(); ++i) {
		if (states[i] > 0) {
			const auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, i + 1);
			assert(state);
			if (state->restriction == lcf::rpg::State::Restriction_do_nothing && state->auto_release_prob == 0) {
				return false;
			}
		}
	}
	return true;
}

const lcf::rpg::State* Game_Battler::GetSignificantState() const {
	return State::GetSignificantState(GetStates());
}

int Game_Battler::GetStateRate(int state_id, int rate) const {
	return State::GetStateRate(state_id, rate);
}

bool Game_Battler::IsSkillUsable(int skill_id) const {
	const lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, skill_id);

	if (!skill) {
		Output::Warning("IsSkillUsable: Invalid skill ID {}", skill_id);
		return false;
	}

	if (CalculateSkillCost(skill_id) > GetSp() || CalculateSkillHpCost(skill_id) >= GetHp()) {
		return false;
	}

	for (auto state_id: GetInflictedStates()) {
		const auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, state_id);
		if (state) {
			if (state->restrict_skill && skill->physical_rate >= state->restrict_skill_level && !skill->easyrpg_ignore_restrict_skill) {
				return false;
			}
			if (state->restrict_magic && skill->magical_rate >= state->restrict_magic_level && !skill->easyrpg_ignore_restrict_magic) {
				return false;
			}
		}
	}

	return Algo::IsSkillUsable(*skill, true);
}

bool Game_Battler::UseItem(int item_id, const Game_Battler* source) {
	const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
	if (!item) {
		Output::Warning("UseItem: Can't use item with invalid ID {}", item_id);
		return false;
	}

	if (item->type == lcf::rpg::Item::Type_medicine) {
		bool was_used = false;
		int revived = 0;
		int hp_change = item->recover_hp_rate * GetMaxHp() / 100 + item->recover_hp;
		int sp_change = item->recover_sp_rate * GetMaxSp() / 100 + item->recover_sp;

		if (IsDead()) {
			// Check if item can revive
			if (item->state_set.empty() || !item->state_set[0]) {
				return false;
			}
		} else if (item->ko_only) {
			// Must be dead
			return false;
		}

		for (int i = 0; i < (int)item->state_set.size(); i++) {
			if (item->state_set[i]) {
				was_used |= HasState(lcf::Data::states[i].ID);
				if (i == 0 && HasState(i + 1))
					revived = 1;
				RemoveState(lcf::Data::states[i].ID, false);
			}
		}

		if (hp_change > 0 && !HasFullHp()) {
			ChangeHp(hp_change - revived, false);
			was_used = true;
		}

		if (sp_change > 0 && !HasFullSp()) {
			ChangeSp(sp_change);
			was_used = true;
		}

		return was_used;
	}

	if (item->type == lcf::rpg::Item::Type_switch) {
		return true;
	}

	bool do_skill = (item->type == lcf::rpg::Item::Type_special)
		|| (item->use_skill && (
				item->type == lcf::rpg::Item::Type_weapon
				|| item->type == lcf::rpg::Item::Type_shield
				|| item->type == lcf::rpg::Item::Type_armor
				|| item->type == lcf::rpg::Item::Type_helmet
				|| item->type == lcf::rpg::Item::Type_accessory
				)
				);

	if (do_skill) {
		auto* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, item->skill_id);
		if (skill == nullptr) {
			Output::Warning("UseItem: Can't use item {} skill with invalid ID {}", item->ID, item->skill_id);
			return false;
		}
		return UseSkill(item->skill_id, source);
	}

	return false;
}

bool Game_Battler::UseSkill(int skill_id, const Game_Battler* source) {
	const lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, skill_id);
	if (!skill) {
		Output::Warning("UseSkill: Can't use skill with invalid ID {}", skill_id);
		return false;
	}

	bool cure_hp_percentage = false;
	bool was_used = false;
	int revived = 0;

	if (Algo::IsNormalOrSubskill(*skill)) {
		// Only takes care of healing skills outside of battle,
		// the other skill logic is in Game_BattleAlgorithm

		if (!(skill->scope == lcf::rpg::Skill::Scope_ally ||
			  skill->scope == lcf::rpg::Skill::Scope_party ||
			  skill->scope == lcf::rpg::Skill::Scope_self)) {
			return false;
		}

		// Calculate effect:
		auto effect = Algo::CalcSkillEffect(*source, *this, *skill, true, false, lcf::rpg::System::BattleCondition_none, false);

		// Negative attributes do damage but cannot kill
		bool negative_effect = false;
		if (effect < 0) {
			negative_effect = true;
			effect = -effect;
		}

		// Cure states
		for (int i = 0; i < (int)skill->state_effects.size(); i++) {
			if (skill->state_effects[i]) {
				if (skill->reverse_state_effect) {
					was_used |= !HasState(lcf::Data::states[i].ID);
					AddState(lcf::Data::states[i].ID, true);
				}
				else {
					if (i == 0 && IsDead()) {
						revived = 1;
					}

					was_used |= HasState(lcf::Data::states[i].ID);
					RemoveState(lcf::Data::states[i].ID, false);

					// If Death is cured and HP is not selected, we set a bool so it later heals HP percentage
					if (i == 0 && !skill->affect_hp && revived) {
						cure_hp_percentage = true;
					}
				}
			}
		}

		// Skills only increase hp and sp outside of battle
		if (!negative_effect) {
			if (effect > 0 && skill->affect_hp && !HasFullHp() && !IsDead()) {
				was_used = true;
				ChangeHp(effect - revived, false);
			}
			else if (effect > 0 && cure_hp_percentage) {
				was_used = true;
				ChangeHp(GetMaxHp() * effect / 100 - revived, false);
			}

			if (effect > 0 && skill->affect_sp && !HasFullSp() && !IsDead()) {
				was_used = true;
				ChangeSp(effect);
			}
		} else {
			if (effect > 0 && skill->affect_hp && !IsDead()) {
				was_used = true;
				ChangeHp(-effect, false);
			}

			if (effect > 0 && skill->affect_sp && !IsDead()) {
				was_used = true;
				ChangeSp(-effect);
			}
		}

	} else if (skill->type == lcf::rpg::Skill::Type_teleport || skill->type == lcf::rpg::Skill::Type_escape) {
		Main_Data::game_system->SePlay(skill->sound_effect);
		was_used = true;
	} else if (skill->type == lcf::rpg::Skill::Type_switch) {
		Main_Data::game_system->SePlay(skill->sound_effect);
		Main_Data::game_switches->Set(skill->switch_id, true);
		was_used = true;
	}

	return was_used;
}

int Game_Battler::CalculateSkillCost(int skill_id) const {
	const lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, skill_id);
	if (!skill) {
		Output::Warning("CalculateSkillCost: Invalid skill ID {}", skill_id);
		return 0;
	}
	return Algo::CalcSkillCost(*skill, GetMaxSp(), false);
}

int Game_Battler::CalculateSkillHpCost(int skill_id) const {
	const lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, skill_id);
	if (!skill) {
		Output::Warning("CalculateSkillHpCost: Invalid skill ID {}", skill_id);
		return 0;
	}
	return Algo::CalcSkillHpCost(*skill, GetMaxHp());
}

bool Game_Battler::AddState(int state_id, bool allow_battle_states) {
	auto was_added = State::Add(state_id, GetStates(), GetPermanentStates(), allow_battle_states);

	if (!was_added) {
		return was_added;
	}

	if (state_id == lcf::rpg::State::kDeathID) {
		SetAtbGauge(0);
		SetHp(0);
		SetAtkModifier(0);
		SetDefModifier(0);
		SetSpiModifier(0);
		SetAgiModifier(0);
		SetIsDefending(false);
		SetCharged(false);
		attribute_shift.clear();
	}

	if (!Game_Battle::IsBattleRunning()) {
		return was_added;
	}

	if (GetSignificantRestriction() != lcf::rpg::State::Restriction_normal) {
		SetIsDefending(false);
		SetCharged(false);
		if (GetBattleAlgorithm() != nullptr
				&& GetBattleAlgorithm()->GetType() != Game_BattleAlgorithm::Type::None) {
			this->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::None>(this));
		}
	}

	if (GetBattleAlgorithm() != nullptr && GetBattleAlgorithm()->GetType() == Game_BattleAlgorithm::Type::Skill) {
		auto* algo = static_cast<Game_BattleAlgorithm::Skill*>(GetBattleAlgorithm().get());
		auto& skill = algo->GetSkill();
		// Only remove the action when it is a now invalid skill. Skills triggered through items are not affected.
		if (!algo->GetItem() && !IsSkillUsable(skill.ID)) {
			SetCharged(false);
			this->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::None>(this));
		}
	}

	Game_Battle::ManiacBattleHook(
		Game_Interpreter_Battle::ManiacBattleHookType::SetState,
		GetType() == Game_Battler::Type_Enemy,
		GetPartyIndex(),
		state_id
	);

	return was_added;
}

template<typename F>
bool RemoveStates(Game_Battler& battler, F&& f) {
	auto prev_restriction = battler.GetSignificantRestriction();

	auto check_dead = [&]() {
		// Cannot use IsDead here, as it checks for HP == 0
		return State::Has(lcf::rpg::State::kDeathID, battler.GetStates());
	};

	bool is_dead = check_dead();
	bool was_removed = f();
	if (was_removed) {
		if (is_dead != check_dead()) {
			// Was revived
			battler.SetHp(1);
		}

		auto cur_restriction = battler.GetSignificantRestriction();
		if (battler.GetBattleAlgorithm() != nullptr
			&& battler.GetBattleAlgorithm()->GetType() != Game_BattleAlgorithm::Type::None
			&& cur_restriction != prev_restriction) {
				battler.SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::None>(&battler));
		}
	}
	return was_removed;
}

void Game_Battler::RemoveBattleStates() {
	RemoveStates(*this, [&]() {
		return State::RemoveAllBattle(GetStates(), GetPermanentStates());
	});
}

void Game_Battler::RemoveAllStates() {
	RemoveStates(*this, [&]() {
		return State::RemoveAll(GetStates(), GetPermanentStates());
	});
}

bool Game_Battler::RemoveState(int state_id, bool always_remove_battle_states) {
	return RemoveStates(*this, [&]() {
		PermanentStates ps;

		auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, state_id);
		if (!(always_remove_battle_states && state && state->type == lcf::rpg::State::Persistence_ends)) {
			ps = GetPermanentStates();
		}

		return State::Remove(state_id, GetStates(), ps);
	});
}

int Game_Battler::ApplyConditions() {
	int damageTaken = 0;
	for (int16_t inflicted : GetInflictedStates()) {
		// States are guaranteed to be valid
		lcf::rpg::State& state = *lcf::ReaderUtil::GetElement(lcf::Data::states, inflicted);
		int hp = state.hp_change_val + (GetMaxHp() * state.hp_change_max / 100);
		int sp = state.sp_change_val + (GetMaxSp() * state.sp_change_max / 100);
		int src_hp = 0;
		int src_sp = 0;
		if (state.hp_change_type == state.ChangeType_lose) {
			src_hp = -hp;
			if(src_hp > 0) {
				src_hp = 0;
			}
		}
		else if(state.hp_change_type == state.ChangeType_gain) {
			src_hp = hp;
			if(src_hp < 0) {
				src_hp = 0;
			}
		}
		else {
			src_hp = 0;
		}
		if (state.sp_change_type == state.ChangeType_lose) {
			src_sp = -sp;
			if(src_sp > 0) {
				src_sp = 0;
			}

		}
		else if (state.sp_change_type == state.ChangeType_gain) {
			src_sp = sp;
			if(src_sp < 0) {
				src_sp = 0;
			}
		}
		else {
			src_sp = 0;
		}
		this->ChangeHp(src_hp, false);
		this->ChangeSp(src_sp);
		damageTaken += src_hp;
	}

	return damageTaken;
}

int Game_Battler::ChangeHp(int hp, bool lethal) {
	if (IsDead()) {
		return 0;
	}
	const auto prev_hp = GetHp();
	auto req_new_hp = prev_hp + hp;
	if (!lethal) {
		req_new_hp = std::max(1, req_new_hp);
	}
	auto new_hp = SetHp(req_new_hp);

	// Death
	if (new_hp <= 0) {
		AddState(lcf::rpg::State::kDeathID, true);
	}
	return new_hp - prev_hp;
}

int Game_Battler::GetMaxHp() const {
	return GetBaseMaxHp();
}

bool Game_Battler::HasFullHp() const {
	return GetMaxHp() == GetHp();
}

int Game_Battler::ChangeSp(int sp) {
	const auto prev_sp = GetSp();
	const auto new_sp = SetSp(prev_sp + sp);
	return new_sp - prev_sp;
}

int Game_Battler::GetMaxSp() const {
	return GetBaseMaxSp();
}

bool Game_Battler::HasFullSp() const {
	return GetMaxSp() == GetSp();
}

static int AdjustParam(int base, int mod, int maxval, Span<const int16_t> states, bool lcf::rpg::State::*adj) {
	auto value = Utils::Clamp(base + mod, 1, maxval);
	bool half = false;
	bool dbl = false;
	for (auto i: states) {
		const auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, i);
		assert(state);
		if (state->*adj) {
			half |= (state->affect_type == lcf::rpg::State::AffectType_half);
			dbl |= (state->affect_type == lcf::rpg::State::AffectType_double);
		}
	}
	if (dbl != half) {
		if (dbl) {
			value *= 2;
		} else {
			value = std::max(1, value / 2);
		}
	}
	// NOTE: RPG_RT does not clamp these values to the upper range!
	// Exceptions:
	// * 2k3 special function which computes atk for individual weapons / dual wield dmg does clamp at the end
	// * 2k3 special function which computes agi for individual weapons / dual wield hit ratio does clamp, but also has a bug where it ignores states which modify agi!
	return value;
}

int Game_Battler::CalcValueAfterAtkStates(int value) const {
	return AdjustParam(value, 0, MaxStatBattleValue(), GetInflictedStates(), &lcf::rpg::State::affect_attack);
}

int Game_Battler::CalcValueAfterDefStates(int value) const {
	return AdjustParam(value, 0, MaxStatBattleValue(), GetInflictedStates(), &lcf::rpg::State::affect_defense);
}

int Game_Battler::CalcValueAfterSpiStates(int value) const {
	return AdjustParam(value, 0, MaxStatBattleValue(), GetInflictedStates(), &lcf::rpg::State::affect_spirit);
}

int Game_Battler::CalcValueAfterAgiStates(int value) const {
	return AdjustParam(value, 0, MaxStatBattleValue(), GetInflictedStates(), &lcf::rpg::State::affect_agility);
}

int Game_Battler::GetAtk(Weapon weapon) const {
	return AdjustParam(GetBaseAtk(weapon), atk_modifier, MaxStatBattleValue(), GetInflictedStates(), &lcf::rpg::State::affect_attack);
}

int Game_Battler::GetDef(Weapon weapon) const {
	return AdjustParam(GetBaseDef(weapon), def_modifier, MaxStatBattleValue(), GetInflictedStates(), &lcf::rpg::State::affect_defense);
}

int Game_Battler::GetSpi(Weapon weapon) const {
	return AdjustParam(GetBaseSpi(weapon), spi_modifier, MaxStatBattleValue(), GetInflictedStates(), &lcf::rpg::State::affect_spirit);
}

int Game_Battler::GetAgi(Weapon weapon) const {
	return AdjustParam(GetBaseAgi(weapon), agi_modifier, MaxStatBattleValue(), GetInflictedStates(), &lcf::rpg::State::affect_agility);
}

int Game_Battler::GetDisplayX() const {
	int shake_x = 0;
	if (Main_Data::game_screen) {
		shake_x = Main_Data::game_screen->GetShakeOffsetX();
	}

	int shake_pos = shake_x + shake.position;
	return Player::menu_offset_x + ((GetBattlePosition().x + shake_pos) * MENU_WIDTH / MENU_WIDTH);
}

int Game_Battler::GetDisplayY() const {
	int shake_y = 0;
	if (Main_Data::game_screen) {
		shake_y = Main_Data::game_screen->GetShakeOffsetY();
	}

	int shake_pos = shake_y;
	return Player::menu_offset_y + ((GetBattlePosition().y + GetFlyingOffset() + shake_pos) * MENU_HEIGHT / MENU_HEIGHT);
}

Game_Party_Base& Game_Battler::GetParty() const {
	if (GetType() == Type_Ally) {
		return *Main_Data::game_party;
	} else {
		return *Main_Data::game_enemyparty;
	}
}

int Game_Battler::GetPartyIndex() {
	return GetParty().GetMemberIndex(this);
}

void Game_Battler::UpdateBattle() {
	Shake::Update(shake.position, shake.time_left, shake.strength, shake.speed, false);
	Flash::Update(flash.current_level, flash.time_left);
	++frame_counter;
}

std::vector<int16_t> Game_Battler::BattleStateHeal() {
	std::vector<int16_t> healed_states;
	std::vector<int16_t>& states = GetStates();

	for (size_t i = 0; i < states.size(); ++i) {
		if (HasState(i + 1)) {
			if (states[i] > lcf::Data::states[i].hold_turn
					&& Rand::ChanceOf(lcf::Data::states[i].auto_release_prob, 100)
					&& RemoveState(i + 1, false)
					) {
				healed_states.push_back(i + 1);
			} else {
				++states[i];
			}
		}
	}

	return healed_states;
}

bool Game_Battler::HasReflectState() const {
	for (int16_t i : GetInflictedStates()) {
		// States are guaranteed to be valid
		if (lcf::ReaderUtil::GetElement(lcf::Data::states, i)->reflect_magic) {
			return true;
		}
	}

	return false;
}

void Game_Battler::ResetBattle() {
	// Note: ATB gauge is not reset here. This is on purpose because RPG_RT will freeze
	// the gauge and carry it between battles if !CanActOrRecoverable().
	SetCharged(false);
	SetIsDefending(false);
	SetHidden(false);
	SetDirectionFlipped(false);
	battle_turn = 0;
	last_battle_action = -1;
	atk_modifier = 0;
	def_modifier = 0;
	spi_modifier = 0;
	agi_modifier = 0;
	frame_counter = Rand::GetRandomNumber(0, 63);
	battle_combo_command_id = -1;
	battle_combo_times = 1;
	attribute_shift.clear();
	SetBattleAlgorithm(nullptr);
	SetBattleSprite(nullptr);
	SetWeaponSprite(nullptr);
}

int Game_Battler::GetAttributeRate(int attribute_id) const {
	auto rate = GetBaseAttributeRate(attribute_id);
	rate += GetAttributeRateShift(attribute_id);
	return Utils::Clamp(rate, 0, 4);
}

int Game_Battler::ShiftAttributeRate(int attribute_id, int shift) {
	auto delta = CanShiftAttributeRate(attribute_id, shift);
	if (delta) {
		if (attribute_id > static_cast<int>(attribute_shift.size())) {
			attribute_shift.resize(attribute_id);
		}
		attribute_shift[attribute_id - 1] += delta;
	}
	return delta;
}

int Game_Battler::GetAttributeRateShift(int attribute_id) const {
	if (attribute_id < 1 || attribute_id > static_cast<int>(attribute_shift.size())) {
		return 0;
	}
	return attribute_shift[attribute_id - 1];
}

int Game_Battler::CanShiftAttributeRate(int attribute_id, int shift) const {
	if (attribute_id < 1 || attribute_id > static_cast<int>(lcf::Data::attributes.size())) {
		return 0;
	}
	const auto prev_shift = GetAttributeRateShift(attribute_id);
	const auto new_shift = Utils::Clamp(prev_shift + shift, -1, 1);
	return new_shift - prev_shift;
}

int Game_Battler::GetHitChanceModifierFromStates() const {
	int modifier = 100;
	// Modify hit chance for each state the source has
	for (const auto id : GetInflictedStates()) {
		auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, id);
		if (state) {
			modifier = std::min<int>(modifier, state->reduce_hit_ratio);
		}
	}
	return modifier;
}

void Game_Battler::ShakeOnce(int strength, int speed, int frames) {
	shake.strength = strength;
	shake.speed = speed;
	shake.time_left = frames;
	// FIXME: RPG_RT doesn't reset position for screen shake. So we guess? it doesn't do so here either.
}

void Game_Battler::Flash(int r, int g, int b, int power, int frames) {
	flash.red = r;
	flash.green = g;
	flash.blue = b;
	flash.current_level = power;
	flash.time_left = frames;
}

const std::vector<lcf::rpg::State*> Game_Battler::GetInflictedStatesOrderedByPriority() const {
	std::vector<lcf::rpg::State*> state_list = State::GetObjects(GetStates());
	return State::SortedByPriority(state_list);
}

int Game_Battler::CanChangeAtkModifier(int modifier) const {
	const auto prev = atk_modifier;
	const auto base = GetBaseAtk();
	const auto new_mod = (Utils::Clamp(atk_modifier + modifier, -base / 2, base));
	return new_mod - prev;
}

int Game_Battler::CanChangeDefModifier(int modifier) const {
	const auto prev = def_modifier;
	const auto base = GetBaseDef();
	const auto new_mod = (Utils::Clamp(def_modifier + modifier, -base / 2, base));
	return new_mod - prev;
}

int Game_Battler::CanChangeSpiModifier(int modifier) const {
	const auto prev = spi_modifier;
	const auto base = GetBaseSpi();
	const auto new_mod = (Utils::Clamp(spi_modifier + modifier, -base / 2, base));
	return new_mod - prev;
}

int Game_Battler::CanChangeAgiModifier(int modifier) const {
	const auto prev = agi_modifier;
	const auto base = GetBaseAgi();
	const auto new_mod = (Utils::Clamp(agi_modifier + modifier, -base / 2, base));
	return new_mod - prev;
}

int Game_Battler::ChangeAtkModifier(int modifier) {
	auto delta = CanChangeAtkModifier(modifier);
	SetAtkModifier(atk_modifier + delta);
	return delta;
}

int Game_Battler::ChangeDefModifier(int modifier) {
	auto delta = CanChangeDefModifier(modifier);
	SetDefModifier(def_modifier + delta);
	return delta;
}

int Game_Battler::ChangeSpiModifier(int modifier) {
	auto delta = CanChangeSpiModifier(modifier);
	SetSpiModifier(spi_modifier + delta);
	return delta;
}

int Game_Battler::ChangeAgiModifier(int modifier) {
	auto delta = CanChangeAgiModifier(modifier);
	SetAgiModifier(agi_modifier + delta);

	if (Player::IsPatchManiac()) {
		int CE_ID = std::get<0>(Game_Interpreter_Battle::maniac_hooks[Game_Interpreter_Battle::ManiacBattleHookType::StatChange]);
		if (CE_ID > 0) {
			int Var_ID = std::get<1>(Game_Interpreter_Battle::maniac_hooks[Game_Interpreter_Battle::ManiacBattleHookType::StatChange]);
			Main_Data::game_variables->Set(Var_ID + 4, 7); // Type: AGI
			Main_Data::game_variables->Set(Var_ID + 5, delta);

			auto* ce = Game_Battle::StartCommonEventID(CE_ID);
			if (ce) {
				ce->UpdateBattle(true, CE_ID);
			}

			delta = Main_Data::game_variables->Get(Var_ID + 5);
		}
	}

	return delta;
}



/*end of file .\game_battler.cpp*/

/*start of file .\game_character.cpp*/

/* ... license chunk ... */

// Headers
#include "audio.h"
#include "game_character.h"
#include "game_map.h"
#include "game_player.h"
#include "game_switches.h"
#include "game_system.h"
#include "input.h"
#include "main_data.h"
#include "game_message.h"
#include "drawable.h"
#include "player.h"
#include "utils.h"
#include "util_macro.h"
#include "output.h"
#include "rand.h"
#include <cmath>
#include <cassert>
#include <limits>
#include <unordered_set>

Game_Character::Game_Character(Type type, lcf::rpg::SaveMapEventBase* d) :
	_type(type), _data(d)
{
}

void Game_Character::SanitizeData(std::string_view name) {
	SanitizeMoveRoute(name, data()->move_route, data()->move_route_index, "move_route_index");
}

void Game_Character::SanitizeMoveRoute(std::string_view name, const lcf::rpg::MoveRoute& mr, int32_t& idx, std::string_view chunk_name) {
	const auto n = static_cast<int32_t>(mr.move_commands.size());
	if (idx < 0 || idx > n) {
		idx = n;
		Output::Warning("{} {}: Save Data invalid {}={}. Fixing ...", TypeToStr(_type), name, chunk_name, idx);
	}
}

void Game_Character::MoveTo(int map_id, int x, int y) {
	data()->map_id = map_id;
	// RPG_RT does not round the position for this function.
	SetX(x);
	SetY(y);
	SetRemainingStep(0);
}

int Game_Character::GetJumpHeight() const {
	if (IsJumping()) {
		int jump_height = (GetRemainingStep() > SCREEN_TILE_SIZE / 2 ? SCREEN_TILE_SIZE - GetRemainingStep() : GetRemainingStep()) / 8;
		return (jump_height < 5 ? jump_height * 2 : jump_height < 13 ? jump_height + 4 : 16);
	}
	return 0;
}

int Game_Character::GetScreenX() const {
	int x = GetSpriteX() / TILE_SIZE - Game_Map::GetDisplayX() / TILE_SIZE + TILE_SIZE;

	if (Game_Map::LoopHorizontal()) {
		x = Utils::PositiveModulo(x, Game_Map::GetTilesX() * TILE_SIZE);
	}
	x -= TILE_SIZE / 2;

	return x;
}

int Game_Character::GetScreenY(bool apply_jump) const {
	int y = GetSpriteY() / TILE_SIZE - Game_Map::GetDisplayY() / TILE_SIZE + TILE_SIZE;

	if (apply_jump) {
		y -= GetJumpHeight();
	}

	if (Game_Map::LoopVertical()) {
		y = Utils::PositiveModulo(y, Game_Map::GetTilesY() * TILE_SIZE);
	}

	return y;
}

Drawable::Z_t Game_Character::GetScreenZ(int x_offset, int y_offset) const {
	Drawable::Z_t z = 0;

	if (IsFlying()) {
		z = Priority_EventsFlying;
	} else if (GetLayer() == lcf::rpg::EventPage::Layers_same) {
		z = Priority_Player;
	} else if (GetLayer() == lcf::rpg::EventPage::Layers_below) {
		z = Priority_EventsBelow;
	} else if (GetLayer() == lcf::rpg::EventPage::Layers_above) {
		z = Priority_EventsAbove;
	}

	// 0x8000 (32768) is added to shift negative numbers into the positive range
	Drawable::Z_t y = static_cast<Drawable::Z_t>(GetScreenY(false) + y_offset + 0x8000);
	Drawable::Z_t x = static_cast<Drawable::Z_t>(GetScreenX() + x_offset + 0x8000);

	// The rendering order of characters is: Highest Y-coordinate, Highest X-coordinate, Highest ID
	// To encode this behaviour all of them get 16 Bit in the Z value
	// L- YY XX II (1 letter = 8 bit)
	// L: Layer (specified by the event page)
	// -: Unused
	// Y: Y-coordinate
	// X: X-coordinate
	// I: ID (This is only applied by subclasses, characters itself put nothing (0) here
	z += (y << 32) + (x << 16);

	return z;
}

void Game_Character::Update() {
	if (!IsActive() || IsProcessed()) {
		return;
	}
	SetProcessed(true);

	if (IsStopping()) {
		this->UpdateNextMovementAction();
	}
	UpdateFlash();

	if (IsStopping()) {
		if (GetStopCount() == 0 || IsMoveRouteOverwritten() ||
				((Main_Data::game_system->GetMessageContinueEvents() || !Game_Map::GetInterpreter().IsRunning()) && !IsPaused())) {
			SetStopCount(GetStopCount() + 1);
		}
	} else if (IsJumping()) {
		static const int jump_speed[] = {8, 12, 16, 24, 32, 64};
		auto amount = jump_speed[GetMoveSpeed() -1 ];
		this->UpdateMovement(amount);
	} else {
		int amount = 1 << (1 + GetMoveSpeed());
		this->UpdateMovement(amount);
	}

	this->UpdateAnimation();
}

void Game_Character::UpdateMovement(int amount) {
	SetRemainingStep(GetRemainingStep() - amount);
	if (GetRemainingStep() <= 0) {
		SetRemainingStep(0);
		SetJumping(false);

		auto& move_route = GetMoveRoute();
		if (IsMoveRouteOverwritten() && GetMoveRouteIndex() >= static_cast<int>(move_route.move_commands.size())) {
			SetMoveRouteFinished(true);
			SetMoveRouteIndex(0);
			if (!move_route.repeat) {
				// If the last command of a move route is a move or jump,
				// RPG_RT cancels the entire move route immediately.
				CancelMoveRoute();
			}
		}
	}

	SetStopCount(0);
}

void Game_Character::UpdateAnimation() {
	const auto speed = Utils::Clamp(GetMoveSpeed(), 1, 6);

	if (IsSpinning()) {
		const auto limit = GetSpinAnimFrames(speed);

		IncAnimCount();

		if (GetAnimCount() >= limit) {
			SetFacing((GetFacing() + 1) % 4);
			SetAnimCount(0);
		}
		return;
	}

	if (IsAnimPaused() || IsJumping()) {
		ResetAnimation();
		return;
	}

	if (!IsAnimated()) {
		return;
	}

	const auto stationary_limit = GetStationaryAnimFrames(speed);
	const auto continuous_limit = GetContinuousAnimFrames(speed);

	if (IsContinuous()
			|| GetStopCount() == 0
			|| data()->anim_frame == lcf::rpg::EventPage::Frame_left || data()->anim_frame == lcf::rpg::EventPage::Frame_right
			|| GetAnimCount() < stationary_limit - 1) {
		IncAnimCount();
	}

	if (GetAnimCount() >= continuous_limit
			|| (GetStopCount() == 0 && GetAnimCount() >= stationary_limit)) {
		IncAnimFrame();
		return;
	}
}

void Game_Character::UpdateFlash() {
	Flash::Update(data()->flash_current_level, data()->flash_time_left);
}

void Game_Character::UpdateMoveRoute(int32_t& current_index, const lcf::rpg::MoveRoute& current_route, bool is_overwrite) {
	if (current_route.move_commands.empty()) {
		return;
	}

	if (is_overwrite && !IsMoveRouteOverwritten()) {
		return;
	}

	const auto num_commands = static_cast<int>(current_route.move_commands.size());
	// Invalid index could occur from a corrupted save game.
	// Player, Vehicle, and Event all check for and fix this, but we still assert here in
	// case any bug causes this to happen still.
	assert(current_index >= 0);
	assert(current_index <= num_commands);

	const auto start_index = current_index;

	while (true) {
		if (!IsStopping() || IsStopCountActive()) {
			return;
		}

		//Move route is finished
		if (current_index >= num_commands) {
			if (is_overwrite) {
				SetMoveRouteFinished(true);
			}
			if (!current_route.repeat) {
				if (is_overwrite) {
					CancelMoveRoute();
				}
				return;
			}
			current_index = 0;
			if (current_index == start_index) {
				return;
			}
		}

		using Code = lcf::rpg::MoveCommand::Code;
		const auto& move_command = current_route.move_commands[current_index];
		const auto prev_direction = GetDirection();
		const auto prev_facing = GetFacing();
		const auto saved_index = current_index;
		const auto cmd = static_cast<Code>(move_command.command_id);

		if (cmd >= Code::move_up && cmd <= Code::move_forward) {
			switch (cmd) {
				case Code::move_up:
				case Code::move_right:
				case Code::move_down:
				case Code::move_left:
				case Code::move_upright:
				case Code::move_downright:
				case Code::move_downleft:
				case Code::move_upleft:
					SetDirection(static_cast<Game_Character::Direction>(cmd));
					break;
				case Code::move_random:
					TurnRandom();
					break;
				case Code::move_towards_hero:
					TurnTowardCharacter(GetPlayer());
					break;
				case Code::move_away_from_hero:
					TurnAwayFromCharacter(GetPlayer());
					break;
				case Code::move_forward:
					break;
				default:
					break;
			}
			Move(GetDirection());

			if (IsStopping()) {
				// Move failed
				if (current_route.skippable) {
					SetDirection(prev_direction);
					SetFacing(prev_facing);
				} else {
					SetMoveFailureCount(GetMoveFailureCount() + 1);
					return;
				}
			}
			if (cmd == Code::move_forward) {
				SetFacing(prev_facing);
			}

			SetMaxStopCountForStep();
		} else if (cmd >= Code::face_up && cmd <= Code::face_away_from_hero) {
			SetDirection(GetFacing());
			switch (cmd) {
				case Code::face_up:
					SetDirection(Up);
					break;
				case Code::face_right:
					SetDirection(Right);
					break;
				case Code::face_down:
					SetDirection(Down);
					break;
				case Code::face_left:
					SetDirection(Left);
					break;
				case Code::turn_90_degree_right:
					Turn90DegreeRight();
					break;
				case Code::turn_90_degree_left:
					Turn90DegreeLeft();
					break;
				case Code::turn_180_degree:
					Turn180Degree();
					break;
				case Code::turn_90_degree_random:
					Turn90DegreeLeftOrRight();
					break;
				case Code::face_random_direction:
					TurnRandom();
					break;
				case Code::face_hero:
					TurnTowardCharacter(GetPlayer());
					break;
				case Code::face_away_from_hero:
					TurnAwayFromCharacter(GetPlayer());
					break;
				default:
					break;
			}
			SetFacing(GetDirection());
			SetMaxStopCountForTurn();
			SetStopCount(0);
		} else {
			switch (cmd) {
				case Code::wait:
					SetMaxStopCountForWait();
					SetStopCount(0);
					break;
				case Code::begin_jump:
					if (!BeginMoveRouteJump(current_index, current_route)) {
						// Jump failed
						if (current_route.skippable) {
							SetDirection(prev_direction);
							SetFacing(prev_facing);
						} else {
							current_index = saved_index;
							SetMoveFailureCount(GetMoveFailureCount() + 1);
							return;
						}
					}
					break;
				case Code::end_jump:
					break;
				case Code::lock_facing:
					SetFacingLocked(true);
					break;
				case Code::unlock_facing:
					SetFacingLocked(false);
					break;
				case Code::increase_movement_speed:
					SetMoveSpeed(min(GetMoveSpeed() + 1, 6));
					break;
				case Code::decrease_movement_speed:
					SetMoveSpeed(max(GetMoveSpeed() - 1, 1));
					break;
				case Code::increase_movement_frequence:
					SetMoveFrequency(min(GetMoveFrequency() + 1, 8));
					break;
				case Code::decrease_movement_frequence:
					SetMoveFrequency(max(GetMoveFrequency() - 1, 1));
					break;
				case Code::switch_on: // Parameter A: Switch to turn on
					Main_Data::game_switches->Set(move_command.parameter_a, true);
					++current_index; // In case the current_index is already 0 ...
					Game_Map::SetNeedRefresh(true);
					Game_Map::Refresh();
					// If page refresh has reset the current move route, abort now.
					if (current_index == 0) {
						return;
					}
					--current_index;
					break;
				case Code::switch_off: // Parameter A: Switch to turn off
					Main_Data::game_switches->Set(move_command.parameter_a, false);
					++current_index; // In case the current_index is already 0 ...
					Game_Map::SetNeedRefresh(true);
					Game_Map::Refresh();
					// If page refresh has reset the current move route, abort now.
					if (current_index == 0) {
						return;
					}
					--current_index;
					break;
				case Code::change_graphic: // String: File, Parameter A: index
					MoveRouteSetSpriteGraphic(ToString(move_command.parameter_string), move_command.parameter_a);
					break;
				case Code::play_sound_effect: // String: File, Parameters: Volume, Tempo, Balance
					if (move_command.parameter_string != "(OFF)" && move_command.parameter_string != "(Brak)") {
						lcf::rpg::Sound sound;
						sound.name = ToString(move_command.parameter_string);
						sound.volume = move_command.parameter_a;
						sound.tempo = move_command.parameter_b;
						sound.balance = move_command.parameter_c;

						Main_Data::game_system->SePlay(sound);
					}
					break;
				case Code::walk_everywhere_on:
					SetThrough(true);
					data()->move_route_through = true;
					break;
				case Code::walk_everywhere_off:
					SetThrough(false);
					data()->move_route_through = false;
					break;
				case Code::stop_animation:
					SetAnimPaused(true);
					break;
				case Code::start_animation:
					SetAnimPaused(false);
					break;
				case Code::increase_transp:
					SetTransparency(GetTransparency() + 1);
					break;
				case Code::decrease_transp:
					SetTransparency(GetTransparency() - 1);
					break;
				default:
					break;
			}
		}
		SetMoveFailureCount(0);
		++current_index;

		if (current_index == start_index) {
			return;
		}
	} // while (true)
}


bool Game_Character::MakeWay(int from_x, int from_y, int to_x, int to_y) {
	return Game_Map::MakeWay(*this, from_x, from_y, to_x, to_y);
}


bool Game_Character::CheckWay(int from_x, int from_y, int to_x, int to_y) {
	return Game_Map::CheckWay(*this, from_x, from_y, to_x, to_y);
}


bool Game_Character::CheckWay(
		int from_x, int from_y, int to_x, int to_y, bool ignore_all_events,
		Span<int> ignore_some_events_by_id) {
	return Game_Map::CheckWay(*this, from_x, from_y, to_x, to_y,
		ignore_all_events, ignore_some_events_by_id);
}


bool Game_Character::Move(int dir) {
	if (!IsStopping()) {
		return true;
	}

	bool move_success = false;

	SetDirection(dir);
	UpdateFacing();

	const auto x = GetX();
	const auto y = GetY();
	const auto dx = GetDxFromDirection(dir);
	const auto dy = GetDyFromDirection(dir);

	if (dx && dy) {
		// For diagonal movement, RPG_RT trys vert -> horiz and if that fails, then horiz -> vert.
		move_success = (MakeWay(x, y, x, y + dy) && MakeWay(x, y + dy, x + dx, y + dy))
					|| (MakeWay(x, y, x + dx, y) && MakeWay(x + dx, y, x + dx, y + dy));
	} else if (dx) {
		move_success = MakeWay(x, y, x + dx, y);
	} else if (dy) {
		move_success = MakeWay(x, y, x, y + dy);
	}

	if (!move_success) {
		return false;
	}

	const auto new_x = Game_Map::RoundX(x + dx);
	const auto new_y = Game_Map::RoundY(y + dy);

	SetX(new_x);
	SetY(new_y);
	SetRemainingStep(SCREEN_TILE_SIZE);

	return true;
}

void Game_Character::Turn90DegreeLeft() {
	SetDirection(GetDirection90DegreeLeft(GetDirection()));
}

void Game_Character::Turn90DegreeRight() {
	SetDirection(GetDirection90DegreeRight(GetDirection()));
}

void Game_Character::Turn180Degree() {
	SetDirection(GetDirection180Degree(GetDirection()));
}

void Game_Character::Turn90DegreeLeftOrRight() {
	if (Rand::ChanceOf(1,2)) {
		Turn90DegreeLeft();
	} else {
		Turn90DegreeRight();
	}
}

int Game_Character::GetDirectionToCharacter(const Game_Character& target) {
	int sx = GetDistanceXfromCharacter(target);
	int sy = GetDistanceYfromCharacter(target);

	if ( std::abs(sx) > std::abs(sy) ) {
		return (sx > 0) ? Left : Right;
	} else {
		return (sy > 0) ? Up : Down;
	}
}

int Game_Character::GetDirectionAwayCharacter(const Game_Character& target) {
	int sx = GetDistanceXfromCharacter(target);
	int sy = GetDistanceYfromCharacter(target);

	if ( std::abs(sx) > std::abs(sy) ) {
		return (sx > 0) ? Right : Left;
	} else {
		return (sy > 0) ? Down : Up;
	}
}

void Game_Character::TurnTowardCharacter(const Game_Character& target) {
	SetDirection(GetDirectionToCharacter(target));
}

void Game_Character::TurnAwayFromCharacter(const Game_Character& target) {
	SetDirection(GetDirectionAwayCharacter(target));
}

void Game_Character::TurnRandom() {
	SetDirection(Rand::GetRandomNumber(0, 3));
}

void Game_Character::Wait() {
	SetStopCount(0);
	SetMaxStopCountForWait();
}

bool Game_Character::BeginMoveRouteJump(int32_t& current_index, const lcf::rpg::MoveRoute& current_route) {
	int jdx = 0;
	int jdy = 0;

	for (++current_index; current_index < static_cast<int>(current_route.move_commands.size()); ++current_index) {
		using Code = lcf::rpg::MoveCommand::Code;
		const auto& move_command = current_route.move_commands[current_index];
		const auto cmd = static_cast<Code>(move_command.command_id);
		if (cmd >= Code::move_up && cmd <= Code::move_forward) {
			switch (cmd) {
				case Code::move_up:
				case Code::move_right:
				case Code::move_down:
				case Code::move_left:
				case Code::move_upright:
				case Code::move_downright:
				case Code::move_downleft:
				case Code::move_upleft:
					SetDirection(move_command.command_id);
					break;
				case Code::move_random:
					TurnRandom();
					break;
				case Code::move_towards_hero:
					TurnTowardCharacter(GetPlayer());
					break;
				case Code::move_away_from_hero:
					TurnAwayFromCharacter(GetPlayer());
					break;
				case Code::move_forward:
					break;
				default:
					break;
			}
			jdx += GetDxFromDirection(GetDirection());
			jdy += GetDyFromDirection(GetDirection());
		}

		if (cmd >= Code::face_up && cmd <= Code::face_away_from_hero) {
			switch (cmd) {
				case Code::face_up:
					SetDirection(Up);
					break;
				case Code::face_right:
					SetDirection(Right);
					break;
				case Code::face_down:
					SetDirection(Down);
					break;
				case Code::face_left:
					SetDirection(Left);
					break;
				case Code::turn_90_degree_right:
					Turn90DegreeRight();
					break;
				case Code::turn_90_degree_left:
					Turn90DegreeLeft();
					break;
				case Code::turn_180_degree:
					Turn180Degree();
					break;
				case Code::turn_90_degree_random:
					Turn90DegreeLeftOrRight();
					break;
				case Code::face_random_direction:
					TurnRandom();
					break;
				case Code::face_hero:
					TurnTowardCharacter(GetPlayer());
					break;
				case Code::face_away_from_hero:
					TurnAwayFromCharacter(GetPlayer());
					break;
				default:
					break;
			}
		}

		if (cmd == Code::end_jump) {
			int new_x = GetX() + jdx;
			int new_y = GetY() + jdy;

			auto rc = Jump(new_x, new_y);
			if (rc) {
				SetMaxStopCountForStep();
			}
			// Note: outer function increment will cause the end jump to pass after the return.
			return rc;
		}
	}

	// Commands finished with no end jump. Back up the index by 1 to allow outer loop increment to work.
	--current_index;

	// Jump is skipped
	return true;
}

bool Game_Character::Jump(int x, int y) {
	if (!IsStopping()) {
		return true;
	}

	auto begin_x = GetX();
	auto begin_y = GetY();
	const auto dx = x - begin_x;
	const auto dy = y - begin_y;

	if (std::abs(dy) >= std::abs(dx)) {
		SetDirection(dy >= 0 ? Down : Up);
	} else {
		SetDirection(dx >= 0 ? Right : Left);
	}

	SetJumping(true);

	if (dx != 0 || dy != 0) {
		if (!IsFacingLocked()) {
			SetFacing(GetDirection());
		}

		// FIXME: Remove dependency on jump from within Game_Map::MakeWay?
		// RPG_RT passes INT_MAX into from_x to tell it to skip self tile checks, which is hacky..
		if (!MakeWay(begin_x, begin_y, x, y)) {
			SetJumping(false);
			return false;
		}
	}

	// Adjust positions for looping maps. jump begin positions
	// get set off the edge of the map to preserve direction.
	if (Game_Map::LoopHorizontal()
			&& (x < 0 || x >= Game_Map::GetTilesX()))
	{
		const auto old_x = x;
		x = Game_Map::RoundX(x);
		begin_x += x - old_x;
	}

	if (Game_Map::LoopVertical()
			&& (y < 0 || y >= Game_Map::GetTilesY()))
	{
		auto old_y = y;
		y = Game_Map::RoundY(y);
		begin_y += y - old_y;
	}

	SetBeginJumpX(begin_x);
	SetBeginJumpY(begin_y);
	SetX(x);
	SetY(y);
	SetJumping(true);
	SetRemainingStep(SCREEN_TILE_SIZE);

	return true;
}

int Game_Character::GetDistanceXfromCharacter(const Game_Character& target) const {
	int sx = GetX() - target.GetX();
	if (Game_Map::LoopHorizontal()) {
		if (std::abs(sx) > Game_Map::GetTilesX() / 2) {
			if (sx > 0)
				sx -= Game_Map::GetTilesX();
			else
				sx += Game_Map::GetTilesX();
		}
	}
	return sx;
}

int Game_Character::GetDistanceYfromCharacter(const Game_Character& target) const {
	int sy = GetY() - target.GetY();
	if (Game_Map::LoopVertical()) {
		if (std::abs(sy) > Game_Map::GetTilesY() / 2) {
			if (sy > 0)
				sy -= Game_Map::GetTilesY();
			else
				sy += Game_Map::GetTilesY();
		}
	}
	return sy;
}

void Game_Character::ForceMoveRoute(const lcf::rpg::MoveRoute& new_route,
									int frequency) {
	if (!IsMoveRouteOverwritten()) {
		original_move_frequency = GetMoveFrequency();
	}

	SetPaused(false);
	SetStopCount(0xFFFF);
	SetMoveRouteIndex(0);
	SetMoveRouteFinished(false);
	SetMoveFrequency(frequency);
	SetMoveRouteOverwritten(true);
	SetMoveRoute(new_route);
	SetMoveFailureCount(0);
	if (frequency != original_move_frequency) {
		SetMaxStopCountForStep();
	}

	if (GetMoveRoute().move_commands.empty()) {
		CancelMoveRoute();
		return;
	}
}

void Game_Character::CancelMoveRoute() {
	if (IsMoveRouteOverwritten()) {
		SetMoveFrequency(original_move_frequency);
		SetMaxStopCountForStep();
	}
	SetMoveRouteOverwritten(false);
	SetMoveRouteFinished(false);
}

struct SearchNode {
	int x = 0;
	int y = 0;
	int cost = 0;
	int direction = 0;

	int id = 0;
	int parent_id = -1;
	int parent_x = -1;
	int parent_y = -1;

	friend bool operator==(const SearchNode& n1, const SearchNode& n2)
	{
		return n1.x == n2.x && n1.y == n2.y;
	}

	bool operator()(SearchNode const& a, SearchNode const& b)
	{
		return a.id > b.id;
	}
};

struct SearchNodeHash {
	size_t operator()(const SearchNode &p) const {
		return (p.x ^ (p.y + (p.y >> 12)));
	}
};

bool Game_Character::CalculateMoveRoute(const CalculateMoveRouteArgs& args) {
	CancelMoveRoute();

	// Set up helper variables:
	SearchNode start = {GetX(), GetY(), 0, -1};
	if ((start.x == args.dest_x && start.y == args.dest_y) || args.steps_max == 0) {
		return true;
	}
	std::vector<SearchNode> queue;
	std::unordered_map<int, SearchNode> graph;
	std::map<std::pair<int, int>, SearchNode> graph_by_coord;
	queue.push_back(start);
	int id = 0;
	int idd = 0;
	int steps_taken = 0;
	SearchNode closest_node = {args.dest_x, args.dest_y, std::numeric_limits<int>::max(), -1}; // Initialize with a very high cost.
	int closest_distance = std::numeric_limits<int>::max(); // Initialize with a very high distance.
	std::unordered_set<SearchNode, SearchNodeHash> seen;

	int steps_max = args.steps_max;
	if (steps_max == -1) {
		steps_max = std::numeric_limits<int>::max();
	}

	if (args.debug_print) {
		Output::Debug("Game_Interpreter::CommandSearchPath: "
			"start search, character x{} y{}, to x{}, y{}, "
			"ignored event ids count: {}",
			start.x, start.y, args.dest_x, args.dest_y, args.event_id_ignore_list.size());
	}

	bool loops_horizontal = Game_Map::LoopHorizontal();
	bool loops_vertical = Game_Map::LoopVertical();
	std::vector<SearchNode> neighbour;
	neighbour.reserve(8);
	while (!queue.empty() && steps_taken < args.search_max) {
		SearchNode n = queue[0];
		queue.erase(queue.begin());
		steps_taken++;
		graph[n.id] = n;
		graph_by_coord.insert({{n.x, n.y}, n});

		if (n.x == args.dest_x && n.y == args.dest_y) {
			// Reached the destination.
			closest_node = n;
			closest_distance = 0;
			break;	// Exit the loop to build final route.
		}
		else {
			neighbour.clear();
			SearchNode nn = {n.x + 1, n.y, n.cost + 1, 1}; // Right
			neighbour.push_back(nn);
			nn = {n.x, n.y - 1, n.cost + 1, 0}; // Up
			neighbour.push_back(nn);
			nn = {n.x - 1, n.y, n.cost + 1, 3}; // Left
			neighbour.push_back(nn);
			nn = {n.x, n.y + 1, n.cost + 1, 2}; // Down
			neighbour.push_back(nn);

			if (args.allow_diagonal) {
				nn = {n.x - 1, n.y + 1, n.cost + 1, 6}; // Down Left
				neighbour.push_back(nn);
				nn = {n.x + 1, n.y - 1, n.cost + 1, 4}; // Up Right
				neighbour.push_back(nn);
				nn = {n.x - 1, n.y - 1, n.cost + 1, 7}; // Up Left
				neighbour.push_back(nn);
				nn = {n.x + 1, n.y + 1, n.cost + 1, 5}; // Down Right
				neighbour.push_back(nn);
			}

			for (SearchNode a : neighbour) {
				idd++;
				a.parent_x = n.x;
				a.parent_y = n.y;
				a.id = idd;
				a.parent_id = n.id;

				// Adjust neighbor coordinates for map looping
				if (loops_horizontal) {
					if (a.x >= Game_Map::GetTilesX())
						a.x -= Game_Map::GetTilesX();
					else if (a.x < 0)
						a.x += Game_Map::GetTilesX();
				}

				if (loops_vertical) {
					if (a.y >= Game_Map::GetTilesY())
						a.y -= Game_Map::GetTilesY();
					else if (a.y < 0)
						a.y += Game_Map::GetTilesY();
				}

				auto check = seen.find(a);
				if (check != seen.end()) {
					SearchNode old_entry = graph[(*check).id];
					if (a.cost < old_entry.cost) {
						// Found a shorter path to previous node, update & reinsert:
						if (args.debug_print) {
							Output::Debug("Game_Interpreter::CommandSearchPath: "
								"found shorter path to x:{} y:{}"
								"from x:{} y:{} direction: {}",
								a.x, a.y, n.x, n.y, a.direction);
						}
						graph.erase(old_entry.id);
						old_entry.cost = a.cost;
						old_entry.parent_id = n.id;
						old_entry.parent_x = n.x;
						old_entry.parent_y = n.y;
						old_entry.direction = a.direction;
						graph[old_entry.id] = old_entry;
					}
					continue;
				} else if (a.x == start.x && a.y == start.y) {
					continue;
				}
				bool added = false;
				if (CheckWay(n.x, n.y, a.x, a.y, true, args.event_id_ignore_list) ||
						(a.x == args.dest_x && a.y == args.dest_y &&
						CheckWay(n.x, n.y, a.x, a.y, false, {}))) {
					if (a.direction == 4) {
						if (CheckWay(n.x, n.y, n.x + 1, n.y,
									true, args.event_id_ignore_list) ||
								CheckWay(n.x, n.y, n.x, n.y - 1,
									true, args.event_id_ignore_list)) {
							added = true;
							queue.push_back(a);
							seen.insert(a);
						}
					}
					else if (a.direction == 5) {
						if (CheckWay(n.x, n.y, n.x + 1, n.y,
									true, args.event_id_ignore_list) ||
								CheckWay(n.x, n.y, n.x, n.y + 1,
									true, args.event_id_ignore_list)) {
							added = true;
							queue.push_back(a);
							seen.insert(a);
						}
					}
					else if (a.direction == 6) {
						if (CheckWay(n.x, n.y, n.x - 1, n.y,
									true, args.event_id_ignore_list) ||
								CheckWay(n.x, n.y, n.x, n.y + 1,
									true, args.event_id_ignore_list)) {
							added = true;
							queue.push_back(a);
							seen.insert(a);
						}
					}
					else if (a.direction == 7) {
						if (CheckWay(n.x, n.y, n.x - 1, n.y,
									true, args.event_id_ignore_list) ||
								CheckWay(n.x, n.y, n.x, n.y - 1,
									true, args.event_id_ignore_list)) {
							added = true;
							queue.push_back(a);
							seen.insert(a);
						}
					}
					else {
						added = true;
						queue.push_back(a);
						seen.insert(a);
					}
				}
				if (added && args.debug_print) {
					Output::Debug("Game_Interpreter::CommandSearchPath: "
						"discovered id:{} x:{} y:{} parentX:{} parentY:{}"
						"parentID:{} direction: {}",
					queue[queue.size() - 1].id,
					queue[queue.size() - 1].x, queue[queue.size() - 1].y,
					queue[queue.size() - 1].parent_x,
					queue[queue.size() - 1].parent_y,
					queue[queue.size() - 1].parent_id,
					queue[queue.size() - 1].direction);
				}
			}
		}
		id++;
		// Calculate the Manhattan distance between the current node and the destination
		int manhattan_dist = abs(args.dest_x - n.x) + abs(args.dest_y - n.y);

		// Check if this node is closer to the destination
		if (manhattan_dist < closest_distance) {
			closest_node = n;
			closest_distance = manhattan_dist;
			if (args.debug_print) {
				Output::Debug("Game_Interpreter::CommandSearchPath: "
						"new closest node at x:{} y:{} id:{}",
					closest_node.x, closest_node.y,
					closest_node.id);
			}
		}
	}

	// Check if a path to the closest node was found.
	if (closest_distance != std::numeric_limits<int>::max()) {
		// Build a route to the closest reachable node.
		if (args.debug_print) {
			Output::Debug("Game_Interpreter::CommandSearchPath: "
					"trying to return route from x:{} y:{} to "
					"x:{} y:{} (id:{})",
				start.x, start.y, closest_node.x, closest_node.y,
				closest_node.id);
		}
		std::vector<SearchNode> list_move;

		SearchNode node = closest_node;
		while (static_cast<int>(list_move.size()) < steps_max) {
			list_move.push_back(node);
			if (graph_by_coord.find({node.parent_x,
					node.parent_y}) == graph_by_coord.end())
				break;
			SearchNode node2 = graph_by_coord[
				{node.parent_x, node.parent_y}
			];
			if (args.debug_print) {
				Output::Debug(
					"Game_Interpreter::CommandSearchPath: "
					"found parent leading to x:{} y:{}, "
					"it's at x:{} y:{} dir:{}",
					node.x, node.y,
					node2.x, node2.y, node2.direction);
			}
			node = node2;
		}

		std::reverse(list_move.rbegin(), list_move.rend());

		std::string debug_output_path("");
		if (list_move.size() > 0) {
			lcf::rpg::MoveRoute route;
			route.skippable = args.skip_when_failed;
			route.repeat = false;

			for (SearchNode node2 : list_move) {
				if (node2.direction >= 0) {
					lcf::rpg::MoveCommand cmd;
					cmd.command_id = node2.direction;
					route.move_commands.push_back(cmd);
					if (args.debug_print >= 1) {
						if (debug_output_path.length() > 0)
							debug_output_path += ",";
						std::ostringstream dirnum;
						dirnum << node2.direction;
						debug_output_path += std::string(dirnum.str());
					}
				}
			}

			lcf::rpg::MoveCommand cmd;
			cmd.command_id = 23;
			route.move_commands.push_back(cmd);

			ForceMoveRoute(route, args.frequency);
		}
		if (args.debug_print) {
			Output::Debug(
				"Game_Interpreter::CommandSearchPath: "
				"setting route {} for character x{} y{}",
				" (ignored event ids count: {})",
				debug_output_path, start.x, start.y,
				args.event_id_ignore_list.size()
			);
		}
		return true;
	}

	// No path to the destination, return failure.
	return false;
}

int Game_Character::GetSpriteX() const {
	int x = GetX() * SCREEN_TILE_SIZE;

	if (IsMoving()) {
		int d = GetDirection();
		if (d == Right || d == UpRight || d == DownRight)
			x -= GetRemainingStep();
		else if (d == Left || d == UpLeft || d == DownLeft)
			x += GetRemainingStep();
	} else if (IsJumping()) {
		x -= ((GetX() - GetBeginJumpX()) * GetRemainingStep());
	}

	return x;
}

int Game_Character::GetSpriteY() const {
	int y = GetY() * SCREEN_TILE_SIZE;

	if (IsMoving()) {
		int d = GetDirection();
		if (d == Down || d == DownRight || d == DownLeft)
			y -= GetRemainingStep();
		else if (d == Up || d == UpRight || d == UpLeft)
			y += GetRemainingStep();
	} else if (IsJumping()) {
		y -= (GetY() - GetBeginJumpY()) * GetRemainingStep();
	}

	return y;
}

bool Game_Character::IsInPosition(int x, int y) const {
	return ((GetX() == x) && (GetY() == y));
}

int Game_Character::GetOpacity() const {
	return Utils::Clamp((8 - GetTransparency()) * 32 - 1, 0, 255);
}

bool Game_Character::IsAnimated() const {
	auto at = GetAnimationType();
	return !IsAnimPaused()
		&& at != lcf::rpg::EventPage::AnimType_fixed_graphic
		&& at != lcf::rpg::EventPage::AnimType_step_frame_fix;
}

bool Game_Character::IsContinuous() const {
	auto at = GetAnimationType();
	return
		at == lcf::rpg::EventPage::AnimType_continuous ||
		at == lcf::rpg::EventPage::AnimType_fixed_continuous;
}

bool Game_Character::IsSpinning() const {
	return GetAnimationType() == lcf::rpg::EventPage::AnimType_spin;
}

int Game_Character::GetBushDepth() const {
	if ((GetLayer() != lcf::rpg::EventPage::Layers_same) || IsJumping() || IsFlying()) {
		return 0;
	}

	return Game_Map::GetBushDepth(GetX(), GetY());
}

void Game_Character::Flash(int r, int g, int b, int power, int frames) {
	data()->flash_red = r;
	data()->flash_green = g;
	data()->flash_blue = b;
	data()->flash_current_level = power;
	data()->flash_time_left = frames;
}

// Gets Character
Game_Character* Game_Character::GetCharacter(int character_id, int event_id) {
	switch (character_id) {
		case CharPlayer:
			// Player/Hero
			return Main_Data::game_player.get();
		case CharBoat:
			return Game_Map::GetVehicle(Game_Vehicle::Boat);
		case CharShip:
			return Game_Map::GetVehicle(Game_Vehicle::Ship);
		case CharAirship:
			return Game_Map::GetVehicle(Game_Vehicle::Airship);
		case CharThisEvent:
			// This event
			return Game_Map::GetEvent(event_id);
		default:
			// Other events
			return Game_Map::GetEvent(character_id);
	}
}

Game_Character& Game_Character::GetPlayer() {
	assert(Main_Data::game_player);

	return *Main_Data::game_player;
}

int Game_Character::ReverseDir(int dir) {
	constexpr static char reversed[] =
		{ Down, Left, Up, Right, DownLeft, UpLeft, UpRight, DownRight };
	return reversed[dir];
}

void Game_Character::SetMaxStopCountForStep() {
	SetMaxStopCount(GetMaxStopCountForStep(GetMoveFrequency()));
}

void Game_Character::SetMaxStopCountForTurn() {
	SetMaxStopCount(GetMaxStopCountForTurn(GetMoveFrequency()));
}

void Game_Character::SetMaxStopCountForWait() {
	SetMaxStopCount(GetMaxStopCountForWait(GetMoveFrequency()));
}

void Game_Character::UpdateFacing() {
	// RPG_RT only does the IsSpinning() check for Game_Event. We did it for all types here
	// in order to avoid a virtual call and because normally with RPG_RT, spinning
	// player or vehicle is impossible.
	if (IsFacingLocked() || IsSpinning()) {
		return;
	}
	const auto dir = GetDirection();
	const auto facing = GetFacing();
	if (dir >= 4) /* is diagonal */ {
		// [UR, DR, DL, UL] -> [U, D, D, U]
		const auto f1 = ((dir + (dir >= 6)) % 2) * 2;
		// [UR, DR, DL, UL] -> [R, R, L, L]
		const auto f2 = (dir / 2) - (dir < 6);
		if (facing != f1 && facing != f2) {
			// Reverse the direction.
			SetFacing((facing + 2) % 4);
		}
	} else {
		SetFacing(dir);
	}
}


/*end of file .\game_character.cpp*/

/*start of file .\game_clock.cpp*/

/* ... license chunk ... */

#include "game_clock.h"
#include "output.h"

#include <thread>
#include <cinttypes>
#include <algorithm>

Game_Clock::Data Game_Clock::data;

// Damping factor fps computation.
static constexpr auto _fps_smooth = 2.0f / 121.0f;

Game_Clock::duration Game_Clock::OnNextFrame(time_point now) {
	const auto mfa = std::chrono::duration_cast<duration>(data.max_frame_accumulator * data.speed);

	const auto dt = now - data.frame_time;
	data.frame_time = now;
	data.frame_accumulator += std::chrono::duration_cast<duration>(dt * data.speed);
	data.frame_accumulator = std::min(data.frame_accumulator, mfa);

	const auto fps = (1.0f / std::chrono::duration<float>(dt).count());
	data.fps = (data.fps * _fps_smooth) + (fps * (1.0f - _fps_smooth));

	++data.frame;

	return dt;
}

void Game_Clock::ResetFrame(time_point now, bool reset_frame_counter) {
	data.frame_time = now;
	data.frame_accumulator = {};
	data.fps = 0.0;
	if (reset_frame_counter) {
		data.frame = 0;
	}
}

void Game_Clock::logClockInfo() {
	const char* period_name = "custom";
	if (std::is_same<period,std::nano>::value) {
		period_name = "ns";
	} else if (std::is_same<period,std::micro>::value) {
		period_name = "us";
	} else if (std::is_same<period,std::milli>::value) {
		period_name = "ms";
	}
	Output::Debug("Clock: {} steady={} period={} ({} / {})",
			Name(),
			is_steady,
			period_name,
			period::num,
			period::den);
}


/*end of file .\game_clock.cpp*/

/*start of file .\game_commonevent.cpp*/

/* ... license chunk ... */

// Headers
#include "game_commonevent.h"
#include "game_map.h"
#include "game_switches.h"
#include "game_interpreter_map.h"
#include "main_data.h"
#include <lcf/reader_util.h>
#include <cassert>
#include "game_interpreter_battle.h"
#include "player.h"
#include <tuple>

Game_CommonEvent::Game_CommonEvent(int common_event_id) :
	common_event_id(common_event_id)
{
	auto* ce = lcf::ReaderUtil::GetElement(lcf::Data::commonevents, common_event_id);

	if (ce->trigger == lcf::rpg::EventPage::Trigger_parallel
			&& !ce->event_commands.empty()) {
		interpreter.reset(new Game_Interpreter_Map());
		interpreter->Push<InterpreterExecutionType::Parallel>(this);
	}


}

void Game_CommonEvent::SetSaveData(const lcf::rpg::SaveEventExecState& data) {
	// RPG_RT Savegames have empty stacks for parallel events.
	// We are LSD compatible but don't load these into interpreter.
	if (!data.stack.empty() && !data.stack.front().commands.empty()) {
		if (!interpreter) {
			interpreter.reset(new Game_Interpreter_Map());
		}
		interpreter->SetState(data);
	}
}

AsyncOp Game_CommonEvent::Update(bool resume_async) {
	if (interpreter && IsWaitingBackgroundExecution(resume_async)) {
		assert(interpreter->IsRunning());
		interpreter->Update(!resume_async);

		// Suspend due to async op ...
		if (interpreter->IsAsyncPending()) {
			return interpreter->GetAsyncOp();
		}
	}

	return {};
}

int Game_CommonEvent::GetId() const {
	return common_event_id;
}

int Game_CommonEvent::GetIndex() const {
	return common_event_id;
}

// Game_Map ensures validity of Common Events

std::string_view Game_CommonEvent::GetName() const {
	return lcf::ReaderUtil::GetElement(lcf::Data::commonevents, common_event_id)->name;
}

bool Game_CommonEvent::GetSwitchFlag() const {
	return lcf::ReaderUtil::GetElement(lcf::Data::commonevents, common_event_id)->switch_flag;
}

int Game_CommonEvent::GetSwitchId() const {
	return lcf::ReaderUtil::GetElement(lcf::Data::commonevents, common_event_id)->switch_id;
}

int Game_CommonEvent::GetTrigger() const {
	return lcf::ReaderUtil::GetElement(lcf::Data::commonevents, common_event_id)->trigger;
}

std::vector<lcf::rpg::EventCommand>& Game_CommonEvent::GetList() {
	return lcf::ReaderUtil::GetElement(lcf::Data::commonevents, common_event_id)->event_commands;
}

lcf::rpg::SaveEventExecState Game_CommonEvent::GetSaveData() {
	lcf::rpg::SaveEventExecState state;
	if (interpreter) {
		state = interpreter->GetSaveState();
	}
	if (GetTrigger() == lcf::rpg::EventPage::Trigger_parallel && state.stack.empty()) {
		// RPG_RT always stores an empty stack frame for parallel events.
		state.stack.push_back({});
	}
	return state;
}

bool Game_CommonEvent::IsWaitingForegroundExecution() const {
	auto* ce = lcf::ReaderUtil::GetElement(lcf::Data::commonevents, common_event_id);
	return ce->trigger == lcf::rpg::EventPage::Trigger_auto_start &&
		(!ce->switch_flag || Main_Data::game_switches->Get(ce->switch_id))
		&& !ce->event_commands.empty();
}

bool Game_CommonEvent::IsWaitingBackgroundExecution(bool force_run) const {
	auto* ce = lcf::ReaderUtil::GetElement(lcf::Data::commonevents, common_event_id);
	return ce->trigger == lcf::rpg::EventPage::Trigger_parallel &&
		(force_run || !ce->switch_flag || Main_Data::game_switches->Get(ce->switch_id));
}


/*end of file .\game_commonevent.cpp*/

/*start of file .\game_config.cpp*/

/* ... license chunk ... */

#include "game_config.h"
#include "cmdline_parser.h"
#include "filefinder.h"
#include "filesystem_stream.h"
#include "input_buttons.h"
#include "keys.h"
#include "options.h"
#include "output.h"
#include "input.h"
#include "player.h"
#include <lcf/inireader.h>
#include <cstring>

#ifdef _WIN32
#  include <shlobj.h>
#endif

#ifdef USE_LIBRETRO
#   include "platform/libretro/ui.h"
#endif

namespace {
	std::string config_path;
	std::string soundfont_path;
	std::string font_path;

	struct {
		bool started = false;
		std::string path;
		Filesystem_Stream::OutputStream handle;
	} logging;

#if USE_SDL == 1
	// For SDL1 hardcode a different config file because it uses a completely different mapping for gamepads
	std::string_view config_name = "config_sdl1.ini";
#else
	std::string_view config_name = EASYRPG_CONFIG_NAME;
#endif
}

void Game_ConfigPlayer::Hide() {
#if !defined(HAVE_FREETYPE) || defined(__ANDROID__)
	// FIXME (Android): URI encoded SAF paths are not supported
	font1.SetOptionVisible(false);
	font1_size.SetOptionVisible(false);
	font2.SetOptionVisible(false);
	font2_size.SetOptionVisible(false);
#endif
	if (automatic_screenshots.IsOptionVisible()) {
		automatic_screenshots_interval.SetLocked(!automatic_screenshots.Get());
	}
}

void Game_ConfigVideo::Hide() {
	// Options that are platform dependent are opt-in
	// Implementors must invoke SetOptionVisible() when supported

	// Always enabled by default:
	// - renderer (name of the renderer)

	vsync.SetOptionVisible(false);
	fullscreen.SetOptionVisible(false);
	fps_limit.SetOptionVisible(false);
	window_zoom.SetOptionVisible(false);
	scaling_mode.SetOptionVisible(false);
	stretch.SetOptionVisible(false);
	touch_ui.SetOptionVisible(false);
	pause_when_focus_lost.SetOptionVisible(false);
	game_resolution.SetOptionVisible(false);
	screen_scale.SetOptionVisible(false);
}

void Game_ConfigAudio::Hide() {
	// Music and SE volume control are opt-out
	// Nothing else available currently
}

void Game_ConfigInput::Hide() {
	// These features are handled by our input system but showing them only
	// makes sense on hardware with the required sticks and buttons
	gamepad_swap_ab_and_xy.SetOptionVisible(false);
	gamepad_swap_analog.SetOptionVisible(false);
	gamepad_swap_dpad_with_buttons.SetOptionVisible(false);
}

Game_Config Game_Config::Create(CmdlineParser& cp) {
	Game_Config cfg;

	// Set platform specific defaults
#if USE_SDL >= 2
	cfg.video.scaling_mode.Set(ConfigEnum::ScalingMode::Bilinear);
#endif

#if defined(__WIIU__)
	cfg.input.gamepad_swap_ab_and_xy.Set(true);
#endif

#if defined(USE_CUSTOM_FILEBUF) || defined(USE_LIBRETRO)
	// Disable logging by default on
	// - platforms with slow IO or bad FS drivers
	// - libretro because the frontend handles the logging
	cfg.player.log_enabled.Set(false);
#endif

	cp.Rewind();

	config_path = GetConfigPath(cp);
	std::string config_file;
	if (!config_path.empty()) {
		config_file = FileFinder::MakePath(config_path, config_name);
	}
	else if (FileFinder::Root().Exists(config_name)) {
		config_file = ToString(config_name);
	}

	auto cli_config = FileFinder::Root().OpenOrCreateInputStream(config_file);
	if (!cli_config) {
		config_path.clear();
		auto global_config = GetGlobalConfigFileInput();
		if (global_config) {
			cfg.LoadFromStream(global_config);
		} else {
			// Game_Config only loads an empty layout
			cfg.input.buttons = Input::GetDefaultButtonMappings();
		}
	} else {
		cfg.LoadFromStream(cli_config);
	}

	cp.Rewind();
	cfg.LoadFromArgs(cp);

	return cfg;
}

FilesystemView Game_Config::GetGlobalConfigFilesystem() {
	// FIXME: Game specific configs?
	std::string path;

	if (config_path.empty()) {
#ifdef __wii__
		path = "/data/easyrpg-player";
#elif defined(__WIIU__)
		path = "fs:/vol/external01/wiiu/data/easyrpg-player";
#elif defined(__SWITCH__)
		path = "/switch/easyrpg-player";
#elif defined(__3DS__)
		path = "sdmc:/data/easyrpg-player";
#elif defined(__vita__)
		path = "ux0:/data/easyrpg-player";
#elif defined(USE_LIBRETRO)
		const char* dir = nullptr;
		if (LibretroUi::environ_cb(RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY, &dir) && dir) {
			path = FileFinder::MakePath(dir, "easyrpg-player");
		}
#elif defined(__ANDROID__)
		// Never called, passed as argument on startup
#elif defined(_WIN32)
		PWSTR knownPath;
		const auto hresult = SHGetKnownFolderPath(FOLDERID_RoamingAppData, 0, nullptr, &knownPath);
		if (SUCCEEDED(hresult)) {
			path = Utils::FromWideString(knownPath);
			CoTaskMemFree(knownPath);
		} else {
			Output::Debug("Config: SHGetKnownFolderPath failed");
		}

		if (!path.empty()) {
			path = FileFinder::MakePath(path, FileFinder::MakePath(ORGANIZATION_NAME, APPLICATION_NAME));
		}
#else
		char* home = getenv("XDG_CONFIG_HOME");
		if (home) {
			path = home;
		} else {
			home = getenv("HOME");
			if (home) {
				path = FileFinder::MakePath(home, ".config");
			}
		}

		if (!path.empty()) {
			path = FileFinder::MakePath(path, FileFinder::MakePath(ORGANIZATION_NAME, APPLICATION_NAME));
		}
#endif
	} else {
		path = config_path;
	}

	auto print_err = [&path]() {
		if (path.empty()) {
			Output::Warning("Could not determine config path");
		} else {
			Output::Warning("Could not access config path {}", path);
		}
	};

	if (path.empty()) {
		print_err();
		return {};
	}

	if (!FileFinder::Root().MakeDirectory(path, true)) {
		print_err();
		return {};
	}

	auto fs = FileFinder::Root().Create(path);

	if (!fs) {
		print_err();
		return {};
	}

	return fs;
}

Filesystem_Stream::InputStream Game_Config::GetGlobalConfigFileInput() {
	auto fs = GetGlobalConfigFilesystem();

	if (fs) {
		return fs.OpenOrCreateInputStream(config_name, std::ios_base::in);
	}

	return Filesystem_Stream::InputStream();
}

FilesystemView Game_Config::GetSoundfontFilesystem() {
	std::string path = soundfont_path;
	if (path.empty()) {
		path = FileFinder::MakePath(GetGlobalConfigFilesystem().GetFullPath(), "Soundfont");
	}

	if (!FileFinder::Root().MakeDirectory(path, true)) {
		Output::Warning("Could not create soundfont path {}", path);
		return {};
	}

	return FileFinder::Root().Create(path);
}


FilesystemView Game_Config::GetFontFilesystem() {
	std::string path = font_path;
	if (path.empty()) {
		path = FileFinder::MakePath(GetGlobalConfigFilesystem().GetFullPath(), "Font");
	}

	if (!FileFinder::Root().MakeDirectory(path, true)) {
		Output::Warning("Could not create fount path {}", path);
		return {};
	}

	return FileFinder::Root().Create(path);
}

Filesystem_Stream::OutputStream Game_Config::GetGlobalConfigFileOutput() {
	auto fs = GetGlobalConfigFilesystem();

	if (fs) {
		return fs.OpenOutputStream(config_name, std::ios_base::out);
	}

	return Filesystem_Stream::OutputStream();
}

Filesystem_Stream::OutputStream& Game_Config::GetLogFileOutput() {
	// Invalid stream that consumes the output when logging is disabled or an error occurs
	static Filesystem_Stream::OutputStream noop_stream;

	if (!Player::player_config.log_enabled.Get()) {
		return noop_stream;
	}

	if (!logging.started) {
		logging.started = true;

		std::string path;

		if (logging.path.empty()) {
	#if defined(_WIN32)
			PWSTR knownPath;
			const auto hresult = SHGetKnownFolderPath(FOLDERID_LocalAppData, 0, nullptr, &knownPath);
			if (SUCCEEDED(hresult)) {
				path = Utils::FromWideString(knownPath);
				CoTaskMemFree(knownPath);
			} else {
				Output::Debug("LogFile: SHGetKnownFolderPath failed");
			}
	#elif defined(SYSTEM_DESKTOP_LINUX_BSD_MACOS)
			char* home = getenv("XDG_STATE_HOME");
			if (home) {
				path = home;
			} else {
				home = getenv("HOME");
				if (home) {
					path = FileFinder::MakePath(home, ".local/state");
				}
			}
	#endif

			if (path.empty()) {
				// Fallback: Use the config directory
				// Can still fail in the rare case that the config path is invalid
				if (auto fs = GetGlobalConfigFilesystem(); fs) {
					path = fs.GetFullPath();
				}
			}

			if (!path.empty()) {
				path = FileFinder::MakePath(path, OUTPUT_FILENAME);
			}
		} else {
			path = logging.path;
		}

		auto print_err = [&path]() {
			if (path.empty()) {
				Output::Warning("Could not determine logfile path");
			} else {
				Output::Warning("Could not access logfile path {}", path);
			}
		};

		if (path.empty()) {
			print_err();
			return noop_stream;
		}

#ifndef ANDROID
		// Make Directory not supported on Android, assume the path exists
		if (!FileFinder::Root().MakeDirectory(FileFinder::GetPathAndFilename(path).first, true)) {
			print_err();
			return noop_stream;
		}
#endif

		logging.handle = FileFinder::Root().OpenOutputStream(path, std::ios_base::out | std::ios_base::app);

		if (!logging.handle) {
			Output::Warning("Could not open logfile {}", path);
			return logging.handle;
		}

		logging.path = path;
	}

	return logging.handle;
}

void Game_Config::CloseLogFile() {
	if (!Game_Config::GetLogFileOutput()) {
		return;
	}

	Game_Config::GetLogFileOutput().Close();

	// Truncate the logfile when it is too large
	const std::streamoff log_size = 1024 * 1024; // 1 MB
	std::vector<char> buf(log_size);

	auto in = FileFinder::Root().OpenInputStream(logging.path);
	if (in) {
		in.seekg(0, std::ios_base::end);
		if (in.tellg() > log_size) {
			in.seekg(-log_size, std::ios_base::end);
			// skip current incomplete line
			std::string line;
			Utils::ReadLine(in, line);

			// Read the remaining logfile into the buffer
			in.read(buf.data(), buf.size());
			size_t read = in.gcount();
			in.Close();

			// Truncate the logfile and write the data into the logfile
			auto out = FileFinder::Root().OpenOutputStream(logging.path);
			if (out) {
				out.write(buf.data(), read);
			}
		}
	}

	logging.started = false;
	logging.handle = Filesystem_Stream::OutputStream();
}

std::string Game_Config::GetConfigPath(CmdlineParser& cp) {
	std::string path;

	while (!cp.Done()) {
		CmdlineArg arg;
		if (cp.ParseNext(arg, 1, "--config-path", 'c')) {
			if (arg.NumValues() > 0) {
				path = arg.Value(0);
				path = FileFinder::MakeCanonical(path, 0);
			}
			continue;
		}

		cp.SkipNext();
	}

	if (!path.empty()) {
		if (!FileFinder::Root().MakeDirectory(path, true)) {
			Output::Debug("Could not create global config directory {}", path);
			path.clear();
		}
	}

	return path;
}

void Game_Config::LoadFromArgs(CmdlineParser& cp) {
	font_path.clear();
	soundfont_path.clear();

	while (!cp.Done()) {
		CmdlineArg arg;
		long li_value = 0;
		std::string str_value;

		if (cp.ParseNext(arg, 0, {"--vsync", "--no-vsync"})) {
			video.vsync.Set(arg.ArgIsOn());
			continue;
		}
		if (cp.ParseNext(arg, 1, "--fps-limit")) {
			if (arg.ParseValue(0, li_value)) {
				video.fps_limit.Set(li_value);
			}
			continue;
		}
		if (cp.ParseNext(arg, 0, "--no-fps-limit")) {
			video.fps_limit.Set(0);
			continue;
		}
		if (cp.ParseNext(arg, 0, "--show-fps")) {
			video.fps.Set(ConfigEnum::ShowFps::ON);
			continue;
		}
		if (cp.ParseNext(arg, 0, "--no-show-fps")) {
			video.fps.Set(ConfigEnum::ShowFps::OFF);
			continue;
		}
		if (cp.ParseNext(arg, 0, "--fps-render-window")) {
			video.fps.Set(ConfigEnum::ShowFps::Overlay);
			continue;
		}
		if (cp.ParseNext(arg, 0, "--pause-focus-lost")) {
			video.pause_when_focus_lost.Set(true);
			continue;
		}
		if (cp.ParseNext(arg, 0, "--no-pause-focus-lost")) {
			video.pause_when_focus_lost.Set(false);
			continue;
		}
		if (cp.ParseNext(arg, 0, "--window")) {
			video.fullscreen.Set(false);
			continue;
		}
		if (cp.ParseNext(arg, 0, "--fullscreen")) {
			video.fullscreen.Set(true);
			continue;
		}
		if (cp.ParseNext(arg, 1, "--window-zoom")) {
			if (arg.ParseValue(0, li_value)) {
				video.window_zoom.Set(li_value);
			}
			continue;
		}
		if (cp.ParseNext(arg, 0, {"--stretch", "--no-stretch"})) {
			video.stretch.Set(arg.ArgIsOn());
			continue;
		}
		if (cp.ParseNext(arg, 1, "--scaling")) {
			if (arg.ParseValue(0, str_value)) {
				video.scaling_mode.SetFromString(str_value);
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--game-resolution")) {
			if (arg.ParseValue(0, str_value)) {
				video.game_resolution.SetFromString(str_value);
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--autobattle-algo")) {
			std::string svalue;
			if (arg.ParseValue(0, svalue)) {
				player.autobattle_algo.Set(std::move(svalue));
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--enemyai-algo")) {
			std::string svalue;
			if (arg.ParseValue(0, svalue)) {
				player.enemyai_algo.Set(std::move(svalue));
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--music-volume")) {
			if (arg.ParseValue(0, li_value)) {
				audio.music_volume.Set(li_value);
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--sound-volume")) {
			if (arg.ParseValue(0, li_value)) {
				audio.sound_volume.Set(li_value);
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--soundfont")) {
			if (arg.NumValues() > 0) {
				audio.soundfont.Set(arg.Value(0));
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--font1")) {
			if (arg.NumValues() > 0) {
				player.font1.Set(FileFinder::MakeCanonical(arg.Value(0), 0));
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--font1-size")) {
			if (arg.ParseValue(0, li_value)) {
				player.font1_size.Set(li_value);
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--font2")) {
			if (arg.NumValues() > 0) {
				player.font2.Set(FileFinder::MakeCanonical(arg.Value(0), 0));
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--font2-size")) {
			if (arg.ParseValue(0, li_value)) {
				player.font2_size.Set(li_value);
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--soundfont-path")) {
			if (arg.NumValues() > 0) {
				soundfont_path = FileFinder::MakeCanonical(arg.Value(0), 0);
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--font-path")) {
			if (arg.NumValues() > 0) {
				font_path = FileFinder::MakeCanonical(arg.Value(0), 0);
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--log-file")) {
			if (arg.NumValues() > 0) {
				logging.path = FileFinder::MakeCanonical(arg.Value(0), 0);
			}
			continue;
		}

		cp.SkipNext();
	}
}

void Game_Config::LoadFromStream(Filesystem_Stream::InputStream& is) {
	lcf::INIReader ini(is);

	if (ini.ParseError()) {
		Output::Debug("Failed to parse ini config file {}", is.GetName());
		return;
	}

	/** VIDEO SECTION */
	video.vsync.FromIni(ini);
	video.fullscreen.FromIni(ini);
	video.fps.FromIni(ini);
	video.fps_limit.FromIni(ini);
	video.window_zoom.FromIni(ini);
	video.scaling_mode.FromIni(ini);
	video.stretch.FromIni(ini);
	video.touch_ui.FromIni(ini);
	video.pause_when_focus_lost.FromIni(ini);
	video.game_resolution.FromIni(ini);
	video.screen_scale.FromIni(ini);

	if (ini.HasValue("Video", "WindowX") && ini.HasValue("Video", "WindowY") && ini.HasValue("Video", "WindowWidth") && ini.HasValue("Video", "WindowHeight")) {
		video.window_x.FromIni(ini);
		video.window_y.FromIni(ini);
		video.window_width.FromIni(ini);
		video.window_height.FromIni(ini);
	}

	/** AUDIO SECTION */
	audio.music_volume.FromIni(ini);
	audio.sound_volume.FromIni(ini);
	audio.fluidsynth_midi.FromIni(ini);
	audio.wildmidi_midi.FromIni(ini);
	audio.native_midi.FromIni(ini);
	audio.soundfont.FromIni(ini);

	/** INPUT SECTION */
	input.buttons = Input::GetDefaultButtonMappings();
	auto& mappings = input.buttons;

	for (int i = 0; i < Input::BUTTON_COUNT; ++i) {
		auto button = static_cast<Input::InputButton>(i);

		auto name = Input::kInputButtonNames.tag(button);
		if (ini.HasValue("input", name)) {
			auto values = ini.GetString("input", name, "");
			mappings.RemoveAll(button);

			auto keys = Utils::Tokenize(values, [](char32_t c) { return c == ','; });

			// When it is a protected (important) button with zero mappings keep the default
			// For all other buttons having no mapping is fine
			bool has_mapping = false;
			if (Input::IsProtectedButton(button)) {
				// Check for protected (important) buttons if they have more than zero mappings
				for (const auto& key: keys) {
					Input::Keys::InputKey k;
					if (Input::Keys::kInputKeyNames.etag(key.c_str(), k)) {
						has_mapping = true;
						break;
					}
				}

				// If not, keep the default mapping
				if (!has_mapping) {
					continue;
				}
			}

			// Load mappings from ini
			for (const auto& key: keys) {
				Input::Keys::InputKey k;
				if (Input::Keys::kInputKeyNames.etag(key.c_str(), k)) {
					mappings.Add({button, k});
				}
			}
		}
	}

	input.gamepad_swap_analog.FromIni(ini);
	input.gamepad_swap_dpad_with_buttons.FromIni(ini);
	input.gamepad_swap_ab_and_xy.FromIni(ini);
	input.speed_modifier_a.FromIni(ini);
	input.speed_modifier_b.FromIni(ini);

	/** PLAYER SECTION */
	player.settings_autosave.FromIni(ini);
	player.settings_in_title.FromIni(ini);
	player.settings_in_menu.FromIni(ini);
	player.lang_select_on_start.FromIni(ini);
	player.lang_select_in_title.FromIni(ini);
	player.show_startup_logos.FromIni(ini);
	player.font1.FromIni(ini);
	player.font1_size.FromIni(ini);
	player.font2.FromIni(ini);
	player.font2_size.FromIni(ini);
	player.log_enabled.FromIni(ini);
	player.screenshot_scale.FromIni(ini);
	player.screenshot_timestamp.FromIni(ini);
	player.automatic_screenshots.FromIni(ini);
	player.automatic_screenshots_interval.FromIni(ini);
}

void Game_Config::WriteToStream(Filesystem_Stream::OutputStream& os) const {
	/** VIDEO SECTION */

	os << "[Video]\n";
	video.vsync.ToIni(os);
	video.fullscreen.ToIni(os);
	video.fps.ToIni(os);
	video.fps_limit.ToIni(os);
	video.window_zoom.ToIni(os);
	video.scaling_mode.ToIni(os);
	video.stretch.ToIni(os);
	video.touch_ui.ToIni(os);
	video.pause_when_focus_lost.ToIni(os);
	video.game_resolution.ToIni(os);
	video.screen_scale.ToIni(os);

	// only preserve when toggling between window and fullscreen is supported
	if (video.fullscreen.IsOptionVisible()) {
		video.window_x.ToIni(os);
		video.window_y.ToIni(os);
		video.window_width.ToIni(os);
		video.window_height.ToIni(os);
	}
	os << "\n";

	/** AUDIO SECTION */
	os << "[Audio]\n";

	audio.music_volume.ToIni(os);
	audio.sound_volume.ToIni(os);
	audio.fluidsynth_midi.ToIni(os);
	audio.wildmidi_midi.ToIni(os);
	audio.native_midi.ToIni(os);
	audio.soundfont.ToIni(os);

	os << "\n";

	/** INPUT SECTION */
	os << "[Input]\n";

	auto& mappings = Input::GetInputSource()->GetButtonMappings();
	for (int i = 0; i < Input::BUTTON_COUNT; ++i) {
		auto button = static_cast<Input::InputButton>(i);

		auto name = Input::kInputButtonNames.tag(button);
		os << name << "=";

		std::stringstream ss;
		bool first = true;
		for (auto ki = mappings.LowerBound(button); ki != mappings.end() && ki->first == button;++ki) {
			if (!first) {
				os << ",";
			}
			first = false;

			auto key = static_cast<Input::Keys::InputKey>(ki->second);
			auto kname = Input::Keys::kInputKeyNames.tag(key);
			os << kname;
		}

		os << "\n";
	}

	input.gamepad_swap_analog.ToIni(os);
	input.gamepad_swap_dpad_with_buttons.ToIni(os);
	input.gamepad_swap_ab_and_xy.ToIni(os);
	input.speed_modifier_a.ToIni(os);
	input.speed_modifier_b.ToIni(os);

	os << "\n";

	/** PLAYER SECTION */
	os << "[Player]\n";
	//os << "autobattle-algo=" << player.autobattle_algo.Get() << "\n";
	//os << "enemyai-algo=" << player.enemyai_algo.Get() << "\n";

	player.settings_autosave.ToIni(os);
	player.settings_in_title.ToIni(os);
	player.settings_in_menu.ToIni(os);
	player.lang_select_on_start.ToIni(os);
	player.lang_select_in_title.ToIni(os);
	player.show_startup_logos.ToIni(os);
	player.font1.ToIni(os);
	player.font1_size.ToIni(os);
	player.font2.ToIni(os);
	player.font2_size.ToIni(os);
	player.log_enabled.ToIni(os);
	player.screenshot_scale.ToIni(os);
	player.screenshot_timestamp.ToIni(os);
	player.automatic_screenshots.ToIni(os);
	player.automatic_screenshots_interval.ToIni(os);

	os << "\n";
}


/*end of file .\game_config.cpp*/

/*start of file .\game_config_game.cpp*/

/* ... license chunk ... */

#include "game_config_game.h"
#include "game_runtime_patches.h"
#include "cmdline_parser.h"
#include "directory_tree.h"
#include "filefinder.h"
#include "options.h"
#include "output.h"
#include "player.h"
#include <cstring>

void Game_ConfigGame::Initialize(CmdlineParser& cp) {
	Game_ConfigGame& cfg = *this;

	auto cli_config = FileFinder::Game().OpenFile(EASYRPG_INI_NAME);
	if (cli_config) {
		cfg.LoadFromStream(cli_config);
	}

	cfg.LoadFromArgs(cp);

	cfg.engine = Player::EngineNone;
	if (!cfg.engine_str.Get().empty()) {
		std::string v = cfg.engine_str.Get();
		if (v == "rpg2k" || v == "2000") {
			cfg.engine = Player::EngineRpg2k;
		}
		else if (v == "rpg2kv150" || v == "2000v150") {
			cfg.engine = Player::EngineRpg2k | Player::EngineMajorUpdated;
		}
		else if (v == "rpg2ke" || v == "2000e") {
			cfg.engine = Player::EngineRpg2k | Player::EngineMajorUpdated | Player::EngineEnglish;
		}
		else if (v == "rpg2k3" || v == "2003") {
			cfg.engine = Player::EngineRpg2k3;
		}
		else if (v == "rpg2k3v105" || v == "2003v105") {
			cfg.engine = Player::EngineRpg2k3 | Player::EngineMajorUpdated;
		}
		else if (v == "rpg2k3e" || v == "2003e") {
			cfg.engine = Player::EngineRpg2k3 | Player::EngineMajorUpdated | Player::EngineEnglish;
		}
	}
}

void Game_ConfigGame::LoadFromArgs(CmdlineParser& cp) {
	cp.Rewind();

	while (!cp.Done()) {
		CmdlineArg arg;
		long li_value = 0;

		if (cp.ParseNext(arg, 0, {"--new-game", "--no-new-game"})) {
			new_game.Set(arg.ArgIsOn());
			continue;
		}
		if (cp.ParseNext(arg, 1, "--engine")) {
			if (arg.NumValues() > 0) {
				const auto& v = arg.Value(0);
				engine_str.Set(v);
			}
			continue;
		}
		if (cp.ParseNext(arg, 0, "--no-patch")) {
			patch_support.Set(false);
			patch_dynrpg.Lock(false);
			patch_maniac.Lock(false);
			patch_unlock_pics.Lock(false);
			patch_common_this_event.Lock(false);
			patch_key_patch.Lock(false);
			patch_rpg2k3_commands.Lock(false);
			patch_anti_lag_switch.Lock(0);
			patch_direct_menu.Lock(0);

			RuntimePatches::LockPatchesAsDiabled();
			patch_override = true;
			continue;
		}
		if (cp.ParseNext(arg, 0, {"--patch-easyrpg", "--no-patch-easyrpg"})) {
			patch_easyrpg.Set(arg.ArgIsOn());
			patch_override = true;
			continue;
		}
		if (cp.ParseNext(arg, 0, {"--patch-dynrpg", "--no-patch-dynrpg"})) {
			patch_dynrpg.Set(arg.ArgIsOn());
			patch_override = true;
			continue;
		}
		if (cp.ParseNext(arg, 1, {"--patch-maniac", "--no-patch-maniac"})) {
			patch_maniac.Set(arg.ArgIsOn());

			if (arg.ArgIsOn() && arg.ParseValue(0, li_value)) {
				patch_maniac.Set(li_value);
			}

			patch_override = true;
			continue;
		}
		if (cp.ParseNext(arg, 0, {"--patch-common-this", "--no-patch-common-this"})) {
			patch_common_this_event.Set(arg.ArgIsOn());
			patch_override = true;
			continue;
		}
		if (cp.ParseNext(arg, 0, {"--patch-pic-unlock", "--no-patch-pic-unlock"})) {
			patch_unlock_pics.Set(arg.ArgIsOn());
			patch_override = true;
			continue;
		}
		if (cp.ParseNext(arg, 0, {"--patch-key-patch", "--no-patch-key-patch"})) {
			patch_key_patch.Set(arg.ArgIsOn());
			patch_override = true;
			continue;
		}
		if (cp.ParseNext(arg, 0, {"--patch-rpg2k3-cmds", "--patch-rpg2k3-commands", "--no-patch-rpg2k3-cmds", "--no-patch-rpg2k3-commands"})) {
			patch_rpg2k3_commands.Set(arg.ArgIsOn());
			patch_override = true;
			continue;
		}
		if (cp.ParseNext(arg, 1, {"--patch-antilag-switch", "--no-patch-antilag-switch"})) {
			if (arg.ArgIsOn() && arg.ParseValue(0, li_value)) {
				patch_anti_lag_switch.Set(li_value);
				patch_override = true;
			}

			if (arg.ArgIsOff()) {
				patch_anti_lag_switch.Set(0);
				patch_override = true;
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, {"--patch-direct-menu", "--no-patch-direct-menu"})) {
			if (arg.ArgIsOn() && arg.ParseValue(0, li_value)) {
				patch_direct_menu.Set(li_value);
				patch_override = true;
			}

			if (arg.ArgIsOff()) {
				patch_direct_menu.Set(0);
				patch_override = true;
			}
			continue;
		}
		if (RuntimePatches::ParseFromCommandLine(cp)) {
			patch_override = true;
			continue;
		}
		if (cp.ParseNext(arg, 6, "--patch")) {
			// For backwards compatibility only
			for (int i = 0; i < arg.NumValues(); ++i) {
				const auto& v = arg.Value(i);
				if (v == "dynrpg") {
					patch_dynrpg.Set(true);
				} else if (v == "maniac") {
					patch_maniac.Set(true);
				} else if (v == "common-this") {
					patch_common_this_event.Set(true);
				} else if (v == "pic-unlock") {
					patch_unlock_pics.Set(true);
				} else if (v == "key-patch") {
					patch_key_patch.Set(true);
				} else if (v == "rpg2k3-cmds" || v == "rpg2k3-commands") {
					patch_rpg2k3_commands.Set(true);
				}
			}
			patch_override = true;

			continue;
		}

		cp.SkipNext();
	}
}

void Game_ConfigGame::LoadFromStream(Filesystem_Stream::InputStream& is) {
	lcf::INIReader ini(is);

	if (ini.ParseError()) {
		Output::Debug("Failed to parse ini config file {}", is.GetName());
		return;
	}

	new_game.FromIni(ini);
	engine_str.FromIni(ini);
	fake_resolution.FromIni(ini);

	if (patch_easyrpg.FromIni(ini)) {
		patch_override = true;
	}

	if (patch_dynrpg.FromIni(ini)) {
		patch_override = true;
	}

	if (patch_maniac.FromIni(ini)) {
		patch_override = true;
	}

	if (patch_common_this_event.FromIni(ini)) {
		patch_override = true;
	}

	if (patch_unlock_pics.FromIni(ini)) {
		patch_override = true;
	}

	if (patch_key_patch.FromIni(ini)) {
		patch_override = true;
	}

	if (patch_rpg2k3_commands.FromIni(ini)) {
		patch_override = true;
	}

	if (patch_anti_lag_switch.FromIni(ini)) {
		patch_override = true;
	}

	if (patch_direct_menu.FromIni(ini)) {
		patch_override = true;
	}

	if (RuntimePatches::ParseFromIni(ini)) {
		patch_override = true;
	}
}

void Game_ConfigGame::PrintActivePatches() {
	std::vector<std::string> patches;

	auto add_bool = [&](auto& patch) {
		if (patch.Get()) {
			patches.push_back(ToString(patch.GetName()));
		}
	};

	add_bool(patch_easyrpg);
	add_bool(patch_destiny);
	add_bool(patch_dynrpg);
	add_bool(patch_common_this_event);
	add_bool(patch_unlock_pics);
	add_bool(patch_key_patch);
	add_bool(patch_rpg2k3_commands);

	auto add_int = [&](auto& patch) {
		if (patch.Get() > 0) {
			patches.push_back(fmt::format("{} ({})", patch.GetName(), patch.Get()));
		}
	};

	add_int(patch_maniac);
	add_int(patch_anti_lag_switch);
	add_int(patch_direct_menu);

	RuntimePatches::DetermineActivePatches(patches);

	if (patches.empty()) {
		Output::Debug("Patch configuration: None");
	} else {
		std::string out = "Patch configuration: ";
		bool first = true;
		for (const auto& s: patches) {
			if (!first) {
				out += ", ";
			}
			out += s;
			first = false;
		}
		Output::DebugStr(out);
	}
}


/*end of file .\game_config_game.cpp*/

/*start of file .\game_destiny.cpp*/

/* ... license chunk ... */

// Headers
#include "game_destiny.h"
#include "filefinder.h"

#ifndef EMSCRIPTEN
#include "exe_reader.h"
#endif // !EMSCRIPTEN
#include "output.h"

using Destiny::InterpretFlag;
using Destiny::MainFunctions::Interpreter;

using lcf::ToString;
using lcf::rpg::EventCommand;
using lcf::rpg::SaveEventExecFrame;


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//				Game_Destiny implementations
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

void Game_Destiny::Load()
{
	// Do not load Destiny whether player cannot find "Destiny.dll"
	if (! FileFinder::Game().Exists(DESTINY_DLL))
	{
		return;
	}

	uint32_t dllVersion = 0;
	uint32_t language = 0;
	uint32_t gameVersion = 0;
	uint32_t extra = 0;
	uint32_t dwordSize = 0;
	uint32_t floatSize = 0;
	uint32_t stringSize = 0;

#ifndef EMSCRIPTEN
	Filesystem_Stream::InputStream exe = FileFinder::Game().OpenFile(EXE_NAME);

	if (exe)
	{
		exe.seekg(0x00030689, std::ios_base::beg);
		exe.read(reinterpret_cast<char*>(&stringSize), sizeof(uint32_t));
		exe.seekg(1, std::ios_base::cur);
		exe.read(reinterpret_cast<char*>(&floatSize), sizeof(uint32_t));
		exe.seekg(1, std::ios_base::cur);
		exe.read(reinterpret_cast<char*>(&dwordSize), sizeof(uint32_t));
		exe.seekg(1, std::ios_base::cur);
		exe.read(reinterpret_cast<char*>(&extra), sizeof(uint32_t));
		exe.seekg(1, std::ios_base::cur);
		exe.read(reinterpret_cast<char*>(&gameVersion), sizeof(uint32_t));
		exe.seekg(1, std::ios_base::cur);
		exe.read(reinterpret_cast<char*>(&language), sizeof(uint32_t));
		exe.seekg(1, std::ios_base::cur);
		exe.read(reinterpret_cast<char*>(&dllVersion), sizeof(uint32_t));
		exe.seekg(1, std::ios_base::cur);
	}
#else
	// TODO [XGB]: Find to manage Destiny initialization parameters on Emscripten
	dllVersion = 0x20000;
	language = Destiny::Language::ENGLISH;
	gameVersion = 0x20000107;
	extra = 0x01;
	dwordSize = floatSize = stringSize = 0x64;
#endif // !EMSCRIPTEN

	Initialize(dllVersion, language, gameVersion, extra, dwordSize, floatSize, stringSize);
}

Game_Destiny::Game_Destiny()
{
	_dllVersion = {};
	_gameVersion = {};
	_language = Destiny::Language::DEUTSCH;
	_extra = 0U;
	_trueColor = 0U;
	_decimalComma = false;
	_rm2k3 = false;
	_protect = false;
}

Game_Destiny::~Game_Destiny()
{
	Terminate();
}

void Game_Destiny::Initialize(
	uint32_t dllVersion,
	uint32_t language,
	uint32_t gameVersion,
	uint32_t extra,
	uint32_t dwordSize,
	uint32_t floatSize,
	uint32_t stringSize
)
{
	_dllVersion = Destiny::Version(dllVersion);
	_gameVersion = Destiny::Version(gameVersion);
	_language = language <= 1
		? static_cast<Destiny::Language>(language)
		: Destiny::Language::ENGLISH;
	_extra = extra;
	_decimalComma = _language == Destiny::Language::DEUTSCH;

	EvaluateExtraFlags();
	CheckVersionInfo();

	// Init containers
	_dwords.resize(dwordSize);
	_floats.resize(floatSize);
	_strings.resize(stringSize);

	// TODO: Init File container
	// TODO: Init ClientSocket container

	// Debug
	Output::Debug("[Destiny] Initialized");
	Output::Debug("[Destiny] Language: {}", _decimalComma ? "Deutsch" : "English");
	Output::Debug("[Destiny] DLL Version: {}", _dllVersion.toString());
	Output::Debug("[Destiny] Dwords: {}", dwordSize);
	Output::Debug("[Destiny] Floats: {}", floatSize);
	Output::Debug("[Destiny] Strings: {}", stringSize);
	Output::Debug("[Destiny] RPG Maker version: {}", _rm2k3 ? 2003 : 2000);
}

void Game_Destiny::Terminate()
{
	_dwords.clear();
	_floats.clear();
	_strings.clear();

	// TODO [XGB]: Clear File container
	// TODO [XGB]: Clear ClientSocket container
}

bool Game_Destiny::Main(SaveEventExecFrame& frame)
{
	const char* script;
	InterpretFlag flag;

	script = _interpreter.MakeString(frame);
	flag = InterpretFlag::IF_EXIT;

	_interpreter.CleanUpData();
	_interpreter.LoadInterpretStack();

	while (! _interpreter.IsEndOfScript())
	{
		if (_interpreter.IsEndOfLine())
		{
			_interpreter.ScriptNextChar();
		}

		flag = _interpreter.Interpret();
		if (flag == InterpretFlag::IF_EXIT)
		{
			break;
		}
	}

	Output::Debug("DestinyScript Code:\n{}", script);
	_interpreter.FreeString();

	return true;
}

void Game_Destiny::EvaluateExtraFlags()
{
	_trueColor = (_extra & Destiny::DF_TRUECOLOR) << 9;
	_protect = _extra & Destiny::DF_PROTECT;
}

void Game_Destiny::CheckVersionInfo()
{
	uint32_t gameVersionMajor;

	gameVersionMajor = _gameVersion.ver_major;

	if (! (gameVersionMajor == 0x2000 || gameVersionMajor == 0x2003))
	{
		Output::Error("[Destiny]: {} is not a valid version", gameVersionMajor);
	}

	_rm2k3 = gameVersionMajor == 0x2003;
}


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//			MainFunctions / Interpreter
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Interpreter::Interpreter()
{
	CleanUpData();
	_scriptPtr = nullptr;
}

const char* Interpreter::MakeString(SaveEventExecFrame& frame)
{
	std::string code;

	int32_t& current = frame.current_command;
	const std::vector<EventCommand>& cmdList = frame.commands;
	std::vector<EventCommand>::const_iterator it = cmdList.begin() + current++;

	code = ToString((*it++).string);

	while (it != cmdList.cend() && it->code == static_cast<int32_t>(EventCommand::Code::Comment_2))
	{
		code += '\n';
		code += ToString((*it++).string);
		++current;
	}

	_destinyScript = code;
	return _scriptPtr = _destinyScript.data();
}

void Interpreter::FreeString()
{
	_destinyScript = "";
	_scriptPtr = _destinyScript.data();
}

void Interpreter::SkipWhiteSpace()
{
	while (IsWhiteSpace(*_scriptPtr))
	{
		++_scriptPtr;
	}
}

size_t Interpreter::GetWordLen()
{
	char* endPtr = _scriptPtr;

	while (IsWordChar(*endPtr))
	{
		++endPtr;
	}

	return endPtr - _scriptPtr;
}

InterpretFlag Interpreter::Interpret()
{
	/*char* code;
	uint8_t flags[4];
	InterpretFlag returnType;

	size_t wordLen;

	code = nullptr;
	returnType = IF_COMMAND;*/

	SkipSpace();
	//wordLen = GetWordLen();

	return IF_EXIT;
}

void Interpreter::LoadInterpretStack()
{
	//
}

void Interpreter::SkipSpace()
{
	bool finished = false;
	char next = '\0';

	while (! finished)
	{
		if (! IsWhiteSpace(*++_scriptPtr))
		{
			if (*_scriptPtr == '/')
			{
				next = *(_scriptPtr + 1);

				if (next == '/')
				{
					finished = LineComment();
				}
				else if (next == '*')
				{
					finished = BlockComment();
				}
			}
			else
			{
				finished = true;
			}
		}
	}
}

bool Interpreter::LineComment()
{
	_scriptPtr += 2;

	while (*(++_scriptPtr))
	{
		if (*_scriptPtr == 0x0A)
		{
			return false;
		}
	}

	return true;
}

bool Interpreter::BlockComment()
{
	_scriptPtr += 2;

	while (*(++_scriptPtr))
	{
		if (*_scriptPtr == '*' && *(++_scriptPtr) == '/')
		{
			return false;
		}
	}

	return true;
}


/*end of file .\game_destiny.cpp*/

/*start of file .\game_dynrpg.cpp*/

/* ... license chunk ... */

// Headers
#include "game_dynrpg.h"
#include "filefinder.h"
#include "game_actors.h"
#include "game_strings.h"
#include "game_variables.h"
#include "main_data.h"
#include "output.h"
#include "player.h"

#include <cstring>
#include <fstream>

#include "dynrpg_easyrpg.h"
#include "dynrpg_textplugin.h"

enum DynRpg_ParseMode {
	ParseMode_Function,
	ParseMode_WaitForComma,
	ParseMode_WaitForArg,
	ParseMode_String,
	ParseMode_Token
};

// Var arg referenced by $n
std::string DynRpg::ParseVarArg(std::string_view func_name, dyn_arg_list args, int index, bool& parse_okay) {
	parse_okay = true;
	if (index >= static_cast<int>(args.size())) {
		parse_okay = false;
		Output::Warning("{}: Vararg {} out of range", func_name, index);
		return {};
	}

	std::string::iterator text_index, end;
	std::string text = args[index];
	text_index = text.begin();
	end = text.end();

	std::stringstream msg;

	for (; text_index != end; ++text_index) {
		char chr = *text_index;

		// Test for "" -> append "
		// otherwise end of string
		if (chr == '$' && std::distance(text_index, end) > 1) {
			char n = *std::next(text_index, 1);

			if (n == '$') {
				// $$ = $
				msg << n;
				++text_index;
			} else if (n >= '1' && n <= '9') {
				int i = (int)(n - '0');

				if (i + index < static_cast<int>(args.size())) {
					msg << args[i + index];
				}
				else {
					// $-ref out of range
					parse_okay = false;
					Output::Warning("{}: Vararg $-ref {} out of range", func_name, i);
					return {};
				}

				++text_index;
			} else {
				msg << chr;
			}
		} else {
			msg << chr;
		}
	}

	return msg.str();
}


static std::string ParseToken(std::string token, std::string_view function_name) {
	std::string::iterator text_index, end;
	text_index = token.begin();
	end = token.end();

	char chr = *text_index;

	bool first = true;

	bool number_encountered = false;

	std::stringstream var_part;
	std::stringstream number_part;

	for (;;) {
		// This loop checks if the token is to be substituted
		// If a token is (regex) [NT]?V+[0-9]+ it is resolved to a var or an actor
		// T is an EasyRPG extension: It will return a Maniac Patch String Var
		if (text_index != end) {
			chr = *text_index;
		}

		if (text_index == end) {
			// Variable reference
			std::string tmp = number_part.str();
			int number = atoi(tmp.c_str());
			tmp = var_part.str();
			if (tmp.empty()) {
				return token;
			}

			// Convert backwards
			for (std::string::reverse_iterator it = tmp.rbegin(); it != tmp.rend(); ++it) {
				if (*it == 'N') {
					if (!Main_Data::game_actors->ActorExists(number)) {
						Output::Warning("{}: Invalid actor id {} in {}", function_name, number, token);
						return {};
					}

					// N (Actor Name) is last
					return ToString(Main_Data::game_actors->GetActor(number)->GetName());
				} else if (*it == 'T' && Player::IsPatchManiac()) {
					// T (String Var) is last
					return ToString(Main_Data::game_strings->Get(number));
				} else {
					// Variable
					number = Main_Data::game_variables->Get(number);
				}
			}

			number_part.str("");
			number_part << number;
			return number_part.str();
		} else if (number_encountered || (chr >= '0' && chr <= '9')) {
			number_encountered = true;
			number_part << chr;
		} else if (chr == 'N') {
			if (!first) {
				break;
			}
			var_part << chr;
		} else if (chr == 'V') {
			var_part << chr;
		} else if (chr == 'T' && Player::IsPatchManiac()) {
			if (!first) {
				break;
			}
			var_part << chr;
		} else {
			break;
		}

		++text_index;
		first = false;
	}

	// Normal token
	Utils::LowerCaseInPlace(token);
	return token;
}

void Game_DynRpg::InitPlugins() {
	if (plugins_loaded) {
		return;
	}

	if (Player::IsPatchDynRpg() || Player::HasEasyRpgExtensions()) {
		plugins.emplace_back(new DynRpg::EasyRpgPlugin(*this));
	}

	if (Player::IsPatchDynRpg()) {
		plugins.emplace_back(new DynRpg::TextPlugin(*this));
	}

	plugins_loaded = true;
}

std::string DynRpg::ParseCommand(std::string command, std::vector<std::string>& args) {
	if (command.empty()) {
		// Not a DynRPG function (empty comment)
		return {};
	}

	std::string::iterator text_index, end;
	text_index = command.begin();
	end = command.end();

	char chr = *text_index;

	if (chr != '@') {
		// Not a DynRPG function, normal comment
		return {};
	}

	DynRpg_ParseMode mode = ParseMode_Function;
	std::string function_name;
	std::string tmp;
	std::stringstream token;

	++text_index;

	// Parameters can be of type Token, Number or String
	// Strings are in "", a "-literal is represented by ""
	// Number is a valid float number
	// Tokens are Strings without "" and with Whitespace stripped o_O

	// All arguments are passed as string to the DynRpg functions and are
	// converted to int or float on demand.

	for (;;) {
		if (text_index != end) {
			chr = *text_index;
		}

		if (text_index == end) {
			switch (mode) {
				case ParseMode_Function:
					// End of function token
					function_name = Utils::LowerCase(token.str());
					if (function_name.empty()) {
						// empty function name
						Output::Warning("Empty DynRPG function name");
						return {};
					}
					break;
				case ParseMode_WaitForComma:
					// no-op
					break;
				case ParseMode_WaitForArg:
					if (!args.empty()) {
						// Found , but no token -> empty arg
						args.emplace_back("");
					}
					break;
				case ParseMode_String:
					// Unterminated literal, handled like a terminated literal
					args.emplace_back(token.str());
					break;
				case ParseMode_Token:
					tmp = ParseToken(token.str(), function_name);
					args.emplace_back(tmp);
					break;
			}

			break;
		} else if (chr == ' ') {
			switch (mode) {
				case ParseMode_Function:
					// End of function token
					function_name = Utils::LowerCase(token.str());
					if (function_name.empty()) {
						// empty function name
						Output::Warning("Empty DynRPG function name");
						return {};
					}
					token.str("");

					mode = ParseMode_WaitForArg;
					break;
				case ParseMode_WaitForComma:
				case ParseMode_WaitForArg:
					// no-op
					break;
				case ParseMode_String:
					token << chr;
					break;
				case ParseMode_Token:
					// Skip whitespace
					break;
			}
		} else if (chr == ',') {
			switch (mode) {
				case ParseMode_Function:
					// End of function token
					function_name = Utils::LowerCase(token.str());
					if (function_name.empty()) {
						// empty function name
						Output::Warning("Empty DynRPG function name");
						return {};
					}
					token.str("");
					// Empty arg
					args.emplace_back("");
					mode = ParseMode_WaitForArg;
					break;
				case ParseMode_WaitForComma:
					mode = ParseMode_WaitForArg;
					break;
				case ParseMode_WaitForArg:
					// Empty arg
					args.emplace_back("");
					break;
				case ParseMode_String:
					token << chr;
					break;
				case ParseMode_Token:
					tmp = ParseToken(token.str(), function_name);
					args.emplace_back(tmp);
					// already on a comma
					mode = ParseMode_WaitForArg;
					token.str("");
					break;
			}
		} else {
			// Anything else that isn't special purpose
			switch (mode) {
				case ParseMode_Function:
					token << chr;
					break;
				case ParseMode_WaitForComma:
					Output::Warning("{}: Expected \",\", got token", function_name);
					return {};
				case ParseMode_WaitForArg:
					if (chr == '"') {
						mode = ParseMode_String;
						// begin of string
					}
					else {
						mode = ParseMode_Token;
						token << chr;
					}
					break;
				case ParseMode_String:
					if (chr == '"') {
						// Test for "" -> append "
						// otherwise end of string
						if (std::distance(text_index, end) > 1 && *std::next(text_index, 1) == '"') {
							token << '"';
							++text_index;
						}
						else {
							// End of string
							args.emplace_back(token.str());

							mode = ParseMode_WaitForComma;
							token.str("");
						}
					}
					else {
						token << chr;
					}
					break;
				case ParseMode_Token:
					token << chr;
					break;
			}
		}

		++text_index;
	}

	return function_name;
}

bool Game_DynRpg::Invoke(std::string_view command, Game_Interpreter* interpreter) {
	InitPlugins();

	std::vector<std::string> args;
	std::string function_name = DynRpg::ParseCommand(ToString(command), args);

	if (function_name.empty()) {
		return true;
	}

	return Invoke(function_name, args, interpreter);
}

bool Game_DynRpg::Invoke(std::string_view func, dyn_arg_list args, Game_Interpreter* interpreter) {
	InitPlugins();

	bool yield = false;

	for (auto& plugin: plugins) {
		if (plugin->Invoke(func, args, yield, interpreter)) {
			return !yield;
		}
	}

	Output::Warning("Unsupported DynRPG function: {}", func);
	return true;
}

std::string get_filename(int slot) {
	auto fs = FileFinder::Save();

	std::string filename = std::string("Save") + (slot <= 9 ? "0" : "") + std::to_string(slot) + ".dyn";

	std::string found = fs.FindFile(filename);

	if (found.empty()) {
		found = filename;
	}

	return found;
}

void Game_DynRpg::Load(int slot) {
	if (!Player::IsPatchDynRpg()) {
		return;
	}

	InitPlugins();

	std::string filename = get_filename(slot);

	auto in = FileFinder::Save().OpenInputStream(filename);

	if (!in) {
		Output::Warning("Couldn't read DynRPG save: {}", filename);
	}

	std::vector<uint8_t> in_buffer;
	in_buffer.resize(8);

	in.read((char*)in_buffer.data(), 8);

	if (strncmp((char*)in_buffer.data(), "DYNSAVE1", 8) != 0) {
		Output::Warning("Corrupted DynRPG save: {}", filename);
		return;
	}

	while (!(in.eof() || in.fail())) {
		// Read header length followed by header (Plugin Identifier)

		uint32_t len;
		in.read((char *) &len, 4);
		Utils::SwapByteOrder(len);

		in_buffer.resize(len);
		in.read((char*)in_buffer.data(), len);

		// Find a plugin that feels responsible
		bool have_one = false;

		for (auto &plugin : plugins) {
			if (strncmp((char*)in_buffer.data(), plugin->GetIdentifier().data(), len) == 0) {
				// Chunk length
				in.read((char *) &len, 4);
				Utils::SwapByteOrder(len);

				if (len > 0) {
					// Read chunk
					in_buffer.resize(len);
					in.read((char*)in_buffer.data(), len);

					plugin->Load(in_buffer);
				}

				have_one = true;
				break;
			}
		}

		if (!have_one) {
			// Skip this chunk, no plugin found
			in.read((char *) &len, 4);
			Utils::SwapByteOrder(len);

			in.seekg(len, std::ios::cur);
		}
	}
}

void Game_DynRpg::Save(int slot) {
	if (!Player::IsPatchDynRpg()) {
		return;
	}

	InitPlugins();

	std::string filename = get_filename(slot);

	auto out = FileFinder::Save().OpenOutputStream(filename);

	if (!out) {
		Output::Warning("Couldn't write DynRPG save: {}", filename);
		return;
	}

	std::string header = "DYNSAVE1";

	out.write(header.c_str(), 8);

	for (auto &plugin : plugins) {
		uint32_t len = plugin->GetIdentifier().size();
		Utils::SwapByteOrder(len);

		out.write((char*)&len, 4);
		out.write(plugin->GetIdentifier().data(), len);

		std::vector<uint8_t> data = plugin->Save();
		len = data.size();
		Utils::SwapByteOrder(len);

		out.write((char*)&len, 4);
		out.write((char*)data.data(), data.size());
	}
}

void Game_DynRpg::Update() {
	for (auto& plugin : plugins) {
		plugin->Update();
	}
}


/*end of file .\game_dynrpg.cpp*/

/*start of file .\game_enemy.cpp*/

/* ... license chunk ... */

// Headers
#include <cmath>
#include <algorithm>
#include <lcf/data.h>
#include <lcf/rpg/enemy.h>
#include "game_battle.h"
#include "game_enemy.h"
#include "game_party.h"
#include "game_switches.h"
#include <lcf/reader_util.h>
#include "output.h"
#include "utils.h"
#include "player.h"
#include "attribute.h"
#include "rand.h"

Game_Enemy::Game_Enemy(const lcf::rpg::TroopMember* member)
	: troop_member(member)
{
	if (troop_member == nullptr) {
		return;
	}
	Transform(troop_member->enemy_id);

	hp = GetMaxHp();
	sp = GetMaxSp();
	ResetBattle();

	SetHidden(troop_member->invisible);
	SetBattlePosition(GetOriginalPosition());
}

int Game_Enemy::MaxHpValue() const {
	auto& val = lcf::Data::system.easyrpg_max_enemy_hp;
	if (val == -1) {
		return Player::IsRPG2k() ? 9999 : 99999;
	}
	return val;
}

int Game_Enemy::MaxSpValue() const {
	auto& val = lcf::Data::system.easyrpg_max_enemy_sp;
	if (val == -1) {
		return 9999;
	}
	return val;
}

int Game_Enemy::MaxStatBattleValue() const {
	auto& val = lcf::Data::system.easyrpg_max_stat_battle_value;
	if (val == -1) {
		return 9999;
	}
	return val;
}

int Game_Enemy::MaxStatBaseValue() const {
	auto& val = lcf::Data::system.easyrpg_max_stat_base_value;
	if (val == -1) {
		return 999;
	}
	return val;
}

int Game_Enemy::GetStateProbability(int state_id) const {
	int rate = 1; // Enemies have only B as the default state rank

	if (state_id >= 1 && state_id <= (int)enemy->state_ranks.size()) {
		rate = enemy->state_ranks[state_id - 1];
	}

	return GetStateRate(state_id, rate);
}

int Game_Enemy::GetBaseAttributeRate(int attribute_id) const {
	int rate = 2; // C - default

	if (attribute_id >= 1 && attribute_id <= (int)enemy->attribute_ranks.size()) {
		rate = enemy->attribute_ranks[attribute_id - 1];
	}

	return rate;
}

bool Game_Enemy::IsImmuneToAttributeDownshifts() const {
	return enemy->easyrpg_immune_to_attribute_downshifts;
}

int Game_Enemy::SetHp(int _hp) {
	hp = Utils::Clamp(_hp, 0, GetMaxHp());
	return hp;
}

int Game_Enemy::SetSp(int _sp) {
	sp = Utils::Clamp(_sp, 0, GetMaxSp());
	return sp;
}

Point Game_Enemy::GetOriginalPosition() const {
	return { troop_member->x, troop_member->y };
}

static lcf::rpg::Enemy makeDummyEnemy() {
	lcf::rpg::Enemy enemy;
	enemy.ID = 1;
	return enemy;
}

void Game_Enemy::Transform(int new_enemy_id) {
	enemy = lcf::ReaderUtil::GetElement(lcf::Data::enemies, new_enemy_id);

	if (!enemy) {
		// Some games (e.g. Battle 5 in Embric) have invalid monsters in the battle.
		// This case will fail in RPG Maker and the game will exit with an error message.
		// Create a warning instead and continue the battle.
		Output::Warning("Invalid enemy ID {}", new_enemy_id);
		// This generates an invisible monster with 0 HP
		static auto dummy = makeDummyEnemy();
		enemy = &dummy;
	}

	auto* sprite = GetEnemyBattleSprite();
	if (sprite) {
		sprite->Refresh();
	}
}

int Game_Enemy::GetHitChance(Weapon) const {
	if (enemy->easyrpg_hit != -1) {
		return enemy->easyrpg_hit;
	} else {
		return enemy->miss ? 70 : 90;
	}
}

float Game_Enemy::GetCriticalHitChance(Weapon) const {
	return enemy->critical_hit ? (1.0f / enemy->critical_hit_chance) : 0.0f;
}

bool Game_Enemy::HasAttackAll(Weapon) const {
	return enemy->easyrpg_attack_all;
}

bool Game_Enemy::AttackIgnoresEvasion(Weapon) const {
	return enemy->easyrpg_ignore_evasion;
}

bool Game_Enemy::PreventsCritical() const {
	return enemy->easyrpg_prevent_critical;
}

bool Game_Enemy::HasPhysicalEvasionUp() const {
	return enemy->easyrpg_raise_evasion;
}

int Game_Enemy::GetFlyingOffset() const {
	// 2k does not support flying, albeit mentioned in the help file
	if (!Player::IsRPG2k3() || !IsFlying()) {
		return 0;
	}

	const auto frame = GetBattleFrameCounter();
	auto offset = Utils::RoundTo<int>(std::sin(2 * M_PI * static_cast<double>(frame) / 256.0) * 4.0);
	return offset;
}

void Game_Enemy::UpdateBattle() {
	if (blink_timer > 0) --blink_timer;
	if (death_timer > 0) --death_timer;
	if (explode_timer > 0) --explode_timer;

	Game_Battler::UpdateBattle();
}

void Game_Enemy::ResetBattle() {
	Game_Battler::ResetBattle();

	blink_timer = 0;
	death_timer = 0;
	explode_timer = 0;
}


/*end of file .\game_enemy.cpp*/

/*start of file .\game_enemyparty.cpp*/

/* ... license chunk ... */

// Headers
#include <cassert>
#include <algorithm>
#include "game_interpreter.h"
#include "game_enemyparty.h"
#include "game_runtime_patches.h"
#include "main_data.h"
#include <lcf/reader_util.h>
#include "utils.h"
#include "output.h"
#include "rand.h"

Game_EnemyParty::Game_EnemyParty() {
}

Game_Enemy* Game_EnemyParty::GetEnemy(int idx) {
	if (idx >= 0 && idx < static_cast<int>(enemies.size())) {
		return &enemies[idx];
	}
	return nullptr;
}

Game_Enemy& Game_EnemyParty::operator[] (const int index) {
	if (index < 0 || index >= (int)enemies.size()) {
		assert(false && "Subscript out of range");
	}

	return enemies[index];
}

int Game_EnemyParty::GetBattlerCount() const {
	return static_cast<int>(enemies.size());
}

int Game_EnemyParty::GetVisibleBattlerCount() const {
	int visible = 0;
	for (const auto& enemy: enemies) {
		visible += !enemy.IsHidden();
	}
	return visible;
}

void Game_EnemyParty::ResetBattle(int battle_troop_id) {
	enemies.clear();
	const auto* troop = lcf::ReaderUtil::GetElement(lcf::Data::troops, battle_troop_id);
	if (!troop) {
		// Valid case when battle quits
		return;
	}

	int non_hidden = static_cast<int>(troop->members.size());
	for (const auto& mem : troop->members) {
		enemies.emplace_back(&mem);
		non_hidden -= enemies.back().IsHidden();
	}

	if (troop->appear_randomly) {
		for (auto& enemy: enemies) {
			if (non_hidden <= 1) {
				// At least one party member must be visible
				break;
			}
			if (enemy.IsHidden()) {
				continue;
			}

			if (Rand::PercentChance(40)) {
				enemy.SetHidden(true);
				--non_hidden;
			}
		}
	}
}

std::vector<Game_Enemy*> Game_EnemyParty::GetEnemies() {
	std::vector<Game_Enemy*> party;
	party.reserve(enemies.size());
	for (auto& e: enemies) {
		party.push_back(&e);
	}
	return party;
}


int Game_EnemyParty::GetExp() const {
	int sum = 0;
	for (auto& enemy: enemies) {
		if (enemy.IsDead()) {
			auto exp = enemy.GetExp();
			RuntimePatches::MonSca::ModifyExpGained(enemy, exp);

			sum += exp;
		}
	}
	return sum;
}

int Game_EnemyParty::GetMoney() const {
	int sum = 0;
	for (auto& enemy: enemies) {
		if (enemy.IsDead()) {
			auto money = enemy.GetMoney();
			RuntimePatches::MonSca::ModifyMoneyGained(enemy, money);

			sum += money;
		}
	}
	return sum;
}

void Game_EnemyParty::GenerateDrops(std::vector<int>& out) const {
	for (auto& enemy: enemies) {
		if (enemy.IsDead()) {
			auto drop_id = enemy.GetDropId();
			RuntimePatches::MonSca::ModifyItemGained(enemy, drop_id);

			// Only roll if the enemy has something to drop
			if (drop_id > 0) {
				auto drop_rate = enemy.GetDropProbability();
				RuntimePatches::MonSca::ModifyItemDropRate(enemy, drop_rate);

				if (Rand::ChanceOf(drop_rate, 100)) {
					out.push_back(drop_id);
				}
			}
		}
	}
}

int Game_EnemyParty::GetEnemyPositionInParty(const Game_Enemy* enemy) const {
	if (enemy >= enemies.data() && enemy < enemies.data() + enemies.size()) {
		return enemy - enemies.data();
	}
	return -1;
}


/*end of file .\game_enemyparty.cpp*/

/*start of file .\game_event.cpp*/

/* ... license chunk ... */

// Headers
#include "game_event.h"
#include "game_actor.h"
#include "game_actors.h"
#include "game_map.h"
#include "game_message.h"
#include "game_party.h"
#include "game_player.h"
#include "game_switches.h"
#include "game_variables.h"
#include "game_system.h"
#include "game_interpreter_map.h"
#include "main_data.h"
#include "player.h"
#include "utils.h"
#include "rand.h"
#include "output.h"
#include <cmath>
#include <cassert>

Game_Event::Game_Event(int map_id, const lcf::rpg::Event* event) :
	Game_EventBase(Event),
	event(event)
{
	data()->ID = event->ID;
	SetMapId(map_id);
	SetX(event->x);
	SetY(event->y);

	RefreshPage();
}

void Game_Event::SanitizeData() {
	std::string_view name = event->name;
	Game_Character::SanitizeData(name);
	if (page != nullptr) {
		SanitizeMoveRoute(name, page->move_route, data()->original_move_route_index, "original_move_route_index");
	}
}

void Game_Event::SetSaveData(lcf::rpg::SaveMapEvent save)
{
	// 2k Savegames have 0 for the mapid for compatibility with RPG_RT.
	auto map_id = GetMapId();
	*data() = std::move(save);

	data()->ID = event->ID;
	SetMapId(map_id);

	SanitizeData();

	if (!data()->active || page == nullptr) {
		return;
	}

	if (interpreter) {
		interpreter->Clear();
	}

	if (GetTrigger() == lcf::rpg::EventPage::Trigger_parallel) {
		auto& state = data()->parallel_event_execstate;
		// RPG_RT Savegames have empty stacks for parallel events.
		// We are LSD compatible but don't load these into interpreter.
		bool has_state = (!state.stack.empty() && !state.stack.front().commands.empty());
		// If the page changed before save but the event never updated,
		// there will be not stack but we still need to create an interpreter
		// for the event page commands.
		if (has_state || !page->event_commands.empty()) {
			if (!interpreter) {
				interpreter.reset(new Game_Interpreter_Map());
			}
		}

		if (has_state) {
			interpreter->SetState(state);
		}
	}
}

lcf::rpg::SaveMapEvent Game_Event::GetSaveData() const {
	auto save = *data();

	lcf::rpg::SaveEventExecState state;
	if (page && page->trigger == lcf::rpg::EventPage::Trigger_parallel) {
		if (interpreter) {
			state = interpreter->GetSaveState();
		}

		if (state.stack.empty() && page->event_commands.empty()) {
			// RPG_RT always stores an empty stack frame for empty parallel events.
			lcf::rpg::SaveEventExecFrame frame;
			frame.event_id = GetId();
			state.stack.push_back(std::move(frame));
		}
	}
	save.parallel_event_execstate = std::move(state);

	return save;
}

Drawable::Z_t Game_Event::GetScreenZ(int x_offset, int y_offset) const {
	// Lowest 16 bit are reserved for the ID
	// See base function for full explanation
	return Game_Character::GetScreenZ(x_offset, y_offset) + GetId();
}

int Game_Event::GetOriginalMoveRouteIndex() const {
	return data()->original_move_route_index;
}

void Game_Event::SetOriginalMoveRouteIndex(int new_index) {
	data()->original_move_route_index = new_index;
}

void Game_Event::ClearWaitingForegroundExecution() {
	data()->waiting_execution = false;
}

static bool CompareMoveRouteCommandCodes(const lcf::rpg::MoveRoute& l, const lcf::rpg::MoveRoute& r) {
	auto& lmc = l.move_commands;
	auto& rmc = r.move_commands;
	if (lmc.size() != rmc.size()) {
		return false;
	}

	for (size_t i = 0; i < lmc.size(); ++i) {
		if (lmc[i].command_id != rmc[i].command_id) {
			return false;
		}
	}
	return true;
}

void Game_Event::RefreshPage() {
	const lcf::rpg::EventPage* new_page = nullptr;
	for (auto i = event->pages.crbegin(); i != event->pages.crend(); ++i) {
		// Loop in reverse order to see whether any page meets conditions...
		if (AreConditionsMet(*i)) {
			new_page = &(*i);
			// Stop looking for more...
			break;
		}
	}

	if (!new_page) {
		ClearWaitingForegroundExecution();
		SetPaused(false);
		SetThrough(true);
		this->page = new_page;
		return;
	}

	if (new_page == this->page) {
		return;
	}

	ClearWaitingForegroundExecution();
	SetPaused(false);
	const auto* old_page = page;
	page = new_page;

	SetSpriteGraphic(ToString(page->character_name), page->character_index);

	if (IsStopping()
			&& (!old_page
				|| old_page->character_direction != new_page->character_direction
				|| old_page->character_pattern != new_page->character_pattern))
	{
		SetFacing(page->character_direction);
		SetDirection(page->character_direction);
	}

	// This fixes a load game bug in RPG_RT where if you save and load while an event
	// has an active move route, it's frequency gets set to zero after the move route ends.
	original_move_frequency = page->move_frequency;

	SetTransparency(page->translucent ? 3 : 0);
	SetMoveFrequency(page->move_frequency);
	SetLayer(page->layer);
	data()->overlap_forbidden = page->overlap_forbidden;
	SetAnimationType(static_cast<lcf::rpg::EventPage::AnimType>(page->animation_type));
	SetMoveSpeed(page->move_speed);

	if (IsFacingLocked()) {
		SetFacing(page->character_direction);
	}

	if (GetAnimationType() == lcf::rpg::EventPage::AnimType_fixed_graphic
			|| GetAnimationType() == lcf::rpg::EventPage::AnimType_spin) {
		SetAnimFrame(page->character_pattern);
	}

	if (page->move_type == lcf::rpg::EventPage::MoveType_random) {
		SetMaxStopCountForRandom();
	} else if (page->move_type == lcf::rpg::EventPage::MoveType_custom) {
		SetMaxStopCountForTurn();
	} else {
		SetMaxStopCountForStep();
	}

	// When the page is being changed, RPG_RT will not reset the original move route index
	// if the move routes of the old page and the new page have the same size and all their command codes are the same.
	// To clarify, other move route command parameters such as switch_id etc... are not considered in the comparison!
	if (!old_page || !CompareMoveRouteCommandCodes(old_page->move_route, new_page->move_route)) {
		SetOriginalMoveRouteIndex(0);
	}

	ResetThrough();

	if (GetTrigger() == lcf::rpg::EventPage::Trigger_parallel) {
		if (!page->event_commands.empty()) {
			if (!interpreter) {
				interpreter.reset(new Game_Interpreter_Map());
			}
			// RPG_RT will wait until the next call to Update() to push the interpreter code.
			// This forces the interpreter to yield when it changes it's own page.
		}
	}

	if (interpreter) {
		interpreter->Clear();
	}
}

bool Game_Event::AreConditionsMet(const lcf::rpg::EventPage& page) {
	// First switch (A)
	if (page.condition.flags.switch_a && !Main_Data::game_switches->Get(page.condition.switch_a_id)) {
		return false;
	}

	// Second switch (B)
	if (page.condition.flags.switch_b && !Main_Data::game_switches->Get(page.condition.switch_b_id)) {
		return false;
	}

	// Variable
	if (Player::IsRPG2k()) {
		if (page.condition.flags.variable && !(Main_Data::game_variables->Get(page.condition.variable_id) >= page.condition.variable_value)) {
			return false;
		}
	} else {
		if (page.condition.flags.variable && page.condition.compare_operator >= 0 && page.condition.compare_operator <= 5) {
			if (!Game_Interpreter_Shared::CheckOperator(Main_Data::game_variables->Get(page.condition.variable_id), page.condition.variable_value, page.condition.compare_operator))
				return false;
		}
	}

	// Item in possession?
	if (page.condition.flags.item && !(Main_Data::game_party->GetItemCount(page.condition.item_id)
		+ Main_Data::game_party->GetEquippedItemCount(page.condition.item_id))) {
			return false;
	}

	// Actor in party?
	if (page.condition.flags.actor) {
		if (!Main_Data::game_party->IsActorInParty(page.condition.actor_id)) {
			return false;
		}
	}

	// Timer
	if (page.condition.flags.timer) {
		int secs = Main_Data::game_party->GetTimerSeconds(Main_Data::game_party->Timer1);
		if (secs > page.condition.timer_sec)
			return false;
	}

	// Timer2
	if (page.condition.flags.timer2 && Player::IsRPG2k3Commands()) {
		int secs = Main_Data::game_party->GetTimerSeconds(Main_Data::game_party->Timer2);
		if (secs > page.condition.timer2_sec)
			return false;
	}

	// All conditions met :D
	return true;
}

int Game_Event::GetId() const {
	return data()->ID;
}

std::string_view Game_Event::GetName() const {
	return event->name;
}

bool Game_Event::IsWaitingForegroundExecution() const {
	return data()->waiting_execution;
}

bool Game_Event::WasStartedByDecisionKey() const {
	return data()->triggered_by_decision_key;
}

lcf::rpg::EventPage::Trigger Game_Event::GetTrigger() const {
	int trigger = page ? page->trigger : -1;
	return static_cast<lcf::rpg::EventPage::Trigger>(trigger);
}


bool Game_Event::ScheduleForegroundExecution(bool by_decision_key, bool face_player) {
	// RPG_RT always resets this everytime this function is called, whether successful or not
	data()->triggered_by_decision_key = by_decision_key;

	auto& list = GetList();
	if (!IsActive() || IsWaitingForegroundExecution() || list.empty()) {
		return false;
	}

	if (face_player && !(IsFacingLocked() || IsSpinning())) {
		SetFacing(GetDirectionToCharacter(GetPlayer()));
	}

	data()->waiting_execution = true;
	SetPaused(true);

	return true;
}

static std::vector<lcf::rpg::EventCommand> _empty_list = {};

const std::vector<lcf::rpg::EventCommand>& Game_Event::GetList() const {
	return page ? page->event_commands : _empty_list;
}

void Game_Event::OnFinishForegroundEvent() {
	UpdateFacing();
	SetPaused(false);
}

bool Game_Event::CheckEventAutostart() {
	if (GetTrigger() == lcf::rpg::EventPage::Trigger_auto_start) {
		ScheduleForegroundExecution(false, false);
		return true;
	}
	return false;
}

bool Game_Event::CheckEventCollision() {
	if (GetTrigger() == lcf::rpg::EventPage::Trigger_collision
			&& GetLayer() != lcf::rpg::EventPage::Layers_same
			&& !Main_Data::game_player->IsMoveRouteOverwritten()
			&& !Game_Map::GetInterpreter().IsRunning()
			&& Main_Data::game_player->GetX() == GetX()
			&& Main_Data::game_player->GetY() == GetY())
	{
		ScheduleForegroundExecution(false, true);
		SetStopCount(0);
		return true;
	}
	return false;
}

void Game_Event::CheckCollisonOnMoveFailure() {
	if (Game_Map::GetInterpreter().IsRunning()) {
		return;
	}

	const auto front_x = Game_Map::XwithDirection(GetX(), GetDirection());
	const auto front_y = Game_Map::YwithDirection(GetY(), GetDirection());

	if (Main_Data::game_player->GetX() == front_x
			&& Main_Data::game_player->GetY() == front_y
			&& GetLayer() == lcf::rpg::EventPage::Layers_same
			&& GetTrigger() == lcf::rpg::EventPage::Trigger_collision)
	{
		ScheduleForegroundExecution(false, true);
		// Events with trigger collision and layer same always reset their
		// stop_count when they fail movement to a tile that the player inhabits.
		SetStopCount(0);
	}
}

bool Game_Event::Move(int dir) {
	Game_Character::Move(dir);
	if (IsStopping()) {
		CheckCollisonOnMoveFailure();
		return false;
	}
	return true;
}

void Game_Event::UpdateNextMovementAction() {
	if (!page) {
		return;
	}

	UpdateMoveRoute(data()->move_route_index, data()->move_route, true);

	CheckEventAutostart();

	if (!IsStopping()) {
		return;
	}

	CheckEventCollision();

	if (!page
			|| IsPaused()
			|| IsMoveRouteOverwritten()
			|| IsStopCountActive()
			|| (!Main_Data::game_system->GetMessageContinueEvents() && Game_Map::GetInterpreter().IsRunning()))
	{
		return;
	}

	switch (page->move_type) {
	case lcf::rpg::EventPage::MoveType_stationary:
		break;
	case lcf::rpg::EventPage::MoveType_random:
		MoveTypeRandom();
		break;
	case lcf::rpg::EventPage::MoveType_vertical:
		MoveTypeCycleUpDown();
		break;
	case lcf::rpg::EventPage::MoveType_horizontal:
		MoveTypeCycleLeftRight();
		break;
	case lcf::rpg::EventPage::MoveType_toward:
		MoveTypeTowardsPlayer();
		break;
	case lcf::rpg::EventPage::MoveType_away:
		MoveTypeAwayFromPlayer();
		break;
	case lcf::rpg::EventPage::MoveType_custom:
		UpdateMoveRoute(data()->original_move_route_index, page->move_route, false);
		break;
	}
}

void Game_Event::SetMaxStopCountForRandom() {
	auto st = GetMaxStopCountForStep(GetMoveFrequency());
	st *= Rand::GetRandomNumber(0, 3) + 3;
	st /= 5;
	SetMaxStopCount(st);
}

void Game_Event::MoveTypeRandom() {
	int draw = Rand::GetRandomNumber(0, 9);

	const auto prev_dir = GetDirection();

	if (draw < 3) {
	} else if (draw < 5) {
		Turn90DegreeLeft();
	} else if (draw < 7) {
		Turn90DegreeRight();
	} else if (draw < 8) {
		Turn180Degree();
	} else {
		SetStopCount(Rand::GetRandomNumber(0, GetMaxStopCount()));
		return;
	}

	Move(GetDirection());

	if (IsStopping()) {
		if (IsWaitingForegroundExecution() || (GetStopCount() >= GetMaxStopCount() + 60)) {
			SetStopCount(0);
		} else {
			SetDirection(prev_dir);
			if (!IsFacingLocked()) {
				SetFacing(prev_dir);
			}
		}
	}

	SetMaxStopCountForRandom();
}

void Game_Event::MoveTypeCycle(int default_dir) {
	if (GetStopCount() < GetMaxStopCount()) return;

	const auto prev_dir = GetDirection();

	const auto reverse_dir = ReverseDir(default_dir);
	int move_dir = GetDirection();
	if (move_dir != reverse_dir) {
		move_dir = default_dir;
	}

	Move(move_dir);

	if (IsStopping() && GetStopCount() >= GetMaxStopCount() + 20) {
		Move(ReverseDir(move_dir));
	}

	if (IsStopping()) {
		if (IsWaitingForegroundExecution() || (GetStopCount() >= GetMaxStopCount() + 60)) {
			SetStopCount(0);
		} else {
			SetDirection(prev_dir);
			if (!IsFacingLocked()) {
				SetFacing(prev_dir);
			}
		}
	}

	SetMaxStopCountForStep();
}

void Game_Event::MoveTypeCycleLeftRight() {
	MoveTypeCycle(Right);
}

void Game_Event::MoveTypeCycleUpDown() {
	MoveTypeCycle(Down);
}

void Game_Event::MoveTypeTowardsOrAwayPlayer(bool towards) {
	int sx = GetScreenX();
	int sy = GetScreenY();

	constexpr int offset = TILE_SIZE * 2;

	const bool in_sight = (sx >= -offset && sx <= Player::screen_width + offset
			&& sy >= -offset && sy <= Player::screen_height + offset);

	const auto prev_dir = GetDirection();

	int dir = 0;
	if (!in_sight) {
		dir = Rand::GetRandomNumber(0, 3);
	} else {
		int draw = Rand::GetRandomNumber(0, 9);
		if (draw == 0) {
			dir = GetDirection();
		} else if(draw == 1) {
			dir = Rand::GetRandomNumber(0, 3);
		} else {
			dir = towards
				? GetDirectionToCharacter(GetPlayer())
				: GetDirectionAwayCharacter(GetPlayer());
		}
	}

	Move(dir);

	if (IsStopping()) {
		if (IsWaitingForegroundExecution() || (GetStopCount() >= GetMaxStopCount() + 60)) {
			SetStopCount(0);
		} else {
			SetDirection(prev_dir);
			if (!IsFacingLocked()) {
				SetFacing(prev_dir);
			}
		}
	}

	SetMaxStopCountForStep();
}

void Game_Event::MoveTypeTowardsPlayer() {
	MoveTypeTowardsOrAwayPlayer(true);
}

void Game_Event::MoveTypeAwayFromPlayer() {
	MoveTypeTowardsOrAwayPlayer(false);
}

AsyncOp Game_Event::Update(bool resume_async) {
	if (!data()->active || (!resume_async && page == NULL)) {
		return {};
	}

	// RPG_RT runs the parallel interpreter everytime Update is called.
	// That means if the event updates multiple times due to makeway,
	// the interpreter will run multiple times per frame.
	// This results in event waits to finish quicker during collisions as
	// the wait will tick by 1 each time the interpreter is invoked.
	if ((resume_async || GetTrigger() == lcf::rpg::EventPage::Trigger_parallel) && interpreter) {
		if (!interpreter->IsRunning() && page && !page->event_commands.empty()) {
			interpreter->Push<InterpreterExecutionType::Parallel>(this);
		}
		interpreter->Update(!resume_async);

		// Suspend due to async op ...
		if (interpreter->IsAsyncPending()) {
			return interpreter->GetAsyncOp();
		}

		// RPG_RT only exits if active is false here, but not if there is
		// no active page...
		if (!data()->active) {
			return {};
		}
	}

	Game_Character::Update();

	return {};
}

const lcf::rpg::EventPage* Game_Event::GetPage(int page) const {
	if (page <= 0 || page - 1 >= static_cast<int>(event->pages.size())) {
		return nullptr;
	}
	return &event->pages[page - 1];
}

const lcf::rpg::EventPage *Game_Event::GetActivePage() const {
	return page;
}



/*end of file .\game_event.cpp*/

/*start of file .\game_ineluki.cpp*/

/* ... license chunk ... */

// Headers
#include "game_ineluki.h"
#include "async_handler.h"
#include "filefinder.h"
#include "utils.h"
#include "output.h"
#include "audio.h"
#include "input.h"
#include "player.h"
#include "system.h"

#include <lcf/inireader.h>

namespace {
#if defined(SUPPORT_KEYBOARD)
	void mask_kb(bool mask) {
		constexpr std::array<Input::Keys::InputKey, 4> keys = {
				Input::Keys::W,
				Input::Keys::S,
				Input::Keys::A,
				Input::Keys::D
		};

		auto keymask = Input::GetMask();
		for (auto k : keys) {
			keymask[k] = mask;
		}
		Input::SetMask(keymask);
	}
#endif
}

Game_Ineluki::~Game_Ineluki() {
#if defined(SUPPORT_KEYBOARD)
	if (key_support) {
		mask_kb(false);
	}
#endif
}

bool Game_Ineluki::Execute(const lcf::rpg::Sound& se) {
	if (Utils::LowerCase(se.name) == "saves.script") {
		// Support for the script written by SaveCount.dat
		// It counts the amount of savegames and outputs the result
		output_mode = OutputMode::Output;
		output_list.push_back(FileFinder::GetSavegames());
		return true;
	}

	std::string ini_file = FileFinder::FindSound(se.name);
	if (!ini_file.empty()) {
		return Execute(ini_file);
	} else {
		Output::Debug("Ineluki: Script {} not found", se.name);
	}
	return false;
}

bool Game_Ineluki::Execute(std::string_view ini_file) {
	auto ini_file_s = ToString(ini_file);

	if (functions.find(ini_file_s) == functions.end()) {
		if (!Parse(ini_file)) {
			return false;
		}
	}

	for (const auto& cmd : functions[ini_file_s]) {
		//Output::Debug("Ineluki {} {}", cmd.name, cmd.arg);

		if (cmd.name == "writetolog") {
			Output::InfoStr(cmd.arg);
		} else if (cmd.name == "execprogram") {
			// Fake execute some known programs
			if (StartsWith(cmd.arg, "exitgame") ||
					StartsWith(cmd.arg, "taskkill")) {
				Player::exit_flag = true;
			} else if (StartsWith(cmd.arg, "SaveCount.dat")) {
				// no-op, detected through saves.script access
			} else {
				Output::Warning("Ineluki ExecProgram {}: Not supported", cmd.arg);
			}
		} else if (cmd.name == "mcicommand") {
			Output::Warning("Ineluki MciProgram {}: Not supported", cmd.arg);
		} else if (cmd.name == "miditickfunction") {
			std::string arg = Utils::LowerCase(cmd.arg);
			if (arg == "original") {
				output_mode = OutputMode::Original;
			} else if (arg == "output") {
				output_mode = OutputMode::Output;
			} else if (arg == "clear") {
				output_list.clear();
			}
		} else if (cmd.name == "addoutput") {
			output_list.push_back(atoi(cmd.arg.c_str()));
		} else if (cmd.name == "enablekeysupport") {
			bool prev_key_support = key_support;
			key_support = Utils::LowerCase(cmd.arg) == "true";

#if !defined(SUPPORT_KEYBOARD)
			if (key_support) {
				Output::Warning("Ineluki: Keyboard input is not supported on this platform");
			}
#else
			if (prev_key_support != key_support) {
				Output::Debug("Ineluki: Key support is now {}", key_support ? "Enabled" : "Disabled");
			}

			mask_kb(key_support);
#endif
		} else if (cmd.name == "registerkeydownevent") {
			std::string arg_lower = Utils::LowerCase(cmd.arg);
			auto it = std::find_if(key_to_ineluki.begin(), key_to_ineluki.end(), [&](const auto& k) {
				return !strcmp(arg_lower.c_str(), k.name);
			});
			if (it != key_to_ineluki.end()) {
				keylist_down.push_back({it->key, atoi(cmd.arg2.c_str())});
			}
		} else if (cmd.name == "registerkeyupevent") {
			std::string arg_lower = Utils::LowerCase(cmd.arg);
			auto it = std::find_if(key_to_ineluki.begin(), key_to_ineluki.end(), [&](const auto& k) {
				return !strcmp(arg_lower.c_str(), k.name);
			});
			if (it != key_to_ineluki.end()) {
				keylist_up.push_back({it->key, atoi(cmd.arg2.c_str())});
			}
		} else if (cmd.name == "enablemousesupport") {
			bool prev_mouse_support = mouse_support;
			mouse_support = Utils::LowerCase(cmd.arg) == "true";
			mouse_id_prefix = atoi(cmd.arg2.c_str());
			// TODO: automatic (append mouse pos every 500ms) not implemented
#if !defined(USE_MOUSE_OR_TOUCH) || !defined(SUPPORT_MOUSE_OR_TOUCH)
			if (mouse_support) {
				Output::Warning("Ineluki: Mouse input is not supported on this platform");
			}
#endif
			if (prev_mouse_support != mouse_support) {
				Output::Debug("Ineluki: Mouse support is now {}", mouse_support ? "Enabled" : "Disabled");
			}
		} else if (cmd.name == "getmouseposition") {
			if (!mouse_support) {
				return true;
			}

			Point mouse_pos = Input::GetMousePosition();

			bool left = Input::IsPressed(Input::MOUSE_LEFT);
			bool right = Input::IsPressed(Input::MOUSE_RIGHT);
			int key = left && right ? 3 : right ? 2 : left ? 1 : 0;

			output_list.push_back(key);
			output_list.push_back(mouse_pos.y);
			output_list.push_back(mouse_pos.x);
			output_list.push_back(mouse_id_prefix);
		} else if (cmd.name == "setdebuglevel") {
			// no-op
		} else if (cmd.name == "registercheatevent") {
			cheatlist.emplace_back(Utils::LowerCase(cmd.arg), atoi(cmd.arg2.c_str()));
		} else if (cmd.name == "setmouseasreturn") {
			// This command is only found in a few uncommon versions of the patch
			if (!mouse_support) {
				return true;
			}
			std::string arg_lower = Utils::LowerCase(cmd.arg);
			if (arg_lower == "left") {
				mouse_decision_binding = MouseReturnMode::Left;
			} else if (arg_lower == "right") {
				mouse_decision_binding = MouseReturnMode::Right;
			} else if (arg_lower == "both") {
				mouse_decision_binding = MouseReturnMode::Both;
			} else if (arg_lower == "none") {
				mouse_decision_binding = MouseReturnMode::None;
			} else {
				Output::Warning("Ineluki: Invalid value for setMouseAsReturn");
				mouse_decision_binding = MouseReturnMode::None;
			}
		} else if (cmd.name == "setmousewheelaskeys") {
			// This command is only found in a few uncommon versions of the patch
			if (!mouse_support) {
				return true;
			}
			std::string arg_lower = Utils::LowerCase(cmd.arg);
			if (arg_lower == "updown") {
				mouse_wheel_binding = MouseWheelMode::UpDown;
			} else if (arg_lower == "leftright") {
				mouse_wheel_binding = MouseWheelMode::LeftRight;
			} else if (arg_lower == "none") {
				mouse_wheel_binding = MouseWheelMode::None;
			} else {
				Output::Warning("Ineluki: Invalid value for setMouseWheelAsKeys");
				mouse_wheel_binding = MouseWheelMode::None;
			}
		}
	}

	return true;
}

bool Game_Ineluki::ExecuteScriptList(std::string_view list_file) {
	auto is = FileFinder::Game().OpenInputStream(ToString(list_file));
	assert(async_scripts.empty());

	if (!is) {
		return false;
	}

	Output::Debug("Ineluki: Processing script list {}", FileFinder::GetPathInsideGamePath(ToString(list_file)));

	std::string line;
	std::vector<FileRequestAsync*> requests;
	while (Utils::ReadLine(is, line)) {
		if (!line.empty()) {
			FileRequestAsync* request = AsyncHandler::RequestFile(line);
			auto binding = request->Bind(&Game_Ineluki::OnScriptFileReady, this);
			async_scripts.emplace_back(binding, line);
			requests.push_back(request);
		}
	}

	for (auto& r: requests) {
		r->SetImportantFile(true);
		r->Start();
	}

	return true;
}

bool Game_Ineluki::Parse(std::string_view ini_file) {
	auto ini_file_s = ToString(ini_file);

	auto is = FileFinder::Game().OpenInputStream(ini_file_s);
	if (!is) {
		return false;
	}

	lcf::INIReader ini(is);
	if (ini.ParseError() == -1) {
		return false;
	}

	Output::Debug("Ineluki: Parsing script {}", FileFinder::GetPathInsideGamePath(ini_file_s));

	command_list commands;
	std::string section = "execute";

	do {
		InelukiCommand cmd;
		cmd.name = Utils::LowerCase(ini.Get(section, "action", std::string()));
		bool valid = true;

		if (cmd.name == "writetolog") {
			cmd.arg = ini.Get(section, "text", std::string());
		} else if (cmd.name == "execprogram") {
			cmd.arg = ini.Get(section, "command", std::string());
		} else if (cmd.name == "mcicommand") {
			cmd.arg = ini.Get(section, "command", std::string());
		} else if (cmd.name == "miditickfunction") {
			cmd.arg = ini.Get(section, "command", std::string());
			if (cmd.arg.empty()) {
				cmd.arg = ini.Get(section, "value", std::string());
			}
		} else if (cmd.name == "addoutput") {
			cmd.arg = ini.Get(section, "value", std::string());
		} else if (cmd.name == "enablekeysupport") {
			cmd.arg = ini.Get(section, "enable", std::string());
		} else if (cmd.name == "registerkeydownevent") {
			cmd.arg = ini.Get(section, "key", std::string());
			cmd.arg2 = ini.Get(section, "value", std::string());
		} else if (cmd.name == "registerkeyupevent") {
			cmd.arg = ini.Get(section, "key", std::string());
			cmd.arg2 = ini.Get(section, "value", std::string());
		} else if (cmd.name == "enablemousesupport") {
			cmd.arg = ini.Get(section, "enable", std::string());
			cmd.arg2 = ini.Get(section, "id", std::string());
			cmd.arg3 = ini.Get(section, "automatic", std::string());
		} else if (cmd.name == "getmouseposition") {
			// no args
		} else if (cmd.name == "setdebuglevel") {
			cmd.arg = ini.Get(section, "level", std::string());
		} else if (cmd.name == "registercheatevent") {
			cmd.arg = ini.Get(section, "cheat", std::string());
			cmd.arg2 = ini.Get(section, "value", std::string());
		} else if (cmd.name == "setmouseasreturn") {
			cmd.arg = ini.Get(section, "value", std::string());
		} else if (cmd.name == "setmousewheelaskeys") {
			cmd.arg = ini.Get(section, "value", std::string());
		} else {
			Output::Debug("Ineluki: Unknown command {}", cmd.name);
			valid = false;
		}

		if (valid) {
			commands.push_back(cmd);
		}

		section = ini.Get(section, "next", std::string());
	} while (!section.empty());

	functions[ini_file_s] = commands;

	return true;
}

int Game_Ineluki::GetMidiTicks() {
	if (output_mode == OutputMode::Original) {
		return Audio().BGM_GetTicks();
	} else {
		int val = -1;
		if (!output_list.empty()) {
			val = output_list.back();
			output_list.pop_back();
		}
		return val;
	}
}

void Game_Ineluki::Update() {
	if (key_support) {
		UpdateKeys();
	}
	if (mouse_support) {
		UpdateMouse();
	}
}

void Game_Ineluki::UpdateKeys() {
	for (const auto& key : keylist_down) {
		if (Input::IsRawKeyTriggered(key.key)) {
			output_list.push_back(key.value);
		}
	}

	for (const auto& key : keylist_up) {
		if (Input::IsRawKeyReleased(key.key)) {
			output_list.push_back(key.value);
		}
	}

	for (auto& cheat: cheatlist) {
		if (cheat.keys.empty()) {
			continue;
		}

		if (Input::IsRawKeyPressed(cheat.keys[cheat.index])) {
			++cheat.index;
			if (cheat.index >= static_cast<int>(cheat.keys.size())) {
				output_list.push_back(cheat.value);
				cheat.index = 0;
			}
		} else if (cheat.index > 0) {
			auto pressed = Input::GetAllRawPressed();
			// Don't reset when the previous cheat key is (still) pressed
			pressed[cheat.keys[cheat.index - 1]] = false;
			if (pressed.any()) {
				cheat.index = 0;
			}
		}
	}
}

void Game_Ineluki::UpdateMouse() {
#if defined(USE_MOUSE) && defined(SUPPORT_MOUSE)
	if (Input::IsRawKeyTriggered(Input::Keys::MOUSE_LEFT)) {
		if ((mouse_decision_binding == MouseReturnMode::Left || mouse_decision_binding == MouseReturnMode::Both)) {
			Input::SimulateButtonPress(Input::DECISION);
		}
	} else if (Input::IsRawKeyTriggered(Input::Keys::MOUSE_RIGHT)) {
		if ((mouse_decision_binding == MouseReturnMode::Right || mouse_decision_binding == MouseReturnMode::Both)) {
			Input::SimulateButtonPress(Input::DECISION);
		}
	}

	if (Input::IsRawKeyTriggered(Input::Keys::MOUSE_SCROLLUP)) {
		if (mouse_wheel_binding == MouseWheelMode::UpDown) {
			Input::SimulateButtonPress(Input::UP);
		} else if (mouse_wheel_binding == MouseWheelMode::LeftRight) {
			Input::SimulateButtonPress(Input::LEFT);
		}
	} else if (Input::IsRawKeyTriggered(Input::Keys::MOUSE_SCROLLDOWN)) {
		if (mouse_wheel_binding == MouseWheelMode::UpDown) {
			Input::SimulateButtonPress(Input::DOWN);
		} else if (mouse_wheel_binding == MouseWheelMode::LeftRight) {
			Input::SimulateButtonPress(Input::RIGHT);
		}
	}
#endif
}

void Game_Ineluki::OnScriptFileReady(FileRequestResult* result) {
	auto it = std::find_if(async_scripts.begin(), async_scripts.end(), [&](const auto& a) {
		return a.script_name == result->file;
	});
	assert(it != async_scripts.end());
	it->invoked = true;

	if (std::all_of(async_scripts.begin(), async_scripts.end(), [](const auto& a) {
		return a.invoked;
	})) {
		std::for_each(async_scripts.begin(), async_scripts.end(), [this](const auto& a) {
			Execute(FileFinder::Game().FindFile(a.script_name));
		});
		async_scripts.clear();
	}
}

Game_Ineluki::CheatItem::CheatItem(const std::string& code, int value) : value(value) {
	for (char c: code) {
		auto it = std::find_if(key_to_ineluki.begin(), key_to_ineluki.end(), [&](const auto& k) {
			return c == k.name[0];
		});
		if (it != key_to_ineluki.end()) {
			keys.push_back(it->key);
		}
	}
}


/*end of file .\game_ineluki.cpp*/

/*start of file .\game_interpreter.cpp*/

/* ... license chunk ... */

// Headers
#include <algorithm>
#include <ctime>
#include <iomanip>
#include <iostream>
#include <regex>
#include <sstream>
#include <string>
#include <cassert>
#include "game_interpreter.h"
#include "async_handler.h"
#include "game_dynrpg.h"
#include "filefinder.h"
#include "game_destiny.h"
#include "game_map.h"
#include "game_event.h"
#include "game_player.h"
#include "game_targets.h"
#include "game_switches.h"
#include "game_variables.h"
#include "game_party.h"
#include "game_actors.h"
#include "game_strings.h"
#include "game_system.h"
#include "game_message.h"
#include "game_pictures.h"
#include "game_runtime_patches.h"
#include "game_screen.h"
#include "game_interpreter_control_variables.h"
#include "game_windows.h"
#include "json_helper.h"
#include "maniac_patch.h"
#include "spriteset_map.h"
#include "sprite_character.h"
#include "scene_gameover.h"
#include "scene_map.h"
#include "scene_save.h"
#include "scene_settings.h"
#include "scene.h"
#include "game_clock.h"
#include "input.h"
#include "main_data.h"
#include "output.h"
#include "player.h"
#include "util_macro.h"
#include <lcf/reader_util.h>
#include <lcf/lsd/reader.h>
#include <lcf/reader_lcf.h>
#include <lcf/writer_lcf.h>
#include "game_battle.h"
#include "utils.h"
#include "transition.h"
#include "baseui.h"
#include "algo.h"

using namespace Game_Interpreter_Shared;

enum BranchSubcommand {
	eOptionBranchElse = 1
};

Game_Interpreter::Game_Interpreter(bool _main_flag) {
	main_flag = _main_flag;

	Clear();
}

Game_Interpreter::~Game_Interpreter() {
}

// Clear.
void Game_Interpreter::Clear() {
	_state = {};
	_keyinput = {};
	_async_op = {};
}

// Is interpreter running.
bool Game_Interpreter::IsRunning() const {
	return !_state.stack.empty();
}

// Setup.
void Game_Interpreter::PushInternal(
	InterpreterPush push_info,
	std::vector<lcf::rpg::EventCommand> _list,
	int event_id,
	int event_page_id
) {
	if (_list.empty()) {
		return;
	}

	if ((int)_state.stack.size() > call_stack_limit) {
		Output::Error("Call Event limit ({}) has been exceeded", call_stack_limit);
	}

	auto type_ex = std::get<ExecutionType>(push_info);
	auto type_src = std::get<EventType>(push_info);

	lcf::rpg::SaveEventExecFrame frame;
	frame.ID = _state.stack.size() + 1;
	frame.commands = std::move(_list);
	frame.current_command = 0;
	frame.triggered_by_decision_key = type_ex == ExecutionType::Action;
	if (type_src == EventType::MapEvent) {
		frame.event_id = event_id;
	}
	frame.maniac_event_id = event_id;
	frame.maniac_event_page_id = event_page_id;

	if (type_ex <= ExecutionType::BattleParallel) {
		frame.maniac_event_info = static_cast<int>(type_ex);
	}

	if (type_src <= EventType::BattleEvent) {
		frame.maniac_event_info |= (static_cast<int>(type_src) << 4);
	}

	if (_state.stack.empty() && main_flag && !Game_Battle::IsBattleRunning()) {
		Main_Data::game_system->ClearMessageFace();
		Main_Data::game_player->SetMenuCalling(false);
		Main_Data::game_player->SetEncounterCalling(false);
	}

	_state.stack.push_back(std::move(frame));
}


void Game_Interpreter::KeyInputState::fromSave(const lcf::rpg::SaveEventExecState& save) {
	*this = {};

	// Maniac Patch aware check functions for parameters that handle
	// keyboard and mouse through a bitmask
	bool is_maniac = Player::IsPatchManiac();
	auto check_key = [&](auto& var) {
		if (is_maniac) {
			return (var & 1) != 0;
		} else {
			return var != 0;
		}
	};
	auto check_mouse = [&](auto& var) {
		return (var & 2) != 0;
	};

	wait = save.keyinput_wait;
	// FIXME: There is an RPG_RT bug where keyinput_variable is uint8_t
	// which we currently have to emulate. So the value from the save could be wrong.
	variable = save.keyinput_variable;

	if (save.keyinput_all_directions) {
		keys[Keys::eDown] = true;
		keys[Keys::eLeft] = true;
		keys[Keys::eRight] = true;
		keys[Keys::eUp] = true;
	} else {
		if (Player::IsRPG2k3()) {
			keys[Keys::eDown] = check_key(save.keyinput_2k3down);
			keys[Keys::eLeft] = check_key(save.keyinput_2k3left);
			keys[Keys::eRight] = check_key(save.keyinput_2k3right);
			keys[Keys::eUp] = check_key(save.keyinput_2k3up);
		} else {
			keys[Keys::eDown] = check_key(save.keyinput_2kdown_2k3operators);
			keys[Keys::eLeft] = check_key(save.keyinput_2kleft_2k3shift);
			keys[Keys::eRight] = check_key(save.keyinput_2kright);
			keys[Keys::eUp] = check_key(save.keyinput_2kup);
		}
	}

	keys[Keys::eDecision] = check_key(save.keyinput_decision);
	keys[Keys::eCancel] = check_key(save.keyinput_cancel);

	if (Player::IsRPG2k3()) {
		keys[Keys::eShift] = check_key(save.keyinput_2kleft_2k3shift);
		keys[Keys::eNumbers] = check_key(save.keyinput_2kshift_2k3numbers);
		keys[Keys::eOperators] = check_key(save.keyinput_2kdown_2k3operators);

		if (is_maniac) {
			keys[Keys::eMouseLeft] = check_mouse(save.keyinput_decision);
			keys[Keys::eMouseRight] = check_mouse(save.keyinput_cancel);
			keys[Keys::eMouseMiddle] = check_mouse(save.keyinput_2kleft_2k3shift);
			keys[Keys::eMouseScrollUp] = check_mouse(save.keyinput_2k3up);
			keys[Keys::eMouseScrollDown] = check_mouse(save.keyinput_2k3down);
		}
	} else {
		keys[Keys::eShift] = check_key(save.keyinput_2kshift_2k3numbers);
	}

	time_variable = save.keyinput_time_variable;
	timed = save.keyinput_timed;
	// FIXME: Rm2k3 has no LSD chunk for this.
	wait_frames = 0;
}

void Game_Interpreter::KeyInputState::toSave(lcf::rpg::SaveEventExecState& save) const {
	save.keyinput_wait = 0;
	save.keyinput_variable = 0;
	save.keyinput_all_directions = 0;
	save.keyinput_decision = 0;
	save.keyinput_cancel = 0;
	save.keyinput_2kshift_2k3numbers = 0;
	save.keyinput_2kdown_2k3operators = 0;
	save.keyinput_2kleft_2k3shift = 0;
	save.keyinput_2kright = 0;
	save.keyinput_2kup = 0;
	save.keyinput_time_variable = 0;
	save.keyinput_2k3down = 0;
	save.keyinput_2k3left = 0;
	save.keyinput_2k3right = 0;
	save.keyinput_2k3up = 0;
	save.keyinput_timed = 0;

	save.keyinput_wait = wait;
	// FIXME: There is an RPG_RT bug where keyinput_variable is uint8_t
	// which we currently have to emulate. So this assignment truncates.
	save.keyinput_variable = variable;

	if (keys[Keys::eDown]
			&& keys[Keys::eLeft]
			&& keys[Keys::eRight]
			&& keys[Keys::eUp]) {
		save.keyinput_all_directions = true;
	} else {
		if (Player::IsRPG2k3()) {
			save.keyinput_2k3down = keys[Keys::eDown];
			save.keyinput_2k3left = keys[Keys::eLeft];
			save.keyinput_2k3right = keys[Keys::eRight];
			save.keyinput_2k3up = keys[Keys::eUp];
		} else {
			// RM2k uses these chunks for directions.
			save.keyinput_2kdown_2k3operators = keys[Keys::eDown];
			save.keyinput_2kleft_2k3shift = keys[Keys::eLeft];
			save.keyinput_2kright = keys[Keys::eRight];
			save.keyinput_2kup = keys[Keys::eUp];
		}
	}

	save.keyinput_decision = keys[Keys::eDecision];
	save.keyinput_cancel = keys[Keys::eCancel];

	if (Player::IsRPG2k3()) {
		save.keyinput_2kleft_2k3shift = keys[Keys::eShift];
		save.keyinput_2kshift_2k3numbers = keys[Keys::eNumbers];
		save.keyinput_2kdown_2k3operators = keys[Keys::eOperators];

		if (Player::IsPatchManiac()) {
			if (keys[Keys::eMouseLeft]) {
				save.keyinput_decision |= 2;
			}
			if (keys[Keys::eMouseRight]) {
				save.keyinput_cancel |= 2;
			}
			if (keys[Keys::eMouseMiddle]) {
				save.keyinput_2kleft_2k3shift |= 2;
			}
			if (keys[Keys::eMouseScrollUp]) {
				save.keyinput_2k3up |= 2;
			}
			if (keys[Keys::eMouseScrollDown]) {
				save.keyinput_2k3down |= 2;
			}
		}
	} else {
		save.keyinput_2kshift_2k3numbers = keys[Keys::eShift];
	}

	save.keyinput_time_variable = time_variable;
	save.keyinput_timed = timed;
	// FIXME: Rm2k3 has no LSD chunk for this.
	//void = wait_frames;
}


const lcf::rpg::SaveEventExecState& Game_Interpreter::GetState() const {
	return _state;
}

lcf::rpg::SaveEventExecState Game_Interpreter::GetSaveState() {
	auto save = _state;
	_keyinput.toSave(save);
	return save;
}


void Game_Interpreter::SetupWait(int duration) {
	if (duration == 0) {
		// 0.0 waits 1 frame
		_state.wait_time = 1;
	} else {
		_state.wait_time = duration * DEFAULT_FPS / 10;
	}
}

void Game_Interpreter::SetupWaitFrames(int duration) {
	if (duration == 0) {
		// 0.0 waits 1 frame
		_state.wait_time = 1;
	} else {
		_state.wait_time = duration;
	}
}

bool Game_Interpreter::ReachedLoopLimit() const {
	return loop_count >= loop_limit;
}

int Game_Interpreter::GetThisEventId() const {
	auto event_id = GetCurrentEventId();

	if (event_id == 0 && (Player::IsRPG2k3E() || Player::IsPatchCommonThisEvent())) {
		// RM2k3E allows "ThisEvent" commands to run from called
		// common events. It operates on the last map event in
		// the call stack.
		for (auto iter = _state.stack.rbegin()++;
				iter != _state.stack.rend(); ++iter) {
			if (iter->event_id != 0) {
				event_id = iter->event_id;
				break;
			}
		}
	}

	return event_id;
}

uint8_t& Game_Interpreter::ReserveSubcommandIndex(int indent) {
	auto& frame = GetFrame();

	auto& path = frame.subcommand_path;
	if (indent >= (int)path.size()) {
		// This fixes an RPG_RT bug where RPG_RT would resize
		// the array with uninitialized values.
		path.resize(indent + 1, subcommand_sentinel);
	}
	return path[indent];
}

void Game_Interpreter::SetSubcommandIndex(int indent, int idx) {
	ReserveSubcommandIndex(indent) = idx;
}

int Game_Interpreter::GetSubcommandIndex(int indent) const {
	auto* frame = GetFramePtr();
	if (frame == nullptr) {
		return subcommand_sentinel;
	}
	auto& path = frame->subcommand_path;
	if ((int)path.size() <= indent) {
		return subcommand_sentinel;
	}
	return path[indent];
}

// Update
void Game_Interpreter::Update(bool reset_loop_count) {
	if (reset_loop_count) {
		loop_count = 0;
	}

	// Always reset async status when we enter interpreter loop.
	_async_op = {};

	if (!IsRunning()) {
		return;
	}

	if (Input::IsTriggered(Input::DEBUG_ABORT_EVENT) && Player::debug_flag && !Game_Battle::IsBattleRunning()) {
		if (Game_Message::IsMessageActive()) {
			Game_Message::GetWindow()->FinishMessageProcessing();
		}
		if (!Main_Data::game_player->GetMoveRoute().move_commands.empty()) {
			Main_Data::game_player->CancelMoveRoute();
		}
		EndEventProcessing();
		return;
	}

#ifdef ENABLE_DYNAMIC_INTERPRETER_CONFIG
	Player::active_interpreter_flags = &_state.easyrpg_runtime_flags;
	auto flags_guard = lcf::makeScopeGuard([]() {
		Player::active_interpreter_flags = &Player::interpreter_default_flags;
	});
#endif

	for (; loop_count < loop_limit; ++loop_count) {
		// If something is calling a menu, we're allowed to execute only 1 command per interpreter. So we pass through if loop_count == 0, and stop at 1 or greater.
		// RPG_RT compatible behavior.
		if (loop_count > 0 && Scene::instance->HasRequestedScene()) {
			break;
		}

		// Previous command triggered an async operation.
		if (IsAsyncPending()) {
			if (_async_op.GetType() == AsyncOp::Type::eYieldRepeat) {
				// This will cause an incorrect execution when the yielding
				// command changed the index.
				// Only use YieldRepeat for commands that do not do this!
				auto& frame = GetFrame();
				--frame.current_command;
			}
			break;
		}

		if (main_flag) {
			if (Main_Data::game_player->IsBoardingOrUnboarding())
				break;

			if (Main_Data::game_player->InVehicle() && Main_Data::game_player->GetVehicle()->IsAscendingOrDescending())
				break;

			if (Game_Message::IsMessagePending())
				break;
		} else {
			if (Game_Message::IsMessageActive() && _state.show_message) {
				break;
			}
		}

		_state.show_message = false;
		_state.abort_on_escape = false;

		if (_state.wait_time > 0) {
			_state.wait_time--;
			break;
		}

		if (_state.wait_key_enter) {
			if (Game_Message::IsMessageActive()) {
				break;
			}

			if (!Input::IsTriggered(Input::DECISION)) {
				break;
			}
			_state.wait_key_enter = false;
		}

		if (_state.wait_movement) {
			if (Game_Map::IsAnyMovePending()) {
				break;
			}
			_state.wait_movement = false;
		}

		if (_keyinput.wait) {
			if (Game_Message::IsMessageActive()) {
				break;
			}

			const int key = _keyinput.CheckInput();
			Main_Data::game_variables->Set(_keyinput.variable, key);
			Game_Map::SetNeedRefreshForVarChange(_keyinput.variable);
			if (key == 0) {
				++_keyinput.wait_frames;
				break;
			}
			if (_keyinput.timed) {
				// 10 per second
				Main_Data::game_variables->Set(_keyinput.time_variable,
						(_keyinput.wait_frames * 10) / Game_Clock::GetTargetGameFps());
				Game_Map::SetNeedRefreshForVarChange(_keyinput.time_variable);
			}
			_keyinput.wait = false;
		}

		auto* frame = GetFramePtr();
		if (frame == nullptr) {
			break;
		}

		if (Game_Map::GetNeedRefresh()) {
			Game_Map::Refresh();
		}

		// Previous operations could have modified the stack.
		// So we need to fetch the frame again.
		frame = GetFramePtr();
		if (frame == nullptr) {
			break;
		}

		// Pop any completed stack frames
		if (frame->current_command >= (int)frame->commands.size()) {
			if (!OnFinishStackFrame()) {
				break;
			}
			continue;
		}

		// Save the frame index before we call events.
		int current_frame_idx = _state.stack.size() - 1;

		const int index_before_exec = frame->current_command;
		if (!ExecuteCommand()) {
			break;
		}

		if (Game_Battle::IsBattleRunning() && Player::IsRPG2k3() && Game_Battle::CheckWin()) {
			// Interpreter is cancelled when a win condition is fulfilled in RPG2k3 battle
			break;
		}

		// Last event command removed the frame? We're done.
		if (current_frame_idx >= (int)_state.stack.size() ) {
			continue;
		}

		// Note: In the case we executed a CallEvent command, be sure to
		// increment the old frame and not the new one we just pushed.
		frame = &_state.stack[current_frame_idx];

		// Only do auto increment if the command didn't manually
		// change the index.
		if (index_before_exec == frame->current_command) {
			frame->current_command++;
		}
	} // for

	if (loop_count > loop_limit - 1) {
		auto* frame = GetFramePtr();
		int event_id = frame ? frame->event_id : 0;
		// Executed Events Count exceeded (10000)
		Output::Debug("Event {} exceeded execution limit", event_id);
	}

	if (Game_Map::GetNeedRefresh()) {
		Game_Map::Refresh();
	}
}

// Setup Starting Event
void Game_Interpreter::PushInternal(Game_Event* ev, ExecutionType ex_type) {
	PushInternal(
		{ ex_type, EventType::MapEvent },
		ev->GetList(), ev->GetId(), ev->GetActivePage() ? ev->GetActivePage()->ID : 0
	);
}

void Game_Interpreter::PushInternal(Game_Event* ev, const lcf::rpg::EventPage* page, ExecutionType ex_type) {
	PushInternal(
		{ ex_type, EventType::MapEvent },
		page->event_commands, ev->GetId(), page->ID
	);
}

void Game_Interpreter::PushInternal(Game_CommonEvent* ev, ExecutionType ex_type) {
	PushInternal({ ex_type, EventType::CommonEvent }, ev->GetList(), ev->GetId());
}

bool Game_Interpreter::CheckGameOver() {
	if (!Game_Battle::IsBattleRunning() && !Main_Data::game_party->IsAnyActive()) {
		// Empty party is allowed
		if (Main_Data::game_party->GetBattlerCount() > 0) {
			Scene::instance->SetRequestedScene(std::make_shared<Scene_Gameover>());
			return true;
		}
	}
	return false;
}

void Game_Interpreter::SkipToNextConditional(std::initializer_list<Cmd> codes, int indent) {
	auto& frame = GetFrame();
	const auto& list = frame.commands;
	auto& index = frame.current_command;

	if (index >= static_cast<int>(list.size())) {
		return;
	}

	for (++index; index < static_cast<int>(list.size()); ++index) {
		const auto& com = list[index];
		if (com.indent > indent) {
			continue;
		}
		if (std::find(codes.begin(), codes.end(), static_cast<Cmd>(com.code)) != codes.end()) {
			break;
		}
	}
}

// Execute Command.
bool Game_Interpreter::ExecuteCommand() {
	auto& frame = GetFrame();
	const auto& com = frame.commands[frame.current_command];
	return ExecuteCommand(com);
}

bool Game_Interpreter::ExecuteCommand(lcf::rpg::EventCommand const& com) {
	switch (static_cast<Cmd>(com.code)) {
		case Cmd::ShowMessage:
			return CmdSetup<&Game_Interpreter::CommandShowMessage, 0>(com);
		case Cmd::MessageOptions:
			return CmdSetup<&Game_Interpreter::CommandMessageOptions, 4>(com);
		case Cmd::ChangeFaceGraphic:
			return CmdSetup<&Game_Interpreter::CommandChangeFaceGraphic, 3>(com);
		case Cmd::ShowChoice:
			return CmdSetup<&Game_Interpreter::CommandShowChoices, 1>(com);
		case Cmd::ShowChoiceOption:
			return CmdSetup<&Game_Interpreter::CommandShowChoiceOption, 1>(com);
		case Cmd::ShowChoiceEnd:
			return CmdSetup<&Game_Interpreter::CommandShowChoiceEnd, 0>(com);
		case Cmd::InputNumber:
			return CmdSetup<&Game_Interpreter::CommandInputNumber, 2>(com);
		case Cmd::ControlSwitches:
			return CmdSetup<&Game_Interpreter::CommandControlSwitches, 4>(com);
		case Cmd::ControlVars:
			return CmdSetup<&Game_Interpreter::CommandControlVariables, 7>(com);
		case Cmd::TimerOperation:
			return CmdSetup<&Game_Interpreter::CommandTimerOperation, 5>(com);
		case Cmd::ChangeGold:
			return CmdSetup<&Game_Interpreter::CommandChangeGold, 3>(com);
		case Cmd::ChangeItems:
			return CmdSetup<&Game_Interpreter::CommandChangeItems, 5>(com);
		case Cmd::ChangePartyMembers:
			return CmdSetup<&Game_Interpreter::CommandChangePartyMember, 3>(com);
		case Cmd::ChangeExp:
			return CmdSetup<&Game_Interpreter::CommandChangeExp, 6>(com);
		case Cmd::ChangeLevel:
			return CmdSetup<&Game_Interpreter::CommandChangeLevel, 6>(com);
		case Cmd::ChangeParameters:
			return CmdSetup<&Game_Interpreter::CommandChangeParameters, 6>(com);
		case Cmd::ChangeSkills:
			return CmdSetup<&Game_Interpreter::CommandChangeSkills, 5>(com);
		case Cmd::ChangeEquipment:
			return CmdSetup<&Game_Interpreter::CommandChangeEquipment, 5>(com);
		case Cmd::ChangeHP:
			return CmdSetup<&Game_Interpreter::CommandChangeHP, 6>(com);
		case Cmd::ChangeSP:
			return CmdSetup<&Game_Interpreter::CommandChangeSP, 5>(com);
		case Cmd::ChangeCondition:
			return CmdSetup<&Game_Interpreter::CommandChangeCondition, 4>(com);
		case Cmd::FullHeal:
			return CmdSetup<&Game_Interpreter::CommandFullHeal, 2>(com);
		case Cmd::SimulatedAttack:
			return CmdSetup<&Game_Interpreter::CommandSimulatedAttack, 8>(com);
		case Cmd::Wait:
			return CmdSetup<&Game_Interpreter::CommandWait, 1>(com);
		case Cmd::PlayBGM:
			return CmdSetup<&Game_Interpreter::CommandPlayBGM, 4>(com);
		case Cmd::FadeOutBGM:
			return CmdSetup<&Game_Interpreter::CommandFadeOutBGM, 1>(com);
		case Cmd::PlaySound:
			return CmdSetup<&Game_Interpreter::CommandPlaySound, 3>(com);
		case Cmd::EndEventProcessing:
			return CmdSetup<&Game_Interpreter::CommandEndEventProcessing, 0>(com);
		case Cmd::Comment:
		case Cmd::Comment_2:
			return CmdSetup<&Game_Interpreter::CommandComment, 0>(com);
		case Cmd::GameOver:
			return CmdSetup<&Game_Interpreter::CommandGameOver, 0>(com);
		case Cmd::ChangeHeroName:
			return CmdSetup<&Game_Interpreter::CommandChangeHeroName, 1>(com);
		case Cmd::ChangeHeroTitle:
			return CmdSetup<&Game_Interpreter::CommandChangeHeroTitle, 1>(com);
		case Cmd::ChangeSpriteAssociation:
			return CmdSetup<&Game_Interpreter::CommandChangeSpriteAssociation, 3>(com);
		case Cmd::ChangeActorFace:
			return CmdSetup<&Game_Interpreter::CommandChangeActorFace, 2>(com);
		case Cmd::ChangeVehicleGraphic:
			return CmdSetup<&Game_Interpreter::CommandChangeVehicleGraphic, 2>(com);
		case Cmd::ChangeSystemBGM:
			return CmdSetup<&Game_Interpreter::CommandChangeSystemBGM, 5>(com);
		case Cmd::ChangeSystemSFX:
			return CmdSetup<&Game_Interpreter::CommandChangeSystemSFX, 4>(com);
		case Cmd::ChangeSystemGraphics:
			return CmdSetup<&Game_Interpreter::CommandChangeSystemGraphics, 2>(com);
		case Cmd::ChangeScreenTransitions:
			return CmdSetup<&Game_Interpreter::CommandChangeScreenTransitions, 2>(com);
		case Cmd::MemorizeLocation:
			return CmdSetup<&Game_Interpreter::CommandMemorizeLocation, 3>(com);
		case Cmd::SetVehicleLocation:
			return CmdSetup<&Game_Interpreter::CommandSetVehicleLocation, 5>(com);
		case Cmd::ChangeEventLocation:
			return CmdSetup<&Game_Interpreter::CommandChangeEventLocation, 4>(com);
		case Cmd::TradeEventLocations:
			return CmdSetup<&Game_Interpreter::CommandTradeEventLocations, 2>(com);
		case Cmd::StoreTerrainID:
			return CmdSetup<&Game_Interpreter::CommandStoreTerrainID, 4>(com);
		case Cmd::StoreEventID:
			return CmdSetup<&Game_Interpreter::CommandStoreEventID, 4>(com);
		case Cmd::EraseScreen:
			return CmdSetup<&Game_Interpreter::CommandEraseScreen, 1>(com);
		case Cmd::ShowScreen:
			return CmdSetup<&Game_Interpreter::CommandShowScreen, 1>(com);
		case Cmd::TintScreen:
			return CmdSetup<&Game_Interpreter::CommandTintScreen, 6>(com);
		case Cmd::FlashScreen:
			return CmdSetup<&Game_Interpreter::CommandFlashScreen, 6>(com);
		case Cmd::ShakeScreen:
			return CmdSetup<&Game_Interpreter::CommandShakeScreen, 4>(com);
		case Cmd::WeatherEffects:
			return CmdSetup<&Game_Interpreter::CommandWeatherEffects, 2>(com);
		case Cmd::ShowPicture:
			return CmdSetup<&Game_Interpreter::CommandShowPicture, 14>(com);
		case Cmd::MovePicture:
			return CmdSetup<&Game_Interpreter::CommandMovePicture, 16>(com);
		case Cmd::ErasePicture:
			return CmdSetup<&Game_Interpreter::CommandErasePicture, 1>(com);
		case Cmd::PlayerVisibility:
			return CmdSetup<&Game_Interpreter::CommandPlayerVisibility, 1>(com);
		case Cmd::MoveEvent:
			return CmdSetup<&Game_Interpreter::CommandMoveEvent, 4>(com);
		case Cmd::MemorizeBGM:
			return CmdSetup<&Game_Interpreter::CommandMemorizeBGM, 0>(com);
		case Cmd::PlayMemorizedBGM:
			return CmdSetup<&Game_Interpreter::CommandPlayMemorizedBGM, 0>(com);
		case Cmd::KeyInputProc:
			return CmdSetup<&Game_Interpreter::CommandKeyInputProc, 5>(com);
		case Cmd::ChangeMapTileset:
			return CmdSetup<&Game_Interpreter::CommandChangeMapTileset, 1>(com);
		case Cmd::ChangePBG:
			return CmdSetup<&Game_Interpreter::CommandChangePBG, 6>(com);
		case Cmd::ChangeEncounterSteps:
			return CmdSetup<&Game_Interpreter::CommandChangeEncounterSteps, 1>(com);
		case Cmd::TileSubstitution:
			return CmdSetup<&Game_Interpreter::CommandTileSubstitution, 3>(com);
		case Cmd::TeleportTargets:
			return CmdSetup<&Game_Interpreter::CommandTeleportTargets, 6>(com);
		case Cmd::ChangeTeleportAccess:
			return CmdSetup<&Game_Interpreter::CommandChangeTeleportAccess, 1>(com);
		case Cmd::EscapeTarget:
			return CmdSetup<&Game_Interpreter::CommandEscapeTarget, 5>(com);
		case Cmd::ChangeEscapeAccess:
			return CmdSetup<&Game_Interpreter::CommandChangeEscapeAccess, 1>(com);
		case Cmd::ChangeSaveAccess:
			return CmdSetup<&Game_Interpreter::CommandChangeSaveAccess, 1>(com);
		case Cmd::ChangeMainMenuAccess:
			return CmdSetup<&Game_Interpreter::CommandChangeMainMenuAccess, 1>(com);
		case Cmd::ConditionalBranch:
			return CmdSetup<&Game_Interpreter::CommandConditionalBranch, 6>(com);
		case Cmd::Label:
			return true;
		case Cmd::JumpToLabel:
			return CmdSetup<&Game_Interpreter::CommandJumpToLabel, 1>(com);
		case Cmd::Loop:
			return CmdSetup<&Game_Interpreter::CommandLoop, 0>(com);
		case Cmd::BreakLoop:
			return CmdSetup<&Game_Interpreter::CommandBreakLoop, 0>(com);
		case Cmd::EndLoop:
			return CmdSetup<&Game_Interpreter::CommandEndLoop, 0>(com);
		case Cmd::EraseEvent:
			return CmdSetup<&Game_Interpreter::CommandEraseEvent, 0>(com);
		case Cmd::CallEvent:
			return CmdSetup<&Game_Interpreter::CommandCallEvent, 3>(com);
		case Cmd::ReturntoTitleScreen:
			return CmdSetup<&Game_Interpreter::CommandReturnToTitleScreen, 0>(com);
		case Cmd::ChangeClass:
			return CmdSetup<&Game_Interpreter::CommandChangeClass, 7>(com);
		case Cmd::ChangeBattleCommands:
			return CmdSetup<&Game_Interpreter::CommandChangeBattleCommands, 4>(com);
		case Cmd::ElseBranch:
			return CmdSetup<&Game_Interpreter::CommandElseBranch, 0>(com);
		case Cmd::EndBranch:
			return CmdSetup<&Game_Interpreter::CommandEndBranch, 0>(com);
		case Cmd::ExitGame:
			return CmdSetup<&Game_Interpreter::CommandExitGame, 0>(com);
		case Cmd::ToggleFullscreen:
			return CmdSetup<&Game_Interpreter::CommandToggleFullscreen, 0>(com);
		case Cmd::OpenVideoOptions:
			return CmdSetup<&Game_Interpreter::CommandOpenVideoOptions, 0>(com);
		case Cmd::Maniac_GetSaveInfo:
			return CmdSetup<&Game_Interpreter::CommandManiacGetSaveInfo, 12>(com);
		case Cmd::Maniac_Load:
			return CmdSetup<&Game_Interpreter::CommandManiacLoad, 3>(com);
		case Cmd::Maniac_Save:
			return CmdSetup<&Game_Interpreter::CommandManiacSave, 3>(com);
		case Cmd::Maniac_EndLoadProcess:
			return CmdSetup<&Game_Interpreter::CommandManiacEndLoadProcess, 0>(com);
		case Cmd::Maniac_GetMousePosition:
			return CmdSetup<&Game_Interpreter::CommandManiacGetMousePosition, 2>(com);
		case Cmd::Maniac_SetMousePosition:
			return CmdSetup<&Game_Interpreter::CommandManiacSetMousePosition, 3>(com);
		case Cmd::Maniac_ShowStringPicture:
			return CmdSetup<&Game_Interpreter::CommandManiacShowStringPicture, 23>(com);
		case Cmd::Maniac_GetPictureInfo:
			return CmdSetup<&Game_Interpreter::CommandManiacGetPictureInfo, 8>(com);
		case Cmd::Maniac_ControlVarArray:
			return CmdSetup<&Game_Interpreter::CommandManiacControlVarArray, 5>(com);
		case Cmd::Maniac_KeyInputProcEx:
			return CmdSetup<&Game_Interpreter::CommandManiacKeyInputProcEx, 4>(com);
		case Cmd::Maniac_RewriteMap:
			return CmdSetup<&Game_Interpreter::CommandManiacRewriteMap, 9>(com);
		case Cmd::Maniac_ControlGlobalSave:
			return CmdSetup<&Game_Interpreter::CommandManiacControlGlobalSave, 6>(com);
		case Cmd::Maniac_ChangePictureId:
			return CmdSetup<&Game_Interpreter::CommandManiacChangePictureId, 6>(com);
		case Cmd::Maniac_SetGameOption:
			return CmdSetup<&Game_Interpreter::CommandManiacSetGameOption, 4>(com);
		case Cmd::Maniac_ControlStrings:
			return CmdSetup<&Game_Interpreter::CommandManiacControlStrings, 8>(com);
		case Cmd::Maniac_CallCommand:
			return CmdSetup<&Game_Interpreter::CommandManiacCallCommand, 6>(com);
		case Cmd::Maniac_GetGameInfo:
			return CmdSetup<&Game_Interpreter::CommandManiacGetGameInfo, 8>(com);
		case Cmd::EasyRpg_SetInterpreterFlag:
			return CmdSetup<&Game_Interpreter::CommandEasyRpgSetInterpreterFlag, 2>(com);
		case Cmd::EasyRpg_ProcessJson:
			return CmdSetup<&Game_Interpreter::CommandEasyRpgProcessJson, 8>(com);
		case Cmd::EasyRpg_CloneMapEvent:
			return CmdSetup<&Game_Interpreter::CommandEasyRpgCloneMapEvent, 10>(com);
		case Cmd::EasyRpg_DestroyMapEvent:
			return CmdSetup<&Game_Interpreter::CommandEasyRpgDestroyMapEvent, 2>(com);
		default:
			return true;
	}
}

bool Game_Interpreter::OnFinishStackFrame() {
	auto& frame = GetFrame();

	const bool is_base_frame = _state.stack.size() == 1;

	if (main_flag && is_base_frame && !Game_Battle::IsBattleRunning()) {
		Main_Data::game_system->ClearMessageFace();
	}

	int event_id = frame.event_id;

	if (is_base_frame && event_id > 0) {
		Game_Event* evnt = Game_Map::GetEvent(event_id);
		if (!evnt) {
			Output::Error("Call stack finished with invalid event id {}. This can be caused by a vehicle teleport?", event_id);
		} else if (main_flag) {
			evnt->OnFinishForegroundEvent();
		}
	}

	if (!main_flag && is_base_frame) {
		// Parallel events will never clear the base stack frame. Instead we just
		// reset the index back to 0 and wait for a frame.
		// This not only optimizes away copying event code, it's also RPG_RT compatible.
		frame.current_command = 0;
	} else {
		// If a called frame, or base frame of foreground interpreter, pop the stack.
		_state.stack.pop_back();
	}

	if (is_base_frame) {
#ifdef ENABLE_DYNAMIC_INTERPRETER_CONFIG
		// Individual runtime flags that may still be set will be cleared by
		// CommandEasyRpgSetInterpreterFlag if neccessary
		_state.easyrpg_runtime_flags.conf_override_active = false;
#endif
	}

	return !is_base_frame;
}

std::vector<std::string> Game_Interpreter::GetChoices(int max_num_choices) {
	const auto& frame = GetFrame();
	const auto& list = frame.commands;
	auto& index = frame.current_command;

	// Let's find the choices
	int current_indent = list[index + 1].indent;
	std::vector<std::string> s_choices;
	for (int index_temp = index + 1; index_temp < static_cast<int>(list.size()); ++index_temp) {
		const auto& com = list[index_temp];
		if (com.indent != current_indent) {
			continue;
		}

		if (static_cast<Cmd>(com.code) == Cmd::ShowChoiceOption && com.parameters.size() > 0 && com.parameters[0] < max_num_choices) {
			// Choice found
			s_choices.push_back(ToString(list[index_temp].string));
		}

		if (static_cast<Cmd>(com.code) == Cmd::ShowChoiceEnd) {
			break;
		}
	}
	return s_choices;
}

bool Game_Interpreter::CommandOptionGeneric(lcf::rpg::EventCommand const& com, int option_sub_idx, std::initializer_list<Cmd> next) {
	const auto sub_idx = GetSubcommandIndex(com.indent);
	if (sub_idx == option_sub_idx) {
		// Executes this option, so clear the subidx to skip all other options.
		SetSubcommandIndex(com.indent, subcommand_sentinel);
	} else {
		SkipToNextConditional(next, com.indent);
	}
	return true;
}

bool Game_Interpreter::CommandShowMessage(lcf::rpg::EventCommand const& com) { // code 10110
	auto& frame = GetFrame();
	const auto& list = frame.commands;
	auto& index = frame.current_command;

	if (!Game_Message::CanShowMessage(main_flag)) {
		return false;
	}

	PendingMessage pm(Game_Message::CommandCodeInserter);
	pm.SetIsEventMessage(true);
	pm.SetFromForegroundInterpreter(main_flag);

	// Set first line
	pm.PushLine(ToString(com.string));

	++index;

	// Check for continued lines via ShowMessage_2
	while (index < static_cast<int>(list.size()) && static_cast<Cmd>(list[index].code) == Cmd::ShowMessage_2) {
		// Add second (another) line
		pm.PushLine(ToString(list[index].string));
		++index;
	}

	// Handle Choices or number
	if (index < static_cast<int>(list.size())) {
		// If next event command is show choices
		if (static_cast<Cmd>(list[index].code) == Cmd::ShowChoice) {
			std::vector<std::string> s_choices = GetChoices(4);
			// If choices fit on screen
			if (static_cast<int>(s_choices.size()) <= (4 - pm.NumLines())) {
				pm.SetChoiceCancelType(list[index].parameters[0]);
				SetupChoices(s_choices, com.indent, pm);
				++index;
			}
		} else if (static_cast<Cmd>(list[index].code) == Cmd::InputNumber) {
			// If next event command is input number
			// If input number fits on screen
			if (pm.NumLines() < 4) {
				int digits = list[index].parameters[0];
				int variable_id = list[index].parameters[1];
				pm.PushNumInput(variable_id, digits);
				++index;
			}
		}
	}

	Game_Message::SetPendingMessage(std::move(pm));
	_state.show_message = true;

	return true;
}

bool Game_Interpreter::CommandMessageOptions(lcf::rpg::EventCommand const& com) { //code 10120
	if (!Game_Message::CanShowMessage(main_flag)) {
		return false;
	}

	Main_Data::game_system->SetMessageTransparent(com.parameters[0] != 0);
	Main_Data::game_system->SetMessagePosition(com.parameters[1]);
	Main_Data::game_system->SetMessagePositionFixed(com.parameters[2] == 0);
	Main_Data::game_system->SetMessageContinueEvents(com.parameters[3] != 0);

	// TODO: Maniac Patch Message Box Size and Font not implemented
	// see https://jetrotal.github.io/CSA/#Display%20Text%20Options

	return true;
}

bool Game_Interpreter::CommandChangeFaceGraphic(lcf::rpg::EventCommand const& com) { // Code 10130
	if (!Game_Message::CanShowMessage(main_flag)) {
		return false;
	}

	Main_Data::game_system->SetMessageFaceName(ToString(CommandStringOrVariableBitfield(com, 3, 0, 4)));
	Main_Data::game_system->SetMessageFaceIndex(ValueOrVariableBitfield(com, 3, 1, 0));
	Main_Data::game_system->SetMessageFaceRightPosition(com.parameters[1] != 0);
	Main_Data::game_system->SetMessageFaceFlipped(com.parameters[2] != 0);

	return true;
}

void Game_Interpreter::SetupChoices(const std::vector<std::string>& choices, int indent, PendingMessage& pm) {
	// Set choices to message text
	pm.SetChoiceResetColors(false);
	for (int i = 0; i < 4 && i < static_cast<int>(choices.size()); i++) {
		pm.PushChoice(choices[i]);
	}

	pm.SetChoiceContinuation([this, indent](int choice_result) {
		SetSubcommandIndex(indent, choice_result);
		return AsyncOp();
	});

	// save game compatibility with RPG_RT
	ReserveSubcommandIndex(indent);
}

bool Game_Interpreter::CommandShowChoices(lcf::rpg::EventCommand const& com) { // code 10140
	auto& index = GetFrame().current_command;

	if (!Game_Message::CanShowMessage(main_flag)) {
		return false;
	}

	PendingMessage pm(Game_Message::CommandCodeInserter);
	pm.SetIsEventMessage(true);
	pm.SetFromForegroundInterpreter(main_flag);

	// Choices setup
	std::vector<std::string> choices = GetChoices(4);
	pm.SetChoiceCancelType(com.parameters[0]);
	SetupChoices(choices, com.indent, pm);

	Game_Message::SetPendingMessage(std::move(pm));
	_state.show_message = true;

	++index;
	return false;
}


bool Game_Interpreter::CommandShowChoiceOption(lcf::rpg::EventCommand const& com) { //code 20140
	const auto opt_sub_idx = com.parameters[0];
	return CommandOptionGeneric(com, opt_sub_idx, {Cmd::ShowChoiceOption, Cmd::ShowChoiceEnd});
}

bool Game_Interpreter::CommandShowChoiceEnd(lcf::rpg::EventCommand const& /* com */) { //code 20141
	return true;
}

bool Game_Interpreter::CommandInputNumber(lcf::rpg::EventCommand const& com) { // code 10150
	if (!Game_Message::CanShowMessage(main_flag)) {
		return false;
	}

	PendingMessage pm(Game_Message::CommandCodeInserter);
	pm.SetIsEventMessage(true);
	pm.SetFromForegroundInterpreter(main_flag);

	int variable_id = com.parameters[1];
	int digits = com.parameters[0];

	pm.PushNumInput(variable_id, digits);

	Game_Message::SetPendingMessage(std::move(pm));
	_state.show_message = true;

	// Continue
	return true;
}

bool Game_Interpreter::CommandControlSwitches(lcf::rpg::EventCommand const& com) { // code 10210
	{
		int start, end;
		bool target_eval_result = DecodeTargetEvaluationMode<
			/* validate_patches */ true,
			/* support_range_indirect */ false,
			/* support_expressions */ false,
			/* support_bitmask */ false,
			/* support_scopes */ false
		>(com, start, end);
		if (!target_eval_result) {
			Output::Warning("ControlSwitches: Unsupported target evaluation mode {}", com.parameters[0]);
			return true;
		}

		int val = com.parameters[3];

		if (start == end) {
			if (val < 2) {
				Main_Data::game_switches->Set(start, val == 0);
			} else {
				Main_Data::game_switches->Flip(start);
			}
			Game_Map::SetNeedRefreshForSwitchChange(start);
		} else {
			if (val < 2) {
				Main_Data::game_switches->SetRange(start, end, val == 0);
			} else {
				Main_Data::game_switches->FlipRange(start, end);
			}
			Game_Map::SetNeedRefresh(true);
		}
	}
	return true;
}

bool Game_Interpreter::CommandControlVariables(lcf::rpg::EventCommand const& com) { // code 10220
	int value = 0;
	int operand = com.parameters[4];

	if (EP_UNLIKELY(operand >= 9 && !Player::IsPatchManiac())) {
		Output::Warning("ControlVariables: Unsupported operand {}", operand);
		return true;
	}

	switch (operand) {
		case 0:
			// Constant
			value = com.parameters[5];
			break;
		case 1:
			// Var A ops B
			value = Main_Data::game_variables->Get(com.parameters[5]);
			break;
		case 2:
			// Number of var A ops B
			value = Main_Data::game_variables->GetIndirect(com.parameters[5]);
			break;
		case 3: {
			// Random between range
			int32_t arg1 = com.parameters[5];
			int32_t arg2 = com.parameters[6];
			if (Player::IsPatchManiac() && com.parameters.size() >= 8) {
				arg1 = ValueOrVariableBitfield(com.parameters[7], 0, arg1);
				arg2 = ValueOrVariableBitfield(com.parameters[7], 1, arg2);
			}

			value = ControlVariables::Random(arg1, arg2);
			break;
		}
		case 4: {
			// Items
			int item = com.parameters[5];
			if (Player::IsPatchManiac() && com.parameters.size() >= 8) {
				item = ValueOrVariable(com.parameters[7], item);
			}

			value = ControlVariables::Item(com.parameters[6], item);
			break;
		}
		case 5: { // Hero
			int actor_id = com.parameters[5];
			if (Player::IsPatchManiac() && com.parameters.size() >= 8) {
				actor_id = ValueOrVariable(com.parameters[7], actor_id);
			}
			value = ControlVariables::Actor(com.parameters[6], actor_id);
			break;
		}
		case 6: {
			// Characters
			int event_id = com.parameters[5];
			if (Player::IsPatchManiac() && com.parameters.size() >= 8) {
				event_id = ValueOrVariable(com.parameters[7], event_id);
			}
			value = ControlVariables::Event(com.parameters[6], event_id, *this);
			break;
		}
		case 7:
			// More
			value = ControlVariables::Other(com.parameters[5]);
			break;
		case 8: {
			int enemy_id = com.parameters[5];
			if (Player::IsPatchManiac() && com.parameters.size() >= 8) {
				enemy_id = ValueOrVariable(com.parameters[7], enemy_id);
			}

			// Battle related
			value = ControlVariables::Enemy(com.parameters[6], enemy_id);
			break;
		}
		case 9: { // Party Member (Maniac)
			int party_idx = com.parameters[5];
			if (Player::IsPatchManiac() && com.parameters.size() >= 8) {
				party_idx = ValueOrVariable(com.parameters[7], party_idx);
			}
			value = ControlVariables::Party(com.parameters[6], party_idx);
			break;
		}
		case 10: {
			// Switch (Maniac)
			value = com.parameters[5];
			if (com.parameters[6] == 1) {
				value = Main_Data::game_switches->GetInt(value);
			} else {
				value = Main_Data::game_switches->GetInt(Main_Data::game_variables->Get(value));
			}
			break;
		}
		case 11: {
			// Pow (Maniac)
			int arg1 = ValueOrVariableBitfield(com.parameters[7], 0, com.parameters[5]);
			int arg2 = ValueOrVariableBitfield(com.parameters[7], 1, com.parameters[6]);
			value = ControlVariables::Pow(arg1, arg2);
			break;
		}
		case 12: {
			// Sqrt (Maniac)
			int arg = ValueOrVariableBitfield(com.parameters[7], 0, com.parameters[5]);
			int mul = com.parameters[6];
			value = ControlVariables::Sqrt(arg, mul);
			break;
		}
		case 13: {
			// Sin (Maniac)
			int arg1 = ValueOrVariableBitfield(com.parameters[7], 0, com.parameters[5]);
			int arg2 = ValueOrVariableBitfield(com.parameters[7], 1, com.parameters[8]);
			float mul = static_cast<float>(com.parameters[6]);
			value = ControlVariables::Sin(arg1, arg2, mul);
			break;
		}
		case 14: {
			// Cos (Maniac)
			int arg1 = ValueOrVariableBitfield(com.parameters[7], 0, com.parameters[5]);
			int arg2 = ValueOrVariableBitfield(com.parameters[7], 1, com.parameters[8]);
			int mul = com.parameters[6];
			value = ControlVariables::Cos(arg1, arg2, mul);
			break;
		}
		case 15: {
			// Atan2 (Maniac)
			int arg1 = ValueOrVariableBitfield(com.parameters[8], 0, com.parameters[5]);
			int arg2 = ValueOrVariableBitfield(com.parameters[8], 1, com.parameters[6]);
			int mul = com.parameters[7];
			value = ControlVariables::Atan2(arg1, arg2, mul);
			break;
		}
		case 16: {
			// Min (Maniac)
			int arg1 = ValueOrVariableBitfield(com.parameters[7], 0, com.parameters[5]);
			int arg2 = ValueOrVariableBitfield(com.parameters[7], 1, com.parameters[6]);
			value = ControlVariables::Min(arg1, arg2);
			break;
		}
		case 17: {
			// Max (Maniac)
			int arg1 = ValueOrVariableBitfield(com.parameters[7], 0, com.parameters[5]);
			int arg2 = ValueOrVariableBitfield(com.parameters[7], 1, com.parameters[6]);
			value = ControlVariables::Max(arg1, arg2);
			break;
		}
		case 18: {
			// Abs (Maniac)
			int arg = ValueOrVariableBitfield(com.parameters[6], 0, com.parameters[5]);
			value = ControlVariables::Abs(arg);
			break;
		}
		case 19: {
			// Binary (Maniac)
			int arg1 = ValueOrVariableBitfield(com.parameters[8], 0, com.parameters[6]);
			int arg2 = ValueOrVariableBitfield(com.parameters[8], 1, com.parameters[7]);
			value = ControlVariables::Binary(com.parameters[5], arg1, arg2);
			break;
		}
		case 20: {
			// Ternary (Maniac)
			int mode = com.parameters[10];
			int arg1 = ValueOrVariableBitfield(mode, 0, com.parameters[6]);
			int arg2 = ValueOrVariableBitfield(mode, 1, com.parameters[7]);
			int op = com.parameters[5];
			if (CheckOperator(arg1, arg2, op)) {
				value = ValueOrVariableBitfield(mode, 2, com.parameters[8]);
			} else {
				value = ValueOrVariableBitfield(mode, 3, com.parameters[9]);
			}
			break;
		}
		case 21:
			// Expression (Maniac)
			value = ManiacPatch::ParseExpression(MakeSpan(com.parameters).subspan(6, com.parameters[5]), *this);
			break;
		default:
			Output::Warning("ControlVariables: Unsupported operand {}", operand);
			return true;
	}

	int start, end;
	bool target_eval_result = DecodeTargetEvaluationMode<
		/* validate_patches */ true,
		/* support_range_indirect */ true,
		/* support_expressions */ true,
		/* support_bitmask */ false,
		/* support_scopes */ false
	>(com, start, end);
	if (!target_eval_result) {
		Output::Warning("ControlVariables: Unsupported target evaluation mode {}", com.parameters[0]);
		return true;
	}

	{
		int operation = com.parameters[3];
		if (EP_UNLIKELY(operation >= 6 && !Player::IsPatchManiac())) {
			Output::Warning("ControlVariables: Unsupported operation {}", operation);
			return true;
		}

		if (start == end) {
			// Single variable case - if this is random value, we already called the RNG earlier.
			switch (operation) {
				case 0:
					Main_Data::game_variables->Set(start, value);
					break;
				case 1:
					Main_Data::game_variables->Add(start, value);
					break;
				case 2:
					Main_Data::game_variables->Sub(start, value);
					break;
				case 3:
					Main_Data::game_variables->Mult(start, value);
					break;
				case 4:
					Main_Data::game_variables->Div(start, value);
					break;
				case 5:
					Main_Data::game_variables->Mod(start, value);
					break;
				case 6:
					Main_Data::game_variables->BitOr(start, value);
					break;
				case 7:
					Main_Data::game_variables->BitAnd(start, value);
					break;
				case 8:
					Main_Data::game_variables->BitXor(start, value);
					break;
				case 9:
					Main_Data::game_variables->BitShiftLeft(start, value);
					break;
				case 10:
					Main_Data::game_variables->BitShiftRight(start, value);
					break;
			}
			Game_Map::SetNeedRefreshForVarChange(start);
		} else if (com.parameters[4] == 1) {
			// Multiple variables - Direct variable lookup
			int var_id = com.parameters[5];
			switch (operation) {
				case 0:
					Main_Data::game_variables->SetRangeVariable(start, end, var_id);
					break;
				case 1:
					Main_Data::game_variables->AddRangeVariable(start, end, var_id);
					break;
				case 2:
					Main_Data::game_variables->SubRangeVariable(start, end, var_id);
					break;
				case 3:
					Main_Data::game_variables->MultRangeVariable(start, end, var_id);
					break;
				case 4:
					Main_Data::game_variables->DivRangeVariable(start, end, var_id);
					break;
				case 5:
					Main_Data::game_variables->ModRangeVariable(start, end, var_id);
					break;
				case 6:
					Main_Data::game_variables->BitOrRangeVariable(start, end, var_id);
					break;
				case 7:
					Main_Data::game_variables->BitAndRangeVariable(start, end, var_id);
					break;
				case 8:
					Main_Data::game_variables->BitXorRangeVariable(start, end, var_id);
					break;
				case 9:
					Main_Data::game_variables->BitShiftLeftRangeVariable(start, end, var_id);
					break;
				case 10:
					Main_Data::game_variables->BitShiftRightRangeVariable(start, end, var_id);
					break;
			}
			Game_Map::SetNeedRefresh(true);
		} else if (com.parameters[4] == 2) {
			// Multiple variables - Indirect variable lookup
			int var_id = com.parameters[5];
			switch (operation) {
				case 0:
					Main_Data::game_variables->SetRangeVariableIndirect(start, end, var_id);
					break;
				case 1:
					Main_Data::game_variables->AddRangeVariableIndirect(start, end, var_id);
					break;
				case 2:
					Main_Data::game_variables->SubRangeVariableIndirect(start, end, var_id);
					break;
				case 3:
					Main_Data::game_variables->MultRangeVariableIndirect(start, end, var_id);
					break;
				case 4:
					Main_Data::game_variables->DivRangeVariableIndirect(start, end, var_id);
					break;
				case 5:
					Main_Data::game_variables->ModRangeVariableIndirect(start, end, var_id);
					break;
				case 6:
					Main_Data::game_variables->BitOrRangeVariableIndirect(start, end, var_id);
					break;
				case 7:
					Main_Data::game_variables->BitAndRangeVariableIndirect(start, end, var_id);
					break;
				case 8:
					Main_Data::game_variables->BitXorRangeVariableIndirect(start, end, var_id);
					break;
				case 9:
					Main_Data::game_variables->BitShiftLeftRangeVariableIndirect(start, end, var_id);
					break;
				case 10:
					Main_Data::game_variables->BitShiftRightRangeVariableIndirect(start, end, var_id);
					break;
			}
			Game_Map::SetNeedRefresh(true);
		} else if (com.parameters[4] == 3) {
			// Multiple variables - random
			int rmax = max(com.parameters[5], com.parameters[6]);
			int rmin = min(com.parameters[5], com.parameters[6]);
			switch (operation) {
				case 0:
					Main_Data::game_variables->SetRangeRandom(start, end, rmin, rmax);
					break;
				case 1:
					Main_Data::game_variables->AddRangeRandom(start, end, rmin, rmax);
					break;
				case 2:
					Main_Data::game_variables->SubRangeRandom(start, end, rmin, rmax);
					break;
				case 3:
					Main_Data::game_variables->MultRangeRandom(start, end, rmin, rmax);
					break;
				case 4:
					Main_Data::game_variables->DivRangeRandom(start, end, rmin, rmax);
					break;
				case 5:
					Main_Data::game_variables->ModRangeRandom(start, end, rmin, rmax);
					break;
				case 6:
					Main_Data::game_variables->BitOrRangeRandom(start, end, rmin, rmax);
					break;
				case 7:
					Main_Data::game_variables->BitAndRangeRandom(start, end, rmin, rmax);
					break;
				case 8:
					Main_Data::game_variables->BitXorRangeRandom(start, end, rmin, rmax);
					break;
				case 9:
					Main_Data::game_variables->BitShiftLeftRangeRandom(start, end, rmin, rmax);
					break;
				case 10:
					Main_Data::game_variables->BitShiftRightRangeRandom(start, end, rmin, rmax);
					break;
			}
			Game_Map::SetNeedRefresh(true);
		} else {
			// Multiple variables - constant
			switch (operation) {
				case 0:
					Main_Data::game_variables->SetRange(start, end, value);
					break;
				case 1:
					Main_Data::game_variables->AddRange(start, end, value);
					break;
				case 2:
					Main_Data::game_variables->SubRange(start, end, value);
					break;
				case 3:
					Main_Data::game_variables->MultRange(start, end, value);
					break;
				case 4:
					Main_Data::game_variables->DivRange(start, end, value);
					break;
				case 5:
					Main_Data::game_variables->ModRange(start, end, value);
					break;
				case 6:
					Main_Data::game_variables->BitOrRange(start, end, value);
					break;
				case 7:
					Main_Data::game_variables->BitAndRange(start, end, value);
					break;
				case 8:
					Main_Data::game_variables->BitXorRange(start, end, value);
					break;
				case 9:
					Main_Data::game_variables->BitShiftLeftRange(start, end, value);
					break;
				case 10:
					Main_Data::game_variables->BitShiftRightRange(start, end, value);
					break;
			}
			Game_Map::SetNeedRefresh(true);
		}
	}

	return true;
}

int Game_Interpreter::OperateValue(int operation, int operand_type, int operand) {
	int value = ValueOrVariable(operand_type, operand);

	// Reverse sign of value if operation is substract
	if (operation == 1) {
		value = -value;
	}

	return value;
}

std::vector<Game_Actor*> Game_Interpreter::GetActors(int mode, int id) {
	std::vector<Game_Actor*> actors;
	Game_Actor* actor;

	switch (mode) {
	case 0:
		// Party
		actors = Main_Data::game_party->GetActors();
		break;
	case 1:
		// Hero
		actor = Main_Data::game_actors->GetActor(id);

		if (!actor) {
			Output::Warning("Invalid actor ID {}", id);
			return actors;
		}

		actors.push_back(actor);
		break;
	case 2:
		// Var hero
		actor = Main_Data::game_actors->GetActor(Main_Data::game_variables->Get(id));
		if (!actor) {
			Output::Warning("Invalid actor ID {}", Main_Data::game_variables->Get(id));
			return actors;
		}

		actors.push_back(actor);
		break;
	}

	return actors;
}

Game_Character* Game_Interpreter::GetCharacter(int event_id, std::string_view origin) const {
	if (event_id == Game_Character::CharThisEvent) {
		event_id = GetThisEventId();
		// Is a common event
		if (event_id == 0) {
			// With no map parent
			Output::Warning("{}: Can't use ThisEvent in common event: Not called from a map event", origin);
			return nullptr;
		}
	}

	Game_Character* ch = Game_Character::GetCharacter(event_id, event_id);
	if (!ch) {
		Output::Warning("{}: Unknown event with id {}", origin, event_id);
	}
	return ch;
}

bool Game_Interpreter::CommandTimerOperation(lcf::rpg::EventCommand const& com) { // code 10230
	int timer_id = 0;

	if (com.parameters.size() > 5 && Player::IsRPG2k3Commands()) {
		timer_id = com.parameters[5];
	}

	int seconds;
	bool visible, battle;

	switch (com.parameters[0]) {
	case 0:
		seconds = ValueOrVariable(com.parameters[1],
			com.parameters[2]);
		Main_Data::game_party->SetTimer(timer_id, seconds);
		break;
	case 1:
		visible = com.parameters[3] != 0;
		battle = com.parameters[4] != 0;
		Main_Data::game_party->StartTimer(timer_id, visible, battle);
		break;
	case 2:
		Main_Data::game_party->StopTimer(timer_id);
		break;
	default:
		return false;
	}
	return true;
}

bool Game_Interpreter::CommandChangeGold(lcf::rpg::EventCommand const& com) { // Code 10310
	int value;
	value = OperateValue(
		com.parameters[0],
		com.parameters[1],
		com.parameters[2]
	);

	Main_Data::game_party->GainGold(value);

	// Continue
	return true;
}

bool Game_Interpreter::CommandChangeItems(lcf::rpg::EventCommand const& com) { // Code 10320
	int value;
	value = OperateValue(
		com.parameters[0],
		com.parameters[3],
		com.parameters[4]
	);

	// Add item can't be used to remove an item and
	// remove item can't be used to add one
	if (com.parameters[0] == 1) {
		// Substract
		if (value > 0) {
			return true;
		}
	} else {
		// Add
		if (value < 0) {
			return true;
		}
	}

	if (com.parameters[1] == 0) {
		// Item by const number
		Main_Data::game_party->AddItem(com.parameters[2], value);
	} else {
		// Item by variable
		Main_Data::game_party->AddItem(
			Main_Data::game_variables->Get(com.parameters[2]),
			value
		);
	}
	Game_Map::SetNeedRefresh(true);
	// Continue
	return true;
}

bool Game_Interpreter::CommandChangePartyMember(lcf::rpg::EventCommand const& com) { // Code 10330
	Game_Actor* actor;
	int id = ValueOrVariable(com.parameters[1], com.parameters[2]);

	actor = Main_Data::game_actors->GetActor(id);

	if (!actor) {
		Output::Warning("ChangePartyMember: Invalid actor ID {}", id);
		return true;
	}

	if (com.parameters[0] == 0) {
		// Add members
		Main_Data::game_party->AddActor(id);

	} else {
		// Remove members
		Main_Data::game_party->RemoveActor(id);
	}

	CheckGameOver();
	Game_Map::SetNeedRefresh(true);

	// Continue
	return true;
}

void Game_Interpreter::ForegroundTextPush(PendingMessage pm) {
	auto& fg_interp = GetForegroundInterpreter();
	fg_interp._state.show_message = true;

	Game_Message::SetPendingMessage(std::move(pm));
}

bool Game_Interpreter::CommandChangeExp(lcf::rpg::EventCommand const& com) { // Code 10410
	bool show_msg = com.parameters[5];

	if (show_msg && !Game_Message::CanShowMessage(true)) {
		return false;
	}
	int value = OperateValue(
		com.parameters[2],
		com.parameters[3],
		com.parameters[4]
	);

	PendingMessage pm(Game_Message::CommandCodeInserter);
	pm.SetEnableFace(false);
	pm.SetFromForegroundInterpreter(main_flag);

	for (const auto& actor : GetActors(com.parameters[0], com.parameters[1])) {
		actor->ChangeExp(actor->GetExp() + value, show_msg ? &pm : nullptr);
	}

	if (CheckGameOver()) {
		return true;
	}

	if (show_msg) {
		ForegroundTextPush(std::move(pm));
	}
	return true;
}

bool Game_Interpreter::CommandChangeLevel(lcf::rpg::EventCommand const& com) { // Code 10420
	bool show_msg = com.parameters[5];

	if (show_msg && !Game_Message::CanShowMessage(true)) {
		return false;
	}

	int value = OperateValue(
		com.parameters[2],
		com.parameters[3],
		com.parameters[4]
	);

	PendingMessage pm(Game_Message::CommandCodeInserter);
	pm.SetEnableFace(false);
	pm.SetFromForegroundInterpreter(main_flag);

	for (const auto& actor : GetActors(com.parameters[0], com.parameters[1])) {
		actor->ChangeLevel(actor->GetLevel() + value, show_msg ? &pm : nullptr);
	}

	if (CheckGameOver()) {
		return true;
	}

	if (show_msg && pm.IsActive()) {
		ForegroundTextPush(std::move(pm));
	}
	return true;
}

bool Game_Interpreter::CommandChangeParameters(lcf::rpg::EventCommand const& com) { // Code 10430
	int value = OperateValue(
		com.parameters[2],
		com.parameters[4],
		com.parameters[5]
	);

	for (const auto& actor : GetActors(com.parameters[0], com.parameters[1])) {
		switch (com.parameters[3]) {
		case 0:
			// Max HP
			actor->SetBaseMaxHp(actor->GetBaseMaxHp() + value);
			break;
		case 1:
			// Max MP
			actor->SetBaseMaxSp(actor->GetBaseMaxSp() + value);
			break;
		case 2:
			// Attack
			actor->SetBaseAtk(actor->GetBaseAtk() + value);
			break;
		case 3:
			// Defense
			actor->SetBaseDef(actor->GetBaseDef() + value);
			break;
		case 4:
			// Spirit
			actor->SetBaseSpi(actor->GetBaseSpi() + value);
			break;
		case 5:
			// Agility
			actor->SetBaseAgi(actor->GetBaseAgi() + value);
			break;
		}
	}

	CheckGameOver();
	return true;
}

bool Game_Interpreter::CommandChangeSkills(lcf::rpg::EventCommand const& com) { // Code 10440
	bool remove = com.parameters[2] != 0;
	int skill_id = ValueOrVariable(com.parameters[3], com.parameters[4]);

	for (const auto& actor : GetActors(com.parameters[0], com.parameters[1])) {
		if (remove)
			actor->UnlearnSkill(skill_id);
		else
			actor->LearnSkill(skill_id, nullptr);
	}

	CheckGameOver();
	return true;
}

bool Game_Interpreter::CommandChangeEquipment(lcf::rpg::EventCommand const& com) { // Code 10450
	int item_id;
	int slot;
	const lcf::rpg::Item* item;

	switch (com.parameters[2]) {
		case 0:
			item_id = ValueOrVariable(com.parameters[3],
									  com.parameters[4]);
			item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
			if (!item) {
				Output::Warning("ChangeEquipment: Invalid item ID {}", item_id);
				return true;
			}

			switch (item->type) {
				case lcf::rpg::Item::Type_weapon:
				case lcf::rpg::Item::Type_shield:
				case lcf::rpg::Item::Type_armor:
				case lcf::rpg::Item::Type_helmet:
				case lcf::rpg::Item::Type_accessory:
					slot = item->type;
					break;
				default:
					return true;
			}
			break;
		case 1:
			item_id = 0;
			slot = com.parameters[3] + 1;
			break;
		default:
			return false;
	}

	if (slot == 6) {
		for (const auto& actor : GetActors(com.parameters[0], com.parameters[1])) {
			actor->RemoveWholeEquipment();
		}
	} else {
		for (const auto &actor : GetActors(com.parameters[0], com.parameters[1])) {
			if (actor->HasTwoWeapons() && slot == lcf::rpg::Item::Type_shield && item_id != 0) {
				continue;
			}

			if (actor->HasTwoWeapons() && slot == lcf::rpg::Item::Type_weapon && item_id != 0) {
				lcf::rpg::Item* new_equipment = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
				lcf::rpg::Item* equipment1 = lcf::ReaderUtil::GetElement(lcf::Data::items, actor->GetWeaponId());
				lcf::rpg::Item* equipment2 = lcf::ReaderUtil::GetElement(lcf::Data::items, actor->GetShieldId());

				if (equipment1 && !equipment2 && !equipment1->two_handed && !new_equipment->two_handed) {
					// Assign to 2nd weapon slot when empty
					actor->ChangeEquipment(slot + 1, item_id);
					continue;
				}
			}

			actor->ChangeEquipment(slot, item_id);
		}
	}

	CheckGameOver();
	return true;
}

bool Game_Interpreter::CommandChangeHP(lcf::rpg::EventCommand const& com) { // Code 10460
	bool remove = com.parameters[2] != 0;
	int amount = ValueOrVariable(com.parameters[3],
								 com.parameters[4]);
	bool lethal = com.parameters[5] != 0;

	if (remove)
		amount = -amount;

	for (const auto& actor : GetActors(com.parameters[0], com.parameters[1])) {
		actor->ChangeHp(amount, lethal);

		auto& scene = Scene::instance;
		if (scene) {
			scene->OnEventHpChanged(actor, amount);
		}

		if (actor->IsDead() && actor->GetActorBattleSprite()) {
			actor->GetActorBattleSprite()->DetectStateChange();
		}
	}

	CheckGameOver();
	return true;
}

bool Game_Interpreter::CommandChangeSP(lcf::rpg::EventCommand const& com) { // Code 10470
	bool remove = com.parameters[2] != 0;
	int amount = ValueOrVariable(com.parameters[3], com.parameters[4]);

	if (remove)
		amount = -amount;

	for (const auto& actor : GetActors(com.parameters[0], com.parameters[1])) {
		int sp = actor->GetSp() + amount;
		if (sp < 0)
			sp = 0;
		actor->SetSp(sp);
	}

	CheckGameOver();
	return true;
}

bool Game_Interpreter::CommandChangeCondition(lcf::rpg::EventCommand const& com) { // Code 10480
	bool remove = com.parameters[2] != 0;
	int state_id = com.parameters[3];

	for (const auto& actor : GetActors(com.parameters[0], com.parameters[1])) {
		if (remove) {
			// RPG_RT: On the map, will remove battle states even if actor has
			// state inflicted by equipment.
			actor->RemoveState(state_id, !Game_Battle::IsBattleRunning());
		} else {
			// RPG_RT always adds states from event commands, even battle states.
			actor->AddState(state_id, true);
		}
		if (actor->GetActorBattleSprite()) {
			actor->GetActorBattleSprite()->DetectStateChange();
		}
	}

	CheckGameOver();
	return true;
}

bool Game_Interpreter::CommandFullHeal(lcf::rpg::EventCommand const& com) { // Code 10490
	for (const auto& actor : GetActors(com.parameters[0], com.parameters[1])) {
		actor->FullHeal();
		if (actor->GetActorBattleSprite()) {
			actor->GetActorBattleSprite()->DetectStateChange();
		}
	}

	CheckGameOver();

	return true;
}

bool Game_Interpreter::CommandSimulatedAttack(lcf::rpg::EventCommand const& com) { // code 10500
	int atk = com.parameters[2];
	int def = com.parameters[3];
	int spi = com.parameters[4];
	int var = com.parameters[5];

	for (const auto& actor : GetActors(com.parameters[0], com.parameters[1])) {
		int result = atk;
		result -= (actor->GetDef() * def) / 400;
		result -= (actor->GetSpi() * spi) / 800;
		result = std::max(result, 0);
		result = Algo::VarianceAdjustEffect(result, var);

		result = std::max(0, result);
		actor->ChangeHp(-result, true);

		if (com.parameters[6] != 0) {
			Main_Data::game_variables->Set(com.parameters[7], result);
			Game_Map::SetNeedRefresh(true);
		}
	}

	CheckGameOver();
	return true;
}

bool Game_Interpreter::CommandWait(lcf::rpg::EventCommand const& com) { // code 11410
	auto& index = GetFrame().current_command;

	bool maniac = Player::IsPatchManiac();

	// Wait a given time
	if (com.parameters.size() <= 1 || (!maniac && !Player::IsRPG2k3Commands())) {
		SetupWait(com.parameters[0]);
		return true;
	}

	if (!maniac && com.parameters.size() > 1 && com.parameters[1] == 0) {
		SetupWait(com.parameters[0]);
		return true;
	}

	if (maniac && com.parameters.size() > 1 && com.parameters[1] != 1) {
		int wait_type = com.parameters[1];
		int mode = 0;

		if (com.parameters.size() > 2) {
			mode = com.parameters[2];
		}

		int duration = ValueOrVariable(mode, com.parameters[0]);

		if (wait_type == 256) {
			SetupWaitFrames(duration);
		} else {
			SetupWait(duration);
		}

		return true;
	}

	if (Game_Message::IsMessageActive()) {
		return false;
	}

	// Wait until decision key pressed, but skip the first frame so that
	// it ignores keys that were pressed before this command started.
	// FIXME: Is this behavior correct?
	_state.wait_key_enter = true;
	++index;
	return false;
}

bool Game_Interpreter::CommandPlayBGM(lcf::rpg::EventCommand const& com) { // code 11510
	lcf::rpg::Music music;
	music.name = ToString(CommandStringOrVariableBitfield(com, 4, 0, 5));

	music.fadein = ValueOrVariableBitfield(com, 4, 1, 0);
	music.volume = ValueOrVariableBitfield(com, 4, 2, 1);
	music.tempo = ValueOrVariableBitfield(com, 4, 3, 2);
	music.balance = ValueOrVariableBitfield(com, 4, 4, 3);

	Main_Data::game_system->BgmPlay(music);
	return true;
}

bool Game_Interpreter::CommandFadeOutBGM(lcf::rpg::EventCommand const& com) { // code 11520
	int fadeout = com.parameters[0];
	Main_Data::game_system->BgmFade(fadeout);
	return true;
}

bool Game_Interpreter::CommandPlaySound(lcf::rpg::EventCommand const& com) { // code 11550
	lcf::rpg::Sound sound;
	sound.name = ToString(CommandStringOrVariableBitfield(com, 3, 0, 4));

	sound.volume = ValueOrVariableBitfield(com, 3, 1, 0);
	sound.tempo = ValueOrVariableBitfield(com, 3, 2, 1);
	sound.balance = ValueOrVariableBitfield(com, 3, 3, 2);

	Main_Data::game_system->SePlay(sound, true);
	return true;
}

bool Game_Interpreter::CommandEndEventProcessing(lcf::rpg::EventCommand const& /* com */) { // code 12310
	EndEventProcessing();
	return true;
}

std::optional<bool> Game_Interpreter::HandleDynRpgScript(const lcf::rpg::EventCommand& com) {
	if (Player::IsPatchDynRpg() || Player::HasEasyRpgExtensions()) {
		if (com.string.empty() || com.string[0] != '@') {
			// Not a DynRPG command
			return {};
		}

		if (!Player::IsPatchDynRpg() && Player::HasEasyRpgExtensions()) {
			// Only accept commands starting with @easyrpg_
			if (!StartsWith(com.string, "@easyrpg_")) {
				return {};
			}
		}

		auto& frame = GetFrame();
		const auto& list = frame.commands;
		auto& index = frame.current_command;

		std::string command = ToString(com.string);

		// Concat everything that is not another command or a new comment block
		for (size_t i = index + 1; i < list.size(); ++i) {
			const auto& cmd = list[i];
			if (cmd.code == static_cast<uint32_t>(Cmd::Comment_2) &&
					!cmd.string.empty() && cmd.string[0] != '@') {
				command += ToString(cmd.string);
			} else {
				break;
			}
		}

		return Main_Data::game_dynrpg->Invoke(command, this);
	}
	return {};
}

std::optional<bool> Game_Interpreter::HandleDestinyScript(const lcf::rpg::EventCommand& com) {
	// DestinyScript
	if (Player::IsPatchDestiny()) {
		if (com.string.empty() || com.string[0] != '$') {
			// Not a DestinyScript
			return {};
		}

		return Main_Data::game_destiny->Main(GetFrame());
	}
	return {};
}

bool Game_Interpreter::CommandComment(const lcf::rpg::EventCommand &com) {
	if (auto handled = HandleDynRpgScript(com); handled.has_value()) {
		return handled.value();
	}
	if (auto handled = HandleDestinyScript(com); handled.has_value()) {
		return handled.value();
	}

	return true;
}

void Game_Interpreter::EndEventProcessing() {
	auto& frame = GetFrame();
	const auto& list = frame.commands;
	auto& index = frame.current_command;

	index = static_cast<int>(list.size());
}

bool Game_Interpreter::CommandGameOver(lcf::rpg::EventCommand const& /* com */) { // code 12420
	auto& index = GetFrame().current_command;

	if (Game_Message::IsMessageActive()) {
		return false;
	}

	Scene::instance->SetRequestedScene(std::make_shared<Scene_Gameover>());
	++index;
	return false;
}

bool Game_Interpreter::CommandChangeHeroName(lcf::rpg::EventCommand const& com) { // code 10610
	int id = ValueOrVariableBitfield(com, 1, 0, 0);
	Game_Actor* actor = Main_Data::game_actors->GetActor(id);

	if (!actor) {
		Output::Warning("ChangeHeroName: Invalid actor ID {}", id);
		return true;
	}

	actor->SetName(ToString(CommandStringOrVariableBitfield(com, 1, 1, 2)));
	return true;
}

bool Game_Interpreter::CommandChangeHeroTitle(lcf::rpg::EventCommand const& com) { // code 10620
	int id = ValueOrVariableBitfield(com, 1, 0, 0);
	Game_Actor* actor = Main_Data::game_actors->GetActor(id);

	if (!actor) {
		Output::Warning("ChangeHeroTitle: Invalid actor ID {}", id);
		return true;
	}

	actor->SetTitle(ToString(CommandStringOrVariableBitfield(com, 1, 1, 2)));
	return true;
}

bool Game_Interpreter::CommandChangeSpriteAssociation(lcf::rpg::EventCommand const& com) { // code 10630
	int id = ValueOrVariableBitfield(com, 3, 0, 0);
	Game_Actor* actor = Main_Data::game_actors->GetActor(id);

	if (!actor) {
		Output::Warning("ChangeSpriteAssociation: Invalid actor ID {}", id);
		return true;
	}

	auto file = ToString(CommandStringOrVariableBitfield(com, 3, 1, 4));
	int idx = ValueOrVariableBitfield(com, 3, 2, 1);
	bool transparent = com.parameters[2] != 0;

	actor->SetSprite(file, idx, transparent);
	Main_Data::game_player->ResetGraphic();
	return true;
}

bool Game_Interpreter::CommandChangeActorFace(lcf::rpg::EventCommand const& com) { // code 10640
	int id = ValueOrVariableBitfield(com, 2, 0, 0);
	Game_Actor* actor = Main_Data::game_actors->GetActor(id);
	if (!actor) {
		Output::Warning("CommandChangeActorFace: Invalid actor ID {}", id);
		return true;
	}

	actor->SetFace(
		ToString(CommandStringOrVariableBitfield(com, 2, 1, 3)),
		ValueOrVariableBitfield(com, 2, 2, 1));
	return true;
}

bool Game_Interpreter::CommandChangeVehicleGraphic(lcf::rpg::EventCommand const& com) { // code 10650
	Game_Vehicle::Type vehicle_id = (Game_Vehicle::Type) (com.parameters[0] + 1);
	Game_Vehicle* vehicle = Game_Map::GetVehicle(vehicle_id);

	if (!vehicle) {
		Output::Warning("ChangeVehicleGraphic: Invalid vehicle ID {}", static_cast<int>(vehicle_id));
		return true;
	}

	const std::string& name = ToString(com.string);
	int vehicle_index = com.parameters[1];

	vehicle->SetSpriteGraphic(name, vehicle_index);
	vehicle->SetOrigSpriteGraphic(name, vehicle_index);

	return true;
}

bool Game_Interpreter::CommandChangeSystemBGM(lcf::rpg::EventCommand const& com) { //code 10660
	lcf::rpg::Music music;
	int context = com.parameters[0];
	music.name = ToString(com.string);
	music.fadein = com.parameters[1];
	music.volume = com.parameters[2];
	music.tempo = com.parameters[3];
	music.balance = com.parameters[4];
	Main_Data::game_system->SetSystemBGM(context, std::move(music));
	return true;
}

bool Game_Interpreter::CommandChangeSystemSFX(lcf::rpg::EventCommand const& com) { //code 10670
	lcf::rpg::Sound sound;
	int context = com.parameters[0];
	sound.name = ToString(com.string);
	sound.volume = com.parameters[1];
	sound.tempo = com.parameters[2];
	sound.balance = com.parameters[3];
	Main_Data::game_system->SetSystemSE(context, std::move(sound));
	return true;
}

bool Game_Interpreter::CommandChangeSystemGraphics(lcf::rpg::EventCommand const& com) { // code 10680
	Main_Data::game_system->SetSystemGraphic(ToString(CommandStringOrVariable(com, 2, 3)),
			static_cast<lcf::rpg::System::Stretch>(com.parameters[0]),
			static_cast<lcf::rpg::System::Font>(com.parameters[1]));

	return true;
}

bool Game_Interpreter::CommandChangeScreenTransitions(lcf::rpg::EventCommand const& com) { // code 10690
	Main_Data::game_system->SetTransition(com.parameters[0], com.parameters[1]);
	return true;
}

bool Game_Interpreter::CommandMemorizeLocation(lcf::rpg::EventCommand const& com) { // code 10820
	Game_Character *player = Main_Data::game_player.get();
	int var_map_id = com.parameters[0];
	int var_x = com.parameters[1];
	int var_y = com.parameters[2];
	Main_Data::game_variables->Set(var_map_id, Game_Map::GetMapId());
	Main_Data::game_variables->Set(var_x, player->GetX());
	Main_Data::game_variables->Set(var_y, player->GetY());
	Game_Map::SetNeedRefreshForVarChange({var_map_id, var_x, var_y});
	return true;
}

bool Game_Interpreter::CommandSetVehicleLocation(lcf::rpg::EventCommand const& com) { // code 10850
	Game_Vehicle::Type vehicle_id = (Game_Vehicle::Type) (com.parameters[0] + 1);
	Game_Vehicle* vehicle = Game_Map::GetVehicle(vehicle_id);

	if (!vehicle) {
		// SetVehicleLocation moves the party, too, when she is in the referenced
		// vehicle. In RPG_RT a party that is in no vehicle has the vehicle_id -1.
		// Due to this implementation detail passing -1 as vehicle_id will move the
		// party instead.
		if (vehicle_id == 0) {
			// 0 because we adjust all vehicle IDs by +1 to match the lcf values
			Output::Debug("SetVehicleLocation: Party referenced");
		} else {
			Output::Warning("SetVehicleLocation: Invalid vehicle ID {}", static_cast<int>(vehicle_id));
			return true;
		}
	}

	int map_id = ValueOrVariable(com.parameters[1], com.parameters[2]);
	int x = ValueOrVariable(com.parameters[1], com.parameters[3]);
	int y = ValueOrVariable(com.parameters[1], com.parameters[4]);

	// Check if the party is in the current vehicle and transfer the party together with it
	if (Main_Data::game_player->GetVehicle() == vehicle) {
		if (map_id == Game_Map::GetMapId()) {
			if (vehicle) {
				vehicle->MoveTo(map_id, x, y);
			}
			Main_Data::game_player->MoveTo(map_id, x, y);
			if (vehicle_id == 0) {
				// This fixes a bug in Yume2kki on map 3D Underworld (ID 1884)
				// The map uses a MoveRoute with a jump and SetVehicleLocation for party movement in a tight loop which
				// causes heavy flickering in our Player.
				// TODO: This fix does not appear to be completely correct as RPG_RT does not reset the jump flag here
				// but the "damage" is reduced because SetVehicleLocation -1 cannot happen without patching the game.
				Main_Data::game_player->SetJumping(false);
			}
			return true;
		};

		// This implements a bug in RPG_RT which allows moving the party to a new map while boarded (or when using -1)
		// without doing a teleport + transition.
		// In player we implement this as an async "Quick Teleport" which immediately switches to
		// the other map with no transition and no change in screen effects such as pictures and
		// battle animations.

		if (vehicle) {
			vehicle->MoveTo(map_id, x, y);
		}

		auto event_id = GetOriginalEventId();
		if (!main_flag && event_id != 0) {
			Output::Error("VehicleTeleport not allowed from parallel map event! Id={}", event_id);
		}

		_async_op = AsyncOp::MakeQuickTeleport(map_id, x, y);
	} else if (vehicle) {
		vehicle->MoveTo(map_id, x, y);
	}

	return true;
}

bool Game_Interpreter::CommandChangeEventLocation(lcf::rpg::EventCommand const& com) { // Code 10860
	int event_id = com.parameters[0];
	Game_Character *event = GetCharacter(event_id, "ChangeEventLocation");
	if (event != nullptr) {
		const auto x = ValueOrVariable(com.parameters[1], com.parameters[2]);
		const auto y = ValueOrVariable(com.parameters[1], com.parameters[3]);
		event->MoveTo(event->GetMapId(), x, y);

		// RPG2k3 feature
		int direction = -1;
		if (Player::IsRPG2k3Commands() && com.parameters.size() > 4) {
			direction = com.parameters[4] - 1;
		}

		// Only for the constant case, not for variables
		if (com.parameters[1] == 0 && direction != -1) {
			event->SetDirection(direction);
			event->UpdateFacing();
		}
	}
	return true;
}

bool Game_Interpreter::CommandTradeEventLocations(lcf::rpg::EventCommand const& com) { // Code 10870
	int event1_id = com.parameters[0];
	int event2_id = com.parameters[1];

	Game_Character *event1 = GetCharacter(event1_id, "TradeEventLocations");
	Game_Character *event2 = GetCharacter(event2_id, "TradeEventLocations");

	if (event1 != nullptr && event2 != nullptr) {
		auto m1 = event1->GetMapId();
		auto x1 = event1->GetX();
		auto y1 = event1->GetY();

		auto m2 = event2->GetMapId();
		auto x2 = event2->GetX();
		auto y2 = event2->GetY();

		event1->MoveTo(m2, x2, y2);
		event2->MoveTo(m1, x1, y1);
	}

	return true;
}

bool Game_Interpreter::CommandStoreTerrainID(lcf::rpg::EventCommand const& com) { // code 10820
	int x = ValueOrVariable(com.parameters[0], com.parameters[1]);
	int y = ValueOrVariable(com.parameters[0], com.parameters[2]);
	int var_id = com.parameters[3];
	Main_Data::game_variables->Set(var_id, Game_Map::GetTerrainTag(x, y));
	Game_Map::SetNeedRefreshForVarChange(var_id);
	return true;
}

bool Game_Interpreter::CommandStoreEventID(lcf::rpg::EventCommand const& com) { // code 10920
	int x = ValueOrVariable(com.parameters[0], com.parameters[1]);
	int y = ValueOrVariable(com.parameters[0], com.parameters[2]);
	int var_id = com.parameters[3];
	auto* ev = Game_Map::GetEventAt(x, y, false);
	Main_Data::game_variables->Set(var_id, ev ? ev->GetId() : 0);
	Game_Map::SetNeedRefreshForVarChange(var_id);
	return true;
}

bool Game_Interpreter::CommandEraseScreen(lcf::rpg::EventCommand const& com) { // code 11010
	if (Game_Message::IsMessageActive()) {
		return false;
	}

	// Emulates RPG_RT behavior where any transition out is skipped when these scenes are pending.
	auto st = Scene::instance->GetRequestedSceneType();
	if (st == Scene::Battle || st == Scene::Gameover) {
		return true;
	}

	// Transition commands in battle have glitchy behavior in RPG_RT, but they don't affect the map.
	// We disable in them in Player.
	if (Game_Battle::IsBattleRunning()) {
		return true;
	}

	int tt = Transition::TransitionNone;

	switch (com.parameters[0]) {
	case -1:
		tt = Main_Data::game_system->GetTransition(Main_Data::game_system->Transition_TeleportErase);
		break;
	case 0:
		tt = Transition::TransitionFadeOut;
		break;
	case 1:
		tt = Transition::TransitionRandomBlocks;
		break;
	case 2:
		tt = Transition::TransitionRandomBlocksDown;
		break;
	case 3:
		tt = Transition::TransitionRandomBlocksUp;
		break;
	case 4:
		tt = Transition::TransitionBlindClose;
		break;
	case 5:
		tt = Transition::TransitionVerticalStripesOut;
		break;
	case 6:
		tt = Transition::TransitionHorizontalStripesOut;
		break;
	case 7:
		tt = Transition::TransitionBorderToCenterOut;
		break;
	case 8:
		tt = Transition::TransitionCenterToBorderOut;
		break;
	case 9:
		tt = Transition::TransitionScrollUpOut;
		break;
	case 10:
		tt = Transition::TransitionScrollDownOut;
		break;
	case 11:
		tt = Transition::TransitionScrollLeftOut;
		break;
	case 12:
		tt = Transition::TransitionScrollRightOut;
		break;
	case 13:
		tt = Transition::TransitionVerticalDivision;
		break;
	case 14:
		tt = Transition::TransitionHorizontalDivision;
		break;
	case 15:
		tt = Transition::TransitionCrossDivision;
		break;
	case 16:
		tt = Transition::TransitionZoomIn;
		break;
	case 17:
		tt = Transition::TransitionMosaicOut;
		break;
	case 18:
		tt = Transition::TransitionWaveOut;
		break;
	case 19:
		tt = Transition::TransitionCutOut;
		break;
	default:
		tt = Transition::TransitionNone;
		break;
	}

	_async_op = AsyncOp::MakeEraseScreen(tt);

	return true;
}

bool Game_Interpreter::CommandShowScreen(lcf::rpg::EventCommand const& com) { // code 11020
	if (Game_Message::IsMessageActive()) {
		return false;
	}

	// Transition commands in battle have glitchy behavior in RPG_RT, but they don't affect the map.
	// We disable in them in Player.
	if (Game_Battle::IsBattleRunning()) {
		return true;
	}

	int tt = Transition::TransitionNone;

	switch (com.parameters[0]) {
	case -1:
		tt = Main_Data::game_system->GetTransition(Main_Data::game_system->Transition_TeleportShow);
		break;
	case 0:
		tt = Transition::TransitionFadeIn;
		break;
	case 1:
		tt = Transition::TransitionRandomBlocks;
		break;
	case 2:
		tt = Transition::TransitionRandomBlocksDown;
		break;
	case 3:
		tt = Transition::TransitionRandomBlocksUp;
		break;
	case 4:
		tt = Transition::TransitionBlindOpen;
		break;
	case 5:
		tt = Transition::TransitionVerticalStripesIn;
		break;
	case 6:
		tt = Transition::TransitionHorizontalStripesIn;
		break;
	case 7:
		tt = Transition::TransitionBorderToCenterIn;
		break;
	case 8:
		tt = Transition::TransitionCenterToBorderIn;
		break;
	case 9:
		tt = Transition::TransitionScrollUpIn;
		break;
	case 10:
		tt = Transition::TransitionScrollDownIn;
		break;
	case 11:
		tt = Transition::TransitionScrollLeftIn;
		break;
	case 12:
		tt = Transition::TransitionScrollRightIn;
		break;
	case 13:
		tt = Transition::TransitionVerticalCombine;
		break;
	case 14:
		tt = Transition::TransitionHorizontalCombine;
		break;
	case 15:
		tt = Transition::TransitionCrossCombine;
		break;
	case 16:
		tt = Transition::TransitionZoomOut;
		break;
	case 17:
		tt = Transition::TransitionMosaicIn;
		break;
	case 18:
		tt = Transition::TransitionWaveIn;
		break;
	case 19:
		tt = Transition::TransitionCutIn;
		break;
	default:
		tt = Transition::TransitionNone;
		break;
	}

	_async_op = AsyncOp::MakeShowScreen(tt);
	return true;
}

bool Game_Interpreter::CommandTintScreen(lcf::rpg::EventCommand const& com) { // code 11030
	Game_Screen* screen = Main_Data::game_screen.get();
	int r = com.parameters[0];
	int g = com.parameters[1];
	int b = com.parameters[2];
	int s = com.parameters[3];
	int tenths = com.parameters[4];
	bool wait = com.parameters[5] != 0;

	screen->TintScreen(r, g, b, s, tenths * DEFAULT_FPS / 10);

	if (wait)
		SetupWait(tenths);

	return true;
}

bool Game_Interpreter::CommandFlashScreen(lcf::rpg::EventCommand const& com) { // code 11040
	Game_Screen* screen = Main_Data::game_screen.get();
	int r = com.parameters[0];
	int g = com.parameters[1];
	int b = com.parameters[2];
	int s = com.parameters[3];
	int tenths = com.parameters[4];
	bool wait = com.parameters[5] != 0;

	if (com.parameters.size() <= 6 || !Player::IsRPG2k3Commands()) {
		screen->FlashOnce(r, g, b, s, tenths * DEFAULT_FPS / 10);
		if (wait)
			SetupWait(tenths);
	} else {
		switch (com.parameters[6]) {
		case 0:
			screen->FlashOnce(r, g, b, s, tenths * DEFAULT_FPS / 10);
			if (wait)
				SetupWait(tenths);
			break;
		case 1:
			screen->FlashBegin(r, g, b, s, tenths * DEFAULT_FPS / 10);
			break;
		case 2:
			screen->FlashEnd();
			break;
		}
	}

	return true;
}

bool Game_Interpreter::CommandShakeScreen(lcf::rpg::EventCommand const& com) { // code 11050
	Game_Screen* screen = Main_Data::game_screen.get();
	int strength = com.parameters[0];
	int speed = com.parameters[1];
	int tenths = com.parameters[2];
	bool wait = com.parameters[3] != 0;
	// params array is size 4 in 2k and 2k games ported to 2k3.
	int shake_cmd = 0;
	if (com.parameters.size() > 4 && Player::IsRPG2k3Commands()) {
		shake_cmd = com.parameters[4];
	}

	switch (shake_cmd) {
		case 0:
			if (tenths > 0) {
				screen->ShakeOnce(strength, speed, tenths * DEFAULT_FPS / 10);
				if (wait) {
					SetupWait(tenths);
				}
			} else {
				screen->ShakeEnd();
			}
			break;
		case 1:
			screen->ShakeBegin(strength, speed);
			break;
		case 2:
			screen->ShakeEnd();
			break;
	}

	return true;
}

bool Game_Interpreter::CommandWeatherEffects(lcf::rpg::EventCommand const& com) { // code 11070
	Game_Screen* screen = Main_Data::game_screen.get();
	int type = com.parameters[0];
	int str = com.parameters[1];
	// Few games use a greater strength value to achieve more intense but glitchy weather
	int strength = std::min(str, 2);

	if (!Player::IsRPG2k3Commands() && type > 2) {
		type = 0;
	}

	screen->SetWeatherEffect(type, strength);
	return true;
}


// PicPointerPatch handling.
// See http://cherrytree.at/cms/download/?did=19
namespace PicPointerPatch {

	static void AdjustId(int& pic_id) {
		if (pic_id > 10000) {
			int new_id;
			if (pic_id > 50000) {
				new_id = Main_Data::game_variables->Get(pic_id - 50000);
			} else {
				new_id = Main_Data::game_variables->Get(pic_id - 10000);
			}

			if (new_id > 0) {
				Output::Debug("PicPointer: ID {} replaced with ID {}", pic_id, new_id);
				pic_id = new_id;
			}
		}
	}

	static void AdjustParams(Game_Pictures::Params& params) {
		if (params.magnify_width > 10000) {
			int new_magnify = Main_Data::game_variables->Get(params.magnify_width - 10000);
			Output::Debug("PicPointer: Zoom {} replaced with {}", params.magnify_width, new_magnify);
			params.magnify_width = new_magnify;
			params.magnify_height = new_magnify;
		}

		if (params.top_trans > 10000) {
			int new_top_trans = Main_Data::game_variables->Get(params.top_trans - 10000);
			Output::Debug("PicPointer: Top transparency {} replaced with {}", params.top_trans, new_top_trans);
			params.top_trans = new_top_trans;
		}

		if (params.bottom_trans > 10000) {
			int new_bottom_trans = Main_Data::game_variables->Get(params.bottom_trans - 10000);
			Output::Debug("PicPointer: Bottom transparency {} replaced with {}", params.bottom_trans, new_bottom_trans);
			params.bottom_trans = new_bottom_trans;
		}
	}

	static std::string ReplaceName(const std::string& str, int value, int digits) {
		// Replace last 4 characters with 0-padded pic_num
		std::u32string u_pic_name = Utils::DecodeUTF32(str);

		// Out of bounds test
		if ((int)u_pic_name.length() < digits) {
			return str;
		}

		// No substitution required
		if (digits == 0) {
			return str;
		}

		std::string new_pic_name = Utils::EncodeUTF(u_pic_name.substr(0, u_pic_name.size() - digits));
		std::stringstream ss;
		ss << new_pic_name << std::setfill('0') << std::setw(digits) << value;
		new_pic_name = ss.str();

		if (!Player::IsRPG2k3ECommands()) {
			// Prevent debug messages because this function is used by ShowPicture of RPG2k3E
			Output::Debug("PicPointer: File {} replaced with {}", str, new_pic_name);
		}
		return new_pic_name;
	}

	static void AdjustShowParams(int& pic_id, Game_Pictures::ShowParams& params) {
		// Adjust name
		if (pic_id >= 50000) {
			// Name substitution is pic_id + 1
			int pic_num = Main_Data::game_variables->Get(pic_id - 50000 + 1);

			if (pic_num >= 0) {
				params.name = ReplaceName(params.name, pic_num, 4);
			}
		}

		AdjustId(pic_id);
		AdjustParams(params);
	}

	static void AdjustMoveParams(int& pic_id, Game_Pictures::MoveParams& params) {
		AdjustId(pic_id);
		AdjustParams(params);

		if (params.duration > 10000) {
			int new_duration = Main_Data::game_variables->Get(params.duration - 10000);
			Output::Debug("PicPointer: Move duration {} replaced with {}", params.duration, new_duration);
			params.duration = new_duration;
		}
	}

}

bool Game_Interpreter::CommandShowPicture(lcf::rpg::EventCommand const& com) { // code 11110
	// Older versions of RPG_RT block pictures when message active.
	if (!Player::IsEnglish() && !Player::IsPatchUnlockPics() && Game_Message::IsMessageActive()) {
		return false;
	}

	int pic_id = com.parameters[0];

	Game_Pictures::ShowParams params = {};
	params.name = ToString(com.string);
	// Maniac Patch uses the upper bits for X/Y origin, mask it away
	int pos_mode = ManiacBitmask(com.parameters[1], 0xFF);
	params.position_x = ValueOrVariable(pos_mode, com.parameters[2]);
	params.position_y = ValueOrVariable(pos_mode, com.parameters[3]);
	params.fixed_to_map = com.parameters[4] > 0;
	params.magnify_width = com.parameters[5];
	params.magnify_height = params.magnify_width;
	params.use_transparent_color = com.parameters[7] > 0;
	params.top_trans = com.parameters[6];
	params.red = com.parameters[8];
	params.green = com.parameters[9];
	params.blue = com.parameters[10];
	params.saturation = com.parameters[11];
	params.effect_mode = com.parameters[12];
	params.effect_power = com.parameters[13];

	size_t param_size = com.parameters.size();

	if (param_size > 14) {
		// RPG2k3 sets this chunk. Versions < 1.12 let you specify separate top and bottom
		// transparency. >= 1.12 Editor only let you set one transparency field but it affects
		// both chunks here.
		// Maniac Patch uses the upper bits for flags, mask it away
		params.bottom_trans = ManiacBitmask(com.parameters[14], 0xFF);
	} else if (Player::IsRPG2k3() && !Player::IsRPG2k3E()) {
		// Corner case when 2k maps are used in 2k3 (pre-1.10) and don't contain this chunk
		params.bottom_trans = params.top_trans;
	}

	if (param_size > 16 && (Player::IsRPG2k3ECommands() || Player::IsPatchManiac())) {
		if (param_size < 30) {
			// Ensure correct size
			return CmdSetup<&Game_Interpreter::CommandShowPicture, 30>(com);
		}

		// Handling of RPG2k3 1.12 chunks
		if (Player::IsPatchManiac()) {
			pic_id = ValueOrVariableBitfield(com.parameters[17], 0, pic_id);
			params.name = ToString(CommandStringOrVariableBitfield(com, 17, 2, 30));
		} else {
			pic_id = ValueOrVariable(com.parameters[17], pic_id);
		}
		if (com.parameters[19] != 0) {
			int var = 0;
			if (Main_Data::game_variables->IsValid(com.parameters[19])) {
				var = Main_Data::game_variables->Get(com.parameters[19]);
			}
			params.name = PicPointerPatch::ReplaceName(params.name, var, com.parameters[18]);
		}

		if (Player::IsPatchManiac()) {
			// Color tint using variables
			params.red = ValueOrVariableBitfield(com.parameters[17], 3, params.red);
			params.green = ValueOrVariableBitfield(com.parameters[17], 3,  params.green);
			params.blue = ValueOrVariableBitfield(com.parameters[17], 3, params.blue);
			params.saturation = ValueOrVariableBitfield(com.parameters[17], 3,  params.saturation);
		}

		params.magnify_width = ValueOrVariableBitfield(com.parameters[20], 0, params.magnify_width);
		if (Player::IsPatchManiac() && com.parameters.size() > 31 && com.parameters[20] >= 16) {
			// The >= 16 check is needed because this bit is set when independent width/height scaling is used
			// Since version 240423, Maniacs supports width/height scaling for special effects pictures.
			params.magnify_height = ValueOrVariableBitfield((com.parameters[20] >> 1), 1, com.parameters[31]);
		} else {
			params.magnify_height = params.magnify_width;
		}

		params.top_trans = ValueOrVariable(com.parameters[21], params.top_trans);
		if (com.parameters[22] > 0) {
			// If spritesheet is enabled
			params.spritesheet_cols = com.parameters[22];
			params.spritesheet_rows = com.parameters[23];

			// Animate and index selection are exclusive
			if (com.parameters[24] == 2) {
				params.spritesheet_speed = com.parameters[25];
				params.spritesheet_play_once = com.parameters[26];
			} else {
				// Picture data / LSD data frame number is 0 based, while event parameter counts from 1.
				params.spritesheet_frame = ValueOrVariable(com.parameters[24], com.parameters[25]) - 1;
			}
		}

		params.map_layer = com.parameters[27];
		params.battle_layer = com.parameters[28];
		params.flags = com.parameters[29];

		if (Player::IsPatchManiac()) {
			int flags = com.parameters[14] >> 8;
			int blend_mode = flags & 3;
			if (blend_mode == 1) {
				params.blend_mode = (int)Bitmap::BlendMode::Multiply;
			} else if (blend_mode == 2) {
				params.blend_mode = (int)Bitmap::BlendMode::Additive;
			} else if (blend_mode == 3) {
				params.blend_mode = (int)Bitmap::BlendMode::Overlay;
			}
			params.flip_x = (flags & 16) == 16;
			params.flip_y = (flags & 32) == 32;
			params.origin = com.parameters[1] >> 8;

			if (params.effect_mode == lcf::rpg::SavePicture::Effect_maniac_fixed_angle) {
				params.effect_power = ValueOrVariableBitfield(com.parameters[16], 0, params.effect_power);
				int divisor = ValueOrVariableBitfield(com.parameters[16], 1, com.parameters[15]);
				if (divisor == 0) {
					divisor = 1;
				}
				params.effect_power /= divisor;
			}
		}
	}

	PicPointerPatch::AdjustShowParams(pic_id, params);

	// Sanitize input
	params.magnify_width = std::max(0, std::min(params.magnify_width, 2000));
	params.magnify_height = std::max(0, std::min(params.magnify_height, 2000));
	params.top_trans = std::max(0, std::min(params.top_trans, 100));
	params.bottom_trans = std::max(0, std::min(params.bottom_trans, 100));

	if (pic_id <= 0) {
		Output::Error("ShowPicture: Requested invalid picture id ({})", pic_id);
	}

	// RPG_RT will crash if you ask for a picture id greater than the limit that
	// version of the engine allows. We allow an arbitrary number of pictures in Player.

	if (Main_Data::game_pictures->Show(pic_id, params)) {
		if (params.origin > 0) {
			auto& pic = Main_Data::game_pictures->GetPicture(pic_id);
			if (pic.IsRequestPending()) {
				pic.MakeRequestImportant();
				_async_op = AsyncOp::MakeYield();
			}
		}
	}

	return true;
}

bool Game_Interpreter::CommandMovePicture(lcf::rpg::EventCommand const& com) { // code 11120
	// Older versions of RPG_RT block pictures when message active.
	if (!Player::IsEnglish() && !Player::IsPatchUnlockPics() && Game_Message::IsMessageActive()) {
		return false;
	}

	int pic_id = com.parameters[0];

	Game_Pictures::MoveParams params;
	// Maniac Patch uses the upper bits for X/Y origin, mask it away
	int pos_mode = ManiacBitmask(com.parameters[1], 0xFF);
	params.position_x = ValueOrVariable(pos_mode, com.parameters[2]);
	params.position_y = ValueOrVariable(pos_mode, com.parameters[3]);
	params.magnify_width = com.parameters[5];
	params.magnify_height = params.magnify_width;
	params.top_trans = com.parameters[6];
	params.red = com.parameters[8];
	params.green = com.parameters[9];
	params.blue = com.parameters[10];
	params.saturation = com.parameters[11];
	params.effect_mode = com.parameters[12];
	params.effect_power = com.parameters[13];
	params.duration = com.parameters[14];

	struct {
		bool wait = false;
		// Starting from here are Maniac Extensions
		// TODO: The extensions are not implemented
		bool relative = false; // new position is relative to current
		// when true these values preserve the values from a previous Show/MovePicture call
		bool preserve_tone = false;
		bool preserve_effect_mode = false;
		bool preserve_blend_mode = false;
		bool preserve_flip = false;
		bool preserve_duration = false;
		// Coordinates consider the scaled picture (when the origin is not centered)
		bool position_scaled = false;
	} options;

	if (Player::IsPatchManiac()) {
		int opts = com.parameters[15];
		options.wait = (opts & (1 << 0)) > 0;
		options.relative = (opts & (1 << 1)) > 0;
		options.preserve_tone = (opts & (1 << 2)) > 0;
		options.preserve_effect_mode = (opts & (1 << 3)) > 0;
		options.preserve_blend_mode = (opts & (1 << 4)) > 0;
		options.preserve_flip = (opts & (1 << 5)) > 0;
		options.preserve_duration = (opts & (1 << 6)) > 0;
		// Bit 7 is unused
		options.position_scaled = (opts & (1 << 8)) > 0;
	} else {
		options.wait = com.parameters[15] != 0;
	}

	size_t param_size = com.parameters.size();

	if (Player::IsRPG2k() || Player::IsRPG2k3E() || Player::IsPatchManiac()) {
		if (param_size > 17 && (Player::IsRPG2k3ECommands() || Player::IsPatchManiac())) {
			if (param_size < 22) {
				// Ensure correct size
				return CmdSetup<&Game_Interpreter::CommandMovePicture, 22>(com);
			}

			// Handling of RPG2k3 1.12 chunks
			// Maniac Patch uses the upper bits for "wait is variable", mask it away
			pic_id = ValueOrVariable(ManiacBitmask(com.parameters[17], 0xFF), pic_id);
			// Currently unused by RPG Maker
			//int chars_to_replace = com.parameters[18];
			//int replace_with = com.parameters[19];

			if (com.parameters[17] >= 4096 && Player::IsPatchManiac()) {
				// Color tint using variables
				params.red = ValueOrVariableBitfield(com.parameters[17], 3, params.red);
				params.green = ValueOrVariableBitfield(com.parameters[17], 3,  params.green);
				params.blue = ValueOrVariableBitfield(com.parameters[17], 3, params.blue);
				params.saturation = ValueOrVariableBitfield(com.parameters[17], 3,  params.saturation);
			}

			params.magnify_width = ValueOrVariableBitfield(com.parameters[20], 0, params.magnify_width);

			if (Player::IsPatchManiac() && com.parameters.size() > 20 && com.parameters[20] >= 16) {
				// The >= 16 check is needed because this bit is set when independent width/height scaling is used
				// Since version 240423, Maniacs supports width/height scaling for special effects pictures.
				params.magnify_height = ValueOrVariableBitfield((com.parameters[20] >> 1), 1, com.parameters[18]);
			} else {
				params.magnify_height = params.magnify_width;
			}

			params.top_trans = ValueOrVariable(com.parameters[21], params.top_trans);
		}

		// RPG2k and RPG2k3 1.10 do not support this option
		params.bottom_trans = params.top_trans;

		if (Player::IsPatchManiac() && param_size > 16) {
			int flags = com.parameters[16] >> 8;
			int blend_mode = flags & 3;
			if (blend_mode == 1) {
				params.blend_mode = (int)Bitmap::BlendMode::Multiply;
			} else if (blend_mode == 2) {
				params.blend_mode = (int)Bitmap::BlendMode::Additive;
			} else if (blend_mode == 3) {
				params.blend_mode = (int)Bitmap::BlendMode::Overlay;
			}

			if (param_size > 17) {
				params.duration = ValueOrVariableBitfield(com.parameters[17], 2, params.duration);
			}
			params.flip_x = (flags & 16) == 16;
			params.flip_y = (flags & 32) == 32;
			params.origin = com.parameters[1] >> 8;

			if (params.effect_mode == lcf::rpg::SavePicture::Effect_maniac_fixed_angle) {
				params.effect_power = ValueOrVariableBitfield(com.parameters[4], 0, params.effect_power);
				int divisor = ValueOrVariableBitfield(com.parameters[4], 1, com.parameters[7]);
				if (divisor == 0) {
					divisor = 1;
				}
				params.effect_power /= divisor;
			}
		}
	} else {
		// Corner case when 2k maps are used in 2k3 (pre-1.10) and don't contain this chunk
		params.bottom_trans = param_size > 16 ? com.parameters[16] : params.top_trans;
	}

	PicPointerPatch::AdjustMoveParams(pic_id, params);

	// Sanitize input
	params.magnify_width = std::max(0, std::min(params.magnify_width, 2000));
	params.magnify_height = std::max(0, std::min(params.magnify_height, 2000));
	params.top_trans = std::max(0, std::min(params.top_trans, 100));
	params.bottom_trans = std::max(0, std::min(params.bottom_trans, 100));
	params.duration = std::max(Player::IsPatchManiac() ? -10000 : 0, std::min(params.duration, 10000));

	if (pic_id <= 0) {
		Output::Error("MovePicture: Requested invalid picture id ({})", pic_id);
	}

	Main_Data::game_pictures->Move(pic_id, params);

	if (params.origin > 0) {
		auto& pic = Main_Data::game_pictures->GetPicture(pic_id);
		if (pic.IsRequestPending()) {
			pic.MakeRequestImportant();
			_async_op = AsyncOp::MakeYield();
		}
	}

	if (options.wait)
		SetupWait(params.duration);

	return true;
}

bool Game_Interpreter::CommandErasePicture(lcf::rpg::EventCommand const& com) { // code 11130
	// Older versions of RPG_RT block pictures when message active.
	if (!Player::IsEnglish() && !Player::IsPatchUnlockPics() && Game_Message::IsMessageActive()) {
		return false;
	}

	int pic_id = com.parameters[0];

	if (com.parameters.size() > 1 && Player::IsRPG2k3ECommands()) {
		// Handling of RPG2k3 1.12 chunks
		int id_type = com.parameters[1];

		int pic_id_max = 0;
		switch (id_type) {
			case 0:
				// Erase single picture specified by constant
			case 1:
				// Erase single picture referenced by variable
				pic_id = ValueOrVariable(id_type, pic_id);
				pic_id_max = pic_id;
				break;
			case 2:
				// Erase [Arg0, Arg2]
				if (com.parameters.size() > 2) {
					pic_id_max = com.parameters[2];
				}
				break;
			case 3:
				// Erase [V[Arg0], V[Arg2]]
				if (!Player::IsPatchManiac()) {
					return true;
				}
				pic_id = Main_Data::game_variables->Get(pic_id);
				if (com.parameters.size() > 2) {
					pic_id_max = Main_Data::game_variables->Get(com.parameters[2]);
				}
				break;
			case 4:
				// Erase single picture referenced by variable indirect
				if (!Player::IsPatchManiac()) {
					return true;
				}
				pic_id = Main_Data::game_variables->GetIndirect(pic_id);
				pic_id_max = pic_id;
				break;
			case 5:
				// Erase all pictures
				if (!Player::IsPatchManiac()) {
					return true;
				}
				Main_Data::game_pictures->EraseAll();
				return true;
			default:
				return true;
		}

		for (int i = pic_id; i <= pic_id_max; ++i) {
			if (i <= 0) {
				Output::Error("ErasePicture: Requested invalid picture id ({})", i);
			}

			Main_Data::game_pictures->Erase(i);
		}
	} else {
		PicPointerPatch::AdjustId(pic_id);

		if (pic_id <= 0) {
			Output::Error("ErasePicture: Requested invalid picture id ({})", pic_id);
		}

		Main_Data::game_pictures->Erase(pic_id);
	}

	return true;
}

bool Game_Interpreter::CommandPlayerVisibility(lcf::rpg::EventCommand const& com) { // code 11310
	bool hidden = (com.parameters[0] == 0);
	Game_Character* player = Main_Data::game_player.get();
	player->SetSpriteHidden(hidden);
	// RPG_RT does this here.
	player->ResetThrough();

	return true;
}

bool Game_Interpreter::CommandMoveEvent(lcf::rpg::EventCommand const& com) { // code 11330
	int event_id = ValueOrVariableBitfield(com.parameters[2], 2, com.parameters[0]);
	int repeat = ManiacBitmask(com.parameters[2], 0x1);

	Game_Character* event = GetCharacter(event_id, "MoveEvent");
	if (event != NULL) {
		// If the event is a vehicle in use, push the commands to the player instead
		if (event_id >= Game_Character::CharBoat && event_id <= Game_Character::CharAirship)
			if (static_cast<Game_Vehicle*>(event)->IsInUse())
				event = Main_Data::game_player.get();

		lcf::rpg::MoveRoute route;
		int move_freq = com.parameters[1];

		if (move_freq <= 0 || move_freq > 8) {
			// Invalid values
			move_freq = 6;
		}

		route.repeat = repeat != 0;
		route.skippable = com.parameters[3] != 0;

		for (auto it = com.parameters.begin() + 4; it < com.parameters.end(); ) {
			route.move_commands.push_back(DecodeMove(it));
		}

		event->ForceMoveRoute(route, move_freq);
	}
	return true;
}

bool Game_Interpreter::CommandMemorizeBGM(lcf::rpg::EventCommand const& /* com */) { // code 11530
	Main_Data::game_system->MemorizeBGM();
	return true;
}

bool Game_Interpreter::CommandPlayMemorizedBGM(lcf::rpg::EventCommand const& /* com */) { // code 11540
	Main_Data::game_system->PlayMemorizedBGM();
	return true;
}

int Game_Interpreter::KeyInputState::CheckInput() const {
	auto check = wait ? Input::IsTriggered : Input::IsPressed;

	// Mouse buttons checked first (Maniac checks them last) to prevent conflict
	// when DECISION is mapped to MOUSE_LEFT
	// The order of checking matches the Maniac behaviour
	if (keys[Keys::eMouseScrollDown] && check(Input::SCROLL_DOWN)) {
		return 1001;
	}

	if (keys[Keys::eMouseScrollUp] && check(Input::SCROLL_UP)) {
		return 1004;
	}

	if (keys[Keys::eMouseMiddle] && check(Input::MOUSE_MIDDLE)) {
		return 1007;
	}

	if (keys[Keys::eMouseRight] && check(Input::MOUSE_RIGHT)) {
		return 1006;
	}

	if (keys[Keys::eMouseLeft] && check(Input::MOUSE_LEFT)) {
		return 1005;
	}

	// RPG processes keys from highest variable value to lowest.
	if (keys[Keys::eOperators]) {
		for (int i = 5; i > 0;) {
			--i;
			if (check((Input::InputButton)(Input::PLUS + i))) {
				return 20 + i;
			}
		}
	}
	if (keys[Keys::eNumbers]) {
		for (int i = 10; i > 0;) {
			--i;
			if (check((Input::InputButton)(Input::N0 + i))) {
				return 10 + i;
			}
		}
	}

	if (keys[Keys::eShift] && check(Input::SHIFT)) {
		return 7;
	}
	if (keys[Keys::eCancel] && check(Input::CANCEL)) {
		return 6;
	}
	if (keys[Keys::eDecision] && check(Input::DECISION)) {
		return 5;
	}
	if (keys[Keys::eUp] && check(Input::UP)) {
		return 4;
	}
	if (keys[Keys::eRight] && check(Input::RIGHT)) {
		return 3;
	}
	if (keys[Keys::eLeft] && check(Input::LEFT)) {
		return 2;
	}
	if (keys[Keys::eDown] && check(Input::DOWN)) {
		return 1;
	}

	return 0;
}

bool Game_Interpreter::CommandKeyInputProc(lcf::rpg::EventCommand const& com) { // code 11610
	int var_id = com.parameters[0];
	bool wait = com.parameters[1] != 0;

	if (wait) {
		// While waiting the variable is reset to 0 each frame.
		Main_Data::game_variables->Set(var_id, 0);
		Game_Map::SetNeedRefreshForVarChange(var_id);
	}

	if (wait && Game_Message::IsMessageActive()) {
		return false;
	}

	_keyinput = {};
	_keyinput.wait = wait;
	_keyinput.variable = var_id;

	const size_t param_size = com.parameters.size();

	// Maniac Patch aware check functions for parameters that handle
	// keyboard and mouse through a bitmask
	bool is_maniac = Player::IsPatchManiac();
	auto check_key = [&](auto idx, bool handle_maniac = false) {
		if (param_size <= idx) {
			return false;
		}
		if (handle_maniac && is_maniac) {
			return (com.parameters[idx] & 1) != 0;
		} else {
			return com.parameters[idx] != 0;
		}
	};

	_keyinput.keys[Keys::eDecision] = check_key(3u, true);
	_keyinput.keys[Keys::eCancel] = check_key(4u, true);

	// All engines support older versions of the command depending on the
	// length of the parameter list
	if (Player::IsRPG2k()) {
		if (param_size < 6 || Player::IsRPG2kLegacy()) {
			// For Rpg2k <1.50 (later versions got individual key checks)
			if (com.parameters[2] != 0) {
				_keyinput.keys[Keys::eDown] = true;
				_keyinput.keys[Keys::eLeft] = true;
				_keyinput.keys[Keys::eRight] = true;
				_keyinput.keys[Keys::eUp] = true;
			}
		} else {
			// For Rpg2k >=1.50
			_keyinput.keys[Keys::eShift] = com.parameters[5] != 0;
			_keyinput.keys[Keys::eDown] = check_key(6u);
			_keyinput.keys[Keys::eLeft] = check_key(7u);
			_keyinput.keys[Keys::eRight] = check_key(8u);
			_keyinput.keys[Keys::eUp] = check_key(9u);
		}
	} else {
		if (param_size != 10 || Player::IsRPG2k3Legacy()) {
			if ((param_size < 10 || Player::IsRPG2k3Legacy()) && com.parameters[2] != 0) {
				// For RPG2k3 <1.05 (later versions got individual key checks)
				_keyinput.keys[Keys::eDown] = true;
				_keyinput.keys[Keys::eLeft] = true;
				_keyinput.keys[Keys::eRight] = true;
				_keyinput.keys[Keys::eUp] = true;
			}
			_keyinput.keys[Keys::eNumbers] = check_key(5u);
			_keyinput.keys[Keys::eOperators] = check_key(6u);
			_keyinput.time_variable = param_size > 7 ? com.parameters[7] : 0; // Attention: int, not bool
			_keyinput.timed = check_key(8u);
			if (param_size > 10 && Player::IsMajorUpdatedVersion()) {
				// For Rpg2k3 >=1.05
				// ManiacPatch Middle & Wheel only handled for 2k3 Major Updated,
				// the only version that has this patch
				_keyinput.keys[Keys::eShift] = check_key(9u, true);
				_keyinput.keys[Keys::eDown] = check_key(10u, true);
				_keyinput.keys[Keys::eLeft] = check_key(11u);
				_keyinput.keys[Keys::eRight] = check_key(12u);
				_keyinput.keys[Keys::eUp] = check_key(13u, true);
			}
		} else {
			// Since RPG2k3 1.05
			// Support for RPG2k >=1.50 games imported into RPG2k3
			_keyinput.keys[Keys::eShift] = check_key(5u);
			_keyinput.keys[Keys::eDown] = check_key(6u);
			_keyinput.keys[Keys::eLeft] = check_key(7u);
			_keyinput.keys[Keys::eRight] = check_key(8u);
			_keyinput.keys[Keys::eUp] = check_key(9u);
		}
	}

	if (is_maniac) {
		auto check_mouse = [&](auto idx) {
			if (param_size <= idx) {
				return false;
			}

			bool result = (com.parameters[idx] & 2) != 0;
#if !defined(USE_MOUSE_OR_TOUCH) || !defined(SUPPORT_MOUSE_OR_TOUCH)
			if (result) {
				Output::Warning("ManiacPatch: Mouse input is not supported on this platform");
				result = false;
			}
#endif
			return result;
		};
		_keyinput.keys[Keys::eMouseLeft] = check_mouse(3u);
		_keyinput.keys[Keys::eMouseRight] = check_mouse(4u);
		_keyinput.keys[Keys::eMouseMiddle] = check_mouse(9u);
		_keyinput.keys[Keys::eMouseScrollDown] = check_mouse(10u);
		_keyinput.keys[Keys::eMouseScrollUp] = check_mouse(13u);
	}

	if (_keyinput.wait) {
		// RPG_RT will reset all trigger key states when a waiting key input proc command is executed,
		// which means we always wait at least 1 frame to continue. Keys which are held down are not reset.
		// This also prevents player actions for this frame such as summoning the menu or triggering events.
		Input::ResetTriggerKeys();
		return true;
	}

	int key = _keyinput.CheckInput();
	Main_Data::game_variables->Set(_keyinput.variable, key);
	Game_Map::SetNeedRefreshForVarChange(_keyinput.variable);

	return true;
}

bool Game_Interpreter::CommandChangeMapTileset(lcf::rpg::EventCommand const& com) { // code 11710
	int chipset_id = com.parameters[0];

	if (chipset_id == Game_Map::GetChipset()) {
		return true;
	}

	Game_Map::SetChipset(chipset_id);

	Scene_Map* scene = (Scene_Map*)Scene::Find(Scene::Map).get();

	if (!scene)
		return true;

	scene->spriteset->ChipsetUpdated();

	return true;
}

bool Game_Interpreter::CommandChangePBG(lcf::rpg::EventCommand const& com) { // code 11720
	Game_Map::Parallax::Params params;
	params.name = ToString(com.string);
	params.scroll_horz = com.parameters[0] != 0;
	params.scroll_vert = com.parameters[1] != 0;
	params.scroll_horz_auto = com.parameters[2] != 0;
	params.scroll_horz_speed = com.parameters[3];
	params.scroll_vert_auto = com.parameters[4] != 0;
	params.scroll_vert_speed = com.parameters[5];

	Game_Map::Parallax::ChangeBG(params);

	if (!params.name.empty()) {
		if (!AsyncHandler::RequestFile("Panorama", params.name)->IsReady()) {
			_async_op = AsyncOp::MakeYield();
		}
	}

	return true;
}

bool Game_Interpreter::CommandChangeEncounterSteps(lcf::rpg::EventCommand const& com) { // code 11740
	int steps = com.parameters[0];

	Game_Map::SetEncounterSteps(steps);

	return true;
}

bool Game_Interpreter::CommandTileSubstitution(lcf::rpg::EventCommand const& com) { // code 11750
	bool upper = com.parameters[0] != 0;
	int old_id = com.parameters[1];
	int new_id = com.parameters[2];
	Scene_Map* scene = (Scene_Map*)Scene::Find(Scene::Map).get();
	if (!scene)
		return true;

	if (upper)
		scene->spriteset->SubstituteUp(old_id, new_id);
	else
		scene->spriteset->SubstituteDown(old_id, new_id);

	return true;
}

bool Game_Interpreter::CommandTeleportTargets(lcf::rpg::EventCommand const& com) { // code 11810
	int map_id = com.parameters[1];

	if (com.parameters[0] != 0) {
		Main_Data::game_targets->RemoveTeleportTarget(map_id);
		return true;
	}

	int x = com.parameters[2];
	int y = com.parameters[3];
	bool switch_on = static_cast<bool>(com.parameters[4]);
	int switch_id = com.parameters[5];
	Main_Data::game_targets->AddTeleportTarget(map_id, x, y, switch_on, switch_id);
	return true;
}

bool Game_Interpreter::CommandChangeTeleportAccess(lcf::rpg::EventCommand const& com) { // code 11820
	Main_Data::game_system->SetAllowTeleport(com.parameters[0] != 0);
	return true;
}

bool Game_Interpreter::CommandEscapeTarget(lcf::rpg::EventCommand const& com) { // code 11830
	int map_id = com.parameters[0];
	int x = com.parameters[1];
	int y = com.parameters[2];
	bool switch_on = static_cast<bool>(com.parameters[3]);
	int switch_id = com.parameters[4];
	Main_Data::game_targets->SetEscapeTarget(map_id, x, y, switch_on, switch_id);
	return true;
}

bool Game_Interpreter::CommandChangeEscapeAccess(lcf::rpg::EventCommand const& com) { // code 11840
	Main_Data::game_system->SetAllowEscape(com.parameters[0] != 0);
	return true;
}

bool Game_Interpreter::CommandChangeSaveAccess(lcf::rpg::EventCommand const& com) { // code 11930
	Main_Data::game_system->SetAllowSave(com.parameters[0] != 0);
	return true;
}

bool Game_Interpreter::CommandChangeMainMenuAccess(lcf::rpg::EventCommand const& com) { // code 11960
	Main_Data::game_system->SetAllowMenu(com.parameters[0] != 0);
	return true;
}

bool Game_Interpreter::CommandConditionalBranch(lcf::rpg::EventCommand const& com) { // Code 12010
	const auto& frame = GetFrame();

	bool result = false;
	int value1, value2;
	int actor_id;
	Game_Actor* actor;
	Game_Character* character;

	switch (com.parameters[0]) {
	case 0:
		// Switch
		result = Main_Data::game_switches->Get(com.parameters[1]) == (com.parameters[2] == 0);
		break;
	case 1:
		// Variable
		value1 = Main_Data::game_variables->Get(com.parameters[1]);
		value2 = ValueOrVariable(com.parameters[2], com.parameters[3]);
		result = CheckOperator(value1, value2, com.parameters[4]);
		break;
	case 2:
		value1 = Main_Data::game_party->GetTimerSeconds(Main_Data::game_party->Timer1);
		value2 = com.parameters[1];
		switch (com.parameters[2]) {
		case 0:
			result = (value1 >= value2);
			break;
		case 1:
			result = (value1 <= value2);
			break;
		}
		break;
	case 3:
		// Gold
		if (com.parameters[2] == 0) {
			// Greater than or equal
			result = (Main_Data::game_party->GetGold() >= com.parameters[1]);
		} else {
			// Less than or equal
			result = (Main_Data::game_party->GetGold() <= com.parameters[1]);
		}
		break;
	case 4: {
		// Item
		int item_id = com.parameters[1];

		if (Player::IsPatchManiac()) {
			item_id = ValueOrVariable(com.parameters[3], item_id);
		}

		if (com.parameters[2] == 0) {
			// Having
			result = Main_Data::game_party->GetItemCount(item_id)
				+ Main_Data::game_party->GetEquippedItemCount(item_id) > 0;
		} else {
			// Not having
			result = Main_Data::game_party->GetItemCount(item_id)
				+ Main_Data::game_party->GetEquippedItemCount(item_id) == 0;
		}
		break;
	}
	case 5:
		// Hero
		actor_id = com.parameters[1];

		if (Player::IsPatchManiac()) {
			actor_id = ValueOrVariable(com.parameters[4], actor_id);
		}

		actor = Main_Data::game_actors->GetActor(actor_id);

		if (!actor) {
			Output::Warning("ConditionalBranch: Invalid actor ID {}", actor_id);
			// Use Else Branch
			SetSubcommandIndex(com.indent, 1);
			SkipToNextConditional({Cmd::ElseBranch, Cmd::EndBranch}, com.indent);
			return true;
		}

		switch (com.parameters[2]) {
		case 0:
			// Is actor in party
			result = Main_Data::game_party->IsActorInParty(actor_id);
			RuntimePatches::EXPlus::StoreActorPosition(actor_id);
			break;
		case 1:
			// Name
			result = (actor->GetName() == com.string);
			break;
		case 2:
			// Higher or equal level
			result = (actor->GetLevel() >= com.parameters[3]);
			break;
		case 3:
			// Higher or equal HP
			result = (actor->GetHp() >= com.parameters[3]);
			break;
		case 4:
			// Is skill learned
			result = (actor->IsSkillLearned(com.parameters[3]));
			break;
		case 5:
			// Equipped object
			result = (
				(actor->GetShieldId() == com.parameters[3]) ||
				(actor->GetArmorId() == com.parameters[3]) ||
				(actor->GetHelmetId() == com.parameters[3]) ||
				(actor->GetAccessoryId() == com.parameters[3]) ||
				(actor->GetWeaponId() == com.parameters[3])
				);
			break;
		case 6:
			// Has state
			result = (actor->HasState(com.parameters[3]));
			break;
		default:
			;
		}
		break;
	case 6: {
		// Orientation of char
		int chara_id = com.parameters[1];

		if (Player::IsPatchManiac()) {
			chara_id = ValueOrVariable(com.parameters[3], chara_id);
		}

		character = GetCharacter(chara_id, "ConditionalBranch");
		if (character != NULL) {
			result = character->GetFacing() == com.parameters[2];
		}
		break;
	}
	case 7: {
		// Vehicle in use
		Game_Vehicle::Type vehicle_id = (Game_Vehicle::Type) (com.parameters[1] + 1);
		Game_Vehicle* vehicle = Game_Map::GetVehicle(vehicle_id);

		if (!vehicle) {
			Output::Warning("ConditionalBranch: Invalid vehicle ID {}", static_cast<int>(vehicle_id));
			return true;
		}

		result = vehicle->IsInUse();
		break;
	}
	case 8:
		// Key decision initiated this event
		result = frame.triggered_by_decision_key;
		break;
	case 9:
		// BGM looped at least once
		result = Main_Data::game_system->BgmPlayedOnce();
		break;
	case 10:
		if (Player::IsRPG2k3Commands()) {
			value1 = Main_Data::game_party->GetTimerSeconds(Main_Data::game_party->Timer2);
			value2 = com.parameters[1];
			switch (com.parameters[2]) {
				case 0:
					result = (value1 >= value2);
					break;
				case 1:
					result = (value1 <= value2);
					break;
			}
		}
		break;
	case 11:
		// RPG Maker 2003 v1.11 features
		if (Player::IsRPG2k3ECommands()) {
			switch (com.parameters[1]) {
				case 0:
					// Any savestate available
					result = FileFinder::HasSavegame();
					break;
				case 1:
					// Is Test Play mode?
					result = Player::debug_flag;
					break;
				case 2:
					// Is ATB wait on?
					result = Main_Data::game_system->GetAtbMode() == lcf::rpg::SaveSystem::AtbMode_atb_wait;
					break;
				case 3:
					// Is Fullscreen active?
					result = DisplayUi->IsFullscreen();
					break;
			}
		}
		break;
	case 12:
		// Maniac: Other
		if (Player::IsPatchManiac()) {
			switch (com.parameters[1]) {
				case 0:
					result = Main_Data::game_system->IsLoadedThisFrame();
					break;
				case 1:
					// Joypad is active (We always read from Controller so simply report 'true')
#if defined(USE_JOYSTICK) && defined(SUPPORT_JOYSTICK)
					result = true;
#else
					result = false;
#endif
					break;
				case 2:
					// FIXME: Window has focus. Needs function exposed in DisplayUi
					// Assuming 'true' as Player usually suspends when loosing focus
					result = true;
					break;
			}
		}
		break;
	case 13:
		// Maniac: Switch through Variable
		if (Player::IsPatchManiac()) {
			result = Main_Data::game_switches->Get(Main_Data::game_variables->Get(com.parameters[1])) == (com.parameters[2] == 0);
		}
		break;
	case 14:
		// Maniac: Variable indirect
		if (Player::IsPatchManiac()) {
			value1 = Main_Data::game_variables->GetIndirect(com.parameters[1]);
			value2 = ValueOrVariable(com.parameters[2], com.parameters[3]);
			result = CheckOperator(value1, value2, com.parameters[4]);
		}
		break;
	case 15:
		// Maniac: String comparison
		if (Player::IsPatchManiac()) {
			int modes[] = {
				(com.parameters[1]     ) & 15, //str_l mode: 0 = direct, 1 = indirect
				(com.parameters[1] >> 4) & 15, //str_r mode: 0 = literal, 1 = direct, 2 = indirect
			};

			int op = com.parameters[4] & 3;
			int ignoreCase = com.parameters[4] >> 8 & 1;

			std::string str_param = ToString(com.string);
			std::string_view str_l = Main_Data::game_strings->GetWithMode(str_param, modes[0]+1, com.parameters[2], *Main_Data::game_variables);
			std::string_view str_r = Main_Data::game_strings->GetWithMode(str_param, modes[1], com.parameters[3], *Main_Data::game_variables);
			result = ManiacPatch::CheckString(str_l, str_r, op, ignoreCase);
		}
		break;
	case 16:
		// Maniac: Expression
		result = ManiacPatch::ParseExpression(MakeSpan(com.parameters).subspan(6), *this);
		break;
	default:
		Output::Warning("ConditionalBranch: Branch {} unsupported", com.parameters[0]);
	}

	int sub_idx = subcommand_sentinel;
	if (!result) {
		sub_idx = eOptionBranchElse;
		SkipToNextConditional({Cmd::ElseBranch, Cmd::EndBranch}, com.indent);
	}

	SetSubcommandIndex(com.indent, sub_idx);
	return true;
}


bool Game_Interpreter::CommandElseBranch(lcf::rpg::EventCommand const& com) { //code 22010
	return CommandOptionGeneric(com, eOptionBranchElse, {Cmd::EndBranch});
}

bool Game_Interpreter::CommandEndBranch(lcf::rpg::EventCommand const& /* com */) { //code 22011
	return true;
}

bool Game_Interpreter::CommandJumpToLabel(lcf::rpg::EventCommand const& com) { // code 12120
	auto& frame = GetFrame();
	const auto& list = frame.commands;
	auto& index = frame.current_command;

	int label_id = com.parameters[0];

	for (int idx = 0; (size_t)idx < list.size(); idx++) {
		if (static_cast<Cmd>(list[idx].code) != Cmd::Label)
			continue;
		if (list[idx].parameters.empty() || list[idx].parameters[0] != label_id)
			continue;
		index = idx;
		break;
	}

	return true;
}

bool Game_Interpreter::CommandLoop(lcf::rpg::EventCommand const& com) { // code 12210
	if (!Player::IsPatchManiac() || com.parameters.size() < 5 || com.parameters[0] == 0) {
		// Infinite loop
		return true;
	}

	int type = com.parameters[0];

	auto& frame = GetFrame();
	auto& index = frame.current_command;
	frame.maniac_loop_info.resize((com.indent + 1) * 2);
	frame.maniac_loop_info_size = static_cast<int32_t>(frame.maniac_loop_info.size() / 2);

	int32_t& begin_loop_val = frame.maniac_loop_info[frame.maniac_loop_info.size() - 2];
	int32_t& end_loop_val = frame.maniac_loop_info[frame.maniac_loop_info.size() - 1];
	begin_loop_val = 0;
	end_loop_val = 0;

	int begin_arg = ValueOrVariableBitfield(com.parameters[1], 0, com.parameters[2]);
	int end_arg = ValueOrVariableBitfield(com.parameters[1], 1, com.parameters[3]);
	int op = com.parameters[1] >> 8;

	switch (type) {
		case 1: // X times
			end_loop_val = begin_arg - 1;
			break;
		case 2: // Count up
		case 3: // Count down
			begin_loop_val = begin_arg;
			end_loop_val = end_arg;
			break;
		case 4: // While
		case 5: // Do While
			break;
		default:
			SkipToNextConditional({Cmd::EndLoop}, com.indent);
			++index;
			return true;
	}

	int check_beg = begin_loop_val;
	int check_end = end_loop_val;
	if (type == 4) { // While
		check_beg = ValueOrVariableBitfield(com.parameters[1], 0, com.parameters[2]);
		check_end = ValueOrVariableBitfield(com.parameters[1], 1, com.parameters[3]);
	}

	// Do While (5) always runs the loop at least once
	if (type != 5 && !ManiacCheckContinueLoop(check_beg, check_end, type, op)) {
		SkipToNextConditional({Cmd::EndLoop}, com.indent);
		++index;
	}

	int loop_count_var = com.parameters[4];
	if (loop_count_var > 0) {
		Main_Data::game_variables->Set(loop_count_var, begin_loop_val);
		Game_Map::SetNeedRefreshForVarChange(loop_count_var);
	}

	return true;
}

bool Game_Interpreter::CommandBreakLoop(lcf::rpg::EventCommand const& /* com */) { // code 12220
	auto& frame = GetFrame();
	const auto& list = frame.commands;
	auto& index = frame.current_command;

	// BreakLoop will jump to the end of the event if there is no loop.

	bool has_bug = !Player::IsPatchManiac();
	if (!has_bug) {
		SkipToNextConditional({ Cmd::EndLoop }, list[index].indent - 1);
		++index;
		return true;
	}

	// This emulates an RPG_RT bug where break loop ignores scopes and
	// unconditionally jumps to the next EndLoop command.
	auto pcode = static_cast<Cmd>(list[index].code);
	for (++index; index < (int)list.size(); ++index) {
		if (pcode == Cmd::EndLoop) {
			break;
		}
		pcode = static_cast<Cmd>(list[index].code);
	}

	return true;
}

bool Game_Interpreter::CommandEndLoop(lcf::rpg::EventCommand const& com) { // code 22210
	auto& frame = GetFrame();
	const auto& list = frame.commands;
	auto& index = frame.current_command;

	int indent = com.indent;

	if (Player::IsPatchManiac() && com.parameters.size() >= 5 && com.parameters[0] != 0) {
		int type = com.parameters[0];
		int offset = com.indent * 2;

		if (static_cast<int>(frame.maniac_loop_info.size()) < (offset + 1) * 2) {
			frame.maniac_loop_info.resize((offset + 1) * 2);
			frame.maniac_loop_info_size = frame.maniac_loop_info.size() / 2;
		}

		int32_t& cur_loop_val = frame.maniac_loop_info[offset];
		int32_t& end_loop_val = frame.maniac_loop_info[offset + 1];

		switch (type) {
			case 1: // X times
			case 2: // Count up
			case 4: // While
			case 5: // Do While
				++cur_loop_val;
				break;
			case 3: // Count down
				--cur_loop_val;
				break;
			default:
				++index;
				return true;
		}

		int check_cur = cur_loop_val;
		int check_end = end_loop_val;
		if (type >= 4) {
			// While (4) and Do While (5) fetch variables each loop
			// For the others it is constant
			check_cur = ValueOrVariableBitfield(com.parameters[1], 0, com.parameters[2]);
			check_end = ValueOrVariableBitfield(com.parameters[1], 1, com.parameters[3]);
		}
		int op = com.parameters[1] >> 8;
		if (!ManiacCheckContinueLoop(check_cur, check_end, type, op)) {
			// End loop
			frame.maniac_loop_info.resize(offset);
			frame.maniac_loop_info_size = offset / 2;
			++index;
			return true;
		}

		int loop_count_var = com.parameters[4];
		if (loop_count_var > 0) {
			Main_Data::game_variables->Set(loop_count_var, cur_loop_val);
			Game_Map::SetNeedRefreshForVarChange(loop_count_var);
		}
	}

	// Restart the loop
	for (int idx = index; idx >= 0; idx--) {
		if (list[idx].indent > indent)
			continue;
		if (list[idx].indent < indent)
			return false;
		if (static_cast<Cmd>(list[idx].code) != Cmd::Loop)
			continue;
		index = idx;
		break;
	}

	// Jump past the Cmd::Loop to the first command.
	if (index < (int)frame.commands.size()) {
		++index;
	}

	return true;
}

bool Game_Interpreter::CommandEraseEvent(lcf::rpg::EventCommand const& com) { // code 12320
	int event_id = 0; // default rm values
	bool is_active = 0; // In Vanilla RM event is always itself and it always becomes inactive

	if (Player::IsPatchManiac() && com.parameters.size() >= 3) {
		event_id = ValueOrVariableBitfield(com.parameters[0], 1, com.parameters[2]);
		is_active = com.parameters[1];
	}

	auto& frame = GetFrame();
	auto& index = frame.current_command;

	if (event_id == 0) {
		event_id = GetThisEventId();
	}

	// When a common event and not RPG2k3E engine ignore the call, otherwise
	// operate on last map_event
	if (event_id == 0)
		return true;

	Game_Event* evnt = Game_Map::GetEvent(event_id);
	if (evnt) {
		evnt->SetActive(is_active);

		// Parallel map events shall stop immediately
		if (!main_flag) {
			// When the event was called indirectly from a parallel process
			// event execution continues after a yield.
			// Increment the index for this special case.
			index++;
			return false;
		}
	}

	return true;
}

bool Game_Interpreter::CommandCallEvent(lcf::rpg::EventCommand const& com) { // code 12330
	int evt_id;
	int event_page;

	switch (com.parameters[0]) {
	case 0:
	case 3:
	case 4: { // Common Event
		if (com.parameters[0] == 0) {
			evt_id = com.parameters[1];
		} else if (com.parameters[0] == 3 && Player::IsPatchManiac()) {
			evt_id = Main_Data::game_variables->Get(com.parameters[1]);
		} else if (com.parameters[0] == 4 && Player::IsPatchManiac()) {
			evt_id = Main_Data::game_variables->GetIndirect(com.parameters[1]);
		} else {
			return true;
		}

		Game_CommonEvent* common_event = lcf::ReaderUtil::GetElement(Game_Map::GetCommonEvents(), evt_id);
		if (!common_event) {
			Output::Warning("CallEvent: Can't call invalid common event {}", evt_id);
			return true;
		}

		Push<ExecutionType::Call>(common_event);

		return true;
	}
	case 1: // Map Event
		evt_id = com.parameters[1];
		event_page = com.parameters[2];
		break;
	case 2: // Indirect
		evt_id = Main_Data::game_variables->Get(com.parameters[1]);
		event_page = Main_Data::game_variables->Get(com.parameters[2]);
		break;
	default:
		return true;
	}

	Game_Event* event = static_cast<Game_Event*>(GetCharacter(evt_id, "CallEvent"));
	if (!event) {
		Output::Warning("CallEvent: Can't call non-existent event {}", evt_id);
		return true;
	}

	const lcf::rpg::EventPage* page = event->GetPage(event_page);
	if (!page) {
		Output::Warning("CallEvent: Can't call non-existent page {} of event {}", event_page, evt_id);
		return true;
	}

	Push<ExecutionType::Call, EventType::MapEvent>(page->event_commands, event->GetId(), page->ID);

	return true;
}

bool Game_Interpreter::CommandReturnToTitleScreen(lcf::rpg::EventCommand const& /* com */) { // code 12510
	if (Game_Message::IsMessageActive()) {
		return false;
	}

	_async_op = AsyncOp::MakeToTitle();
	return true;
}

bool Game_Interpreter::CommandChangeClass(lcf::rpg::EventCommand const& com) { // code 1008
	if (!Player::IsRPG2k3Commands()) {
		return true;
	}

	int class_id = com.parameters[2]; // 0: No class, 1+: Specific class
	bool level1 = com.parameters[3] > 0;
	int skill_mode = com.parameters[4]; // no change, replace, add
	int param_mode = com.parameters[5]; // no change, halve, level 1, current level
	bool show_msg = com.parameters[6] > 0;

	if (show_msg && !Game_Message::CanShowMessage(true)) {
		return false;
	}

	PendingMessage pm(Game_Message::CommandCodeInserter);
	pm.SetEnableFace(false);
	pm.SetFromForegroundInterpreter(main_flag);

	const lcf::rpg::Class* cls = lcf::ReaderUtil::GetElement(lcf::Data::classes, class_id);
	if (!cls && class_id != 0) {
		Output::Warning("ChangeClass: Can't change class. Class {} is invalid", class_id);
		return true;
	}

	for (const auto& actor : GetActors(com.parameters[0], com.parameters[1])) {
		int level = level1 ? 1 : actor->GetLevel();
		actor->ChangeClass(class_id, level,
				static_cast<Game_Actor::ClassChangeSkillMode>(skill_mode),
				static_cast<Game_Actor::ClassChangeParamMode>(param_mode),
				show_msg ? &pm : nullptr
				);
	}

	if (CheckGameOver()) {
		return true;
	}

	if (show_msg && pm.IsActive()) {
		ForegroundTextPush(std::move(pm));
	}

	return true;
}

bool Game_Interpreter::CommandChangeBattleCommands(lcf::rpg::EventCommand const& com) { // code 1009
	if (!Player::IsRPG2k3Commands()) {
		return true;
	}

	int cmd_id = com.parameters[2];
	bool add = com.parameters[3] != 0;

	for (const auto& actor : GetActors(com.parameters[0], com.parameters[1])) {
		actor->ChangeBattleCommands(add, cmd_id);
	}

	return true;
}

bool Game_Interpreter::CommandExitGame(lcf::rpg::EventCommand const& /* com */) {
	if (!Player::IsRPG2k3ECommands()) {
		return true;
	}

	if (Game_Message::IsMessageActive()) {
		return false;
	}

	_async_op = AsyncOp::MakeExitGame();
	return true;
}

bool Game_Interpreter::CommandToggleFullscreen(lcf::rpg::EventCommand const& /* com */) {
	if (!Player::IsRPG2k3ECommands()) {
		return true;
	}

	auto cfg = DisplayUi->GetConfig();
	if (!cfg.fullscreen.IsOptionVisible() || cfg.fullscreen.IsLocked()) {
		Output::Debug("ToggleFullscreen: Not supported on this platform");
		return true;
	}

	DisplayUi->ToggleFullscreen();
	return true;
}

bool Game_Interpreter::CommandOpenVideoOptions(lcf::rpg::EventCommand const& /* com */) {
	if (!Player::IsRPG2k3ECommands()) {
		return true;
	}

	auto& frame = GetFrame();
	auto& index = frame.current_command;

	if (Game_Message::IsMessageActive()) {
		return false;
	}

	// Don't interrupt other pending game scenes for the settings menu.
	if (Scene::instance->HasRequestedScene()) {
		return false;
	}

	// FIXME: RPG_RT pops up an immediate modal dialog, while this
	// does a normal scene call. This could result in interpreter timing differences.
	Scene::instance->SetRequestedScene(std::make_shared<Scene_Settings>());
	++index;
	return false;
}

bool Game_Interpreter::CommandManiacGetGameInfo(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	int event_id;
	int var = com.parameters[2];

	switch (com.parameters[1]) {
		case 0: // Get map size
			Main_Data::game_variables->Set(var, Game_Map::GetTilesX());
			Main_Data::game_variables->Set(var + 1, Game_Map::GetTilesY());
			break;
		case 1: { // Get tile info
			var = com.parameters[7];

			int32_t tile_layer = com.parameters[2]; // 0: Lower || 1: Upper
			Rect tile_coords;

			tile_coords.x = ValueOrVariableBitfield(com.parameters[0], 1, com.parameters[3]);
			tile_coords.y = ValueOrVariableBitfield(com.parameters[0], 2, com.parameters[4]);
			tile_coords.width = ValueOrVariableBitfield(com.parameters[0], 3, com.parameters[5]);
			tile_coords.height = ValueOrVariableBitfield(com.parameters[0], 4, com.parameters[6]);

			if (tile_coords.width <= 0 || tile_coords.height <= 0) return true;

			auto tiles = Game_Map::GetTilesIdAt(tile_coords, tile_layer);

			for (int i = 0; i < tile_coords.width * tile_coords.height; i++) {
				Main_Data::game_variables->Set(var + i, tiles[i]);
			}
			break;
		}
		case 2: // Get window size
			Main_Data::game_variables->Set(var, Player::screen_width);
			Main_Data::game_variables->Set(var + 1, Player::screen_height);
			break;
		case 3: // Get pixel info
			// FIXME: figure out how 'Pixel info' works
			Output::Warning("GetGameInfo: Option 'Pixel Info' not implemented.");
			break;
		case 4: // Get command interpreter state
		{
			// Parameter "Nest" in the English version of Maniacs
			// This value specifies how far you'd want to go back the stack
			int peek = ValueOrVariableBitfield(com.parameters[0], 2, com.parameters[4]);

			//First set everything to '0'
			Main_Data::game_variables->SetRange(var, var + 4, 0);

			int stack_no = _state.stack.size() - peek;
			if (stack_no > 0) {
				auto frame = &_state.stack[stack_no - 1];

				// Note: It looks like for Battles, Maniacs doesn't give out any detailed interpreter
				// information via this command (only the current command line: frame->current_command)
				// The others are implemented here nonetheless for consistency.
				// (This is true for both the normal "Troop" events & the new "Battle Start"/"Battle Parallel" execution types)

				Main_Data::game_variables->Set(var, static_cast<int>(ManiacEventType(*frame)));
				Main_Data::game_variables->Set(var + 1, frame->maniac_event_id);
				Main_Data::game_variables->Set(var + 2, frame->maniac_event_page_id);
				Main_Data::game_variables->Set(var + 3, static_cast<int>(ManiacExecutionType(*frame)));
				Main_Data::game_variables->Set(var + 4, frame->current_command + 1);
			}
		}
			break;
		case 5: // Get tileset ID
			Main_Data::game_variables->Set(var, Game_Map::GetChipset());
			break;
		case 6: // Get actor/message face graphic
			if (com.parameters[4] == 1) {
				// Message
				Main_Data::game_strings->Asg(var, Main_Data::game_system->GetMessageFaceName());
				Main_Data::game_variables->Set(com.parameters[3], Main_Data::game_system->GetMessageFaceIndex());
			} else {
				// Actor
				event_id = ValueOrVariableBitfield(com.parameters[0], 0, com.parameters[5]);

				auto* actor = Main_Data::game_actors->GetActor(event_id);
				if (!actor) {
					Output::Warning("GetGameInfo: Invalid actor ID {}", event_id);
					return true;
				}

				if (com.parameters[6] == 1) {
					// Dynamic
					Main_Data::game_strings->Asg(var, actor->GetFaceName());
					Main_Data::game_variables->Set(com.parameters[3], actor->GetFaceIndex());
				} else {
					// Original
					Main_Data::game_strings->Asg(var, actor->GetOriginalFaceName());
					Main_Data::game_variables->Set(com.parameters[3], actor->GetOriginalFaceIndex());
				}
			}
			break;
		case 7: { // Get actor/event body graphic
			event_id = ValueOrVariableBitfield(com.parameters[0], 0, com.parameters[5]);
			auto* character = GetCharacter(event_id, "GetGameInfo");
			if (!character) {
				return true;
			}

			if (com.parameters[4] == 1) {
				// Get event graphic
				// Bug: .static 10001 gives current sprite of Player. .dynamic 10001 gives out nothing.
				// Bug: Cannot get .static 10005 sprite of self. .dynamic 10005 works however
				if (com.parameters[6] == 1) {
					// Dynamic
					if (event_id == Game_Character::CharPlayer) {
							// Return nothing as per Maniac Patch
							Main_Data::game_strings->Asg(var, "");
							Main_Data::game_variables->Set(com.parameters[3], 0);
							break;
					}
					Main_Data::game_strings->Asg(var, std::string_view(character->GetSpriteName()));
					Main_Data::game_variables->Set(com.parameters[3], character->GetSpriteIndex());
					break;
				} else {
					// Static
					switch (event_id) {
						case Game_Character::CharPlayer:
							// Return dynamic player sprite
							Main_Data::game_strings->Asg(var, std::string_view(character->GetSpriteName()));
							Main_Data::game_variables->Set(com.parameters[3], character->GetSpriteIndex());
							break;
						case Game_Character::CharBoat:
							Main_Data::game_strings->Asg(var, std::string_view(lcf::Data::system.boat_name));
							Main_Data::game_variables->Set(com.parameters[3], lcf::Data::system.boat_index);
							break;
						case Game_Character::CharShip:
							Main_Data::game_strings->Asg(var, std::string_view(lcf::Data::system.ship_name));
							Main_Data::game_variables->Set(com.parameters[3], lcf::Data::system.ship_index);
							break;
						case Game_Character::CharAirship:
							Main_Data::game_strings->Asg(var, std::string_view(lcf::Data::system.airship_name));
							Main_Data::game_variables->Set(com.parameters[3], lcf::Data::system.airship_index);
							break;
						default: {
							auto* event = static_cast<Game_Event*>(character);
							auto* page = event->GetActivePage();
							if (page == nullptr) {
								// return nothing
								Main_Data::game_strings->Asg(var, "");
								Main_Data::game_variables->Set(com.parameters[3], 0);
							} else {
								Main_Data::game_strings->Asg(var, std::string_view(page->character_name));
								Main_Data::game_variables->Set(com.parameters[3], page->character_index);
							}
						}
					}
				}
			} else {
				// Get actor graphic
				auto* actor = Main_Data::game_actors->GetActor(event_id);
				if (!actor) {
					Output::Warning("GetGameInfo: Invalid actor ID {}", event_id);
					return true;
				}

				if (com.parameters[6] == 1) {
					// Dynamic
					Main_Data::game_strings->Asg(var, actor->GetSpriteName());
					Main_Data::game_variables->Set(com.parameters[3], actor->GetSpriteIndex());
				} else {
					// Default one
					Main_Data::game_strings->Asg(var, actor->GetOriginalSpriteName());
					Main_Data::game_variables->Set(com.parameters[3], actor->GetOriginalSpriteIndex());
				}
			}
			break;
		}
		case 8:
			// Screen position
			Main_Data::game_variables->Set(var, Game_Map::GetPositionX() >> 4);
			Main_Data::game_variables->Set(var + 1, Game_Map::GetPositionY() >> 4);
			break;
		case 9:
			// Screen shake
			Main_Data::game_variables->Set(var, Main_Data::game_screen->GetShakeOffsetX());
			Main_Data::game_variables->Set(var + 1, Main_Data::game_screen->GetShakeOffsetY());
			break;
		case 10: {
			// Current BGM
			const auto& bgm = Main_Data::game_system->GetCurrentBGM();
			Main_Data::game_strings->Asg(var, bgm.name);
			Main_Data::game_variables->Set(com.parameters[3], bgm.fadein);
			Main_Data::game_variables->Set(com.parameters[3] + 1, bgm.volume);
			Main_Data::game_variables->Set(com.parameters[3] + 2, bgm.tempo);
			Main_Data::game_variables->Set(com.parameters[3] + 3, bgm.balance);
			break;
		}
	}

	Game_Map::SetNeedRefresh(true);

	return true;
}

bool Game_Interpreter::CommandManiacGetSaveInfo(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	int save_number = ValueOrVariable(com.parameters[0], com.parameters[1]);

	// Error case, set later on success
	Main_Data::game_variables->Set(com.parameters[2], 0);
	Main_Data::game_variables->Set(com.parameters[3], 0);
	Main_Data::game_variables->Set(com.parameters[4], 0);
	Main_Data::game_variables->Set(com.parameters[5], 0);

	if (save_number <= 0) {
		Output::Debug("ManiacGetSaveInfo: Invalid save number {}", save_number);
		return true;
	}

	auto savefs = FileFinder::Save();
	std::string save_name = Scene_Save::GetSaveFilename(savefs, save_number);
	auto save_stream = FileFinder::Save().OpenInputStream(save_name);

	if (!save_stream) {
		Output::Debug("ManiacGetSaveInfo: Save not found {}", save_number);
		return true;
	}

	auto save = lcf::LSD_Reader::Load(save_stream, Player::encoding);
	if (!save) {
		Output::Debug("ManiacGetSaveInfo: Save corrupted {}", save_number);
		// Maniac Patch writes this for whatever reason
		Main_Data::game_variables->Set(com.parameters[2], 8991230);
		return true;
	}

	std::time_t t = lcf::LSD_Reader::ToUnixTimestamp(save->title.timestamp);
	std::tm* tm = std::gmtime(&t);

	Main_Data::game_variables->Set(com.parameters[2], atoi(Utils::FormatDate(tm, Utils::DateFormat_YYMMDD).c_str()));
	Main_Data::game_variables->Set(com.parameters[3], atoi(Utils::FormatDate(tm, Utils::DateFormat_HHMMSS).c_str()));
	Main_Data::game_variables->Set(com.parameters[4], save->title.hero_level);
	Main_Data::game_variables->Set(com.parameters[5], save->title.hero_hp);
	Game_Map::SetNeedRefresh(true);

	auto face_ids = Utils::MakeArray(save->title.face1_id, save->title.face2_id, save->title.face3_id, save->title.face4_id);
	auto face_names = Utils::MakeArray(save->title.face1_name, save->title.face2_name, save->title.face3_name, save->title.face4_name);

	for (int i = 0; i <= 3; ++i) {
		const int param = 8 + i;

		int pic_id = ValueOrVariable(com.parameters[7], com.parameters[param]);
		if (pic_id <= 0) {
			continue;
		}

		if (face_names[i].empty()) {
			Main_Data::game_pictures->Erase(pic_id);
			continue;
		}

		// An existing picture is overwritten
		// Default data is used with the exceptions listed below
		Game_Pictures::ShowParams params;
		params.use_transparent_color = true;
		params.top_trans = 100; // Full transparent by default
		params.map_layer = 7;
		params.battle_layer = 7;

		// Spritesheet configured to match the FaceSet layout
		params.name = FileFinder::MakePath("..\\FaceSet", face_names[i]);
		params.spritesheet_cols = 4;
		params.spritesheet_rows = 4;
		params.spritesheet_frame = face_ids[i];
		params.spritesheet_speed = 0;
		Main_Data::game_pictures->Show(pic_id, params);
	}

	return true;
}

bool Game_Interpreter::CommandManiacSave(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	int slot = ValueOrVariable(com.parameters[0], com.parameters[1]);
	if (slot <= 0) {
		Output::Debug("ManiacSave: Invalid save slot {}", slot);
		return true;
	}

	int out_var = com.parameters[2] != 0 ? com.parameters[3] : -1;

	// Maniac Patch saves directly and game data could be in an undefined state
	// We yield first to the Update loop and then do a save.
	_async_op = AsyncOp::MakeSave(slot, out_var);

	return true;
}

bool Game_Interpreter::CommandManiacLoad(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	int slot = ValueOrVariable(com.parameters[0], com.parameters[1]);
	if (slot <= 0) {
		Output::Debug("ManiacLoad: Invalid save slot {}", slot);
		return true;
	}

	// Not implemented (kinda useless feature):
	// When com.parameters[2] is 1 the check whether the file exists is skipped
	// When skipped and missing RPG_RT will crash
	auto savefs = FileFinder::Save();
	std::string save_name = Scene_Save::GetSaveFilename(savefs, slot);
	auto save_stream = FileFinder::Save().OpenInputStream(save_name);
	std::unique_ptr<lcf::rpg::Save> save = lcf::LSD_Reader::Load(save_stream, Player::encoding);

	if (!save) {
		Output::Debug("ManiacLoad: Save not found {}", slot);
		return true;
	}

	// FIXME: In Maniac the load causes a blackscreen followed by a fade-in that can be cancelled by a transition event
	// This is not implemented yet, the loading is instant without fading
	_async_op = AsyncOp::MakeLoad(slot);

	return true;
}

bool Game_Interpreter::CommandManiacEndLoadProcess(lcf::rpg::EventCommand const&) {
	// no-op
	return true;
}

bool Game_Interpreter::CommandManiacGetMousePosition(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

#if !defined(USE_MOUSE_OR_TOUCH) || !defined(SUPPORT_MOUSE_OR_TOUCH)
	static bool warned = false;
	if (!warned) {
		// This command is polled, prevent excessive spam
		Output::Warning("Maniac Patch: Mouse input is not supported on this platform");
		warned = true;
	}
	return true;
#endif

	Point mouse_pos = Input::GetMousePosition();

	Main_Data::game_variables->Set(com.parameters[0], mouse_pos.x);
	Main_Data::game_variables->Set(com.parameters[1], mouse_pos.y);

	Game_Map::SetNeedRefresh(true);

	return true;
}

bool Game_Interpreter::CommandManiacSetMousePosition(lcf::rpg::EventCommand const&) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	Output::Warning("Maniac Patch: Command SetMousePosition not supported");
	return true;
}

bool Game_Interpreter::CommandManiacShowStringPicture(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	int pic_id = ValueOrVariableBitfield(com.parameters[0], 0, com.parameters[1]);

	if (pic_id <= 0) {
		Output::Error("ShowStringPic: Requested invalid picture id ({})", pic_id);
		return true;
	}

	Game_Windows::WindowParams params = {};
	Game_Windows::WindowText text;

	params.position_x = ValueOrVariableBitfield(com.parameters[0], 1, com.parameters[2]);
	params.position_y = ValueOrVariableBitfield(com.parameters[0], 1, com.parameters[3]);
	params.magnify_width = ValueOrVariableBitfield(com.parameters[0], 2, com.parameters[4]);
	params.top_trans = ValueOrVariableBitfield(com.parameters[0], 3, com.parameters[5]);
	params.red = com.parameters[6];
	params.green = com.parameters[7];
	params.blue = com.parameters[8];
	params.saturation = com.parameters[9];
	params.effect_mode = com.parameters[10];
	params.effect_power = com.parameters[11];

	params.map_layer = com.parameters[15];
	params.battle_layer = com.parameters[16];
	params.flags = com.parameters[17];

	params.magnify_width = ValueOrVariableBitfield(com.parameters[0], 2, com.parameters[4]);
	if (com.parameters.size() > 23 && com.parameters[0] >= 0x10000000 && params.effect_mode == 0) {
		// The >= 0x10000000 check is needed because this bit is set when independent width/height scaling is used
		// When using special effects on Maniacs, Height is set to Width
		params.magnify_height = ValueOrVariableBitfield((com.parameters[0] >> 1), 7, com.parameters[23]);
	} else {
		params.magnify_height = params.magnify_width;
	}

	int flags = com.parameters[12];
	int blend_mode = flags & 0xF;
	if (blend_mode == 1) {
		params.blend_mode = (int)Bitmap::BlendMode::Multiply;
	} else if (blend_mode == 2) {
		params.blend_mode = (int)Bitmap::BlendMode::Additive;
	} else if (blend_mode == 3) {
		params.blend_mode = (int)Bitmap::BlendMode::Overlay;
	}
	params.flip_x = (flags & 16) == 16;
	params.flip_y = (flags & 32) == 32;
	params.origin = (com.parameters[0] & (0xF << 24)) >> 24;

	flags = com.parameters[13];
	if (params.effect_mode == lcf::rpg::SavePicture::Effect_maniac_fixed_angle) {
		params.effect_power = ValueOrVariableBitfield(flags, 6, params.effect_power);
		int divisor = ValueOrVariableBitfield(flags, 7, com.parameters[21]);
		if (divisor == 0) {
			divisor = 1;
		}
		params.effect_power /= divisor;
	}

	params.fixed_to_map = (flags & 0xFF) > 0;
	params.message_stretch = (flags & 0xF00) >> 8;

	// Shifting values around to match System::Stretch enum
	if (params.message_stretch == 0) {
		params.message_stretch = 2;
	} else {
		params.message_stretch -= 1;
	}

	params.draw_frame = (flags & (1 << 12)) == 0;
	text.draw_gradient = (flags & (1 << 13)) == 0;
	text.draw_shadow = (flags & (1 << 14)) == 0;
	text.bold = (flags & (1 << 15)) > 0;
	params.border_margin = (flags & (1 << 16)) == 0;

	params.width = ValueOrVariableBitfield(com.parameters[0], 4, com.parameters[18]);
	params.height = ValueOrVariableBitfield(com.parameters[0], 4, com.parameters[19]);

	if (params.width < 0 || params.height < 0) {
		Output::Warning("ShowStringPic: Invalid window dimension {}x{} (id={})", params.width, params.height, pic_id);
		return true;
	}

	flags = com.parameters[14];
	params.use_transparent_color = (flags & 0xFF) > 0;
	text.letter_spacing = (flags & (0xFF << 8)) >> 8;
	text.line_spacing = (flags & (0xFF << 16)) >> 16;
	text.font_size = ValueOrVariableBitfield(com.parameters[0], 5, com.parameters[20]);


	// maniacs stores string parsing modes in the delimiters
	// x01 -> literal string
	// x02 -> direct reference
	// x03 -> indirect reference
	// for the displayed string, the id argument is in com.parameters[22]
	// here we are capturing all the delimiters, but currently only need to support reading the first one
	std::vector<int> delims;
	auto components = Utils::Tokenize(com.string, [p = &delims](char32_t ch) {
		if (ch == '\x01' || ch == '\x02' || ch == '\x03') {
			p->push_back(static_cast<int>(ch));
			return true;
		}
		return false;
	});

	if (components.size() < 4) {
		Output::Warning("ShowStringPic: Bad text arg (id={})", pic_id);
		return true;
	}

	if (com.parameters.size() >= 23) {
		text.text = ToString(Main_Data::game_strings->GetWithMode(
			components[1],
			delims[0] - 1,
			com.parameters[22],
			*Main_Data::game_variables
		));
	} else {
		text.text = components[1];
	}

	params.system_name = components[2];
	text.font_name = components[3];

	params.texts = {text};

	bool async_wait;
	Main_Data::game_windows->Create(pic_id, params, async_wait);

	if (async_wait) {
		_async_op = AsyncOp::MakeYield();
	}

	return true;
}

bool Game_Interpreter::CommandManiacGetPictureInfo(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	int pic_id = ValueOrVariable(com.parameters[0], com.parameters[3]);
	auto& pic = Main_Data::game_pictures->GetPicture(pic_id);

	if (pic.IsRequestPending()) {
		// Cannot do anything useful here without the dimensions
		pic.MakeRequestImportant();
		_async_op = AsyncOp::MakeYieldRepeat();
		return true;
	}

	const auto& data = pic.data;

	int x = 0;
	int y = 0;
	int width = pic.sprite ? pic.sprite->GetWidth() : 0;
	int height = pic.sprite ? pic.sprite->GetHeight() : 0;

	switch (com.parameters[1]) {
		case 0:
			x = Utils::RoundTo<int>(data.current_x);
			y = Utils::RoundTo<int>(data.current_y);
			break;
		case 1:
			x = Utils::RoundTo<int>(data.current_x);
			y = Utils::RoundTo<int>(data.current_y);
			width = Utils::RoundTo<int>(width * data.current_magnify / 100.0);
			height = Utils::RoundTo<int>(height * data.maniac_current_magnify_height / 100.0);
			break;
		case 2:
			x = Utils::RoundTo<int>(data.finish_x);
			y = Utils::RoundTo<int>(data.finish_y);
			width = Utils::RoundTo<int>(width * data.finish_magnify / 100.0);
			height = Utils::RoundTo<int>(height * data.maniac_finish_magnify_height / 100.0);
			break;
	}

	switch (com.parameters[2]) {
		case 1:
			// X/Y is top-left corner
			x -= (width / 2);
			y -= (height / 2);
			break;
		case 2: {
			// Left, Top, Right, Bottom
			x -= (width / 2);
			y -= (height / 2);
			width += x;
			height += y;
			break;
		}
	}

	Main_Data::game_variables->Set(com.parameters[4], x);
	Main_Data::game_variables->Set(com.parameters[5], y);
	Main_Data::game_variables->Set(com.parameters[6], width);
	Main_Data::game_variables->Set(com.parameters[7], height);

	Game_Map::SetNeedRefresh(true);

	return true;
}

bool Game_Interpreter::CommandManiacControlVarArray(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	int op = com.parameters[0];
	int mode = com.parameters[1];

	int target_a = ValueOrVariableBitfield(mode, 0, com.parameters[2]);
	int length = ValueOrVariableBitfield(mode, 1, com.parameters[3]);
	int target_b = ValueOrVariableBitfield(mode, 2, com.parameters[4]);
	int last_target_a = target_a + length - 1;

	if (target_a < 1 || length <= 0) {
		return true;
	}

	switch (op) {
		case 0: {
			// Copy, assigns left to right, the others apply right to left
			int last_target_b = target_b + length - 1;
			Main_Data::game_variables->SetArray(target_b, last_target_b, target_a);
			break;
		}
		case 1:
			// Swap
			Main_Data::game_variables->SwapArray(target_a, last_target_a, target_b);
			break;
		case 2:
			// Sort asc
			Main_Data::game_variables->SortRange(target_a, last_target_a, true);
			break;
		case 3:
			// Sort desc
			Main_Data::game_variables->SortRange(target_a, last_target_a, false);
			break;
		case 4:
			// Shuffle
			Main_Data::game_variables->ShuffleRange(target_a, last_target_a);
			break;
		case 5:
			// Enumerate (target_b is a single value here, not an array)
			Main_Data::game_variables->EnumerateRange(target_a, last_target_a, target_b);
			break;
		case 6:
			// Add
			Main_Data::game_variables->AddArray(target_a, last_target_a, target_b);
			break;
		case 7:
			// Sub
			Main_Data::game_variables->SubArray(target_a, last_target_a, target_b);
			break;
		case 8:
			// Mul
			Main_Data::game_variables->MultArray(target_a, last_target_a, target_b);
			break;
		case 9:
			// Div
			Main_Data::game_variables->DivArray(target_a, last_target_a, target_b);
			break;
		case 10:
			// Mod
			Main_Data::game_variables->ModArray(target_a, last_target_a, target_b);
			break;
		case 11:
			// OR
			Main_Data::game_variables->BitOrArray(target_a, last_target_a, target_b);
			break;
		case 12:
			// AND
			Main_Data::game_variables->BitAndArray(target_a, last_target_a, target_b);
			break;
		case 13:
			// XOR
			Main_Data::game_variables->BitXorArray(target_a, last_target_a, target_b);
			break;
		case 14:
			// Shift left
			Main_Data::game_variables->BitShiftLeftArray(target_a, last_target_a, target_b);
			break;
		case 15:
			// Shift right
			Main_Data::game_variables->BitShiftRightArray(target_a, last_target_a, target_b);
			break;
		default:
			Output::Warning("ManiacControlVarArray: Unknown operation {}", op);
	}

	Game_Map::SetNeedRefresh(true);

	return true;
}

bool Game_Interpreter::CommandManiacKeyInputProcEx(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

#if !defined(SUPPORT_KEYBOARD)
	Output::Warning("Maniac KeyInputProc: Keyboard input is not supported on this platform");
	// Fallthrough: Variables are still set to 0
#endif

	int operation = com.parameters[0];
	int start_var_id = com.parameters[1];

	if (operation == 0 || operation == 1) {
		// The difference between 0 and 1 is whether the Joypad is checked
		// We do not implement the Joypad code so both behave the same
		auto keys = ManiacPatch::GetKeyRange();

		for (int i = 0; i < static_cast<int>(keys.size()); ++i) {
			Main_Data::game_variables->Set(start_var_id + i, keys[i] ? 1 : 0);
		}
	} else if (operation == 2) {
		int key_id = ValueOrVariable(com.parameters[2], com.parameters[3]);
		auto key = RuntimePatches::VirtualKeys::VirtualKeyToInputKey(key_id);
		if (key == Input::Keys::NONE) {
			Output::Debug("Maniac KeyInputProcEx: Unsupported keycode {}", key_id);
		}
		bool key_state = Input::IsRawKeyPressed(key);
		Main_Data::game_variables->Set(start_var_id, key_state ? 1 : 0);
	} else {
		Output::Warning("Maniac KeyInputProcEx: Joypad not supported");
	}

	Game_Map::SetNeedRefresh(true);

	return true;
}

bool Game_Interpreter::CommandManiacRewriteMap(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	int mode = com.parameters[0];
	//bool is_replace_range = com.parameters[1] != 0; FIXME not implemented
	bool is_upper_layer = com.parameters[2] != 0;

	int tile_index = ValueOrVariableBitfield(mode, 0, com.parameters[3]);
	int x_start = ValueOrVariableBitfield(mode, 1, com.parameters[4]);
	int y_start = ValueOrVariableBitfield(mode, 2, com.parameters[5]);
	int width = ValueOrVariableBitfield(mode, 3, com.parameters[6]);
	int height = ValueOrVariableBitfield(mode, 4, com.parameters[7]);

	bool disable_autotile = com.parameters[8] != 0;

	Scene_Map* scene = (Scene_Map*)Scene::Find(Scene::Map).get();
	if (!scene)
		return true;

	if (is_upper_layer) {
		for (auto y = y_start; y < y_start + height; ++y) {
			for (auto x = x_start; x < x_start + width; ++x) {
				scene->spriteset->ReplaceUpAt(x, y, tile_index);
			}
		}
	} else {
		for (auto y = y_start; y < y_start + height; ++y) {
			for (auto x = x_start; x < x_start + width; ++x) {
				scene->spriteset->ReplaceDownAt(x, y, tile_index, disable_autotile);
			}
		}
	}

	return true;
}

bool Game_Interpreter::CommandManiacControlGlobalSave(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	int operation = com.parameters[0];

	if (operation == 0) {
		// Open: Fill Global Save with data from Save.lgs
		// Does nothing when already opened
		ManiacPatch::GlobalSave::Load();
	} else if (operation == 1) {
		// Close
		// Marks the file as closed and does nothing
		ManiacPatch::GlobalSave::Close();
	} else if (operation == 2 || operation == 3) {
		// 2: Save (write to file)
		// 3: Save and Close
		ManiacPatch::GlobalSave::Save(operation == 3);
	} else if (operation == 4 || operation == 5) {
		// Reload the file when it was already closed
		ManiacPatch::GlobalSave::Load();

		int type = com.parameters[2];
		int game_state_idx = ValueOrVariableBitfield(com.parameters[1], 0, com.parameters[3]);
		int global_save_idx = ValueOrVariableBitfield(com.parameters[1], 1, com.parameters[4]);
		int length = ValueOrVariableBitfield(com.parameters[1], 2, com.parameters[5]);

		if (operation == 4) {
			// Copy from global save to game state
			for (int i = 0; i < length; ++i) {
				if (type == 0) {
					Main_Data::game_switches->Set(game_state_idx, Main_Data::game_switches_global->Get(global_save_idx));
				} else if (type == 1) {
					Main_Data::game_variables->Set(game_state_idx, Main_Data::game_variables_global->Get(global_save_idx));
				}
				++game_state_idx;
				++global_save_idx;
			}

			Game_Map::SetNeedRefresh(true);
		} else {
			// Copy from game state to global save
			for (int i = 0; i < length; ++i) {
				if (type == 0) {
					Main_Data::game_switches_global->Set(global_save_idx, Main_Data::game_switches->Get(game_state_idx));
				} else if (type == 1) {
					Main_Data::game_variables_global->Set(global_save_idx, Main_Data::game_variables->Get(game_state_idx));
				}
				++game_state_idx;
				++global_save_idx;
			}
		}
	}

	return true;
}

bool Game_Interpreter::CommandManiacChangePictureId(lcf::rpg::EventCommand const&) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	Output::Warning("Maniac Patch: Command ChangePictureId not supported");
	return true;
}

bool Game_Interpreter::CommandManiacSetGameOption(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	int operation = com.parameters[1];
	//int value = ValueOrVariable(com.parameters[0], com.parameters[2]);

	switch (operation) {
		case 2: // Change Picture Limit (noop, we support arbitrary amount of pictures)
			break;
		default:
			Output::Warning("Maniac SetGameOption: Operation {} not supported", operation);
	}

	return true;
}

bool Game_Interpreter::CommandManiacControlStrings(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}
	//*parameter 0 - Modifier of the operation members
	//	-bits 0..3:
	//		Refers to the String mode: t[x], t[x..y], t[v[x]], t[v[x]..v[y]]
	//	-bits 4..7:
	//		Refers to the first argument, which can change depending on the type of operation:  x, v[x], v[v[x]] | string, t[x], t[v[x]]
	//	-bits 8..11:
	//		Refers to the second argument, which can change depending on the type of operation: x, v[x], v[v[x]] | string, t[x], t[v[x]]
	//	-bits 12..15:
	//		Refers to the third argument, which can change depending on the type of operation:  x, v[x], v[v[x]] | string, t[x], t[v[x]]
	//	-bits 16..19:
	//		Refers to the fourth argument, which can change depending on the type of operation: x, v[x], v[v[x]] | string, t[x], t[v[x]] (edge case for exMatch)
	//
	//*parameter 1 - String index 0
	//
	//*parameter 2 - String index 1 (optional for ranges)
	//
	//*parameter 3 - general flags
	//	-byte0:
	//		Refers to the type of operation: asg, cat, toNum...
	//	-byte1:
	//		It is a flag that indicates sub-operation: actor[x].name, .actor[x].desc, ins, rep, subs, join... Used only in asg and cat operations
	//	-byte2:
	//		Flags, such as: extract, hex... There is also an edge case where the last argument of exRep is here
	//
	//*parameters 4..n - arguments
	bool is_range = com.parameters[0] & 1;
	int string_id_0, string_id_1;
	DecodeTargetEvaluationMode<false, true, false, true, false>(com, string_id_0, string_id_1);

	int op = (com.parameters[3] >>  0) & 255;
	int fn = (com.parameters[3] >>  8) & 255;
	int flags = (com.parameters[3] >> 16) & 255;

	int hex_flag     = (flags >> 1) & 1;
	int extract_flag = (flags >> 2) & 1;
	int first_flag = (flags >> 3) & 1;

	int args[] = {
		com.parameters[4],
		com.parameters[5],
		com.parameters[6],
		0
	};
	if (com.parameters.size() > 7) {
		args[3] = com.parameters[7]; //The exMatch command is a edge case that uses 4 arguments
	}
	int modes[] = {
		(com.parameters[0] >>  4) & 15,
		(com.parameters[0] >>  8) & 15,
		(com.parameters[0] >> 12) & 15,

		(com.parameters[0] >> 16) & 15
	};

	std::string str_param = ToString(com.string);
	std::string result;
	Game_Strings::Str_Params str_params = {
		string_id_0,
		hex_flag,
		extract_flag,
	};

	switch (op)
	{
	case 0: //asg <fn(string text)>
	case 1: //cat <fn(string text)>
		switch (fn)
		{
		case 0: //String <fn(string text, int min_size)>
			result = ToString(Main_Data::game_strings->GetWithMode(str_param, modes[0], args[0], *Main_Data::game_variables));
			args[1] = ValueOrVariable(modes[1], args[1]);

			// min_size
			result = Game_Strings::PrependMin(result, args[1], ' ');
			break;
		case 1: //Number <fn(int number, int min_size)>
			args[0] = ValueOrVariable(modes[0], args[0]);
			args[1] = ValueOrVariable(modes[1], args[1]);

			result = std::to_string(args[0]);
			result = Game_Strings::PrependMin(result, args[1], '0');
			break;
		case 2: //Switch <fn(int number, int min_size)>
		{
			if (modes[0] == 1) args[0] = Main_Data::game_variables->Get(args[0]);
			args[1] = ValueOrVariable(modes[1], args[1]);

			if (Main_Data::game_switches->Get(args[0])) {
				result = "ON";
			} else {
				result = "OFF";
			}
			result = Game_Strings::PrependMin(result, args[1], ' ');
			break;
		}
		case 3: //Database Names <fn(int database_id, int entity_id, bool dynamic)>
			args[1] = ValueOrVariable(modes[1], args[1]);
			result = ToString(ManiacPatch::GetLcfName(args[0], args[1], (bool)args[2]));
			break;
		case 4: //Database Descriptions <fn(int id, bool dynamic)>
			args[1] = ValueOrVariable(modes[1], args[1]);
			result = ToString(ManiacPatch::GetLcfDescription(args[0], args[1], (bool)args[2]));
			break;
		case 6: //Concatenate (cat) <fn(int id_or_length_a, int id_or_length_b, int id_or_length_c)>
		{
			int pos = 0;
			std::string op_string;
			for (int i = 0; i < 3; i++) {
				op_string += Main_Data::game_strings->GetWithModeAndPos(str_param, modes[i], args[i], pos, *Main_Data::game_variables);
			}
			result = std::move(op_string);
			break;
		}
		case 7: //Insert (ins) <fn(string base, int index, string insert)>
		{
			int pos = 0;
			std::string base, insert;

			args[1] = ValueOrVariable(modes[1], args[1]);
			base = Main_Data::game_strings->GetWithModeAndPos(str_param, modes[0], args[0], pos, *Main_Data::game_variables);
			insert = Main_Data::game_strings->GetWithModeAndPos(str_param, modes[2], args[2], pos, *Main_Data::game_variables);

			result = Game_Strings::Insert(base, insert, args[1]);
			break;
		}
		case 8: //Replace (rep) <fn(string base, string search, string replacement)>
		{
			int pos = 0;
			std::string base, search, replacement;

			base = Main_Data::game_strings->GetWithModeAndPos(str_param, modes[0], args[0], pos, *Main_Data::game_variables);
			search = Main_Data::game_strings->GetWithModeAndPos(str_param, modes[1], args[1], pos, *Main_Data::game_variables);
			replacement = Main_Data::game_strings->GetWithModeAndPos(str_param, modes[2], args[2], pos, *Main_Data::game_variables);
			result = Utils::ReplaceAll(base, search, replacement);

			break;
		}
		case 9: //Substring (subs) <fn(string base, int index, int size)>
			args[1] = ValueOrVariable(modes[1], args[1]);
			args[2] = ValueOrVariable(modes[2], args[2]);

			result = ToString(Main_Data::game_strings->GetWithMode(str_param, modes[0], args[0], *Main_Data::game_variables));
			result = Game_Strings::Substring(result, args[1], args[2]);
			break;
		case 10: //Join (join) <fn(string delimiter, int id, int size)>
		{
			std::string op_string;
			std::string delimiter = ToString(Main_Data::game_strings->GetWithMode(str_param, modes[0], args[0], *Main_Data::game_variables));

			// args[1] & mode[1] relates to starting ID for strings to join
			// mode 0 = id literal, 1 = direct var, 2 = var literal, 3 = direct var
			args[1] = ValueOrVariable(modes[1] % 2, args[1]);
			args[2] = ValueOrVariable(modes[2], args[2]);

			while (args[2] > 0) {
				if (modes[1] < 2) {
					op_string += ToString(Main_Data::game_strings->Get(args[1]++));
				} else {
					op_string += std::to_string(Main_Data::game_variables->Get(args[1]++));
				}

				if (--args[2] > 0) op_string += delimiter;
			}

			result = op_string;
			break;
		}
		case 12: //File (file) <fn(string filename, int encode)>
		{
			// maniacs does not like a file extension
			std::string_view filename = Main_Data::game_strings->GetWithMode(str_param, modes[0], args[0], *Main_Data::game_variables);
			// args[1] is the encoding... 0 for ansi, 1 for utf8
			bool do_yield;
			result = Game_Strings::FromFile(filename, args[1], do_yield);

			if (do_yield) {
				// Wait for text file download and repeat
				_async_op = AsyncOp::MakeYieldRepeat();
				return true;
			}

			break;
		}
		case 13: //Remove (rem) <fn(string base, int index, int size)>
			args[1] = ValueOrVariable(modes[1], args[1]);
			args[2] = ValueOrVariable(modes[2], args[2]);
			result = ToString(Main_Data::game_strings->GetWithMode(str_param, modes[0], args[0], *Main_Data::game_variables));
			result = Game_Strings::Erase(result, args[1], args[2]);
			break;
		case 14: //Replace Ex (exRep) <fn(string base, string search, string replacement, bool first)>, edge case: the arg "first" is at ((flags >> 19) & 1). Wtf BingShan
		{
			int pos = 0;
			std::string base, search, replacement;

			base = Main_Data::game_strings->GetWithModeAndPos(str_param, modes[0], args[0], pos, *Main_Data::game_variables);
			search = Main_Data::game_strings->GetWithModeAndPos(str_param, modes[1], args[1], pos, *Main_Data::game_variables);
			replacement = Main_Data::game_strings->GetWithModeAndPos(str_param, modes[2], args[2], pos, *Main_Data::game_variables);

			auto flags = std::regex_constants::match_default;

			if (first_flag) {
				flags = std::regex_constants::format_first_only;
			}

			result = Game_Strings::RegExReplace(base, search, replacement, flags);
			break;
		}
		default:
			Output::Warning("Unknown or unimplemented string sub-operation {}", op);
			break;
		}
		if (is_range) Main_Data::game_strings->RangeOp(str_params, string_id_1, result, op, nullptr, *Main_Data::game_variables);
		else {
			if (op == 0) Main_Data::game_strings->Asg(str_params, result);
			if (op == 1) Main_Data::game_strings->Cat(str_params, result);
		}
		break;
	case 2: //toNum <fn(int var_id)> takes hex
	case 3: //getLen <fn(int var_id)>
		if (is_range) Main_Data::game_strings->RangeOp(str_params, string_id_1, result, op, args, *Main_Data::game_variables);
		else {
			if (op == 2) {
				int num = Main_Data::game_strings->ToNum(str_params, args[0], *Main_Data::game_variables);
				Main_Data::game_variables->Set(args[0], num);
			}
			if (op == 3) Main_Data::game_strings->GetLen(str_params, args[0], *Main_Data::game_variables);
		}
		break;
	case 4: //inStr <fn(string text, int var_id, int begin)> FIXME: takes hex?
	{
		std::string_view search = Main_Data::game_strings->GetWithMode(str_param, modes[0], args[0], *Main_Data::game_variables);
		args[1] = ValueOrVariable(modes[1], args[1]); // not sure this is necessary but better safe
		args[2] = ValueOrVariable(modes[2], args[2]);

		if (is_range) Main_Data::game_strings->RangeOp(str_params, string_id_1, ToString(search), op, args, *Main_Data::game_variables);
		else          Main_Data::game_strings->InStr(str_params, ToString(search), args[1], args[2], *Main_Data::game_variables);
		break;
	}
	case 5: //split <fn(string text, int str_id, int var_id)> takes hex
	{
		std::string_view delimiter = Main_Data::game_strings->GetWithMode(str_param, modes[0], args[0], *Main_Data::game_variables);
		args[1] = ValueOrVariable(modes[1], args[1]);
		args[2] = ValueOrVariable(modes[2], args[2]);

		if (is_range) Main_Data::game_strings->RangeOp(str_params, string_id_1, ToString(delimiter), op, args, *Main_Data::game_variables);
		else          Main_Data::game_strings->Split(str_params, ToString(delimiter), args[1], args[2], *Main_Data::game_variables);
		break;
	}
	case 7: //toFile <fn(string filename, int encode)>  takes hex
	{
		std::string_view filename = Main_Data::game_strings->GetWithMode(str_param, modes[0], args[0], *Main_Data::game_variables);
		args[1] = ValueOrVariable(modes[1], args[1]);

		Main_Data::game_strings->ToFile(str_params, ToString(filename), args[1]);
		break;
	}
	case 8: //popLine <fn(int output_str_id)> takes hex
		// a range parameter with popLine doesn't affect multiple strings;
		// it instead alters the behavior.
		// given a range t[a..b], it will pop the first (b-a)+1 lines,
		// and store the last popped line into the output string.
		args[1] = ValueOrVariable(modes[0], args[0]);

		if (is_range) Main_Data::game_strings->PopLine(str_params, string_id_1 - string_id_0, args[0]);
		else          Main_Data::game_strings->PopLine(str_params, 0, args[0]);
		break;
	case 9: //exInStr <fn(string text, int var_id, int begin)>
	case 10: //exMatch <fn(string text, int var_id, int begin, int str_id)>, edge case: the only command that generates 8 parameters instead of 7
	{
		// takes hex
		std::string expr = ToString(Main_Data::game_strings->GetWithMode(str_param, modes[0], args[0], *Main_Data::game_variables));
		args[1] = ValueOrVariable(modes[1], args[1]); // output var
		args[2] = ValueOrVariable(modes[2], args[2]); // beginning pos

		if (is_range) {
			Main_Data::game_strings->RangeOp(str_params, string_id_1, expr, op, args, *Main_Data::game_variables);
		}
		else {
			if (op == 9) Main_Data::game_strings->ExMatch(str_params, expr, args[1], args[2], -1, *Main_Data::game_variables);
			else         Main_Data::game_strings->ExMatch(str_params, expr, args[1], args[2], args[3], *Main_Data::game_variables);
		}
		break;
	}
	default:
		Output::Warning("Unknown or unimplemented string operation {}", op);
		break;
	}
	return true;
}

bool Game_Interpreter::CommandManiacCallCommand(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	enum class ProcessingMode {
		Constant = 0, // 0 and 1: Parameters read from variables
		Variable = 1,
		//VariableIndirect = 2, // Somehow not implemented by ManiacPatch
		Inline = 3, // Parameters are directly provided by the command
		Expression = 4 // Like 3, but the parameters are calculated from expressions
	};

	std::vector<int32_t> values;

	// Create command with basic parameters
	lcf::rpg::EventCommand cmd;
	cmd.code = ValueOrVariableBitfield(com.parameters[0], 0, com.parameters[1]);

	cmd.string = lcf::DBString(CommandStringOrVariableBitfield(com, 0, 3, 4));

	// Determine processing mode
	auto processing_mode = static_cast<ProcessingMode>((com.parameters[0] >> 4) & 0b1111);

	switch (processing_mode) {
	case ProcessingMode::Constant:
	case ProcessingMode::Variable: {
		int start_index = ValueOrVariable(static_cast<int>(processing_mode), com.parameters[2]);
		int length = ValueOrVariableBitfield(com.parameters[0], 2, com.parameters[3]);

		for (int i = 0; i < length; ++i) {
			values.push_back(Main_Data::game_variables->Get(start_index + i));
		}
		break;
	}
	case ProcessingMode::Inline: {
		int value_index = 5; // Start of the values
		int mode_index = com.parameters[2]; // Mode of the values
		int length = com.parameters[3];

		for (int i = 0; i < length; ++i) {
			// The mode is the typical 4 bit packing
			// Always 4 modes (16 bit) are packing into one parameter
			// Then the mode_index increments
			if (i != 0 && i % 4 == 0) {
				++mode_index;
			}

			values.push_back(ValueOrVariableBitfield(com, mode_index, i % 4, value_index + i));
		}
		break;
	}
	case ProcessingMode::Expression: {
		values = ManiacPatch::ParseExpressions(MakeSpan(com.parameters).subspan(5), *this);
		break;
	}
	default:
		Output::Warning("Call Command: Unsupported Processing Mode: {}", static_cast<int>(processing_mode));
		return true;
	}

	// Finalize command parameters
	cmd.parameters = lcf::DBArray<int32_t>(values.begin(), values.end());

	// Debug output
	/*Output::Warning("Processing mode: {}", static_cast<int>(processing_mode));
	Output::Warning("Command code: {}", cmd.code);
	Output::Warning("Command string: {}", cmd.string);
	std::string params_str;
	for (const auto& param : values) {
		params_str += " " + std::to_string(param);
	}
	Output::Warning("Command parameters:{}", params_str);
	Output::Info("--------------------\n");*/

	// Our implementation pushes a new frame containing the command instead of invoking it directly.
	// This is incompatible to Maniacs but has a better compatibility with our code.
	Push<ExecutionType::Eval, EventType::None>({ cmd }, GetCurrentEventId(), 0);

	return true;
}

bool Game_Interpreter::CommandEasyRpgSetInterpreterFlag(lcf::rpg::EventCommand const& com) {
	if (!Player::HasEasyRpgExtensions()) {
		return true;
	}

#ifndef ENABLE_DYNAMIC_INTERPRETER_CONFIG
	Output::Warning("CommandEasyRpgSetInterpreterFlag: Not supported on this platform");
	return true;
#else
	constexpr std::array<std::pair<const char*, int>, 9> config_names = {{
		{ "destiny",          1 },
		{ "dynrpg",           2 },
		{ "maniac",           3 },
		{ "common-this",      4 },
		{ "pic-unlock",       5 },
		{ "key-patch",        6 },
		{ "rpg2k3-cmds",      7 },
		{ "rpg2k3-commands",  7 },
		{ "rpg2k-battle",     8 }
	}};

	std::string flag_name = Utils::LowerCase(ToString(com.string));
	int flag_value = ValueOrVariable(com.parameters[0], com.parameters[1]);
	int flag_id = 0;

	if (flag_name.empty() && com.parameters.size() > 2) {
		flag_id = com.parameters[2];
	} else {
		auto it = std::find_if(config_names.begin(), config_names.end(), [&flag_name](auto& p) { return p.first == flag_name; });
		if (it != config_names.end()) {
			flag_id = it->second;
		}
	}

	// Clear any inactive flags that might be left over from a previous InterpreterFlag command
	if (!_state.easyrpg_runtime_flags.conf_override_active) {
		_state.easyrpg_runtime_flags.flags.fill(false);
	}

	switch (flag_id) {
		case 1:
			if (flag_value) {
				_state.easyrpg_runtime_flags.patch_destiny_on = true;
			} else {
				_state.easyrpg_runtime_flags.patch_destiny_off = true;
			}
			break;
		case 2:
			if (flag_value) {
				_state.easyrpg_runtime_flags.patch_dynrpg_on = true;
			} else {
				_state.easyrpg_runtime_flags.patch_dynrpg_off = true;
			}
			break;
		case 3:
			if (flag_value) {
				_state.easyrpg_runtime_flags.patch_maniac_on = true;
			} else {
				_state.easyrpg_runtime_flags.patch_maniac_off = true;
			}
			break;
		case 4:
			if (flag_value) {
				_state.easyrpg_runtime_flags.patch_common_this_event_on = true;
			} else {
				_state.easyrpg_runtime_flags.patch_common_this_event_off = true;
			}
			break;
		case 5:
			if (flag_value) {
				_state.easyrpg_runtime_flags.patch_unlock_pics_on = true;
			} else {
				_state.easyrpg_runtime_flags.patch_unlock_pics_off = true;
			}
			break;
		case 6:
			if (flag_value) {
				_state.easyrpg_runtime_flags.patch_keypatch_on = true;
			} else {
				_state.easyrpg_runtime_flags.patch_keypatch_off = true;
			}
			break;
		case 7:
			if (flag_value) {
				_state.easyrpg_runtime_flags.patch_rpg2k3_cmds_on = true;
			} else {
				_state.easyrpg_runtime_flags.patch_rpg2k3_cmds_off = true;
			}
			break;
		case 8:
			if (flag_value) {
				_state.easyrpg_runtime_flags.use_rpg2k_battle_system_on = true;
			} else {
				_state.easyrpg_runtime_flags.use_rpg2k_battle_system_off = true;
			}
			break;
		default:
			return true;
	}
	_state.easyrpg_runtime_flags.conf_override_active = true;
#endif

	return true;
}

bool Game_Interpreter::CommandEasyRpgProcessJson(lcf::rpg::EventCommand const& com) {
	if (!Player::HasEasyRpgExtensions()) {
		return true;
	}

#ifndef HAVE_NLOHMANN_JSON
	Output::Warning("CommandEasyRpgProcessJson: JSON not supported on this platform");
	return true;
#else

	// Helper lambda for getting values from variables
	auto get_var_value = [](int var_type, int var_id) -> std::string {
		switch (var_type) {
		case 0: // Switch
			return std::to_string(Main_Data::game_switches->Get(var_id));
		case 1: // Variable
			return std::to_string(Main_Data::game_variables->Get(var_id));
		case 2: // String
			return ToString(Main_Data::game_strings->Get(var_id));
		default:
			Output::Warning("CommandEasyRpgProcessJson: Unsupported var_type {}", var_type);
			return {};
		}
		};

	// Helper lambda for setting values to variables
	auto set_var_value = [](int var_type, int var_id, const std::string& value) -> bool {
		switch (var_type) {
		case 0: // Switch
			Main_Data::game_switches->Set(var_id, atoi(value.c_str()) != 0);
			break;
		case 1: // Variable
			Main_Data::game_variables->Set(var_id, atoi(value.c_str()));
			break;
		case 2: // String
			Main_Data::game_strings->Asg(var_id, value);
			break;
		default:
			Output::Warning("CommandEasyRpgProcessJson: Unsupported var_type {}", var_type);
			return false;
		}
		return true;
		};

	int operation = ValueOrVariable(com.parameters[0], com.parameters[1]);

	json* json_data = nullptr;
	std::optional<json> json_data_imm;

	int source_var_id = -1;

	int pos = 0;
	std::string json_path = Main_Data::game_strings->GetWithModeAndPos(com.string, com.parameters[8], com.parameters[9], pos, *Main_Data::game_variables);

	if (com.parameters[2] == 0) {
		std::string json_str = Main_Data::game_strings->GetWithModeAndPos(com.string, com.parameters[2], com.parameters[3], pos, *Main_Data::game_variables);
		json_data_imm = Json_Helper::Parse(json_str);
		if (json_data_imm) {
			json_data = &*json_data_imm;
		} else {
			Output::Warning("JSON Parse error for {}", json_str);
			return true;
		}
	} else {
		source_var_id = ValueOrVariable(com.parameters[2] - 1, com.parameters[3]);
		json_data = Main_Data::game_strings->ParseJson(source_var_id);

		if (!json_data) {
			Output::Warning("JSON Parse error for {}", Main_Data::game_strings->Get(source_var_id));
			return true;
		}
	}

	int target_var_type = ValueOrVariable(com.parameters[4], com.parameters[5]);
	int target_var_id = ValueOrVariable(com.parameters[6], com.parameters[7]);

	int flags = com.parameters[10];
	bool pretty_print = (flags & 4) == 4;

	if ((flags & 1) == 1) { // parse command codes
		json_path = Game_Strings::Extract(json_path, false);
	} else if ((flags & 2) == 2) { // parse command codes, numbers as hex
		json_path = Game_Strings::Extract(json_path, true);
	}

	if (!Json_Helper::CheckJsonPointer(json_path)) {
		return true;
	}

	if (target_var_type == 2 && !Player::IsPatchManiac()) {
		Output::Warning("CommandEasyRpgProcessJson: String operations require Maniac Patch support");
		return true;
	}

	std::optional<std::string> result;

	switch (operation) {
	case 0: { // Get operation: Extract a value from JSON data
		result = Json_Helper::GetValue(*json_data, json_path);
		if (result) {
			set_var_value(target_var_type, target_var_id, *result);
		}
		break;
	}
	case 1: { // Set operation: Update JSON data with a new value
		if (json_data_imm) {
			Output::Warning("CommandEasyRpgProcessJson: Cannot modify constant JSON string");
			return true;
		}

		std::string new_value = get_var_value(target_var_type, target_var_id);
		result = Json_Helper::SetValue(*json_data, json_path, new_value);
		if (result) {
			Main_Data::game_strings->Asg(source_var_id, *result);
		}
		break;
	}
	case 2: { // GetLength operation
		size_t length = Json_Helper::GetLength(*json_data, json_path);
		std::string length_str;
		if (target_var_type == 0) {
			// For switches, true if length > 0
			length_str = (length > 0) ? "1" : "0";
		}
		else {
			length_str = std::to_string(length);
		}
		set_var_value(target_var_type, target_var_id, length_str);
		break;
	}
	case 3: { // GetKeys operation
		bool create_keys_obj = (flags & 8) == 8;
		auto keys = Json_Helper::GetKeys(*json_data, json_path);
		std::string keys_str;
		for (size_t i = 0; i < keys.size(); ++i) {
			if (i > 0) keys_str += ",";
			keys_str += "\"" + (keys)[i] + "\"";
		}
		std::string json_str = "[" + keys_str + "]";
		if (create_keys_obj) {
			json_str = fmt::format(R"({{ "keys": {} }})", json_str);
		}
		set_var_value(target_var_type, target_var_id, json_str);
		break;
	}
	case 4: { // GetType operation
		std::string type = Json_Helper::GetType(*json_data, json_path);
		std::string value;
		if (target_var_type == 0) {
			// For switches, true if it exists and not null
			value = (!type.empty() && type != "null");
		}
		else if (target_var_type == 1) {
			// For variables, numeric code for type
			int type_code = 0;
			if (type == "object") type_code = 1;
			else if (type == "array") type_code = 2;
			else if (type == "string") type_code = 3;
			else if (type == "number") type_code = 4;
			else if (type == "boolean") type_code = 5;
			else if (type == "null") type_code = 6;
			value = std::to_string(type_code);
		}
		else {
			value = type;
		}
		set_var_value(target_var_type, target_var_id, value);
		break;
	}
	case 5: { // Remove operation: Remove value from JSON data
		if (json_data_imm) {
			Output::Warning("CommandEasyRpgProcessJson: Cannot modify constant JSON string");
			return true;
		}

		std::string result = Json_Helper::RemoveValue(*json_data, json_path);
		if (!result.empty()) {
			Main_Data::game_strings->Asg(source_var_id, result);
		}
		break;
	}
	case 6: { // Push operation: Add value to end of array
		if (json_data_imm) {
			Output::Warning("CommandEasyRpgProcessJson: Cannot modify constant JSON string");
			return true;
		}

		std::string value = get_var_value(target_var_type, target_var_id);
		std::string result = Json_Helper::PushValue(*json_data, json_path, value);
		if (!result.empty()) {
			Main_Data::game_strings->Asg(source_var_id, result);
		}
		break;
	}
	case 7: { // Pop operation: Remove and return last element of array
		auto [json_obj, element] = Json_Helper::PopValue(*json_data, json_path);
		if (!json_obj.empty()) {
			// Set popped value to target variable
			set_var_value(target_var_type, target_var_id, element);
			// Update source with modified JSON after pop
			if (!json_data_imm) {
				Main_Data::game_strings->Asg(source_var_id, json_obj);
			}
		}
		break;
	}
	case 8: { // Contains operation: Check if path exists
		bool exists = Json_Helper::Contains(*json_data, json_path);
		set_var_value(target_var_type, target_var_id, exists ? "1" : "0");
		break;
	}
	default:
		Output::Warning("CommandEasyRpgProcessJson: Invalid Operation {}", operation);
	}

	if (target_var_type == 2 && pretty_print == 1) { // Only works with strings
		std::string target_str = ToString(Main_Data::game_strings->Get(target_var_id));
		if (auto parsed_json = Json_Helper::Parse(target_str)) {
			std::string formatted = Json_Helper::PrettyPrint(*parsed_json, 2);
			Main_Data::game_strings->Asg({ target_var_id }, formatted);
		}
	}

	return true;

#endif // !HAVE_NLOHMANN_JSON
}

bool Game_Interpreter::CommandEasyRpgCloneMapEvent(lcf::rpg::EventCommand const& com) {
	if (!Player::HasEasyRpgExtensions()) {
		return true;
	}

	if (com.parameters.size() < 8) {
		return true;
	}

	int src_map = ValueOrVariable(com.parameters[0], com.parameters[1]);
	int src_event = ValueOrVariable(com.parameters[2], com.parameters[3]);
	int target_x = ValueOrVariable(com.parameters[4], com.parameters[5]);
	int target_y = ValueOrVariable(com.parameters[6], com.parameters[7]);
	int target_event = ValueOrVariable(com.parameters[8], com.parameters[9]);

	std::string target_name = ToString(CommandStringOrVariable(com, 10, 11));

	if (src_map == 0) {
		src_map = Game_Map::GetMapId();
	} else {
		auto* request = Game_Map::RequestMap(src_map);
		request->Start();

		if (!request->IsReady()) {
			// Download the map and try again
			_async_op = AsyncOp::MakeYieldRepeat();
			return true;
		}
	}

	_async_op = AsyncOp::MakeCloneMapEvent(target_name, src_event, target_event, src_map, target_x, target_y);

	return true;
}

bool Game_Interpreter::CommandEasyRpgDestroyMapEvent(lcf::rpg::EventCommand const& com) {
	if (!Player::HasEasyRpgExtensions()) {
		return true;
	}

	int target_event = ValueOrVariable(com.parameters[0], com.parameters[1]);

	if (target_event == 0 || target_event == Game_Character::CharThisEvent) {
		target_event = GetThisEventId();
	}

	_async_op = AsyncOp::MakeDestroyMapEvent(target_event);

	return true;
}

Game_Interpreter& Game_Interpreter::GetForegroundInterpreter() {
	return Game_Battle::IsBattleRunning()
		? Game_Battle::GetInterpreter()
		: Game_Map::GetInterpreter();
}

bool Game_Interpreter::IsWaitingForWaitCommand() const {
	return (_state.wait_time > 0) || _state.wait_key_enter;
}

int Game_Interpreter::ManiacBitmask(int value, int mask) const {
	if (Player::IsPatchManiac()) {
		return value & mask;
	}

	return value;
}

namespace {
	lcf::rpg::SaveEventExecState const& empty_state = {};
}


lcf::rpg::SaveEventExecState const& Game_Interpreter_Inspector::GetForegroundExecState() {
	return Game_Interpreter::GetForegroundInterpreter()._state;
}

lcf::rpg::SaveEventExecState& Game_Interpreter_Inspector::GetForegroundExecStateUnsafe() {
	return Game_Interpreter::GetForegroundInterpreter()._state;
}

lcf::rpg::SaveEventExecState const& Game_Interpreter_Inspector::GetExecState(Game_Event const& ev) {
	if (!ev.interpreter) {
		return empty_state;
	}
	return ev.interpreter->GetState();
}

lcf::rpg::SaveEventExecState const& Game_Interpreter_Inspector::GetExecState(Game_CommonEvent const& ce) {
	if (!ce.interpreter) {
		return empty_state;
	}
	return ce.interpreter->GetState();
}

lcf::rpg::SaveEventExecState& Game_Interpreter_Inspector::GetExecStateUnsafe(Game_Event& ev) {
	assert(ev.interpreter);
	return ev.interpreter->_state;
}

lcf::rpg::SaveEventExecState& Game_Interpreter_Inspector::GetExecStateUnsafe(Game_CommonEvent& ce) {
	assert(ce.interpreter);
	return ce.interpreter->_state;
}

bool Game_Interpreter_Inspector::IsInActiveExcecution(Game_Event const& ev, bool background_only) {
	if (!background_only) {
		//TODO
	}
	if (!ev.IsActive() || ev.GetTrigger() != lcf::rpg::EventPage::Trigger_parallel) {
		return false;
	}
	auto pg = ev.GetActivePage();
	if (pg == nullptr || pg->event_commands.empty())
		return false;
	return ev.interpreter && ev.interpreter->IsRunning();
}

bool Game_Interpreter_Inspector::IsInActiveExcecution(Game_CommonEvent const& ce, bool background_only) {
	if (!background_only) {
		//TODO
	}
	if (!ce.IsWaitingBackgroundExecution(false)) {
		return false;
	}
	return ce.interpreter && ce.interpreter->IsRunning();
}


/*end of file .\game_interpreter.cpp*/

/*start of file .\game_interpreter_battle.cpp*/

/* ... license chunk ... */

 // Headers
#include "game_actors.h"
#include "game_battle.h"
#include "game_enemyparty.h"
#include "game_interpreter_battle.h"
#include "game_party.h"
#include "game_switches.h"
#include "game_system.h"
#include "game_variables.h"
#include <lcf/reader_util.h>
#include "main_data.h"
#include "output.h"
#include "player.h"
#include "game_map.h"
#include "spriteset_battle.h"
#include <cassert>
#include "scene_battle.h"

using namespace Game_Interpreter_Shared;

enum BranchBattleSubcommand {
	eOptionBranchBattleElse = 1
};

enum TargetType {
	Actor,
	Member,
	Enemy,
};

// Implemented as a static map, since maniac hooks can only have one common event callback at a time.
// Subsequent calls will simply override the previous common event callback.
std::map<Game_Interpreter_Battle::ManiacBattleHookType, std::tuple<int, int>> Game_Interpreter_Battle::maniac_hooks;

void Game_Interpreter_Battle::InitBattle() {
	if (Player::IsPatchManiac()) {
		Game_Interpreter_Battle::maniac_hooks = {
			{Game_Interpreter_Battle::ManiacBattleHookType::AtbIncrement, std::make_tuple(0, 0)},
			{Game_Interpreter_Battle::ManiacBattleHookType::DamagePop, std::make_tuple(0, 0)},
			{Game_Interpreter_Battle::ManiacBattleHookType::Targetting, std::make_tuple(0, 0)},
			{Game_Interpreter_Battle::ManiacBattleHookType::SetState, std::make_tuple(0, 0)},
			{Game_Interpreter_Battle::ManiacBattleHookType::StatChange, std::make_tuple(0, 0)}
		};
	}
}

static const char* target_text[] = { "actor", "party member", "enemy" };

static void MissingTargetWarning(const char* command_name, TargetType target_type, int target_id) {
	Output::Warning("{}: Invalid {} ID: {}", command_name, target_text[target_type], target_id);
}

// Provides a facility for battle sub-events to be run immediately
// without blocking the standard interpreter from actually processing them.
std::unique_ptr<Game_Interpreter_Battle> maniac_interpreter;

Game_Interpreter_Battle::Game_Interpreter_Battle(Span<const lcf::rpg::TroopPage> pages)
	: Game_Interpreter(true), pages(pages), executed(pages.size(), false)
{
	maniac_interpreter.reset(new Game_Interpreter_Battle());
}

Game_Interpreter_Battle::Game_Interpreter_Battle()
	: Game_Interpreter(true)
{
}

bool Game_Interpreter_Battle::AreConditionsMet(const lcf::rpg::TroopPageCondition& condition, Game_Battler* source) {
	if (!condition.flags.switch_a &&
		!condition.flags.switch_b &&
		!condition.flags.variable &&
		!condition.flags.turn &&
		!condition.flags.turn_enemy &&
		!condition.flags.turn_actor &&
		!condition.flags.fatigue &&
		!condition.flags.enemy_hp &&
		!condition.flags.actor_hp &&
		!condition.flags.command_actor
		) {
		// Pages without trigger are never run
		return false;
	}

	if (condition.flags.switch_a && !Main_Data::game_switches->Get(condition.switch_a_id))
		return false;

	if (condition.flags.switch_b && !Main_Data::game_switches->Get(condition.switch_b_id))
		return false;

	if (condition.flags.variable && !(Main_Data::game_variables->Get(condition.variable_id) >= condition.variable_value))
		return false;

	if (condition.flags.turn && !Game_Battle::CheckTurns(Game_Battle::GetTurn(), condition.turn_b, condition.turn_a))
		return false;

	if (Player::IsRPG2k3Commands() && condition.flags.turn_enemy) {
		const auto* enemy = Main_Data::game_enemyparty->GetEnemy(condition.turn_enemy_id);
		if (!enemy) {
			Output::Warning("AreConditionsMet: Invalid enemy ID {}", condition.turn_enemy_id);
			return false;
		}

		if (source && source != enemy)
			return false;
		if (!Game_Battle::CheckTurns(enemy->GetBattleTurn(), condition.turn_enemy_b, condition.turn_enemy_a))
			return false;
	}

	if (Player::IsRPG2k3Commands() && condition.flags.turn_actor) {
		const auto* actor = Main_Data::game_actors->GetActor(condition.turn_actor_id);
		if (!actor) {
			Output::Warning("AreConditionsMet: Invalid actor ID {}", condition.turn_actor_id);
			return false;
		}

		if (source && source != actor)
			return false;
		if (!Game_Battle::CheckTurns(actor->GetBattleTurn(), condition.turn_actor_b, condition.turn_actor_a))
			return false;
	}

	if (Player::IsRPG2k3Commands() && condition.flags.fatigue) {
		int fatigue = Main_Data::game_party->GetFatigue();
		if (fatigue < condition.fatigue_min || fatigue > condition.fatigue_max)
			return false;
	}

	if (condition.flags.enemy_hp) {
		const auto* enemy = Main_Data::game_enemyparty->GetEnemy(condition.enemy_id);
		if (!enemy) {
			Output::Warning("AreConditionsMet: Invalid enemy ID {}", condition.enemy_id);
			return false;
		}

		int result = 100 * enemy->GetHp() / enemy->GetMaxHp();
		if (result < condition.enemy_hp_min || result > condition.enemy_hp_max)
			return false;
	}

	if (condition.flags.actor_hp) {
		const auto* actor = Main_Data::game_actors->GetActor(condition.actor_id);
		if (!actor) {
			Output::Warning("AreConditionsMet: Invalid actor ID {}", condition.actor_id);
			return false;
		}

		int result = 100 * actor->GetHp() / actor->GetMaxHp();
		if (result < condition.actor_hp_min || result > condition.actor_hp_max)
			return false;
	}

	if (Player::IsRPG2k3Commands() && condition.flags.command_actor) {
		if (!source)
			return false;
		const auto* actor = Main_Data::game_actors->GetActor(condition.command_actor_id);
		if (!actor) {
			Output::Warning("AreConditionsMet: Invalid actor ID {}", condition.command_actor_id);
			return false;
		}

		if (source != actor)
			return false;
		if (condition.command_id != actor->GetLastBattleAction())
			return false;
	}

	return true;
}

int Game_Interpreter_Battle::ScheduleNextPage(Game_Battler* source) {
	lcf::rpg::TroopPageCondition::Flags f;
	for (auto& ff: f.flags) ff = true;

	return ScheduleNextPage(f, source);
}

static bool HasRequiredCondition(lcf::rpg::TroopPageCondition::Flags page, lcf::rpg::TroopPageCondition::Flags required) {
	for (size_t i = 0; i < page.flags.size(); ++i) {
		if (required.flags[i] && page.flags[i]) {
			return true;
		}
	}
	return false;
}

int Game_Interpreter_Battle::ScheduleNextPage(lcf::rpg::TroopPageCondition::Flags required_conditions, Game_Battler* source) {
	if (IsRunning()) {
		return 0;
	}

	for (size_t i = 0; i < pages.size(); ++i) {
		auto& page = pages[i];
		if (executed[i]
				|| !HasRequiredCondition(page.condition.flags, required_conditions)
				|| !AreConditionsMet(page.condition, source)) {
			continue;
		}
		Clear();
		Push<ExecutionType::Action, EventType::BattleEvent>(page.event_commands, 0);
		executed[i] = true;
		return i + 1;
	}
	return 0;
}

// Execute Command.
bool Game_Interpreter_Battle::ExecuteCommand(lcf::rpg::EventCommand const& com) {
	switch (static_cast<Cmd>(com.code)) {
		case Cmd::CallCommonEvent:
			return CmdSetup<&Game_Interpreter_Battle::CommandCallCommonEvent, 1>(com);
		case Cmd::ForceFlee:
			return CmdSetup<&Game_Interpreter_Battle::CommandForceFlee, 3>(com);
		case Cmd::EnableCombo:
			return CmdSetup<&Game_Interpreter_Battle::CommandEnableCombo, 3>(com);
		case Cmd::ChangeMonsterHP:
			return CmdSetup<&Game_Interpreter_Battle::CommandChangeMonsterHP, 5>(com);
		case Cmd::ChangeMonsterMP:
			return CmdSetup<&Game_Interpreter_Battle::CommandChangeMonsterMP, 4>(com);
		case Cmd::ChangeMonsterCondition:
			return CmdSetup<&Game_Interpreter_Battle::CommandChangeMonsterCondition, 3>(com);
		case Cmd::ShowHiddenMonster:
			return CmdSetup<&Game_Interpreter_Battle::CommandShowHiddenMonster, 1>(com);
		case Cmd::ChangeBattleBG:
			return CmdSetup<&Game_Interpreter_Battle::CommandChangeBattleBG, 0>(com);
		case Cmd::ShowBattleAnimation_B:
			return CmdSetup<&Game_Interpreter_Battle::CommandShowBattleAnimation, 3>(com);
		case Cmd::TerminateBattle:
			return CmdSetup<&Game_Interpreter_Battle::CommandTerminateBattle, 0>(com);
		case Cmd::ConditionalBranch_B:
			return CmdSetup<&Game_Interpreter_Battle::CommandConditionalBranchBattle, 5>(com);
		case Cmd::ElseBranch_B:
			return CmdSetup<&Game_Interpreter_Battle::CommandElseBranchBattle, 0>(com);
		case Cmd::EndBranch_B:
			return CmdSetup<&Game_Interpreter_Battle::CommandEndBranchBattle, 0>(com);
		case Cmd::Maniac_ControlBattle:
			return CmdSetup<&Game_Interpreter_Battle::CommandManiacControlBattle, 4>(com);
		case Cmd::Maniac_ControlAtbGauge:
			return CmdSetup<&Game_Interpreter_Battle::CommandManiacControlAtbGauge, 7>(com);
		case Cmd::Maniac_ChangeBattleCommandEx:
			return CmdSetup<&Game_Interpreter_Battle::CommandManiacChangeBattleCommandEx, 2>(com);
		case Cmd::Maniac_GetBattleInfo:
			return CmdSetup<&Game_Interpreter_Battle::CommandManiacGetBattleInfo, 5>(com);
		default:
			return Game_Interpreter::ExecuteCommand(com);
	}
}

// Commands

bool Game_Interpreter_Battle::CommandCallCommonEvent(lcf::rpg::EventCommand const& com) {
	if (!Player::IsRPG2k3Commands()) {
		return true;
	}

	int evt_id = com.parameters[0];

	Game_CommonEvent* common_event = lcf::ReaderUtil::GetElement(Game_Map::GetCommonEvents(), evt_id);
	if (!common_event) {
		Output::Warning("CallCommonEvent: Can't call invalid common event {}", evt_id);
		return true;
	}

	Push<ExecutionType::Call>(common_event);

	return true;
}

bool Game_Interpreter_Battle::CommandForceFlee(lcf::rpg::EventCommand const& com) {
	if (!Player::IsRPG2k3Commands()) {
		return true;
	}

	bool check = com.parameters[2] == 0;

	switch (com.parameters[0]) {
	case 0:
		if (!check || Game_Battle::GetBattleCondition() != lcf::rpg::System::BattleCondition_pincers) {
			this->force_flee_enabled = true;
		}
		break;
	case 1:
		if (!check || Game_Battle::GetBattleCondition() != lcf::rpg::System::BattleCondition_surround) {
			int num_escaped = 0;
			for (auto* enemy: Main_Data::game_enemyparty->GetEnemies()) {
				if (enemy->Exists()) {
					enemy->SetHidden(true);
					enemy->SetDeathTimer();
					++num_escaped;
				}
			}
			if (num_escaped) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Escape));
			}
		}
		break;
	case 2:
		if (!check || Game_Battle::GetBattleCondition() != lcf::rpg::System::BattleCondition_surround) {
			auto* enemy = Main_Data::game_enemyparty->GetEnemy(com.parameters[1]);
			if (!enemy) {
				Output::Warning("ForceFlee: Invalid enemy ID {}", com.parameters[1]);
				return true;
			}

			if (enemy->Exists()) {
				enemy->SetHidden(true);
				enemy->SetDeathTimer();
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Escape));
			}
		}
		break;
	}

	return true;
}

bool Game_Interpreter_Battle::CommandEnableCombo(lcf::rpg::EventCommand const& com) {
	if (!Player::IsRPG2k3Commands()) {
		return true;
	}

	int actor_id = com.parameters[0];

	if (!Main_Data::game_party->IsActorInParty(actor_id)) {
		return true;
	}

	int command_id = com.parameters[1];
	int multiple = com.parameters[2];

	Game_Actor* actor = Main_Data::game_actors->GetActor(actor_id);

	if (!actor) {
		Output::Warning("EnableCombo: Invalid actor ID {}", actor_id);
		return true;
	}

	actor->SetBattleCombo(command_id, multiple);

	return true;
}

bool Game_Interpreter_Battle::CommandChangeMonsterHP(lcf::rpg::EventCommand const& com) {
	auto* enemy = Main_Data::game_enemyparty->GetEnemy(com.parameters[0]);
	if (!enemy) {
		Output::Warning("ChangeMonsterHP: Invalid enemy ID {}", com.parameters[0]);
		return true;
	}

	bool lose = com.parameters[1] > 0;
	bool lethal = com.parameters[4] > 0;
	int hp = enemy->GetHp();

	if (enemy->IsDead())
		return true;

	int change = 0;
	switch (com.parameters[2]) {
	case 0:
		change = com.parameters[3];
		break;
	case 1:
		change = Main_Data::game_variables->Get(com.parameters[3]);
		break;
	case 2:
		change = com.parameters[3] * hp / 100;
		break;
	}

	if (lose) {
		change = -change;
	}

	enemy->ChangeHp(change, lethal);

	auto& scene = Scene::instance;
	if (scene) {
		scene->OnEventHpChanged(enemy, change);
	}

	if (enemy->IsDead()) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_EnemyKill));
		enemy->SetDeathTimer();
	}

	return true;
}

bool Game_Interpreter_Battle::CommandChangeMonsterMP(lcf::rpg::EventCommand const& com) {
	auto* enemy = Main_Data::game_enemyparty->GetEnemy(com.parameters[0]);
	if (!enemy) {
		Output::Warning("ChangeMonsterMP: Invalid enemy ID {}", com.parameters[0]);
		return true;
	}

	bool lose = com.parameters[1] > 0;
	int sp = enemy->GetSp();

	int change = 0;
	switch (com.parameters[2]) {
	case 0:
		change = com.parameters[3];
		break;
	case 1:
		change = Main_Data::game_variables->Get(com.parameters[3]);
		break;
	}

	if (lose)
		change = -change;

	sp += change;

	enemy->SetSp(sp);

	return true;
}

bool Game_Interpreter_Battle::CommandChangeMonsterCondition(lcf::rpg::EventCommand const& com) {
	auto* enemy = Main_Data::game_enemyparty->GetEnemy(com.parameters[0]);
	if (!enemy) {
		Output::Warning("ChangeMonsterCondition: Invalid enemy ID {}", com.parameters[0]);
		return true;
	}

	bool remove = com.parameters[1] > 0;
	int state_id = com.parameters[2];
	if (remove) {
		// RPG_RT BUG: Monster dissapears immediately and doesn't animate death
		enemy->RemoveState(state_id, false);
	} else {
		enemy->AddState(state_id, true);
	}
	return true;
}

bool Game_Interpreter_Battle::CommandShowHiddenMonster(lcf::rpg::EventCommand const& com) {
	auto* enemy = Main_Data::game_enemyparty->GetEnemy(com.parameters[0]);
	if (!enemy) {
		Output::Warning("ShowHiddenMonster: Invalid enemy ID {}", com.parameters[0]);
		return true;
	}

	enemy->SetHidden(false);
	return true;
}

bool Game_Interpreter_Battle::CommandChangeBattleBG(lcf::rpg::EventCommand const& com) {
	Game_Battle::ChangeBackground(ToString(com.string));
	return true;
}

bool Game_Interpreter_Battle::CommandShowBattleAnimation(lcf::rpg::EventCommand const& com) {
	int animation_id = com.parameters[0];
	int target = com.parameters[1];
	bool waiting_battle_anim = com.parameters[2] != 0;
	bool allies = false;

	if (Player::IsRPG2k3() && com.parameters.size() > 3) {
		allies = com.parameters[3] != 0;
	}

	int frames = 0;

	if (target < 0) {
		std::vector<Game_Battler*> v;

		if (allies) {
			Main_Data::game_party->GetBattlers(v);
		} else {
			Main_Data::game_enemyparty->GetBattlers(v);
		}
		auto iter = std::remove_if(v.begin(), v.end(),
				[](auto* target) { return !(target->Exists() || (target->GetType() == Game_Battler::Type_Ally && target->IsDead())); });
		v.erase(iter, v.end());

		frames = Game_Battle::ShowBattleAnimation(animation_id, v, false);
	}
	else {
		Game_Battler* battler_target = nullptr;

		if (allies) {
			// Allies counted from 1
			target -= 1;
			if (target >= 0 && target < Main_Data::game_party->GetBattlerCount()) {
				battler_target = &(*Main_Data::game_party)[target];
			}
		}
		else {
			if (target < Main_Data::game_enemyparty->GetBattlerCount()) {
				battler_target = &(*Main_Data::game_enemyparty)[target];
			}
		}

		if (battler_target) {
			frames = Game_Battle::ShowBattleAnimation(animation_id, { battler_target });
		}
	}

	if (waiting_battle_anim) {
		_state.wait_time = frames;
	}

	return true;
}

bool Game_Interpreter_Battle::CommandTerminateBattle(lcf::rpg::EventCommand const& /* com */) {
	_async_op = AsyncOp::MakeTerminateBattle(static_cast<int>(BattleResult::Abort));
	return false;
}

// Conditional branch.
bool Game_Interpreter_Battle::CommandConditionalBranchBattle(lcf::rpg::EventCommand const& com) {
	bool result = false;
	int value1, value2;

	switch (com.parameters[0]) {
		case 0:
			// Switch
			result = Main_Data::game_switches->Get(com.parameters[1]) == (com.parameters[2] == 0);
			break;
		case 1:
			// Variable
			value1 = Main_Data::game_variables->Get(com.parameters[1]);
			if (com.parameters[2] == 0) {
				value2 = com.parameters[3];
			} else {
				value2 = Main_Data::game_variables->Get(com.parameters[3]);
			}
			switch (com.parameters[4]) {
				case 0:
					// Equal to
					result = (value1 == value2);
					break;
				case 1:
					// Greater than or equal
					result = (value1 >= value2);
					break;
				case 2:
					// Less than or equal
					result = (value1 <= value2);
					break;
				case 3:
					// Greater than
					result = (value1 > value2);
					break;
				case 4:
					// Less than
					result = (value1 < value2);
					break;
				case 5:
					// Different
					result = (value1 != value2);
					break;
			}
			break;
		case 2: {
			// Hero can act
			const auto* actor = Main_Data::game_actors->GetActor(com.parameters[1]);

			if (!actor) {
				Output::Warning("ConditionalBranchBattle: Invalid actor ID {}", com.parameters[1]);
			} else {
				result = actor->CanAct();
			}
			break;
		}
		case 3: {
			// Monster can act
			const auto* enemy = Main_Data::game_enemyparty->GetEnemy(com.parameters[1]);

			if (!enemy) {
				Output::Warning("ConditionalBranchBattle: Invalid enemy ID {}", com.parameters[1]);
			} else {
				result = enemy->CanAct();
			}
			break;
		}
		case 4:
			// Monster is the current target
			if (Player::IsRPG2k3Commands()) {
				result = (targets_single_enemy && target_enemy_index == com.parameters[1]);
			}
			break;
		case 5: {
			// Hero uses the ... command
			if (Player::IsRPG2k3Commands() && current_actor_id == com.parameters[1]) {
				auto *actor = Main_Data::game_actors->GetActor(current_actor_id);
				if (actor) {
					result = actor->GetLastBattleAction() == com.parameters[2];
				}
			}
			break;
		}
	}

	int sub_idx = subcommand_sentinel;
	if (!result) {
		sub_idx = eOptionBranchBattleElse;
		SkipToNextConditional({Cmd::ElseBranch_B, Cmd::EndBranch_B}, com.indent);
	}

	SetSubcommandIndex(com.indent, sub_idx);
	return true;
}

bool Game_Interpreter_Battle::CommandElseBranchBattle(lcf::rpg::EventCommand const& com) { //code 23310
	return CommandOptionGeneric(com, eOptionBranchBattleElse, {Cmd::EndBranch_B});
}

bool Game_Interpreter_Battle::CommandEndBranchBattle(lcf::rpg::EventCommand const& /* com */) { //code 23311
	return true;
}

bool Game_Interpreter_Battle::ManiacBattleHook(ManiacBattleHookType hook_type, int var1, int var2, int var3, int var4, int var5, int var6) {
	if (!Player::IsPatchManiac()) {
		return false;
	}

	int common_event_id = std::get<0>(maniac_hooks[hook_type]);
	int variable_start_id = std::get<1>(maniac_hooks[hook_type]);

	if (common_event_id <= 0) {
		return false;
	}

	Game_CommonEvent* common_event = lcf::ReaderUtil::GetElement(Game_Map::GetCommonEvents(), common_event_id);
	if (!common_event) {
		Output::Warning("CommandManiacControlBattle: Can't call invalid common event {}", common_event_id);
		return false;
	}
	
	// pushes the common event to be run into the queue of events.
	maniac_interpreter->Push<ExecutionType::ManiacHook>(common_event);

	// pushes the change variable events into the interpreters
	// event queue, so we don't run into a race condition.
	std::vector<lcf::rpg::EventCommand> pre_commands;
	for (size_t i = 0; i < 6; i++)
	{
		auto event_command = lcf::rpg::EventCommand();
		event_command.code = static_cast<int>(lcf::rpg::EventCommand::Code::ControlVars);
		event_command.parameters = lcf::DBArray<int32_t>(7);
		event_command.parameters[1] = variable_start_id + i;
		switch (i)
		{
			case 0:
				event_command.parameters[5] = var1;
				break;
			case 1:
				event_command.parameters[5] = var2;
				break;
			case 2:
				event_command.parameters[5] = var3;
				break;
			case 3:
				event_command.parameters[5] = var4;
				break;
			case 4:
				event_command.parameters[5] = var5;
				break;
			case 5:
				event_command.parameters[5] = var6;
				break;
			default:
				break;
		}
		pre_commands.push_back(event_command);
	}

	// Push is actually "push_back", so this gets added before other events.
	maniac_interpreter->Push<ExecutionType::ManiacHook, EventType::None>(pre_commands, 0);

	// Necessary to start the sub-event.
	maniac_interpreter->Update();

	return true;
}

bool Game_Interpreter_Battle::ProcessManiacSubEvents() {
	// If we have sub-events we're going to update them immediately
	// until the queue is empty while making the rest of the game wait.
	if (Player::IsPatchManiac() && maniac_interpreter->IsRunning()) {
		maniac_interpreter->Update();
		return true;
	}
	return false;
}

bool Game_Interpreter_Battle::CommandManiacControlBattle(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	ManiacBattleHookType control_type_flags = static_cast<ManiacBattleHookType>(com.parameters[0]);
	int common_event_identifier = ValueOrVariable(com.parameters[1], com.parameters[2]);
	int value_reference_identifier = com.parameters[3];

	// Sets the maniacs battle event hook to:
	// the common event id and the variable id the developer would like to use.
	std::get<0>(maniac_hooks[control_type_flags]) = common_event_identifier;
	std::get<1>(maniac_hooks[control_type_flags]) = value_reference_identifier;

	return true;
}

bool Game_Interpreter_Battle::CommandManiacControlAtbGauge(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	int target_flags = com.parameters[0];
	int target_reference_flags = com.parameters[1];
	int target_reference_identifier = com.parameters[2];
	int operation_flags = com.parameters[3];
	int operand_flags = com.parameters[4];
	int value_reference_flags = com.parameters[5];
	int value_reference_identifier = com.parameters[6];

	int target_id = ValueOrVariable(target_reference_flags, target_reference_identifier);

	auto getAtbValue = [this, value_reference_flags, value_reference_identifier](int flags) {
		int value = ValueOrVariable(value_reference_flags, value_reference_identifier);

		switch (flags) {
			case 0:
				// value
				return value;
				break;
			case 1:
				// percentage
				return (int) ((double)value / 100 * Game_Battler::GetMaxAtbGauge());
				break;
			default: return 0;
		}
	};

	auto executeOperation = [getAtbValue, operand_flags, target_id](int flags, Game_Battler* battler, TargetType battler_type) {
		if (!battler) {
			MissingTargetWarning("CommandManiacControlAtbGauge", battler_type, target_id);
			return;
		}

		switch (flags) {
			case 0:
				// set
				battler->SetAtbGauge(getAtbValue(operand_flags));
				break;
			case 1:
				// add
				battler->IncrementAtbGauge(getAtbValue(operand_flags));
				break;
			case 2:
				// sub
				battler->IncrementAtbGauge(-getAtbValue(operand_flags));
				break;
		}
	};

	switch (target_flags) {
		case 0:
			// actor
			if (target_id > 0) {
				executeOperation(operation_flags, Main_Data::game_actors->GetActor(target_id), Actor);
			}
			break;
		case 1:
			// party member
			executeOperation(operation_flags, Main_Data::game_party->GetActor(target_id), Member);
			break;
		case 2:
			// entire party
			for (Game_Battler* member : Main_Data::game_party->GetActors()) {
				executeOperation(operation_flags, member, Member);
			}
			break;
		case 3:
			// troop member
			if (target_id > 0) {
				executeOperation(operation_flags, Main_Data::game_enemyparty->GetEnemy(target_id), Enemy);
			}
			break;
		case 4:
			// entire troop
			for (Game_Battler* member : Main_Data::game_enemyparty->GetEnemies()) {
				executeOperation(operation_flags, member, Enemy);
			}
			break;
	}

	return true;
}

bool Game_Interpreter_Battle::CommandManiacChangeBattleCommandEx(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	// 1 row removed
	bool actor_command_flags = com.parameters[0];

	lcf::Data::battlecommands.easyrpg_disable_row_feature = actor_command_flags;

	// 10000 lose added
	// 01000 win added
	// 00100 escape removed
	// 00010 auto removed
	// 00001 fight removed
	int party_command_flags = com.parameters[1];

	lcf::Data::system.easyrpg_battle_options.clear();
	for (size_t i = 0; i < Scene_Battle::BattleOptionType::Lose + 1; i++) {
		bool party_command_flag = party_command_flags & (1 << i);
		bool flag_is_set = i > 2;

		if (party_command_flag == flag_is_set) {
			lcf::Data::system.easyrpg_battle_options.push_back(i);
		}
	}

	auto* scene_battle = static_cast<Scene_Battle*>(Scene::instance.get());

	if (scene_battle) {
		scene_battle->CreateOptions();
	}

	return true;
}

bool Game_Interpreter_Battle::CommandManiacGetBattleInfo(lcf::rpg::EventCommand const& com) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	int target_flags = com.parameters[0];
	int target_reference_flags = com.parameters[2];
	int target_reference_identifier = com.parameters[3];
	int information_flags = com.parameters[1];
	int information_identifier = com.parameters[4];

	int target_id = ValueOrVariable(target_reference_flags, target_reference_identifier);

	auto executeOperationSingle = [information_flags, information_identifier, target_id](Game_Battler* battler, TargetType battler_type) {
		if (!battler) {
			MissingTargetWarning("CommandManiacGetBattleInfo", battler_type, target_id);
			return;
		}

		switch (information_flags)
		{
			case 0:
				// parameter buffs: attack, defense, mind, agility
				Main_Data::game_variables->Set(information_identifier, battler->GetAtkModifier());
				Main_Data::game_variables->Set(information_identifier + 1, battler->GetDefModifier());
				Main_Data::game_variables->Set(information_identifier + 2, battler->GetSpiModifier());
				Main_Data::game_variables->Set(information_identifier + 3, battler->GetAgiModifier());
				break;
			case 1:
			{
				// states: size, [...state_id]
				auto states = lcf::Data::states.size();
				Main_Data::game_variables->Set(information_identifier, states);
				for (size_t i = 0; i < states; i++)
				{
					Main_Data::game_variables->Set(information_identifier + i + 1, battler->HasState(lcf::Data::states[i].ID));
				}
				break;
			}
			case 2:
			{
				// elements: size, [...element_id]
				auto elements = lcf::Data::attributes.size();
				Main_Data::game_variables->Set(information_identifier, elements);
				for (size_t i = 0; i < elements; i++)
				{
					Main_Data::game_variables->Set(information_identifier + i + 1, battler->GetAttributeRateShift(lcf::Data::attributes[i].ID) + 1);
				}
				break;
			}
			case 3:
				// others: x, y, can move, defending, charging, appeared
				Main_Data::game_variables->Set(information_identifier, battler->GetBattlePosition().x);
				Main_Data::game_variables->Set(information_identifier + 1, battler->GetBattlePosition().y);
				Main_Data::game_variables->Set(information_identifier + 2, battler->CanAct());
				Main_Data::game_variables->Set(information_identifier + 3, battler->IsDefending());
				Main_Data::game_variables->Set(information_identifier + 4, battler->IsCharged());
				Main_Data::game_variables->Set(information_identifier + 5, !battler->IsHidden());
				break;
		}
	};

	auto executeOperationMany = [information_flags](Game_Battler* battler) {
		switch (information_flags)
		{
			case 0:
				// list of members
				return true;
			case 1:
				// list of members alive
				return !battler->IsDead();
			case 2:
				// list of members who can move
				return battler->CanAct();
		}

		return false;
	};

	switch (target_flags) {
		case 0:
			// actor
			if (target_id > 0) {
				executeOperationSingle(Main_Data::game_actors->GetActor(target_id), Actor);
			}
			break;
		case 1:
			// party member
			executeOperationSingle(Main_Data::game_party->GetActor(target_id), Member);
			break;
		case 2:
		{
			// entire party
			auto count = 0;
			for (Game_Battler* member : Main_Data::game_party->GetActors()) {
				count += executeOperationMany(member);
			}
			Main_Data::game_variables->Set(information_identifier, count);
			break;
		}
		case 3:
			// troop member
			if (target_id > 0) {
				executeOperationSingle(Main_Data::game_enemyparty->GetEnemy(target_id), Enemy);
			}
			break;
		case 4:
		{
			// entire troop
			auto count = 0;
			for (Game_Battler* member : Main_Data::game_enemyparty->GetEnemies()) {
				count += executeOperationMany(member);
			}
			Main_Data::game_variables->Set(information_identifier, count);
			break;
		}
	}

	return true;
}



/*end of file .\game_interpreter_battle.cpp*/

/*start of file .\game_interpreter_control_variables.cpp*/

/* ... license chunk ... */

#include "game_interpreter_shared.h"
#include "game_interpreter_control_variables.h"
#include "game_actors.h"
#include "game_enemyparty.h"
#include "game_ineluki.h"
#include "game_interpreter.h"
#include "game_party.h"
#include "game_player.h"
#include "game_system.h"
#include "main_data.h"
#include "output.h"
#include "player.h"
#include "rand.h"
#include "utils.h"
#include "audio.h"
#include <cmath>
#include <cstdint>
#include <lcf/rpg/savepartylocation.h>

int ControlVariables::Random(int value, int value2) {
	int rmax = std::max(value, value2);
	int rmin = std::min(value, value2);

	return Rand::GetRandomNumber(rmin, rmax);
}

int ControlVariables::Item(int op, int item) {
	switch (op) {
		case 0:
			// Number of items posessed
			return Main_Data::game_party->GetItemCount(item);
			break;
		case 1:
			// How often the item is equipped
			return Main_Data::game_party->GetEquippedItemCount(item);
			break;
	}

	Output::Warning("ControlVariables::Item: Unknown op {}", op);
	return 0;
}

int ControlVariables::Actor(int op, int actor_id) {
	auto actor = Main_Data::game_actors->GetActor(actor_id);

	if (!actor) {
		Output::Warning("ControlVariables::Actor: Bad actor_id {}", actor_id);
		return 0;
	}

	switch (op) {
		case 0:
			// Level
			return actor->GetLevel();
			break;
		case 1:
			// Experience
			return actor->GetExp();
			break;
		case 2:
			// Current HP
			return actor->GetHp();
			break;
		case 3:
			// Current MP
			return actor->GetSp();
			break;
		case 4:
			// Max HP
			return actor->GetMaxHp();
			break;
		case 5:
			// Max MP
			return actor->GetMaxSp();
			break;
		case 6:
			// Attack
			return actor->GetAtk();
			break;
		case 7:
			// Defense
			return actor->GetDef();
			break;
		case 8:
			// Intelligence
			return actor->GetSpi();
			break;
		case 9:
			// Agility
			return actor->GetAgi();
			break;
		case 10:
			// Weapon ID
			return actor->GetWeaponId();
			break;
		case 11:
			// Shield ID
			return actor->GetShieldId();
			break;
		case 12:
			// Armor ID
			return actor->GetArmorId();
			break;
		case 13:
			// Helmet ID
			return actor->GetHelmetId();
			break;
		case 14:
			// Accessory ID
			return actor->GetAccessoryId();
			break;
		case 15:
			// ID
			if (Player::IsPatchManiac()) {
				return actor->GetId();
			}
			break;
		case 16:
			// ATB
			if (Player::IsPatchManiac()) {
				return actor->GetAtbGauge();
			}
			break;
	}

	Output::Warning("ControlVariables::Actor: Unknown op {}", op);
	return 0;
}

int ControlVariables::Party(int op, int party_idx) {
	auto actor = Main_Data::game_party->GetActor(party_idx);

	if (!actor) {
		Output::Warning("ControlVariables::Party: Bad party_idx {}", party_idx);
		return 0;
	}

	return ControlVariables::Actor(op, actor->GetId());
}

int ControlVariables::Event(int op, int event_id, const Game_BaseInterpreterContext& interpreter) {
	auto character = interpreter.GetCharacter(event_id, "ControlVariables::Event");
	if (character) {
		switch (op) {
			case 0:
				// Map ID
				if (!Player::IsRPG2k()
					|| event_id == Game_Character::CharPlayer
					|| event_id == Game_Character::CharBoat
					|| event_id == Game_Character::CharShip
					|| event_id == Game_Character::CharAirship) {
					return character->GetMapId();
				} else {
					// This is an RPG_RT bug for 2k only. Requesting the map id of an event always returns 0.
					return 0;
				}
				break;
			case 1:
				// X Coordinate
				return character->GetX();
				break;
			case 2:
				// Y Coordinate
				return character->GetY();
				break;
			case 3:
				// Orientation
				int dir;
				dir = character->GetFacing();
				return dir == 0 ? 8 :
						dir == 1 ? 6 :
						dir == 2 ? 2 : 4;
				break;
			case 4: {
				// Screen X
				if (Player::game_config.fake_resolution.Get()) {
					int pan_delta = (Game_Player::GetDefaultPanX() - lcf::rpg::SavePartyLocation::kPanXDefault) / TILE_SIZE;
					return character->GetScreenX() - pan_delta;
				} else {
					return character->GetScreenX();
				}
			}
			case 5: {
				// Screen Y
				if (Player::game_config.fake_resolution.Get()) {
					int pan_delta = (Game_Player::GetDefaultPanY() - lcf::rpg::SavePartyLocation::kPanYDefault) / TILE_SIZE;
					return character->GetScreenY() - pan_delta;
				} else {
					return character->GetScreenY();
				}
			}
			case 6:
				// Event ID
				return Player::IsPatchManiac() ? interpreter.GetThisEventId() : 0;
		}

		Output::Warning("ControlVariables::Event: Unknown op {}", op);
	}

	return 0;
}

int ControlVariables::Other(int op) {
	switch (op) {
		case 0:
			// Gold
			return Main_Data::game_party->GetGold();
			break;
		case 1:
			// Timer 1 remaining time
			return Main_Data::game_party->GetTimerSeconds(Main_Data::game_party->Timer1);
			break;
		case 2:
			// Number of heroes in party
			return Main_Data::game_party->GetActors().size();
			break;
		case 3:
			// Number of saves
			return Main_Data::game_system->GetSaveCount();
			break;
		case 4:
			// Number of battles
			return Main_Data::game_party->GetBattleCount();
			break;
		case 5:
			// Number of wins
			return Main_Data::game_party->GetWinCount();
			break;
		case 6:
			// Number of defeats
			return Main_Data::game_party->GetDefeatCount();
			break;
		case 7:
			// Number of escapes (aka run away)
			return Main_Data::game_party->GetRunCount();
			break;
		case 8:
			// MIDI play position
			if (Player::IsPatchKeyPatch()) {
				return Main_Data::game_ineluki->GetMidiTicks();
			} else {
				return Audio().BGM_GetTicks();
			}
			break;
		case 9:
			// Timer 2 remaining time
			return Main_Data::game_party->GetTimerSeconds(Main_Data::game_party->Timer2);
			break;
		case 10:
			// Current date (YYMMDD)
			if (Player::IsPatchManiac()) {
				std::time_t t = std::time(nullptr);
				std::tm* tm = std::localtime(&t);
				return atoi(Utils::FormatDate(tm, Utils::DateFormat_YYMMDD).c_str());
			}
			break;
		case 11:
			// Current time (HHMMSS)
			if (Player::IsPatchManiac()) {
				std::time_t t = std::time(nullptr);
				std::tm* tm = std::localtime(&t);
				return atoi(Utils::FormatDate(tm, Utils::DateFormat_HHMMSS).c_str());
			}
			break;
		case 12:
			// Frames
			if (Player::IsPatchManiac()) {
				return Main_Data::game_system->GetFrameCounter();
			}
			break;
		case 13:
			// Patch version
			if (Player::IsPatchManiac()) {
				// Latest version before the engine rewrite
				return 200128;
			}
			break;
	}

	Output::Warning("ControlVariables::Other: Unknown op {}", op);
	return 0;
}

int ControlVariables::Enemy(int op, int enemy_idx) {
	auto enemy = Main_Data::game_enemyparty->GetEnemy(enemy_idx);

	if (!enemy) {
		Output::Warning("ControlVariables::Enemy: Bad enemy_idx {}", enemy_idx);
		return 0;
	}

	switch (op) {
		case 0:
			// Enemy HP
			return enemy->GetHp();
			break;
		case 1:
			// Enemy SP
			return enemy->GetSp();
			break;
		case 2:
			// Enemy MaxHP
			return enemy->GetMaxHp();
			break;
		case 3:
			// Enemy MaxSP
			return enemy->GetMaxSp();
			break;
		case 4:
			// Enemy Attack
			return enemy->GetAtk();
			break;
		case 5:
			// Enemy Defense
			return enemy->GetDef();
			break;
		case 6:
			// Enemy Spirit
			return enemy->GetSpi();
			break;
		case 7:
			// Enemy Agility
			return enemy->GetAgi();
			break;
		case 8:
			// ID
			if (Player::IsPatchManiac()) {
				return enemy->GetId();
			}
			break;
		case 9:
			// ATB
			if (Player::IsPatchManiac()) {
				return enemy->GetAtbGauge();
			}
			break;
	}

	Output::Warning("ControlVariables::Enemy: Unknown op {}", op);
	return 0;
}

int ControlVariables::Pow(int arg1, int arg2) {
	return static_cast<int>(std::pow(arg1, arg2));
}

int ControlVariables::Sqrt(int arg, int mul) {
	// This is not how negative sqrt works, just following the implementation here
	int res = static_cast<int>(sqrt(abs(arg)) * mul);
	if (arg < 0) {
		res = -res;
	}
	return res;
}

int ControlVariables::Sin(int arg1, int arg2, int mul) {
	float res = static_cast<float>(arg1);
	if (arg2 != 0) {
		res /= static_cast<float>(arg2);
	}
	return static_cast<int>(std::sin(res * M_PI / 180.f) * mul);
}

int ControlVariables::Cos(int arg1, int arg2, int mul) {
	float res = static_cast<float>(arg1);
	if (arg2 != 0) {
		res /= static_cast<float>(arg2);
	}
	return static_cast<int>(std::cos(res * M_PI / 180.f) * mul);
}

int ControlVariables::Atan2(int arg1, int arg2, int mul) {
	return static_cast<int>(std::atan2(arg1, arg2) * 180.f / M_PI * mul);
}

int ControlVariables::Min(int arg1, int arg2) {
	return std::min(arg1, arg2);
}

int ControlVariables::Max(int arg1, int arg2) {
	return std::max(arg1, arg2);
}

int ControlVariables::Abs(int arg) {
	return abs(arg);
}

int ControlVariables::Binary(int op, int arg1, int arg2) {
	// 64 Bit for overflow protection
	int64_t result = 0;

	auto arg1_64 = static_cast<int64_t>(arg1);
	auto arg2_64 = static_cast<int64_t>(arg2);

	switch (op) {
		case 1:
			result = arg1_64 + arg2_64;
			break;
		case 2:
			result = arg1_64 - arg2_64;
			break;
		case 3:
			result = arg1_64 * arg2_64;
			break;
		case 4:
			if (arg2_64 != 0) {
				result = arg1_64 / arg2_64;
			} else {
				result = arg1_64;
			}
			break;
		case 5:
			if (arg2_64 != 0) {
				result = arg1_64 % arg2_64;
			} else {
				result = arg1_64;
			}
			break;
		case 6:
			result = arg1_64 | arg2_64;
			break;
		case 7:
			result = arg1_64 & arg2_64;
			break;
		case 8:
			result = arg1_64 ^ arg2_64;
			break;
		case 9:
			result = arg1_64 << arg2_64;
			break;
		case 10:
			result = arg1_64 >> arg2_64;
			break;
		default:
			Output::Warning("ControlVariables::Binary: Unknown op {}", op);
			return 0;
	}

	return static_cast<int>(Utils::Clamp<int64_t>(result, std::numeric_limits<int32_t>::min(), std::numeric_limits<int32_t>::max()));
}

int ControlVariables::Clamp(int arg1, int arg2, int arg3) {
	return Utils::Clamp(arg1, arg2, arg3);
}

int ControlVariables::Muldiv(int arg1, int arg2, int arg3) {
	auto arg1_64 = static_cast<int64_t>(arg1);
	auto arg2_64 = static_cast<int64_t>(arg2);
	auto arg3_64 = static_cast<int64_t>(arg3);

	if (arg3_64 == 0) {
		arg3_64 = 1;
	}

	return static_cast<int>(arg1_64 * arg2_64 / arg3_64);
}

int ControlVariables::Divmul(int arg1, int arg2, int arg3) {
	auto arg1_64 = static_cast<int64_t>(arg1);
	auto arg2_d = static_cast<double>(arg2);
	auto arg3_64 = static_cast<int64_t>(arg3);

	if (arg2_d == 0) {
		arg2_d = 1.0;
	}

	return static_cast<int>(arg1_64 / arg2_d * arg3_64);
}

int ControlVariables::Between(int arg1, int arg2, int arg3) {
	return (arg1 >= arg2 && arg2 <= arg3) ? 0 : 1;
}


/*end of file .\game_interpreter_control_variables.cpp*/

/*start of file .\game_interpreter_debug.cpp*/

/* ... license chunk ... */

#include "game_interpreter_debug.h"
#include "game_interpreter.h"
#include "game_battle.h"
#include "game_map.h"
#include "main_data.h"
#include "game_variables.h"
#include "output.h"
#include <lcf/reader_util.h>

Debug::ParallelInterpreterStates Debug::ParallelInterpreterStates::GetCachedStates() {
	Game_Interpreter_Inspector inspector;

	std::vector<int> ev_ids;
	std::vector<int> ce_ids;

	std::vector<lcf::rpg::SaveEventExecState> state_ev;
	std::vector<lcf::rpg::SaveEventExecState> state_ce;

	if (Game_Map::GetMapId() > 0) {
		for (auto& ev : Game_Map::GetEvents()) {
			if (!inspector.IsInActiveExcecution(ev, true)) {
				continue;
			}

			ev_ids.emplace_back(ev.GetId());
			state_ev.emplace_back(inspector.GetExecState(ev));
		}
		for (auto& ce : Game_Map::GetCommonEvents()) {
			if (!inspector.IsInActiveExcecution(ce, true)) {
				continue;
			}
			ce_ids.emplace_back(ce.GetId());
			state_ce.emplace_back(inspector.GetExecState(ce));
		}
	} else if (Game_Battle::IsBattleRunning() && Player::IsPatchManiac()) {
		//FIXME: Not implemented: battle common events
	}

	return { ev_ids, ce_ids, state_ev, state_ce };
}

std::vector<Debug::CallStackItem> Debug::CreateCallStack(const lcf::rpg::SaveEventExecState& state) {
	std::vector<CallStackItem> items;
	items.reserve(state.stack.size());

	for (int i = state.stack.size() - 1; i >= 0; i--) {
		auto& frame = state.stack[i];

		bool map_has_changed = (frame.event_id == 0 && frame.maniac_event_id > 0);

		Debug::CallStackItem item = {
			Game_Interpreter_Shared::EasyRpgExecutionType(frame),
			Game_Interpreter_Shared::EasyRpgEventType(frame),
			frame.maniac_event_id,
			frame.maniac_event_page_id,
			GetEventName(frame),
			i + 1,					//stack_item_no
			frame.current_command,	// cmd_current
			frame.commands.size(),	// cmd_count
			map_has_changed
		};

		items.push_back(item);
	}

	return items;
}

std::string Debug::GetEventName(const lcf::rpg::SaveEventExecFrame& frame) {
	switch (Game_Interpreter_Shared::EasyRpgEventType(frame)) {
		case InterpreterEventType::MapEvent:
			if (auto* ev = Game_Map::GetEvent(frame.event_id)) {
				return ToString(ev->GetName());
			} else if (frame.maniac_event_id > 0) {
				return fmt::format("[(EV{:04d}) from another map..]", frame.maniac_event_id);
			}
			break;
		case InterpreterEventType::CommonEvent:
			if (auto* ce = lcf::ReaderUtil::GetElement(lcf::Data::commonevents, frame.maniac_event_id)) {
				return ToString(ce->name);
			}
			break;
		default:
			break;
	}
	return "";
}

std::string Debug::FormatEventName(Game_Character const& ch) {
	switch (ch.GetType()) {
		case Game_Character::Player:
			return "Player";
		case Game_Character::Vehicle:
		{
			int type = static_cast<Game_Vehicle const&>(ch).GetVehicleType();
			assert(type > Game_Vehicle::None && type <= Game_Vehicle::Airship);
			return Game_Vehicle::TypeNames[type];
		}
		case Game_Character::Event:
		{
			auto& ev = static_cast<Game_Event const&>(ch);
			if (ev.GetName().empty()) {
				return fmt::format("EV{:04d}", ev.GetId());
			}
			return fmt::format("EV{:04d} '{}'", ev.GetId(), ev.GetName());
		}
		default:
			assert(false);
	}
	return "";
}

std::string Debug::FormatEventName(Game_CommonEvent const& ce) {
	if (ce.GetName().empty()) {
		return fmt::format("CE{:04d}", ce.GetIndex());
	}
	return fmt::format("CE{:04d}: '{}'", ce.GetIndex(), ce.GetName());
}


/*end of file .\game_interpreter_debug.cpp*/

/*start of file .\game_interpreter_map.cpp*/

/* ... license chunk ... */

// Headers
#include <cstdlib>
#include <algorithm>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <cassert>
#include <unordered_set>
#include "audio.h"
#include "feature.h"
#include "game_character.h"
#include "game_map.h"
#include "game_battle.h"
#include "game_event.h"
#include "game_player.h"
#include "game_switches.h"
#include "game_variables.h"
#include "game_party.h"
#include "game_actors.h"
#include "game_system.h"
#include "game_message.h"
#include "game_screen.h"
#include "spriteset_map.h"
#include "sprite_character.h"
#include "scene_map.h"
#include "scene_battle.h"
#include "scene_equip.h"
#include "scene_item.h"
#include "scene_menu.h"
#include "scene_order.h"
#include "scene_save.h"
#include "scene_status.h"
#include "scene_skill.h"
#include "scene_load.h"
#include "scene_name.h"
#include "scene_shop.h"
#include "scene_debug.h"
#include "scene_gameover.h"
#include "scene_settings.h"
#include "scene_language.h"
#include "scene.h"
#include "graphics.h"
#include "input.h"
#include "main_data.h"
#include "output.h"
#include "player.h"
#include "util_macro.h"
#include "game_interpreter_map.h"
#include <lcf/reader_lcf.h>

enum EnemyEncounterSubcommand {
	eOptionEnemyEncounterVictory = 0,
	eOptionEnemyEncounterEscape = 1,
	eOptionEnemyEncounterDefeat = 2,
};

enum ShopSubcommand {
	eOptionShopTransaction = 0,
	eOptionShopNoTransaction = 1,
};

enum InnSubcommand {
	eOptionInnStay = 0,
	eOptionInnNoStay = 1,
};

using namespace Game_Interpreter_Shared;

void Game_Interpreter_Map::SetState(const lcf::rpg::SaveEventExecState& save) {
	Clear();
	_state = save;
	_keyinput.fromSave(save);
}

void Game_Interpreter_Map::OnMapChange() {
	// When we change the map, we reset all event id's to 0.
	for (auto& frame: _state.stack) {
		frame.event_id = 0;
	}

	// When the message was created by a parallel process, close it
	if (Game_Message::IsMessageActive() && !Game_Message::GetWindow()->GetPendingMessage().IsFromForegroundInterpreter()) {
		Game_Message::GetWindow()->FinishMessageProcessing();
	}
}

bool Game_Interpreter_Map::RequestMainMenuScene(int subscreen_id, int actor_index, bool is_db_actor) {
	if (Player::game_config.patch_direct_menu.Get() && subscreen_id == -1) {
		subscreen_id = Main_Data::game_variables->Get(Player::game_config.patch_direct_menu.Get());
		actor_index = Main_Data::game_variables->Get(Player::game_config.patch_direct_menu.Get() + 1);
		// When true refers to the index of an actor, instead of a party index
		is_db_actor = (actor_index < 0);
		actor_index = std::abs(actor_index);
	}

	std::vector<Game_Actor*> actors;

	switch (subscreen_id)
	{
	case 1: // Inventory
		Scene::instance->SetRequestedScene(std::make_shared<Scene_Item>());
		return true;
	case 2: // Skills
	case 3: // Equipment
	case 4: // Status
		if (is_db_actor) {
			Game_Actor* actor = Main_Data::game_actors->GetActor(actor_index);
			if (!actor) {
				Output::Warning("RequestMainMenu: Invalid actor ID {}", actor_index);
				return false;
			}
			actors = std::vector{actor};
			actor_index = 0;
		} else {
			// 0, 1 and 5+ refer to the first actor
			if (actor_index == 0 || actor_index > 4) {
				actor_index = 1;
			}
			actor_index--;
			actors = Main_Data::game_party->GetActors();

			if (actor_index < 0 || actor_index >= static_cast<int>(actors.size())) {
				Output::Warning("RequestMainMenu: Invalid actor party member {}", actor_index);
				return false;
			}
		}

		if (subscreen_id == 2) {
			Scene::instance->SetRequestedScene(std::make_shared<Scene_Skill>(actors, actor_index));
		}
		else if (subscreen_id == 3) {
			Scene::instance->SetRequestedScene(std::make_shared<Scene_Equip>(actors, actor_index));
		}
		else if (subscreen_id == 4) {
			Scene::instance->SetRequestedScene(std::make_shared<Scene_Status>(actors, actor_index));
		}
		return true;
	case 5: // Order
		if (!Feature::HasRow()) {
			break;
		}

		if (Main_Data::game_party->GetActors().size() <= 1) {
			Output::Warning("Party size must exceed '1' for 'Order' subscreen to be opened");
			return false;
		}
		else {
			Scene::instance->SetRequestedScene(std::make_shared<Scene_Order>());
			return true;
		}
	case 6: // Settings
		Scene::instance->SetRequestedScene(std::make_shared<Scene_Settings>());
		return true;
	case 7: // Language
		if (Player::translation.HasTranslations()) {
			Scene::instance->SetRequestedScene(std::make_shared<Scene_Language>());
		}
		return true;
	}

	Scene::instance->SetRequestedScene(std::make_shared<Scene_Menu>());
	return true;
}

/**
 * Execute Command.
 */
bool Game_Interpreter_Map::ExecuteCommand(lcf::rpg::EventCommand const& com) {
	switch (static_cast<Cmd>(com.code)) {
		case Cmd::RecallToLocation:
			return CmdSetup<&Game_Interpreter_Map::CommandRecallToLocation, 3>(com);
		case Cmd::EnemyEncounter:
			if (Player::IsRPG2k()) {
				return CmdSetup<&Game_Interpreter_Map::CommandEnemyEncounter, 6>(com);
			} else {
				return CmdSetup<&Game_Interpreter_Map::CommandEnemyEncounter, 10>(com);
			}
		case Cmd::VictoryHandler:
			return CmdSetup<&Game_Interpreter_Map::CommandVictoryHandler, 0>(com);
		case Cmd::EscapeHandler:
			return CmdSetup<&Game_Interpreter_Map::CommandEscapeHandler, 0>(com);
		case Cmd::DefeatHandler:
			return CmdSetup<&Game_Interpreter_Map::CommandDefeatHandler, 0>(com);
		case Cmd::EndBattle:
			return CmdSetup<&Game_Interpreter_Map::CommandEndBattle, 0>(com);
		case Cmd::OpenShop:
			return CmdSetup<&Game_Interpreter_Map::CommandOpenShop, 4>(com);
		case Cmd::Transaction:
			return CmdSetup<&Game_Interpreter_Map::CommandTransaction, 0>(com);
		case Cmd::NoTransaction:
			return CmdSetup<&Game_Interpreter_Map::CommandNoTransaction, 0>(com);
		case Cmd::EndShop:
			return CmdSetup<&Game_Interpreter_Map::CommandEndShop, 0>(com);
		case Cmd::ShowInn:
			return CmdSetup<&Game_Interpreter_Map::CommandShowInn, 3>(com);
		case Cmd::Stay:
			return CmdSetup<&Game_Interpreter_Map::CommandStay, 0>(com);
		case Cmd::NoStay:
			return CmdSetup<&Game_Interpreter_Map::CommandNoStay, 0>(com);
		case Cmd::EndInn:
			return CmdSetup<&Game_Interpreter_Map::CommandEndInn, 0>(com);
		case Cmd::EnterHeroName:
			return CmdSetup<&Game_Interpreter_Map::CommandEnterHeroName, 3>(com);
		case Cmd::Teleport:
			return CmdSetup<&Game_Interpreter_Map::CommandTeleport, 3>(com);
		case Cmd::EnterExitVehicle:
			return CmdSetup<&Game_Interpreter_Map::CommandEnterExitVehicle, 0>(com);
		case Cmd::PanScreen:
			return CmdSetup<&Game_Interpreter_Map::CommandPanScreen, 5>(com);
		case Cmd::ShowBattleAnimation:
			return CmdSetup<&Game_Interpreter_Map::CommandShowBattleAnimation, 4>(com);
		case Cmd::FlashSprite:
			return CmdSetup<&Game_Interpreter_Map::CommandFlashSprite, 7>(com);
		case Cmd::ProceedWithMovement:
			return CmdSetup<&Game_Interpreter_Map::CommandProceedWithMovement, 0>(com);
		case Cmd::HaltAllMovement:
			return CmdSetup<&Game_Interpreter_Map::CommandHaltAllMovement, 0>(com);
		case Cmd::PlayMovie:
			return CmdSetup<&Game_Interpreter_Map::CommandPlayMovie, 5>(com);
		case Cmd::OpenSaveMenu:
			return CmdSetup<&Game_Interpreter_Map::CommandOpenSaveMenu, 0>(com);
		case Cmd::OpenMainMenu:
			return CmdSetup<&Game_Interpreter_Map::CommandOpenMainMenu, 0>(com);
		case Cmd::OpenLoadMenu:
			return CmdSetup<&Game_Interpreter_Map::CommandOpenLoadMenu, 0>(com);
		case Cmd::ToggleAtbMode:
			return CmdSetup<&Game_Interpreter_Map::CommandToggleAtbMode, 0>(com);
		case Cmd::EasyRpg_TriggerEventAt:
			return CmdSetup<&Game_Interpreter_Map::CommandEasyRpgTriggerEventAt, 4>(com);
		case Cmd::EasyRpg_WaitForSingleMovement:
			return CmdSetup<&Game_Interpreter_Map::CommandEasyRpgWaitForSingleMovement, 6>(com);
		case Cmd::EasyRpg_Pathfinder:
			return CmdSetup<&Game_Interpreter_Map::CommandEasyRpgPathfinder, 13>(com);
		default:
			return Game_Interpreter::ExecuteCommand(com);
	}
}

/**
 * Commands
 */
bool Game_Interpreter_Map::CommandRecallToLocation(lcf::rpg::EventCommand const& com) { // Code 10830
	if (Game_Message::IsMessageActive()) {
		return false;
	}

	auto& frame = GetFrame();
	auto& index = frame.current_command;

	int var_map_id = com.parameters[0];
	int var_x = com.parameters[1];
	int var_y = com.parameters[2];
	int map_id = Main_Data::game_variables->Get(var_map_id);
	int x = Main_Data::game_variables->Get(var_x);
	int y = Main_Data::game_variables->Get(var_y);

	auto tt = main_flag ? TeleportTarget::eForegroundTeleport : TeleportTarget::eParallelTeleport;

	Main_Data::game_player->ReserveTeleport(map_id, x, y, -1, tt);

	// Parallel events should keep on running in 2k and 2k3, unlike in later versions
	if (!main_flag)
		return true;

	index++;
	return false;
}

bool Game_Interpreter_Map::CommandEnemyEncounter(lcf::rpg::EventCommand const& com) { // code 10710
	if (Game_Message::IsMessageActive()) {
		return false;
	}

	auto& frame = GetFrame();
	auto& index = frame.current_command;

	BattleArgs args;

	args.troop_id = ValueOrVariable(com.parameters[0], com.parameters[1]);

	switch (com.parameters[2]) {
	case 0:
		Game_Map::SetupBattle(args);
		break;
	case 1:
		args.background = ToString(com.string);

		if (Player::IsRPG2k3()) {
			args.formation = static_cast<lcf::rpg::System::BattleFormation>(com.parameters[7]);
		}
		break;
	case 2:
		args.terrain_id = com.parameters[8];
		break;
	default:
		return false;
	}
	auto escape_mode = com.parameters[3]; // 0 disallow, 1 end event processing, 2 victory/escape custom handler
	auto defeat_mode = com.parameters[4]; // 0 game over, 1 victory/defeat custom handler

	if (escape_mode == 1) {
		_state.abort_on_escape = true;
	}

	args.allow_escape = (escape_mode != 0);
	args.first_strike = com.parameters[5] != 0;

	if (Player::IsRPG2k3()) {
		args.condition = static_cast<lcf::rpg::System::BattleCondition>(com.parameters[6]);
	}

	auto indent = com.indent;
	auto continuation = [this, indent, defeat_mode](BattleResult result) {
		int sub_idx = subcommand_sentinel;

		switch (result) {
			case BattleResult::Victory:
				sub_idx = eOptionEnemyEncounterVictory;
				break;
			case BattleResult::Escape:
				sub_idx = eOptionEnemyEncounterEscape;
				if (_state.abort_on_escape) {
					return EndEventProcessing();
				}
				break;
			case BattleResult::Defeat:
				sub_idx = eOptionEnemyEncounterDefeat;
				if (defeat_mode == 0) {
					Scene::Push(std::make_shared<Scene_Gameover>());
				}
				break;
			case BattleResult::Abort:
				break;
		}

		SetSubcommandIndex(indent, sub_idx);
	};

	args.on_battle_end = continuation;

	Scene::instance->SetRequestedScene(Scene_Battle::Create(std::move(args)));

	// save game compatibility with RPG_RT
	ReserveSubcommandIndex(com.indent);

	++index;
	return false;
}

bool Game_Interpreter_Map::CommandVictoryHandler(lcf::rpg::EventCommand const& com) { // code 20710
	return CommandOptionGeneric(com, eOptionEnemyEncounterVictory, {Cmd::EscapeHandler, Cmd::DefeatHandler, Cmd::EndBattle});
}

bool Game_Interpreter_Map::CommandEscapeHandler(lcf::rpg::EventCommand const& com) { // code 20711
	return CommandOptionGeneric(com, eOptionEnemyEncounterEscape, {Cmd::DefeatHandler, Cmd::EndBattle});
}

bool Game_Interpreter_Map::CommandDefeatHandler(lcf::rpg::EventCommand const& com) { // code 20712
	return CommandOptionGeneric(com, eOptionEnemyEncounterDefeat, {Cmd::EndBattle});
}

bool Game_Interpreter_Map::CommandEndBattle(lcf::rpg::EventCommand const& /* com */) { // code 20713
	return true;
}

bool Game_Interpreter_Map::CommandOpenShop(lcf::rpg::EventCommand const& com) { // code 10720
	if (Game_Message::IsMessageActive()) {
		return false;
	}

	auto& frame = GetFrame();
	auto& index = frame.current_command;

	bool allow_buy = false;
	bool allow_sell = false;

	switch (com.parameters[0]) {
		case 0:
			allow_buy = true;
			allow_sell = true;
			break;
		case 1:
			allow_buy = true;
			break;
		case 2:
			allow_sell = true;
			break;
		default:
			break;
	}

	auto shop_type = com.parameters[1];

	// Not used, but left here for documentation purposes
	// bool has_shop_handlers = com.parameters[2] != 0;

	std::vector<int> goods;
	for (auto it = com.parameters.begin() + 4; it < com.parameters.end(); ++it) {
		goods.push_back(*it);
	}

	auto indent = com.indent;
	auto continuation = [this, indent](bool did_transaction) {
		int sub_idx = did_transaction ? eOptionShopTransaction : eOptionShopNoTransaction;
		SetSubcommandIndex(indent, sub_idx);
	};

	auto scene = std::make_shared<Scene_Shop>(
			std::move(goods), shop_type, allow_buy, allow_sell, std::move(continuation));

	Scene::instance->SetRequestedScene(std::move(scene));

	// save game compatibility with RPG_RT
	ReserveSubcommandIndex(com.indent);

	++index;
	return false;
}

bool Game_Interpreter_Map::CommandTransaction(lcf::rpg::EventCommand const& com) { // code 20720
	return CommandOptionGeneric(com, eOptionShopTransaction, {Cmd::NoTransaction, Cmd::EndShop});
}

bool Game_Interpreter_Map::CommandNoTransaction(lcf::rpg::EventCommand const& com) { // code 20721
	return CommandOptionGeneric(com, eOptionShopNoTransaction, {Cmd::EndShop});
}

bool Game_Interpreter_Map::CommandEndShop(lcf::rpg::EventCommand const& /* com */) { // code 20722
	return true;
}

bool Game_Interpreter_Map::CommandShowInn(lcf::rpg::EventCommand const& com) { // code 10730
	int inn_type = com.parameters[0];
	int inn_price = com.parameters[1];
	// Not used, but left here for documentation purposes
	// bool has_inn_handlers = com.parameters[2] != 0;

	if (inn_price == 0) {
		if (Game_Message::IsMessageActive()) {
			return false;
		}

		// Skip prompt.
		_async_op = ContinuationShowInnStart(com.indent, 0, inn_price);
		return true;
	}

	// Emulates RPG_RT behavior (Bug?) Inn's called by parallel events
	// overwrite the current message.
	if (main_flag && !Game_Message::CanShowMessage(main_flag)) {
		return false;
	}

	PendingMessage pm(Game_Message::CommandCodeInserter);
	pm.SetFromForegroundInterpreter(main_flag);

	std::string_view greeting_1, greeting_2, greeting_3, accept, cancel;

	switch (inn_type) {
		case 0:
			greeting_1 = lcf::Data::terms.inn_a_greeting_1;
			greeting_2 = lcf::Data::terms.inn_a_greeting_2;
			greeting_3 = lcf::Data::terms.inn_a_greeting_3;
			accept = lcf::Data::terms.inn_a_accept;
			cancel = lcf::Data::terms.inn_a_cancel;
			break;
		case 1:
			greeting_1 = lcf::Data::terms.inn_b_greeting_1;
			greeting_2 = lcf::Data::terms.inn_b_greeting_2;
			greeting_3 = lcf::Data::terms.inn_b_greeting_3;
			accept = lcf::Data::terms.inn_b_accept;
			cancel = lcf::Data::terms.inn_b_cancel;
			break;
	}

	if (Player::IsRPG2kE()) {
		auto price_s = std::to_string(inn_price);
		pm.PushLine(
			Utils::ReplacePlaceholders(
				greeting_1,
				Utils::MakeArray('V', 'U'),
				Utils::MakeSvArray(price_s, lcf::Data::terms.gold)
			)
		);
		pm.PushLine(
			Utils::ReplacePlaceholders(
				greeting_3,
				Utils::MakeArray('V', 'U'),
				Utils::MakeSvArray(price_s, lcf::Data::terms.gold)
			)
		);
	}
	else {
		pm.PushLine(fmt::format("{} {}{} {}", greeting_1, inn_price, lcf::Data::terms.gold, greeting_2));
		pm.PushLine(ToString(greeting_3));
	}

	bool can_afford = (Main_Data::game_party->GetGold() >= inn_price);
	pm.SetChoiceResetColors(true);

	pm.PushChoice(ToString(accept), can_afford);
	pm.PushChoice(ToString(cancel));

	pm.SetShowGoldWindow(true);

	int indent = com.indent;
	pm.SetChoiceContinuation([this, indent, inn_price](int choice_result) {
			return ContinuationShowInnStart(indent, choice_result, inn_price);
			});

	// save game compatibility with RPG_RT
	ReserveSubcommandIndex(com.indent);

	Game_Message::SetPendingMessage(std::move(pm));
	_state.show_message = true;

	return true;
}

AsyncOp Game_Interpreter_Map::ContinuationShowInnStart(int indent, int choice_result, int price) {
	bool inn_stay = (choice_result == 0);

	SetSubcommandIndex(indent, inn_stay ? eOptionInnStay : eOptionInnNoStay);

	if (inn_stay) {
		Main_Data::game_party->GainGold(-price);

		return AsyncOp::MakeCallInn();
	}
	return {};
}

bool Game_Interpreter_Map::CommandStay(lcf::rpg::EventCommand const& com) { // code 20730
	return CommandOptionGeneric(com, eOptionInnStay, {Cmd::NoStay, Cmd::EndInn});
}

bool Game_Interpreter_Map::CommandNoStay(lcf::rpg::EventCommand const& com) { // code 20731
	return CommandOptionGeneric(com, eOptionInnNoStay, {Cmd::EndInn});
}

bool Game_Interpreter_Map::CommandEndInn(lcf::rpg::EventCommand const& /* com */) { // code 20732
	return true;
}

bool Game_Interpreter_Map::CommandEnterHeroName(lcf::rpg::EventCommand const& com) { // code 10740
	if (Game_Message::IsMessageActive()) {
		return false;
	}

	auto& frame = GetFrame();
	auto& index = frame.current_command;

	auto actor_id = com.parameters[0];
	auto charset = com.parameters[1];
	auto use_default_name = com.parameters[2];

	Game_Actor* actor = Main_Data::game_actors->GetActor(actor_id);
	if (!actor) {
		Output::Warning("EnterHeroName: Invalid actor ID {}", actor_id);
		return true;
	}

	auto scene = std::make_shared<Scene_Name>(*actor, charset, use_default_name);
	Scene::instance->SetRequestedScene(std::move(scene));

	++index;
	return false;
}

bool Game_Interpreter_Map::CommandTeleport(lcf::rpg::EventCommand const& com) { // Code 10810
																		   // TODO: if in battle return true
	if (Game_Message::IsMessageActive()) {
		return false;
	}

	auto& frame = GetFrame();
	auto& index = frame.current_command;

	int map_id = com.parameters[0];
	int x = com.parameters[1];
	int y = com.parameters[2];

	// RPG2k3 feature
	int direction = -1;
	if (com.parameters.size() > 3 && Player::IsRPG2k3Commands()) {
		direction = com.parameters[3] - 1;
	}

	auto tt = main_flag ? TeleportTarget::eForegroundTeleport : TeleportTarget::eParallelTeleport;

	Main_Data::game_player->ReserveTeleport(map_id, x, y, direction, tt);

	// Parallel events should keep on running in 2k and 2k3, unlike in later versions
	if (!main_flag)
		return true;

	index++;
	return false;
}

bool Game_Interpreter_Map::CommandEnterExitVehicle(lcf::rpg::EventCommand const& /* com */) { // code 10840
	Main_Data::game_player->GetOnOffVehicle();

	return true;
}

bool Game_Interpreter_Map::CommandPanScreen(lcf::rpg::EventCommand const& com) { // code 11060
	int direction;
	int distance;
	int speed;
	bool waiting_pan_screen = false;

	auto& player = *Main_Data::game_player;

	switch (com.parameters[0]) {
	case 0: // Lock
		player.LockPan();
		break;
	case 1: // Unlock
		player.UnlockPan();
		break;
	case 2: // Pan
		direction = com.parameters[1];
		distance = com.parameters[2];
		// FIXME: For an "instant pan" Yume2kki passes a huge value (53) here
		// which crashes depending on the hardware
		speed = Utils::Clamp<int>(com.parameters[3], 1, 6);
		waiting_pan_screen = com.parameters[4] != 0;
		player.StartPan(direction, distance, speed);
		break;
	case 3: // Reset
		speed = Utils::Clamp<int>(com.parameters[3], 1, 6);
		waiting_pan_screen = com.parameters[4] != 0;
		player.ResetPan(speed);
		distance = std::max(
				std::abs(player.GetPanX() - player.GetTargetPanX())
				, std::abs(player.GetPanY() - player.GetTargetPanY()));
		distance /= SCREEN_TILE_SIZE;
		break;
	}

	if (Player::IsPatchManiac() && com.parameters.size() > 5) {
		// Pixel scrolling with h/v offsets
		bool centered = false; // absolute from default pan (centered on hero)
		bool relative = false; // relative to current camera
		int h = ValueOrVariableBitfield(com, 1, 0, 2);
		int v = ValueOrVariableBitfield(com, 1, 1, 3);
		waiting_pan_screen = (com.parameters[4] & 0x01) != 0;
		speed = ValueOrVariableBitfield(com, 1, 2, 5);
		switch (com.parameters[0]) {
		case 4: // Relative Pixel Pan (speed)
			centered = false;
			relative = true;
			player.StartPixelPan(h, v, speed, false, centered, relative);
			break;
		case 5: // Relative Pixel Pan (interpolated)
			centered = false;
			relative = true;
			player.StartPixelPan(h, v, speed, true, centered, relative);
			break;
		case 6: // Absolute Pixel Pan (speed)
			centered = (com.parameters[4] & 0x02) != 0;
			relative = (com.parameters[4] & 0x04) != 0;
			player.StartPixelPan(h, v, speed, false, centered, relative);
			break;
		case 7: // Absolute Pixel Pan (interpolated)
			centered = (com.parameters[4] & 0x02) != 0;
			relative = (com.parameters[4] & 0x04) != 0;
			player.StartPixelPan(h, v, speed, true, centered, relative);
			break;
		}
	}

	if (waiting_pan_screen) {
		// RPG_RT uses the max wait for all pending pan commands, not just the current one.
		_state.wait_time = player.GetPanWait();
	}

	return true;
}

bool Game_Interpreter_Map::CommandShowBattleAnimation(lcf::rpg::EventCommand const& com) { // code 11210
	int animation_id = com.parameters[0];
	int evt_id = com.parameters[1];
	bool waiting_battle_anim = com.parameters[2] > 0;
	bool global = com.parameters[3] > 0;

	Game_Character* chara = GetCharacter(evt_id, "ShowBattleAnimation");
	if (chara == NULL)
		return true;

	if (evt_id == Game_Character::CharThisEvent)
		evt_id = GetThisEventId();

	int frames = Main_Data::game_screen->ShowBattleAnimation(animation_id, evt_id, global);

	if (waiting_battle_anim) {
		_state.wait_time = frames;
	}

	return true;
}

bool Game_Interpreter_Map::CommandFlashSprite(lcf::rpg::EventCommand const& com) { // code 11320
	int event_id = ValueOrVariableBitfield(com, 7, 0, 0);
	int r = ValueOrVariableBitfield(com, 7, 1, 1);
	int g = ValueOrVariableBitfield(com, 7, 2, 2);
	int b = ValueOrVariableBitfield(com, 7, 3, 3);
	int p = ValueOrVariableBitfield(com, 7, 4, 4);

	int tenths = com.parameters[5];
	bool wait = com.parameters[6] > 0;
	Game_Character* event = GetCharacter(event_id, "FlashSprite");

	if (event != NULL) {
		event->Flash(r, g, b, p, tenths * DEFAULT_FPS / 10);

		if (wait) {
			SetupWait(tenths);
		}
	}

	return true;
}

bool Game_Interpreter_Map::CommandProceedWithMovement(lcf::rpg::EventCommand const& /* com */) { // code 11340
	_state.wait_movement = true;
	return true;
}

bool Game_Interpreter_Map::CommandHaltAllMovement(lcf::rpg::EventCommand const& /* com */) { // code 11350
	Game_Map::RemoveAllPendingMoves();
	return true;
}

bool Game_Interpreter_Map::CommandPlayMovie(lcf::rpg::EventCommand const& com) { // code 11560
	if (Game_Message::IsMessageActive()) {
		return false;
	}

	auto filename = ToString(com.string);
	int pos_x = ValueOrVariable(com.parameters[0], com.parameters[1]);
	int pos_y = ValueOrVariable(com.parameters[0], com.parameters[2]);
	int res_x = com.parameters[3];
	int res_y = com.parameters[4];

	Output::Warning("Couldn't play movie: {}. Movie playback is not implemented (yet).", filename);

	Main_Data::game_screen->PlayMovie(filename, pos_x, pos_y, res_x, res_y);

	return true;
}

bool Game_Interpreter_Map::CommandOpenSaveMenu(lcf::rpg::EventCommand const& com) { // code 11910
	if (Game_Message::IsMessageActive()) {
		return false;
	}

	auto& frame = GetFrame();
	auto& index = frame.current_command;

	Scene::instance->SetRequestedScene(std::make_shared<Scene_Save>());

	int current_system_function = 0;
	if (com.parameters.size() > 0) {
		current_system_function = com.parameters[0];
	}

	// Handle save menu (default behavior)
	if (!Player::IsPatchManiac() || current_system_function <= 0) {
		Scene::instance->SetRequestedScene(std::make_shared<Scene_Save>());
		++index;
		return false;
	}

	// Command "Call System Functions"
	switch (current_system_function) {
	case 1: // Load menu
		return CmdSetup<&Game_Interpreter_Map::CommandOpenLoadMenu, 100>(com);
	case 2: // Game menu
		return CmdSetup<&Game_Interpreter_Map::CommandOpenMainMenu, 100>(com);
	case 3: // Toggle fullscreen
		// TODO Implement fullscreen mode once maniacs supports it
		// const int fullscreen_mode = com.parameters[1]; // Broken in Maniac.
		return CmdSetup<&Game_Interpreter_Map::CommandToggleFullscreen, 100>(com);
	case 4: // Settings menu
		return CmdSetup<&Game_Interpreter_Map::CommandOpenVideoOptions, 100>(com);
	case 5: // Debug menu
		// const int pause_while_debugging = com.parameters[1]; // unused in our ingame debug screen.
		Scene::instance->SetRequestedScene(std::make_shared<Scene_Debug>());
		++index;
		return false;
	case 6: // License information menu
		// TODO Implement license information menu
		return true;
	case 7: // Reset game
		return CmdSetup<&Game_Interpreter_Map::CommandReturnToTitleScreen, 100>(com);
	default:
		if (Player::HasEasyRpgExtensions() && current_system_function >= 200 && current_system_function < 210) {
			const int actor_index = ValueOrVariable(com.parameters[1], com.parameters[2]);
			const bool is_db_actor = ValueOrVariable(com.parameters[3], com.parameters[4]);

			if (RequestMainMenuScene(current_system_function - 200, actor_index, is_db_actor)) {
				++index;
				return false;
			}
		} else {
			Output::Warning("CommandOpenSaveMenu: Unsupported scene {}", current_system_function);
		}
	}

	return true;
}

bool Game_Interpreter_Map::CommandOpenMainMenu(lcf::rpg::EventCommand const&) { // code 11950
	if (Game_Message::IsMessageActive()) {
		return false;
	}

	auto& frame = GetFrame();
	auto& index = frame.current_command;

	int subscreen_id = -1, actor_index = 0;
	bool is_db_actor = false;

	if (RequestMainMenuScene(subscreen_id, actor_index, is_db_actor)) {
		++index;
		return false;
	}
	return true;
}

bool Game_Interpreter_Map::CommandOpenLoadMenu(lcf::rpg::EventCommand const& /* com */) {
	if (!Player::IsRPG2k3ECommands()) {
		return true;
	}

	if (Game_Message::IsMessageActive()) {
		return false;
	}

	auto& frame = GetFrame();
	auto& index = frame.current_command;

	Scene::instance->SetRequestedScene(std::make_shared<Scene_Load>());
	++index;
	return false;
}

bool Game_Interpreter_Map::CommandToggleAtbMode(lcf::rpg::EventCommand const& /* com */) {
	if (!Player::IsRPG2k3ECommands()) {
		return true;
	}

	Main_Data::game_system->ToggleAtbMode();
	return true;
}

bool Game_Interpreter_Map::CommandEasyRpgTriggerEventAt(lcf::rpg::EventCommand const& com) {
	if (!Player::HasEasyRpgExtensions()) {
		return true;
	}

	int x = ValueOrVariable(com.parameters[0], com.parameters[1]);
	int y = ValueOrVariable(com.parameters[2], com.parameters[3]);

	// backwards compatible with old (shorter) command
	bool face_player = true;

	if (com.parameters.size() > 4) {
		int flags = com.parameters[4];
		face_player = (flags & 1) > 0;
	}

	Main_Data::game_player->TriggerEventAt(x, y, GetFrame().triggered_by_decision_key, face_player);

	return true;
}

bool Game_Interpreter_Map::CommandEasyRpgPathfinder(lcf::rpg::EventCommand const& com) {
	/*
	This commands calculates a path between an event and the target.
	Then it applies a move route to the event.
	This command sets a longer route of all the steps necessary to a possibly farther off target.
 	The route is computed to smartly go around any obstacles.

	Event command parameters are as follows:

	Parameter 0, 1: Source Event ID
	Parameter 2, 3: Target X coordinate
	Parameter 4, 5: Target Y coordinate
	Parameter 6, 7: Iteration limit when searching
	Parameter 8, 9: Length of the route in tiles
	Parameter 10: Flags (1 = Wait when moving, 2 = Allow diagonal,
		4 = Debug log, 8 = Skip command when moving, 16 = "skippable" flag of the route)
	Parameter 11, 12: Ignore Event IDs
	Parameter 13 - 13+N: Number of Event IDs specified by 12
	Parameter 13+N+1, 13+N+2: Move frequency (default 3)
 	*/
	if (!Player::HasEasyRpgExtensions()) {
		return true;
	}

	Game_Character::CalculateMoveRouteArgs args;

	int event_id = ValueOrVariable(com.parameters[0], com.parameters[1]);
	args.dest_x = ValueOrVariable(com.parameters[2], com.parameters[3]);
	args.dest_y = ValueOrVariable(com.parameters[4], com.parameters[5]);
	args.search_max = ValueOrVariable(com.parameters[6], com.parameters[7]);
	args.steps_max = ValueOrVariable(com.parameters[8], com.parameters[9]);

	int flags = com.parameters[10];
	bool wait_when_moving = (flags & 1) > 0;
	args.allow_diagonal = (flags & 2) > 0;
	args.debug_print = (flags & 4) > 0;
	bool skip_when_moving = (flags & 8) > 0;
	args.skip_when_failed = (flags & 16) > 0;

	std::vector<int> event_id_ignore_list;
	int ni; // ni = next_index;
	if (com.parameters[11] == 0) {
		// Part of the command
		int num_events_ids = com.parameters[12];
		event_id_ignore_list = {com.parameters.begin() + 13, com.parameters.begin() + 13 + num_events_ids};
		ni = 13 + num_events_ids;
	} else {
		// Read from variables
		int var = ValueOrVariable(com.parameters[11], com.parameters[12]);
		int num_events_ids = Main_Data::game_variables->Get(var);
		auto lst = Main_Data::game_variables->GetRange(var + 1, num_events_ids);
		std::copy(lst.begin(), lst.end(), event_id_ignore_list.begin());
		ni = 13;
	}
	args.event_id_ignore_list = event_id_ignore_list;

	if (static_cast<int>(com.parameters.size()) > ni + 1) {
		args.frequency = ValueOrVariable(com.parameters[ni], com.parameters[ni + 1]);
	}

	Game_Character* chara = GetCharacter(event_id, "EasyRpgPathFinder");
	if (chara == nullptr) {
		return true;
	}

	if (chara->IsMoving()) {
		if (wait_when_moving) {
			return false;
		} else if (skip_when_moving) {
			return true;
		}
	}

	chara->CalculateMoveRoute(args);

	return true;
}

bool Game_Interpreter_Map::CommandEasyRpgWaitForSingleMovement(lcf::rpg::EventCommand const& com) {
	if (!Player::HasEasyRpgExtensions()) {
		return true;
	}

	_state.easyrpg_parameters.resize(3);

	auto& event_id = _state.easyrpg_parameters[0];
	auto& failure_limit = _state.easyrpg_parameters[1];
	auto& output_var = _state.easyrpg_parameters[2];

	if (!_state.easyrpg_active) {
		event_id = ValueOrVariable(com.parameters[0], com.parameters[1]);
		failure_limit = ValueOrVariable(com.parameters[2], com.parameters[3]);
		output_var = ValueOrVariable(com.parameters[4], com.parameters[5]);
	}

	_state.easyrpg_active = false;

	Game_Character* chara = GetCharacter(event_id, "EasyRpgWaitForSingleMovement");
	if (chara == nullptr) {
		return true;
	}

	bool exists = chara->IsMoveRouteOverwritten();
	bool finished = chara->IsMoveRouteFinished();

	if (!exists || (exists && finished)) {
		if (output_var > 0) {
			// Move route inexistant or ended: Report success (1)
			Main_Data::game_variables->Set(output_var, 1);
			Game_Map::SetNeedRefresh(true);
		}
		return true;
	}

	// !finished
	if (failure_limit == 0 || chara->GetMoveFailureCount() < failure_limit) {
		// Below threshold: Yield
		_state.easyrpg_active = true;
		return false;
	}

	// Cancel move route and report abort (0)
	chara->CancelMoveRoute();
	if (output_var > 0) {
		Main_Data::game_variables->Set(output_var, 0);
		Game_Map::SetNeedRefresh(true);
	}

	return true;
}


/*end of file .\game_interpreter_map.cpp*/

/*start of file .\game_interpreter_shared.cpp*/

/* ... license chunk ... */

#include "game_interpreter_shared.h"
#include "game_strings.h"
#include "game_switches.h"
#include "game_variables.h"
#include "maniac_patch.h"
#include "main_data.h"
#include "player.h"
#include <cstdint>
#include <lcf/rpg/savepartylocation.h>
#include <lcf/reader_util.h>

using Main_Data::game_switches, Main_Data::game_variables, Main_Data::game_strings;

template<bool validate_patches, bool support_range_indirect, bool support_expressions, bool support_bitmask, bool support_scopes, bool support_named>
inline bool Game_Interpreter_Shared::DecodeTargetEvaluationMode(lcf::rpg::EventCommand const& com, int& id_0, int& id_1, Game_BaseInterpreterContext const& interpreter) {
	int mode = com.parameters[0];

	if constexpr (support_bitmask) {
		mode = com.parameters[0] & 15;
	}

	switch (mode) {
		case TargetEvalMode::eTargetEval_Single:
			id_0 = com.parameters[1];
			id_1 = id_0;
			break;
		case TargetEvalMode::eTargetEval_Range:
			id_0 = com.parameters[1];
			id_1 = com.parameters[2];
			break;
		case TargetEvalMode::eTargetEval_IndirectSingle:
			id_0 = game_variables->Get(com.parameters[1]);
			id_1 = id_0;
			break;
		case TargetEvalMode::eTargetEval_IndirectRange:
			if constexpr (!support_range_indirect) {
				return false;
			}
			if constexpr (validate_patches) {
				if (!Player::IsPatchManiac()) {
					return false;
				}
			}
			id_0 = game_variables->Get(com.parameters[1]);
			id_1 = game_variables->Get(com.parameters[2]);
			break;
		case TargetEvalMode::eTargetEval_Expression:
			if constexpr (!support_expressions) {
				return false;
			}
			if constexpr (validate_patches) {
				if (!Player::IsPatchManiac()) {
					return false;
				}
			}
			{
				// Expression (Maniac)
				int idx = com.parameters[1];
				id_0 = ManiacPatch::ParseExpression(MakeSpan(com.parameters).subspan(idx + 1, com.parameters[idx]), interpreter);
				id_1 = id_0;
				return true;
			}
			break;
	}

	if constexpr (validate_patches) {
		if (Player::IsPatchManiac() && id_1 < id_0) {
			// Vanilla does not support end..start, Maniac does
			std::swap(id_0, id_1);
		}
	} else {
		if (id_1 < id_0) {
			std::swap(id_0, id_1);
		}
	}

	return true;
}

template<bool validate_patches, bool support_indirect_and_switch, bool support_scopes, bool support_named>
int Game_Interpreter_Shared::ValueOrVariable(int mode, int val, Game_BaseInterpreterContext const& /*interpreter*/) {
	if (mode == ValueEvalMode::eValueEval_Constant) {
		return val;
	} else if (mode == ValueEvalMode::eValueEval_Variable) {
		return game_variables->Get(val);
	} else {
		if constexpr (support_indirect_and_switch) {
			if constexpr (validate_patches) {
				if (!Player::IsPatchManiac())
					return -1;
			}
			// Maniac Patch does not implement all modes for all commands
			// For simplicity it is enabled for all here
			if (mode == ValueEvalMode::eValueEval_VariableIndirect) {
				// Variable indirect
				return game_variables->GetIndirect(val);
			} else if (mode == ValueEvalMode::eValueEval_Switch) {
				// Switch (F = 0, T = 1)
				return game_switches->GetInt(val);
			} else if (mode == ValueEvalMode::eValueEval_SwitchIndirect) {
				// Switch through Variable (F = 0, T = 1)
				return game_switches->GetInt(game_variables->Get(val));
			}
		}
	}
	return -1;
}

template<bool validate_patches, bool support_indirect_and_switch, bool support_scopes, bool support_named>
int Game_Interpreter_Shared::ValueOrVariableBitfield(int mode, int shift, int val, Game_BaseInterpreterContext const& interpreter) {
	return ValueOrVariable<validate_patches, support_indirect_and_switch, support_scopes, support_named>((mode & (0xF << shift * 4)) >> shift * 4, val, interpreter);
}

template<bool validate_patches, bool support_indirect_and_switch, bool support_scopes, bool support_named>
int Game_Interpreter_Shared::ValueOrVariableBitfield(lcf::rpg::EventCommand const& com, int mode_idx, int shift, int val_idx, Game_BaseInterpreterContext const& interpreter) {
	assert(static_cast<int>(com.parameters.size()) > val_idx);

	if (!Player::IsPatchManiac()) {
		return com.parameters[val_idx];
	}

	assert(mode_idx != val_idx);

	if (static_cast<int>(com.parameters.size()) > std::max(mode_idx, val_idx)) {
		int mode = com.parameters[mode_idx];
		return ValueOrVariableBitfield<validate_patches, support_indirect_and_switch, support_scopes, support_named>(mode, shift, com.parameters[val_idx], interpreter);
	}

	return com.parameters[val_idx];
}

std::string_view Game_Interpreter_Shared::CommandStringOrVariable(lcf::rpg::EventCommand const& com, int mode_idx, int val_idx) {
	if (!Player::IsPatchManiac()) {
		return com.string;
	}

	assert(mode_idx != val_idx);

	if (static_cast<int>(com.parameters.size()) > std::max(mode_idx, val_idx)) {
		return game_strings->GetWithMode(com.string, com.parameters[mode_idx], com.parameters[val_idx], *game_variables);
	}

	return com.string;
}

std::string_view Game_Interpreter_Shared::CommandStringOrVariableBitfield(lcf::rpg::EventCommand const& com, int mode_idx, int shift, int val_idx) {
	if (!Player::IsPatchManiac()) {
		return com.string;
	}

	assert(mode_idx != val_idx);

	if (static_cast<int>(com.parameters.size()) >= std::max(mode_idx, val_idx) + 1) {
		int mode = com.parameters[mode_idx];
		return game_strings->GetWithMode(com.string, (mode & (0xF << shift * 4)) >> shift * 4, com.parameters[val_idx], *game_variables);
	}

	return com.string;
}


int Game_Interpreter_Shared::DecodeInt(lcf::DBArray<int32_t>::const_iterator& it) {
	int value = 0;

	for (;;) {
		int x = *it++;
		value <<= 7;
		value |= x & 0x7F;
		if (!(x & 0x80))
			break;
	}

	return value;
}

const std::string Game_Interpreter_Shared::DecodeString(lcf::DBArray<int32_t>::const_iterator& it) {
	std::ostringstream out;
	int len = DecodeInt(it);

	for (int i = 0; i < len; i++)
		out << (char)*it++;

	std::string result = lcf::ReaderUtil::Recode(out.str(), Player::encoding);

	return result;
}

lcf::rpg::MoveCommand Game_Interpreter_Shared::DecodeMove(lcf::DBArray<int32_t>::const_iterator& it) {
	lcf::rpg::MoveCommand cmd;
	cmd.command_id = *it++;

	switch (cmd.command_id) {
		case 32:	// Switch ON
		case 33:	// Switch OFF
			cmd.parameter_a = DecodeInt(it);
			break;
		case 34:	// Change Graphic
			cmd.parameter_string = lcf::DBString(DecodeString(it));
			cmd.parameter_a = DecodeInt(it);
			break;
		case 35:	// Play Sound Effect
			cmd.parameter_string = lcf::DBString(DecodeString(it));
			cmd.parameter_a = DecodeInt(it);
			cmd.parameter_b = DecodeInt(it);
			cmd.parameter_c = DecodeInt(it);
			break;
	}

	return cmd;
}

#ifdef ENABLE_DYNAMIC_INTERPRETER_CONFIG

std::optional<bool> Game_Interpreter_Shared::GetRuntimeFlag(lcf::rpg::SaveEventExecState const& state, StateRuntimeFlagRef const field_on, StateRuntimeFlagRef const field_off) {
	return GetRuntimeFlag(state.easyrpg_runtime_flags, field_on, field_off);
}

std::optional<bool> Game_Interpreter_Shared::GetRuntimeFlag(lcf::rpg::SaveEventExecState::EasyRpgStateRuntime_Flags const& state_runtime_flags, StateRuntimeFlagRef const field_on, StateRuntimeFlagRef const field_off) {
	if (state_runtime_flags.conf_override_active) {
		if (state_runtime_flags.*field_on)
			return true;
		if (state_runtime_flags.*field_off)
			return false;
	}
	return std::nullopt;
}

#endif

//explicit declarations for target evaluation logic shared between ControlSwitches/ControlVariables/ControlStrings
template bool Game_Interpreter_Shared::DecodeTargetEvaluationMode<true, false, false, false, false>(lcf::rpg::EventCommand const&, int&, int&, Game_BaseInterpreterContext const&);
template bool Game_Interpreter_Shared::DecodeTargetEvaluationMode<true, true, true, false, false>(lcf::rpg::EventCommand const&, int&, int&, Game_BaseInterpreterContext const&);
template bool Game_Interpreter_Shared::DecodeTargetEvaluationMode<false, true, false, true, false>(lcf::rpg::EventCommand const&, int&, int&, Game_BaseInterpreterContext const&);

//common variant for suggested "Ex" commands
template bool Game_Interpreter_Shared::DecodeTargetEvaluationMode<false, true, true, true, true, true>(lcf::rpg::EventCommand const&, int&, int&, Game_BaseInterpreterContext const&);

//explicit declarations for default value evaluation logic
template int Game_Interpreter_Shared::ValueOrVariable<true, true, false, false>(int, int, const Game_BaseInterpreterContext&);
template int Game_Interpreter_Shared::ValueOrVariableBitfield<true, true, false, false>(int, int, int, const Game_BaseInterpreterContext&);
template int Game_Interpreter_Shared::ValueOrVariableBitfield<true, true, false, false>(lcf::rpg::EventCommand const&, int, int, int, const Game_BaseInterpreterContext&);

//variant for "Ex" commands
template int Game_Interpreter_Shared::ValueOrVariableBitfield<false, true, true, true>(int, int, int, const Game_BaseInterpreterContext&);


/*end of file .\game_interpreter_shared.cpp*/

/*start of file .\game_map.cpp*/

/* ... license chunk ... */

// Headers
#include <cassert>
#include <initializer_list>
#include <iomanip>
#include <sstream>
#include <algorithm>
#include <climits>
#include <numeric>
#include <unordered_set>

#include "async_handler.h"
#include "options.h"
#include "system.h"
#include "game_battle.h"
#include "game_battler.h"
#include "game_map.h"
#include "game_interpreter_map.h"
#include "game_switches.h"
#include "game_player.h"
#include "game_party.h"
#include "game_message.h"
#include "game_screen.h"
#include "game_pictures.h"
#include "game_variables.h"
#include "scene_battle.h"
#include "scene_map.h"
#include <lcf/lmu/reader.h>
#include <lcf/reader_lcf.h>
#include "map_data.h"
#include "main_data.h"
#include "output.h"
#include "util_macro.h"
#include "game_system.h"
#include "filefinder.h"
#include "player.h"
#include "input.h"
#include "utils.h"
#include "rand.h"
#include <lcf/scope_guard.h>
#include <lcf/rpg/save.h>
#include "scene_gameover.h"
#include "feature.h"

namespace {
	// Intended bad value, Game_Map::Init sets them correctly
	int screen_width = -1;
	int screen_height = -1;

	lcf::rpg::SaveMapInfo map_info;
	lcf::rpg::SavePanorama panorama;

	bool need_refresh;

	int animation_type;
	bool animation_fast;
	std::vector<unsigned char> passages_down;
	std::vector<unsigned char> passages_up;
	std::vector<Game_Event> events;
	std::vector<Game_CommonEvent> common_events;
	std::unique_ptr<Game_Map::Caching::MapCache> map_cache;

	std::unique_ptr<lcf::rpg::Map> map;

	std::unique_ptr<Game_Interpreter_Map> interpreter;
	std::vector<Game_Vehicle> vehicles;

	lcf::rpg::Chipset* chipset;

	//FIXME: Find a better way to do this.
	bool panorama_on_map_init = true;
	bool reset_panorama_x_on_next_init = true;
	bool reset_panorama_y_on_next_init = true;

	bool translation_changed = false;

	// Used when the current map is not in the maptree
	const lcf::rpg::MapInfo empty_map_info;
}

namespace Game_Map {
void SetupCommon();
}

void Game_Map::OnContinueFromBattle() {
	Main_Data::game_system->BgmPlay(Main_Data::game_system->GetBeforeBattleMusic());
}

static Game_Map::Parallax::Params GetParallaxParams();

void Game_Map::Init() {
	Dispose();

	map_info = {};
	panorama = {};
	SetNeedRefresh(true);

	interpreter.reset(new Game_Interpreter_Map(true));
	map_cache.reset(new Caching::MapCache());

	InitCommonEvents();

	vehicles.clear();
	vehicles.emplace_back(Game_Vehicle::Boat);
	vehicles.emplace_back(Game_Vehicle::Ship);
	vehicles.emplace_back(Game_Vehicle::Airship);
}

void Game_Map::InitCommonEvents() {
	common_events.clear();
	common_events.reserve(lcf::Data::commonevents.size());
	for (const lcf::rpg::CommonEvent& ev : lcf::Data::commonevents) {
		common_events.emplace_back(ev.ID);
	}
	translation_changed = false;
}

void Game_Map::Dispose() {
	events.clear();
	map.reset();
	map_info = {};
	panorama = {};
}

void Game_Map::Quit() {
	Dispose();
	common_events.clear();
	interpreter.reset();
	map_cache.reset();
}

int Game_Map::GetMapSaveCount() {
	return (Player::IsRPG2k3() && map->save_count_2k3e > 0)
		? map->save_count_2k3e
		: map->save_count;
}

void Game_Map::Setup(std::unique_ptr<lcf::rpg::Map> map_in) {
	Dispose();

	map = std::move(map_in);

	SetupCommon();

	panorama_on_map_init = true;
	Parallax::ClearChangedBG();

	SetEncounterSteps(GetMapInfo().encounter_steps);
	SetChipset(map->chipset_id);

	std::iota(map_info.lower_tiles.begin(), map_info.lower_tiles.end(), 0);
	std::iota(map_info.upper_tiles.begin(), map_info.upper_tiles.end(), 0);

	// Save allowed
	const auto* current_info = &GetMapInfo();
	int current_index = current_info->ID;
	int can_save = current_info->save;
	int can_escape = current_info->escape;
	int can_teleport = current_info->teleport;

	while (can_save == lcf::rpg::MapInfo::TriState_parent
			|| can_escape == lcf::rpg::MapInfo::TriState_parent
			|| can_teleport == lcf::rpg::MapInfo::TriState_parent)
	{
		const auto* parent_info = &GetParentMapInfo(*current_info);
		int parent_index = parent_info->ID;
		if (parent_index == 0) {
			// If parent is 0 and flag is parent, it's implicitly enabled.
			break;
		}
		if (parent_index == current_index) {
			Output::Warning("Map {} has parent pointing to itself!", current_index);
			break;
		}
		current_info = parent_info;
		if (can_save == lcf::rpg::MapInfo::TriState_parent) {
			can_save = current_info->save;
		}
		if (can_escape == lcf::rpg::MapInfo::TriState_parent) {
			can_escape = current_info->escape;
		}
		if (can_teleport == lcf::rpg::MapInfo::TriState_parent) {
			can_teleport = current_info->teleport;
		}
	}
	Main_Data::game_system->SetAllowSave(can_save != lcf::rpg::MapInfo::TriState_forbid);
	Main_Data::game_system->SetAllowEscape(can_escape != lcf::rpg::MapInfo::TriState_forbid);
	Main_Data::game_system->SetAllowTeleport(can_teleport != lcf::rpg::MapInfo::TriState_forbid);

	auto& player = *Main_Data::game_player;

	SetPositionX(player.GetX() * SCREEN_TILE_SIZE - player.GetPanX());
	SetPositionY(player.GetY() * SCREEN_TILE_SIZE - player.GetPanY());

	// Update the save counts so that if the player saves the game
	// events will properly resume upon loading.
	Main_Data::game_player->UpdateSaveCounts(lcf::Data::system.save_count, GetMapSaveCount());
}

void Game_Map::SetupFromSave(
		std::unique_ptr<lcf::rpg::Map> map_in,
		lcf::rpg::SaveMapInfo save_map,
		lcf::rpg::SaveVehicleLocation save_boat,
		lcf::rpg::SaveVehicleLocation save_ship,
		lcf::rpg::SaveVehicleLocation save_airship,
		lcf::rpg::SaveEventExecState save_fg_exec,
		lcf::rpg::SavePanorama save_pan,
		std::vector<lcf::rpg::SaveCommonEvent> save_ce) {

	map = std::move(map_in);
	map_info = std::move(save_map);
	panorama = std::move(save_pan);

	SetupCommon();

	const bool is_db_save_compat = Main_Data::game_player->IsDatabaseCompatibleWithSave(lcf::Data::system.save_count);
	const bool is_map_save_compat = Main_Data::game_player->IsMapCompatibleWithSave(GetMapSaveCount());

	InitCommonEvents();

	if (is_db_save_compat && is_map_save_compat) {
		for (size_t i = 0; i < std::min(save_ce.size(), common_events.size()); ++i) {
			common_events[i].SetSaveData(save_ce[i].parallel_event_execstate);
		}
	}

	if (is_map_save_compat) {
		std::vector<int> destroyed_event_ids;

		for (size_t i = 0, j = 0; i < events.size() && j < map_info.events.size(); ++i) {
			auto& ev = events[i];
			auto& save_ev = map_info.events[j];
			if (ev.GetId() == save_ev.ID) {
				ev.SetSaveData(save_ev);
				++j;
			} else {
				if (save_ev.ID > ev.GetId()) {
					// assume that the event has been destroyed during gameplay via "DestroyMapEvent"
					destroyed_event_ids.emplace_back(ev.GetId());
				} else {
					Output::Debug("SetupFromSave: Unexpected ID {}/{}", save_ev.ID, ev.GetId());
				}
			}
		}
		for (size_t i = 0; i < destroyed_event_ids.size(); ++i) {
			DestroyMapEvent(destroyed_event_ids[i], true);
		}
		if (destroyed_event_ids.size() > 0) {
			UpdateUnderlyingEventReferences();
		}
	}

	// Handle cloned events in a separate loop, regardless of "is_map_save_compat"
	if (Player::HasEasyRpgExtensions()) {
		for (size_t i = 0; i < map_info.events.size(); ++i) {
			auto& save_ev = map_info.events[i];
			bool is_cloned_evt = save_ev.easyrpg_clone_map_id > 0 || save_ev.easyrpg_clone_event_id > 0;
			if (is_cloned_evt && CloneMapEvent(
				save_ev.easyrpg_clone_map_id, save_ev.easyrpg_clone_event_id,
				save_ev.position_x, save_ev.position_y,
				save_ev.ID, "")) { // FIXME: Customized event names for saved events aren't part of liblcf/SaveMapEvent at the moment & thus cannot be restored
				if (auto new_event = GetEvent(save_ev.ID); new_event != nullptr) {
					new_event->SetSaveData(save_ev);
				}
			}
		}
		UpdateUnderlyingEventReferences();
	}
	map_info.events.clear();
	interpreter->Clear();

	GetVehicle(Game_Vehicle::Boat)->SetSaveData(std::move(save_boat));
	GetVehicle(Game_Vehicle::Ship)->SetSaveData(std::move(save_ship));
	GetVehicle(Game_Vehicle::Airship)->SetSaveData(std::move(save_airship));

	if (is_map_save_compat) {
		// Make main interpreter "busy" if save contained events to prevent auto-events from starting
		interpreter->SetState(std::move(save_fg_exec));
	}

	SetEncounterSteps(map_info.encounter_steps);

	// RPG_RT bug: Chipset is not loaded. Fixed in 2k3E
	if (Player::IsRPG2k3E()) {
		SetChipset(map_info.chipset_id);
	} else {
		SetChipset(0);
	}

	if (!is_map_save_compat) {
		panorama = {};
	}

	// We want to support loading rm2k3e panning chunks
	// but also not break other saves which don't have them.
	// To solve this problem, we reuse the scrolling methods
	// which always reset the position anyways when scroll_horz/vert
	// is false.
	// This produces compatible behavior for old RPG_RT saves, namely
	// the pan_x/y is always forced to 0.
	// If the later async code will load panorama, set the flag to not clear the offsets.
	// FIXME: RPG_RT compatibility bug: Everytime we load a savegame with default panorama chunks,
	// this causes them to get overwritten
	// FIXME: RPG_RT compatibility bug: On async platforms, panorama async loading can
	// cause panorama chunks to be out of sync.
	Game_Map::Parallax::ChangeBG(GetParallaxParams());
}

std::unique_ptr<lcf::rpg::Map> Game_Map::LoadMapFile(int map_id) {
	std::unique_ptr<lcf::rpg::Map> map;

	// Try loading EasyRPG map files first, then fallback to normal RPG Maker
	// FIXME: Assert map was cached for async platforms
	std::string map_name = Game_Map::ConstructMapName(map_id, true);
	std::string map_file = FileFinder::Game().FindFile(map_name);
	if (map_file.empty()) {
		map_name = Game_Map::ConstructMapName(map_id, false);
		map_file = FileFinder::Game().FindFile(map_name);

		if (map_file.empty()) {
			Output::Error("Loading of Map {} failed.\nThe map was not found.", map_name);
			return nullptr;
		}

		auto map_stream = FileFinder::Game().OpenInputStream(map_file);
		if (!map_stream) {
			Output::Error("Loading of Map {} failed.\nMap not readable.", map_name);
			return nullptr;
		}

		map = lcf::LMU_Reader::Load(map_stream, Player::encoding);

		if (Input::IsRecording()) {
			map_stream.clear();
			map_stream.seekg(0);
			Input::AddRecordingData(Input::RecordingData::Hash,
						   fmt::format("map{:04} {:#08x}", map_id, Utils::CRC32(map_stream)));
		}
	} else {
		auto map_stream = FileFinder::Game().OpenInputStream(map_file);
		if (!map_stream) {
			Output::Error("Loading of Map {} failed.\nMap not readable.", map_name);
			return nullptr;
		}
		map = lcf::LMU_Reader::LoadXml(map_stream);
	}

	Output::Debug("Loaded Map {}", map_name);

	if (map.get() == NULL) {
		Output::ErrorStr(lcf::LcfReader::GetError());
	}

	return map;
}

void Game_Map::SetupCommon() {
	screen_width = (Player::screen_width / 16.0) * SCREEN_TILE_SIZE;
	screen_height = (Player::screen_height / 16.0) * SCREEN_TILE_SIZE;

	if (!Tr::GetCurrentTranslationId().empty()) {
		TranslateMapMessages(GetMapId(), *map);
	}
	SetNeedRefresh(true);

	PrintPathToMap();

	if (translation_changed) {
		InitCommonEvents();
	}

	map_cache->Clear();

	CreateMapEvents();
}

void Game_Map::CreateMapEvents() {
	events.reserve(map->events.size());
	for (auto& ev : map->events) {
		events.emplace_back(GetMapId(), &ev);
		AddEventToCache(ev);
	}
}

void Game_Map::AddEventToCache(const lcf::rpg::Event& ev) {
	using Op = Caching::ObservedVarOps;

	for (const auto& pg : ev.pages) {
		if (pg.condition.flags.switch_a) {
			map_cache->AddEventAsRefreshTarget<Op::SwitchSet>(pg.condition.switch_a_id, ev);
		}
		if (pg.condition.flags.switch_b) {
			map_cache->AddEventAsRefreshTarget<Op::SwitchSet>(pg.condition.switch_b_id, ev);
		}
		if (pg.condition.flags.variable) {
			map_cache->AddEventAsRefreshTarget<Op::VarSet>(pg.condition.variable_id, ev);
		}
	}
}

void Game_Map::RemoveEventFromCache(const lcf::rpg::Event& ev) {
	using Op = Caching::ObservedVarOps;

	for (const auto& pg : ev.pages) {
		if (pg.condition.flags.switch_a) {
			map_cache->RemoveEventAsRefreshTarget<Op::SwitchSet>(pg.condition.switch_a_id, ev);
		}
		if (pg.condition.flags.switch_b) {
			map_cache->RemoveEventAsRefreshTarget<Op::SwitchSet>(pg.condition.switch_b_id, ev);
		}
		if (pg.condition.flags.variable) {
			map_cache->RemoveEventAsRefreshTarget<Op::VarSet>(pg.condition.variable_id, ev);
		}
	}
}

void Game_Map::Caching::MapCache::Clear() {
	for (int i = 0; i < static_cast<int>(ObservedVarOps_END); i++) {
		refresh_targets_by_varid[i].clear();
	}
}

bool Game_Map::CloneMapEvent(int src_map_id, int src_event_id, int target_x, int target_y, int target_event_id, std::string_view target_name) {
	std::unique_ptr<lcf::rpg::Map> source_map_storage;
	const lcf::rpg::Map* source_map;

	if (src_map_id == GetMapId()) {
		source_map = &GetMap();
	} else {
		source_map_storage = Game_Map::LoadMapFile(src_map_id);
		source_map = source_map_storage.get();

		if (source_map_storage == nullptr) {
			Output::Warning("CloneMapEvent: Invalid source map ID {}", src_map_id);
			return false;
		}

		if (!Tr::GetCurrentTranslationId().empty()) {
			TranslateMapMessages(src_map_id, *source_map_storage);
		}
	}

	const lcf::rpg::Event* source_event = FindEventById(source_map->events, src_event_id);
	if (source_event == nullptr) {
		Output::Warning("CloneMapEvent: Event ID {} not found on source map {}", src_event_id, src_map_id);
		return false;
	}

	lcf::rpg::Event new_event = *source_event;
	if (target_event_id > 0) {
		DestroyMapEvent(target_event_id, true);
		new_event.ID = target_event_id;
	} else {
		new_event.ID = GetNextAvailableEventId();
	}
	new_event.x = target_x;
	new_event.y = target_y;

	if (!target_name.empty()) {
		new_event.name = lcf::DBString(target_name);
	}

	// sorted insert
	auto insert_it = map->events.insert(
		std::upper_bound(map->events.begin(), map->events.end(), new_event, [](const auto& e, const auto& e2) {
			return e.ID < e2.ID;
		}), new_event);

	auto game_event = Game_Event(GetMapId(), &*insert_it);
	game_event.data()->easyrpg_clone_event_id = src_event_id;
	game_event.data()->easyrpg_clone_map_id = src_map_id;

	events.insert(
		std::upper_bound(events.begin(), events.end(), game_event, [](const auto& e, const auto& e2) {
			return e.GetId() < e2.GetId();
		}), std::move(game_event));

	UpdateUnderlyingEventReferences();

	AddEventToCache(new_event);

	Scene_Map* scene = (Scene_Map*)Scene::Find(Scene::Map).get();
	if (scene) {
		scene->spriteset->Refresh();
		SetNeedRefresh(true);
	}

	return true;
}

bool Game_Map::DestroyMapEvent(const int event_id, bool from_clone) {
	const lcf::rpg::Event* event = FindEventById(map->events, event_id);

	if (event == nullptr) {
		if (!from_clone) {
			Output::Warning("DestroyMapEvent: Event ID {} not found on current map", event_id);
		}
		return true;
	}

	// Remove event from cache
	RemoveEventFromCache(*event);

	// Remove event from events vector
	for (auto it = events.begin(); it != events.end(); ++it) {
		if (it->GetId() == event_id) {
			events.erase(it);
			break;
		}
	}

	// Remove event from map
	for (auto it = map->events.begin(); it != map->events.end(); ++it) {
		if (it->ID == event_id) {
			map->events.erase(it);
			break;
		}
	}

	if (!from_clone) {
		UpdateUnderlyingEventReferences();

		Scene_Map* scene = (Scene_Map*)Scene::Find(Scene::Map).get();
		scene->spriteset->Refresh();
		SetNeedRefresh(true);
	}

	if (GetInterpreter().GetOriginalEventId() == event_id) {
		// Prevent triggering "invalid event on stack" sanity check
		GetInterpreter().ClearOriginalEventId();
	}

	return true;
}

void Game_Map::TranslateMapMessages(int mapId, lcf::rpg::Map& map) {
	std::stringstream ss;
	ss << "map" << std::setfill('0') << std::setw(4) << mapId << ".po";
	Player::translation.RewriteMapMessages(ss.str(), map);
}


void Game_Map::UpdateUnderlyingEventReferences() {
	// Update references because modifying the vector can reallocate
	size_t idx = 0;
	for (auto& ev : events) {
		ev.SetUnderlyingEvent(&map->events.at(idx++));
	}

	Main_Data::game_screen->UpdateUnderlyingEventReferences();
}

const lcf::rpg::Event* Game_Map::FindEventById(const std::vector<lcf::rpg::Event>& events, int eventId) {
	for (const auto& ev : events) {
		if (ev.ID == eventId) {
			return &ev;
		}
	}
	return nullptr;
}

int Game_Map::GetNextAvailableEventId() {
	return map->events.back().ID + 1;
}

void Game_Map::PrepareSave(lcf::rpg::Save& save) {
	save.foreground_event_execstate = interpreter->GetSaveState();

	save.airship_location = GetVehicle(Game_Vehicle::Airship)->GetSaveData();
	save.ship_location = GetVehicle(Game_Vehicle::Ship)->GetSaveData();
	save.boat_location = GetVehicle(Game_Vehicle::Boat)->GetSaveData();

	save.map_info = map_info;
	save.map_info.chipset_id = GetChipset();
	if (save.map_info.chipset_id == GetOriginalChipset()) {
		// This emulates RPG_RT behavior, where chipset id == 0 means use the default map chipset.
		save.map_info.chipset_id = 0;
	}
	if (save.map_info.encounter_steps == GetOriginalEncounterSteps()) {
		save.map_info.encounter_steps = -1;
	}
	// Note: RPG_RT does not use a sentinel for parallax parameters. Once the parallax BG is changed, it stays that way forever.

	save.map_info.events.clear();
	save.map_info.events.reserve(events.size());
	for (Game_Event& ev : events) {
		save.map_info.events.push_back(ev.GetSaveData());
	}

	save.panorama = panorama;

	save.common_events.clear();
	save.common_events.reserve(common_events.size());
	for (Game_CommonEvent& ev : common_events) {
		save.common_events.push_back(lcf::rpg::SaveCommonEvent());
		save.common_events.back().ID = ev.GetIndex();
		save.common_events.back().parallel_event_execstate = ev.GetSaveData();
	}
}

void Game_Map::PlayBgm() {
	const auto* current_info = &GetMapInfo();
	while (current_info->music_type == 0 && GetParentMapInfo(*current_info).ID != current_info->ID) {
		current_info = &GetParentMapInfo(*current_info);
	}

	if ((current_info->ID > 0) && !current_info->music.name.empty()) {
		if (current_info->music_type == 1) {
			return;
		}
		auto& music = current_info->music;
		if (!Main_Data::game_player->IsAboard()) {
			Main_Data::game_system->BgmPlay(music);
		} else {
			Main_Data::game_system->SetBeforeVehicleMusic(music);
		}
	}
}

std::vector<uint8_t> Game_Map::GetTilesLayer(int layer) {
	return layer >= 1 ? map_info.upper_tiles : map_info.lower_tiles;
}

void Game_Map::Refresh() {
	if (GetMapId() > 0) {
		for (Game_Event& ev : events) {
			ev.RefreshPage();
		}
	}

	need_refresh = false;
}

Game_Interpreter_Map& Game_Map::GetInterpreter() {
	assert(interpreter);
	return *interpreter;
}

void Game_Map::Scroll(int dx, int dy) {
	int x = map_info.position_x;
	AddScreenX(x, dx);
	map_info.position_x = x;

	int y = map_info.position_y;
	AddScreenY(y, dy);
	map_info.position_y = y;

	if (dx == 0 && dy == 0) {
		return;
	}

	Main_Data::game_screen->OnMapScrolled(dx, dy);
	Main_Data::game_pictures->OnMapScrolled(dx, dy);
	Game_Map::Parallax::ScrollRight(dx);
	Game_Map::Parallax::ScrollDown(dy);
}

// Add inc to acc, clamping the result into the range [low, high].
// If the result is clamped, inc is also modified to be actual amount
// that acc changed by.
static void ClampingAdd(int low, int high, int& acc, int& inc) {
	int original_acc = acc;
	// Do not use std::clamp here. When the map is smaller than the screen the
	// upper bound is smaller than the lower bound making the function fail.
	acc = std::max(low, std::min(high, acc + inc));
	inc = acc - original_acc;
}

void Game_Map::AddScreenX(int& screen_x, int& inc) {
	int map_width = GetTilesX() * SCREEN_TILE_SIZE;
	if (LoopHorizontal()) {
		screen_x = (screen_x + inc) % map_width;
	} else {
		ClampingAdd(0, map_width - screen_width, screen_x, inc);
	}
}

void Game_Map::AddScreenY(int& screen_y, int& inc) {
	int map_height = GetTilesY() * SCREEN_TILE_SIZE;
	if (LoopVertical()) {
		screen_y = (screen_y + inc) % map_height;
	} else {
		ClampingAdd(0, map_height - screen_height, screen_y, inc);
	}
}

bool Game_Map::IsValid(int x, int y) {
	return (x >= 0 && x < GetTilesX() && y >= 0 && y < GetTilesY());
}

static int GetPassableMask(int old_x, int old_y, int new_x, int new_y) {
	int bit = 0;
	if (new_x > old_x) { bit |= Passable::Right; }
	if (new_x < old_x) { bit |= Passable::Left; }
	if (new_y > old_y) { bit |= Passable::Down; }
	if (new_y < old_y) { bit |= Passable::Up; }
	return bit;
}

static bool WouldCollide(const Game_Character& self, const Game_Character& other, bool self_conflict) {
	if (self.GetThrough() || other.GetThrough()) {
		return false;
	}

	if (self.IsFlying() || other.IsFlying()) {
		return false;
	}

	if (!self.IsActive() || !other.IsActive()) {
		return false;
	}

	if (self.GetType() == Game_Character::Event
			&& other.GetType() == Game_Character::Event
			&& (self.IsOverlapForbidden() || other.IsOverlapForbidden())) {
		return true;
	}

	if (other.GetLayer() == lcf::rpg::EventPage::Layers_same && self_conflict) {
		return true;
	}

	if (self.GetLayer() == other.GetLayer()) {
		return true;
	}

	return false;
}

template <typename T>
static void MakeWayUpdate(T& other) {
	other.Update();
}

static void MakeWayUpdate(Game_Event& other) {
	other.Update(false);
}

template <typename T>
static bool CheckWayTestCollideEvent(int x, int y, const Game_Character& self, T& other, bool self_conflict) {
	if (&self == &other) {
		return false;
	}

	if (!other.IsInPosition(x, y)) {
		return false;
	}

	return WouldCollide(self, other, self_conflict);
}

template <typename T>
static bool MakeWayCollideEvent(int x, int y, const Game_Character& self, T& other, bool self_conflict) {
	if (&self == &other) {
		return false;
	}

	if (!other.IsInPosition(x, y)) {
		return false;
	}

	// Force the other event to update, allowing them to possibly move out of the way.
	MakeWayUpdate(other);

	if (!other.IsInPosition(x, y)) {
		return false;
	}

	return WouldCollide(self, other, self_conflict);
}

static Game_Vehicle::Type GetCollisionVehicleType(const Game_Character* ch) {
	if (ch && ch->GetType() == Game_Character::Vehicle) {
		return static_cast<Game_Vehicle::Type>(static_cast<const Game_Vehicle*>(ch)->GetVehicleType());
	}
	return Game_Vehicle::None;
}

bool Game_Map::CheckWay(const Game_Character& self,
		int from_x, int from_y,
		int to_x, int to_y
		)
{
	return CheckOrMakeWayEx(
		self, from_x, from_y, to_x, to_y, true, {}, false
	);
}

bool Game_Map::CheckWay(const Game_Character& self,
		int from_x, int from_y,
		int to_x, int to_y,
		bool check_events_and_vehicles,
		Span<int> ignore_some_events_by_id) {
	return CheckOrMakeWayEx(
		self, from_x, from_y, to_x, to_y,
		check_events_and_vehicles,
		ignore_some_events_by_id, false
	);
}

bool Game_Map::CheckOrMakeWayEx(const Game_Character& self,
		int from_x, int from_y,
		int to_x, int to_y,
		bool check_events_and_vehicles,
		Span<int> ignore_some_events_by_id,
		bool make_way
		)
{
	// Infer directions before we do any rounding.
	const int bit_from = GetPassableMask(from_x, from_y, to_x, to_y);
	const int bit_to = GetPassableMask(to_x, to_y, from_x, from_y);

	// Now round for looping maps.
	to_x = Game_Map::RoundX(to_x);
	to_y = Game_Map::RoundY(to_y);

	// Note, even for diagonal, if the tile is invalid we still check vertical/horizontal first!
	if (!Game_Map::IsValid(to_x, to_y)) {
		return false;
	}

	if (self.GetThrough()) {
		return true;
	}

	const auto vehicle_type = GetCollisionVehicleType(&self);
	bool self_conflict = false;

	// Depending on whether we're supposed to call MakeWayCollideEvent
	// (which might change the map) or not, choose what to call:
	auto CheckOrMakeCollideEvent = [&](auto& other) {
		if (make_way) {
			return MakeWayCollideEvent(to_x, to_y, self, other, self_conflict);
		} else {
			return CheckWayTestCollideEvent(
				to_x, to_y, self, other, self_conflict
			);
		}
	};

	if (!self.IsJumping()) {
		// Check for self conflict.
		// If this event has a tile graphic and the tile itself has passage blocked in the direction
		// we want to move, flag it as "self conflicting" for use later.
		if (self.GetLayer() == lcf::rpg::EventPage::Layers_below && self.GetTileId() != 0) {
			int tile_id = self.GetTileId();
			if ((passages_up[tile_id] & bit_from) == 0) {
				self_conflict = true;
			}
		}

		if (vehicle_type == Game_Vehicle::None) {
			// Check that we are allowed to step off of the current tile.
			// Note: Vehicles can always step off a tile.

			// The current coordinate can be invalid due to an out-of-bounds teleport or a "Set Location" event.
			// Round it for looping maps to ensure the check passes
			// This is not fully bug compatible to RPG_RT. Assuming the Y-Coordinate is out-of-bounds: When moving
			// left or right the invalid Y will stay in RPG_RT preventing events from being triggered, but we wrap it
			// inbounds after the first move.
			from_x = Game_Map::RoundX(from_x);
			from_y = Game_Map::RoundY(from_y);
			if (!IsPassableTile(&self, bit_from, from_x, from_y)) {
				return false;
			}
		}
	}
	if (vehicle_type != Game_Vehicle::Airship && check_events_and_vehicles) {
		// Check for collision with events on the target tile.
		if (ignore_some_events_by_id.empty()) {
			for (auto& other: GetEvents()) {
				if (CheckOrMakeCollideEvent(other)) {
					return false;
				}
			}
		} else {
			for (auto& other: GetEvents()) {
				if (std::find(ignore_some_events_by_id.begin(), ignore_some_events_by_id.end(), other.GetId()) != ignore_some_events_by_id.end())
					continue;
				if (CheckOrMakeCollideEvent(other)) {
					return false;
				}
			}
		}

		auto& player = Main_Data::game_player;
		if (player->GetVehicleType() == Game_Vehicle::None) {
			if (CheckOrMakeCollideEvent(*Main_Data::game_player)) {
				return false;
			}
		}
		for (auto vid: { Game_Vehicle::Boat, Game_Vehicle::Ship}) {
			auto& other = vehicles[vid - 1];
			if (other.IsInCurrentMap()) {
				if (CheckOrMakeCollideEvent(other)) {
					return false;
				}
			}
		}
		auto& airship = vehicles[Game_Vehicle::Airship - 1];
		if (airship.IsInCurrentMap() && self.GetType() != Game_Character::Player) {
			if (CheckOrMakeCollideEvent(airship)) {
				return false;
			}
		}
	}
	int bit = bit_to;
	if (self.IsJumping()) {
		bit = Passable::Down | Passable::Up | Passable::Left | Passable::Right;
	}

	return IsPassableTile(
		&self, bit, to_x, to_y, check_events_and_vehicles, true
		);
}

bool Game_Map::MakeWay(const Game_Character& self,
		int from_x, int from_y,
		int to_x, int to_y
		)
{
	return CheckOrMakeWayEx(
		self, from_x, from_y, to_x, to_y, true, {}, true
		);
}


bool Game_Map::CanLandAirship(int x, int y) {
	if (!Game_Map::IsValid(x, y)) return false;

	const auto* terrain = lcf::ReaderUtil::GetElement(lcf::Data::terrains, GetTerrainTag(x, y));
	if (!terrain) {
		Output::Warning("CanLandAirship: Invalid terrain at ({}, {})", x, y);
		return false;
	}
	if (!terrain->airship_land) {
		return false;
	}

	for (auto& ev: events) {
		if (ev.IsInPosition(x, y)
				&& ev.IsActive()
				&& ev.GetActivePage() != nullptr) {
			return false;
		}
	}
	for (auto vid: { Game_Vehicle::Boat, Game_Vehicle::Ship }) {
		auto& vehicle = vehicles[vid - 1];
		if (vehicle.IsInCurrentMap() && vehicle.IsInPosition(x, y)) {
			return false;
		}
	}

	const int bit = Passable::Down | Passable::Right | Passable::Left | Passable::Up;

	int tile_index = x + y * GetTilesX();

	if (!IsPassableLowerTile(bit, tile_index)) {
		return false;
	}

	int tile_id = map->upper_layer[tile_index] - BLOCK_F;
	tile_id = map_info.upper_tiles[tile_id];

	return (passages_up[tile_id] & bit) != 0;
}

bool Game_Map::CanEmbarkShip(Game_Player& player, int x, int y) {
	auto bit = GetPassableMask(player.GetX(), player.GetY(), x, y);
	return IsPassableTile(&player, bit, player.GetX(), player.GetY());
}

bool Game_Map::CanDisembarkShip(Game_Player& player, int x, int y) {
	if (!Game_Map::IsValid(x, y)) {
		return false;
	}

	for (auto& ev: GetEvents()) {
		if (ev.IsInPosition(x, y)
			&& ev.GetLayer() == lcf::rpg::EventPage::Layers_same
			&& ev.IsActive()
			&& ev.GetActivePage() != nullptr) {
			return false;
		}
	}

	int bit = GetPassableMask(x, y, player.GetX(), player.GetY());

	return IsPassableTile(nullptr, bit, x, y);
}

bool Game_Map::IsPassableLowerTile(int bit, int tile_index) {
	int tile_raw_id = map->lower_layer[tile_index];
	int tile_id = 0;

	if (tile_raw_id >= BLOCK_E) {
		tile_id = tile_raw_id - BLOCK_E;
		tile_id = map_info.lower_tiles[tile_id] + BLOCK_E_INDEX;

	} else if (tile_raw_id >= BLOCK_D) {
		tile_id = (tile_raw_id - BLOCK_D) / BLOCK_D_STRIDE + BLOCK_D_INDEX;
		int autotile_id = (tile_raw_id - BLOCK_D) % BLOCK_D_STRIDE;

		if (((passages_down[tile_id] & Passable::Wall) != 0) && (
				(autotile_id >= 20 && autotile_id <= 23) ||
				(autotile_id >= 33 && autotile_id <= 37) ||
				autotile_id == 42 || autotile_id == 43 ||
				autotile_id == 45 || autotile_id == 46))
			return true;

	} else if (tile_raw_id >= BLOCK_C) {
		tile_id = (tile_raw_id - BLOCK_C) / BLOCK_C_STRIDE + BLOCK_C_INDEX;

	} else if (map->lower_layer[tile_index] < BLOCK_C) {
		tile_id = tile_raw_id / BLOCK_B_STRIDE;
	}

	return (passages_down[tile_id] & bit) != 0;
}

bool Game_Map::IsPassableTile(
		const Game_Character* self, int bit, int x, int y
		) {
	return IsPassableTile(
		self, bit, x, y, true, true
	);
}

bool Game_Map::IsPassableTile(
		const Game_Character* self, int bit, int x, int y,
		bool check_events_and_vehicles, bool check_map_geometry
		) {
	if (!IsValid(x, y)) return false;

	const auto vehicle_type = GetCollisionVehicleType(self);
	if (check_events_and_vehicles) {
		if (vehicle_type != Game_Vehicle::None) {
			const auto* terrain = lcf::ReaderUtil::GetElement(lcf::Data::terrains, GetTerrainTag(x, y));
			if (!terrain) {
				Output::Warning("IsPassableTile: Invalid terrain at ({}, {})", x, y);
				return false;
			}
			if (vehicle_type == Game_Vehicle::Boat && !terrain->boat_pass) {
				return false;
			}
			if (vehicle_type == Game_Vehicle::Ship && !terrain->ship_pass) {
				return false;
			}
			if (vehicle_type == Game_Vehicle::Airship) {
				return terrain->airship_pass;
			}
		}

		// Highest ID event with layer=below, not through, and a tile graphic wins.
		int event_tile_id = 0;
		for (auto& ev: events) {
			if (self == &ev) {
				continue;
			}
			if (!ev.IsActive() || ev.GetActivePage() == nullptr || ev.GetThrough()) {
				continue;
			}
			if (ev.IsInPosition(x, y) && ev.GetLayer() == lcf::rpg::EventPage::Layers_below) {
				if (ev.HasTileSprite()) {
					event_tile_id = ev.GetTileId();
				}
			}
		}

		// If there was a below tile event, and the tile is not above
		// Override the chipset with event tile behavior.
		if (event_tile_id > 0
				&& ((passages_up[event_tile_id] & Passable::Above) == 0)) {
			switch (vehicle_type) {
				case Game_Vehicle::None:
					return ((passages_up[event_tile_id] & bit) != 0);
				case Game_Vehicle::Boat:
				case Game_Vehicle::Ship:
					return false;
				case Game_Vehicle::Airship:
					break;
			};
		}
	}

	if (check_map_geometry) {
		int tile_index = x + y * GetTilesX();
		int tile_id = map->upper_layer[tile_index] - BLOCK_F;
		tile_id = map_info.upper_tiles[tile_id];

		if (vehicle_type == Game_Vehicle::Boat || vehicle_type == Game_Vehicle::Ship) {
			if ((passages_up[tile_id] & Passable::Above) == 0)
				return false;
			return true;
		}

		if ((passages_up[tile_id] & bit) == 0)
			return false;

		if ((passages_up[tile_id] & Passable::Above) == 0)
			return true;

		return IsPassableLowerTile(bit, tile_index);
	} else {
		return true;
	}
}

int Game_Map::GetBushDepth(int x, int y) {
	if (!Game_Map::IsValid(x, y)) return 0;

	const lcf::rpg::Terrain* terrain = lcf::ReaderUtil::GetElement(lcf::Data::terrains, GetTerrainTag(x,y));
	if (!terrain) {
		Output::Warning("GetBushDepth: Invalid terrain at ({}, {})", x, y);
		return 0;
	}
	return terrain->bush_depth;
}

bool Game_Map::IsCounter(int x, int y) {
	if (!Game_Map::IsValid(x, y)) return false;

	int const tile_id = map->upper_layer[x + y * GetTilesX()];
	if (tile_id < BLOCK_F) return false;
	int const index = map_info.upper_tiles[tile_id - BLOCK_F];
	return !!(passages_up[index] & Passable::Counter);
}

int Game_Map::GetTerrainTag(int x, int y) {
	if (!chipset) {
		// FIXME: Is this ever possible?
		return 1;
	}

	auto& terrain_data = chipset->terrain_data;

	if (terrain_data.empty()) {
		// RPG_RT optimisation: When the terrain is all 1, no terrain data is stored
		return 1;
	}

	// Terrain tag wraps on looping maps
	if (Game_Map::LoopHorizontal()) {
		x = RoundX(x);
	}
	if (Game_Map::LoopVertical()) {
		y = RoundY(y);
	}

	// RPG_RT always uses the terrain of the first lower tile
	// for out of bounds coordinates.
	unsigned chip_index = 0;

	if (Game_Map::IsValid(x, y)) {
		const auto chip_id = map->lower_layer[x + y * GetTilesX()];
		chip_index = ChipIdToIndex(chip_id);

		// Apply tile substitution
		if (chip_index >= BLOCK_E_INDEX && chip_index < NUM_LOWER_TILES) {
			chip_index = map_info.lower_tiles[chip_index - BLOCK_E_INDEX] + BLOCK_E_INDEX;
		}
	}

	assert(chip_index < terrain_data.size());

	return terrain_data[chip_index];
}

Game_Event* Game_Map::GetEventAt(int x, int y, bool require_active) {
	auto& events = GetEvents();
	for (auto iter = events.rbegin(); iter != events.rend(); ++iter) {
		auto& ev = *iter;
		if (ev.IsInPosition(x, y) && (!require_active || ev.IsActive())) {
			return &ev;
		}
	}
	return nullptr;
}

bool Game_Map::LoopHorizontal() {
	return map->scroll_type == lcf::rpg::Map::ScrollType_horizontal || map->scroll_type == lcf::rpg::Map::ScrollType_both;
}

bool Game_Map::LoopVertical() {
	return map->scroll_type == lcf::rpg::Map::ScrollType_vertical || map->scroll_type == lcf::rpg::Map::ScrollType_both;
}

int Game_Map::RoundX(int x, int units) {
	if (LoopHorizontal()) {
		return Utils::PositiveModulo(x, GetTilesX() * units);
	} else {
		return x;
	}
}

int Game_Map::RoundY(int y, int units) {
	if (LoopVertical()) {
		return Utils::PositiveModulo(y, GetTilesY() * units);
	} else {
		return y;
	}
}

int Game_Map::RoundDx(int dx, int units) {
	if (LoopHorizontal()) {
		return Utils::PositiveModulo(std::abs(dx), GetTilesX() * units) * Utils::Sign(dx);
	} else {
		return dx;
	}
}

int Game_Map::RoundDy(int dy, int units) {
	if (LoopVertical()) {
		return Utils::PositiveModulo(std::abs(dy), GetTilesY() * units) * Utils::Sign(dy);
	} else {
		return dy;
	}
}

int Game_Map::XwithDirection(int x, int direction) {
	return RoundX(x + (direction == lcf::rpg::EventPage::Direction_right ? 1 : direction == lcf::rpg::EventPage::Direction_left ? -1 : 0));
}

int Game_Map::YwithDirection(int y, int direction) {
	return RoundY(y + (direction == lcf::rpg::EventPage::Direction_down ? 1 : direction == lcf::rpg::EventPage::Direction_up ? -1 : 0));
}

int Game_Map::CheckEvent(int x, int y) {
	for (const Game_Event& ev : events) {
		if (ev.IsInPosition(x, y)) {
			return ev.GetId();
		}
	}

	return 0;
}

void Game_Map::Update(MapUpdateAsyncContext& actx, bool is_preupdate) {
	if (GetNeedRefresh()) {
		Refresh();
	}

	if (!actx.IsActive()) {
		//If not resuming from async op ...
		UpdateProcessedFlags(is_preupdate);
	}

	if (!actx.IsActive() || actx.IsParallelCommonEvent()) {
		if (!UpdateCommonEvents(actx)) {
			// Suspend due to common event async op ...
			return;
		}
	}

	if (!actx.IsActive() || actx.IsParallelMapEvent()) {
		if (!UpdateMapEvents(actx)) {
			// Suspend due to map event async op ...
			return;
		}
	}

	if (is_preupdate) {
		return;
	}

	if (!actx.IsActive()) {
		//If not resuming from async op ...
		Main_Data::game_player->Update();

		for (auto& vehicle: vehicles) {
			if (vehicle.GetMapId() == GetMapId()) {
				vehicle.Update();
			}
		}
	}

	if (!actx.IsActive() || actx.IsMessage()) {
		if (!UpdateMessage(actx)) {
			// Suspend due to message async op ...
			return;
		}
	}

	if (!actx.IsActive()) {
		Main_Data::game_party->UpdateTimers();
		Main_Data::game_screen->Update();
		Main_Data::game_pictures->Update(false);
	}

	if (!actx.IsActive() || actx.IsForegroundEvent()) {
		if (!UpdateForegroundEvents(actx)) {
			// Suspend due to foreground event async op ...
			return;
		}
	}

	Parallax::Update();

	actx = {};
}

void Game_Map::UpdateProcessedFlags(bool is_preupdate) {
	for (Game_Event& ev : events) {
		ev.SetProcessed(false);
	}
	if (!is_preupdate) {
		Main_Data::game_player->SetProcessed(false);
		for (auto& vehicle: vehicles) {
			if (vehicle.IsInCurrentMap()) {
				vehicle.SetProcessed(false);
			}
		}
	}
}


bool Game_Map::UpdateCommonEvents(MapUpdateAsyncContext& actx) {
	int resume_ce = actx.GetParallelCommonEvent();

	for (Game_CommonEvent& ev : common_events) {
		bool resume_async = false;
		if (resume_ce != 0) {
			// If resuming, skip all until the event to resume from ..
			if (ev.GetIndex() != resume_ce) {
				continue;
			} else {
				resume_ce = 0;
				resume_async = true;
			}
		}

		auto aop = ev.Update(resume_async);
		if (aop.IsActive()) {
			// Suspend due to this event ..
			actx = MapUpdateAsyncContext::FromCommonEvent(ev.GetIndex(), aop);
			return false;
		}
	}

	actx = {};
	return true;
}

bool Game_Map::UpdateMapEvents(MapUpdateAsyncContext& actx) {
	int resume_ev = actx.GetParallelMapEvent();

	for (Game_Event& ev : events) {
		bool resume_async = false;
		if (resume_ev != 0) {
			// If resuming, skip all until the event to resume from ..
			if (ev.GetId() != resume_ev) {
				continue;
			} else {
				resume_ev = 0;
				resume_async = true;
			}
		}

		auto aop = ev.Update(resume_async);
		if (aop.IsActive()) {
			// Suspend due to this event ..
			actx = MapUpdateAsyncContext::FromMapEvent(ev.GetId(), aop);
			return false;
		}
	}

	actx = {};
	return true;
}

bool Game_Map::UpdateMessage(MapUpdateAsyncContext& actx) {
	// Message system does not support suspend and resume internally. So if the last frame the message
	// produced an async event, the message loop finished completely. Therefore this frame we should
	// resume *after* the message and not run it again.
	if (!actx.IsActive()) {
		auto aop = Game_Message::Update();
		if (aop.IsActive()) {
			actx = MapUpdateAsyncContext::FromMessage(aop);
			return false;
		}
	}

	actx = {};
	return true;
}

bool Game_Map::UpdateForegroundEvents(MapUpdateAsyncContext& actx) {
	auto& interp = GetInterpreter();

	// If we resume from async op, we don't clear the loop index.
	const bool resume_fg = actx.IsForegroundEvent();

	// Run any event loaded from last frame.
	interp.Update(!resume_fg);
	if (interp.IsAsyncPending()) {
		// Suspend due to this event ..
		actx = MapUpdateAsyncContext::FromForegroundEvent(interp.GetAsyncOp());
		return false;
	}

	while (!interp.IsRunning() && !interp.ReachedLoopLimit()) {
		interp.Clear();

		// This logic is probably one big loop in RPG_RT. We have to replicate
		// it here because once we stop executing from this we should not
		// clear anymore waiting flags.
		if (Scene::instance->HasRequestedScene() && interp.GetLoopCount() > 0) {
			break;
		}
		Game_CommonEvent* run_ce = nullptr;

		for (auto& ce: common_events) {
			if (ce.IsWaitingForegroundExecution()) {
				run_ce = &ce;
				break;
			}
		}
		if (run_ce) {
			interp.Push<InterpreterExecutionType::AutoStart>(run_ce);
		}

		Game_Event* run_ev = nullptr;
		for (auto& ev: events) {
			if (ev.IsWaitingForegroundExecution()) {
				if (!ev.IsActive()) {
					ev.ClearWaitingForegroundExecution();
					continue;
				}
				run_ev = &ev;
				break;
			}
		}
		if (run_ev) {
			if (run_ev->WasStartedByDecisionKey()) {
				interp.Push<InterpreterExecutionType::Action>(run_ev);
			} else {
				switch (run_ev->GetTrigger()) {
					case lcf::rpg::EventPage::Trigger_touched:
						interp.Push<InterpreterExecutionType::Touch>(run_ev);
						break;
					case lcf::rpg::EventPage::Trigger_collision:
						interp.Push<InterpreterExecutionType::Collision>(run_ev);
						break;
					case lcf::rpg::EventPage::Trigger_auto_start:
						interp.Push<InterpreterExecutionType::AutoStart>(run_ev);
						break;
					case lcf::rpg::EventPage::Trigger_action:
					default:
						interp.Push<InterpreterExecutionType::Action>(run_ev);
						break;
				}
			}
			run_ev->ClearWaitingForegroundExecution();
		}

		// If no events to run we're finished.
		if (!interp.IsRunning()) {
			break;
		}

		interp.Update(false);
		if (interp.IsAsyncPending()) {
			// Suspend due to this event ..
			actx = MapUpdateAsyncContext::FromForegroundEvent(interp.GetAsyncOp());
			return false;
		}
	}

	actx = {};
	return true;
}

lcf::rpg::MapInfo const& Game_Map::GetMapInfo() {
	return GetMapInfo(GetMapId());
}

lcf::rpg::MapInfo const& Game_Map::GetMapInfo(int map_id) {
	for (const auto& mi: lcf::Data::treemap.maps) {
		if (mi.ID == map_id) {
			return mi;
		}
	}

	Output::Debug("Map {} not in Maptree", map_id);
	return empty_map_info;
}

const lcf::rpg::MapInfo& Game_Map::GetParentMapInfo() {
	return GetParentMapInfo(GetMapInfo());
}

const lcf::rpg::MapInfo& Game_Map::GetParentMapInfo(const lcf::rpg::MapInfo& map_info) {
	return GetMapInfo(map_info.parent_map);
}

lcf::rpg::Map const& Game_Map::GetMap() {
	return *map;
}

int Game_Map::GetMapId() {
	return Main_Data::game_player->GetMapId();
}

void Game_Map::PrintPathToMap() {
	const auto* current_info = &GetMapInfo();
	std::ostringstream ss;
	ss << current_info->name;

	current_info = &GetParentMapInfo(*current_info);
	while (current_info->ID != 0 && current_info->ID != GetMapId()) {
		ss << " < " << current_info->name;
		current_info = &GetParentMapInfo(*current_info);
	}

	Output::Debug("Tree: {}", ss.str());
}

int Game_Map::GetTilesX() {
	return map->width;
}

int Game_Map::GetTilesY() {
	return map->height;
}

int Game_Map::GetOriginalEncounterSteps() {
	return GetMapInfo().encounter_steps;
}

int Game_Map::GetEncounterSteps() {
	return map_info.encounter_steps;
}

void Game_Map::SetEncounterSteps(int step) {
	if (step < 0) {
		step = GetOriginalEncounterSteps();
	}
	map_info.encounter_steps = step;
}

std::vector<int> Game_Map::GetEncountersAt(int x, int y) {
	int terrain_tag = GetTerrainTag(Main_Data::game_player->GetX(), Main_Data::game_player->GetY());

	std::function<bool(int)> is_acceptable = [=](int troop_id) {
		const lcf::rpg::Troop* troop = lcf::ReaderUtil::GetElement(lcf::Data::troops, troop_id);
		if (!troop) {
			Output::Warning("GetEncountersAt: Invalid troop ID {} in encounter list", troop_id);
			return false;
		}

		const auto& terrain_set = troop->terrain_set;

		// RPG_RT optimisation: Omitted entries are the default value (true)
		return terrain_set.size() <= (unsigned)(terrain_tag - 1) ||
				terrain_set[terrain_tag - 1];
	};

	std::vector<int> out;

	for (unsigned int i = 0; i < lcf::Data::treemap.maps.size(); ++i) {
		lcf::rpg::MapInfo& map = lcf::Data::treemap.maps[i];

		if (map.ID == GetMapId()) {
			for (const auto& enc : map.encounters) {
				if (is_acceptable(enc.troop_id)) {
					out.push_back(enc.troop_id);
				}
			}
		} else if (map.parent_map == GetMapId() && map.type == lcf::rpg::TreeMap::MapType_area) {
			// Area
			Rect area_rect(map.area_rect.l, map.area_rect.t, map.area_rect.r - map.area_rect.l, map.area_rect.b - map.area_rect.t);
			Rect player_rect(x, y, 1, 1);

			if (!player_rect.IsOutOfBounds(area_rect)) {
				for (const lcf::rpg::Encounter& enc : map.encounters) {
					if (is_acceptable(enc.troop_id)) {
						out.push_back(enc.troop_id);
					}
				}
			}
		}
	}

	return out;
}

static void OnEncounterEnd(BattleResult result) {
	if (result != BattleResult::Defeat) {
		return;
	}

	if (!Game_Battle::HasDeathHandler()) {
		Scene::Push(std::make_shared<Scene_Gameover>());
		return;
	}

	//2k3 death handler

	auto* ce = lcf::ReaderUtil::GetElement(common_events, Game_Battle::GetDeathHandlerCommonEvent());
	if (ce) {
		auto& interp = Game_Map::GetInterpreter();
		interp.Push<InterpreterExecutionType::DeathHandler>(ce);
	}

	auto tt = Game_Battle::GetDeathHandlerTeleport();
	if (tt.IsActive()) {
		Main_Data::game_player->ReserveTeleport(tt.GetMapId(), tt.GetX(), tt.GetY(), tt.GetDirection(), tt.GetType());
	}
}

bool Game_Map::PrepareEncounter(BattleArgs& args) {
	int x = Main_Data::game_player->GetX();
	int y = Main_Data::game_player->GetY();

	std::vector<int> encounters = GetEncountersAt(x, y);

	if (encounters.empty()) {
		// No enemies on this map :(
		return false;
	}

	args.troop_id = encounters[Rand::GetRandomNumber(0, encounters.size() - 1)];

	if (RuntimePatches::EncounterRandomnessAlert::HandleEncounter(args.troop_id)) {
		//Cancel the battle setup
		return false;
	}

	if (Feature::HasRpg2kBattleSystem()) {
		if (Rand::ChanceOf(1, 32)) {
			args.first_strike = true;
		}
	} else {
		const auto* terrain = lcf::ReaderUtil::GetElement(lcf::Data::terrains, GetTerrainTag(x, y));
		if (!terrain) {
			Output::Warning("PrepareEncounter: Invalid terrain at ({}, {})", x, y);
		} else {
			if (terrain->special_flags.back_party && Rand::PercentChance(terrain->special_back_party)) {
				args.condition = lcf::rpg::System::BattleCondition_initiative;
			} else if (terrain->special_flags.back_enemies && Rand::PercentChance(terrain->special_back_enemies)) {
				args.condition = lcf::rpg::System::BattleCondition_back;
			} else if (terrain->special_flags.lateral_party && Rand::PercentChance(terrain->special_lateral_party)) {
				args.condition = lcf::rpg::System::BattleCondition_surround;
			} else if (terrain->special_flags.lateral_enemies && Rand::PercentChance(terrain->special_lateral_enemies)) {
				args.condition = lcf::rpg::System::BattleCondition_pincers;
			}
		}
	}

	SetupBattle(args);
	args.on_battle_end = OnEncounterEnd;
	args.allow_escape = true;

	return true;
}

void Game_Map::SetupBattle(BattleArgs& args) {
	int x = Main_Data::game_player->GetX();
	int y = Main_Data::game_player->GetY();

	args.terrain_id = GetTerrainTag(x, y);

	const auto* current_info = &GetMapInfo();
	while (current_info->background_type == 0 && GetParentMapInfo(*current_info).ID != current_info->ID) {
		current_info = &GetParentMapInfo(*current_info);
	}

	if (current_info->background_type == 2) {
		args.background = ToString(current_info->background_name);
	}
}

std::vector<short>& Game_Map::GetMapDataDown() {
	return map->lower_layer;
}

std::vector<short>& Game_Map::GetMapDataUp() {
	return map->upper_layer;
}

int Game_Map::GetOriginalChipset() {
	return map != nullptr ? map->chipset_id : 0;
}

int Game_Map::GetChipset() {
	return chipset != nullptr ? chipset->ID : 0;
}

std::string_view Game_Map::GetChipsetName() {
	return chipset != nullptr
		? std::string_view(chipset->chipset_name)
		: std::string_view("");
}

int Game_Map::GetPositionX() {
	return map_info.position_x;
}

int Game_Map::GetDisplayX() {
	return map_info.position_x + Main_Data::game_screen->GetShakeOffsetX() * 16;
}

void Game_Map::SetPositionX(int x, bool reset_panorama) {
	const int map_width = GetTilesX() * SCREEN_TILE_SIZE;
	if (LoopHorizontal()) {
		x = Utils::PositiveModulo(x, map_width);
	} else {
		// Do not use std::clamp here. When the map is smaller than the screen the
		// upper bound is smaller than the lower bound making the function fail.
		x = std::max(0, std::min(map_width - screen_width, x));
	}
	map_info.position_x = x;
	if (reset_panorama) {
		Parallax::SetPositionX(map_info.position_x);
		Parallax::ResetPositionX();
	}
}

int Game_Map::GetPositionY() {
	return map_info.position_y;
}

int Game_Map::GetDisplayY() {
	return map_info.position_y + Main_Data::game_screen->GetShakeOffsetY() * 16;
}

void Game_Map::SetPositionY(int y, bool reset_panorama) {
	const int map_height = GetTilesY() * SCREEN_TILE_SIZE;
	if (LoopVertical()) {
		y = Utils::PositiveModulo(y, map_height);
	} else {
		// Do not use std::clamp here. When the map is smaller than the screen the
		// upper bound is smaller than the lower bound making the function fail.
		y = std::max(0, std::min(map_height - screen_height, y));
	}
	map_info.position_y = y;
	if (reset_panorama) {
		Parallax::SetPositionY(map_info.position_y);
		Parallax::ResetPositionY();
	}
}

bool Game_Map::GetNeedRefresh() {
	int anti_lag_switch = Player::game_config.patch_anti_lag_switch.Get();
	if (anti_lag_switch > 0 && Main_Data::game_switches->Get(anti_lag_switch)) {
		return false;
	}

	return need_refresh;
}

void Game_Map::SetNeedRefresh(bool refresh) {
	need_refresh = refresh;
}

void Game_Map::SetNeedRefreshForSwitchChange(int switch_id) {
	if (need_refresh)
		return;
	if (map_cache->GetNeedRefresh<Caching::ObservedVarOps::SwitchSet>(switch_id))
		SetNeedRefresh(true);
}

void Game_Map::SetNeedRefreshForVarChange(int var_id) {
	if (need_refresh)
		return;
	if (map_cache->GetNeedRefresh<Caching::ObservedVarOps::VarSet>(var_id))
		SetNeedRefresh(true);
}

void Game_Map::SetNeedRefreshForSwitchChange(std::initializer_list<int> switch_ids) {
	for (auto switch_id: switch_ids) {
		SetNeedRefreshForSwitchChange(switch_id);
	}
}

void Game_Map::SetNeedRefreshForVarChange(std::initializer_list<int> var_ids) {
	for (auto var_id: var_ids) {
		SetNeedRefreshForVarChange(var_id);
	}
}

std::vector<unsigned char>& Game_Map::GetPassagesDown() {
	return passages_down;
}

std::vector<unsigned char>& Game_Map::GetPassagesUp() {
	return passages_up;
}

int Game_Map::GetAnimationType() {
	return animation_type;
}

int Game_Map::GetAnimationSpeed() {
	return (animation_fast ? 12 : 24);
}

std::vector<Game_Event>& Game_Map::GetEvents() {
	return events;
}

int Game_Map::GetHighestEventId() {
	int id = 0;
	for (auto& ev: events) {
		id = std::max(id, ev.GetId());
	}
	return id;
}

Game_Event* Game_Map::GetEvent(int event_id) {
	auto it = std::find_if(events.begin(), events.end(),
			[&event_id](Game_Event& ev) {return ev.GetId() == event_id;});
	return it == events.end() ? nullptr : &(*it);
}

std::vector<Game_CommonEvent>& Game_Map::GetCommonEvents() {
	return common_events;
}

std::string_view Game_Map::GetMapName(int id) {
	for (unsigned int i = 0; i < lcf::Data::treemap.maps.size(); ++i) {
		if (lcf::Data::treemap.maps[i].ID == id) {
			return lcf::Data::treemap.maps[i].name;
		}
	}
	// nothing found
	return {};
}

void Game_Map::SetChipset(int id) {
	if (id == 0) {
		// This emulates RPG_RT behavior, where chipset id == 0 means use the default map chipset.
		id = GetOriginalChipset();
	}
	map_info.chipset_id = id;

	if (!ReloadChipset()) {
		Output::Warning("SetChipset: Invalid chipset ID {}", map_info.chipset_id);
	} else {
		passages_down = chipset->passable_data_lower;
		passages_up = chipset->passable_data_upper;
		animation_type = chipset->animation_type;
		animation_fast = chipset->animation_speed != 0;
	}

	if (passages_down.size() < 162)
		passages_down.resize(162, (unsigned char) 0x0F);
	if (passages_up.size() < 144)
		passages_up.resize(144, (unsigned char) 0x0F);
}

bool Game_Map::ReloadChipset() {
	chipset = lcf::ReaderUtil::GetElement(lcf::Data::chipsets, map_info.chipset_id);
	if (!chipset) {
		return false;
	}
	return true;
}

void Game_Map::OnTranslationChanged() {
	ReloadChipset();
	// Marks common events for reload on map change
	// This is not save to do while they are executing
	translation_changed = true;
}

Game_Vehicle* Game_Map::GetVehicle(Game_Vehicle::Type which) {
	if (which == Game_Vehicle::Boat ||
		which == Game_Vehicle::Ship ||
		which == Game_Vehicle::Airship) {
		return &vehicles[which - 1];
	}

	return nullptr;
}

bool Game_Map::IsAnyEventStarting() {
	for (Game_Event& ev : events)
		if (ev.IsWaitingForegroundExecution() && !ev.GetList().empty() && ev.IsActive())
			return true;

	for (Game_CommonEvent& ev : common_events)
		if (ev.IsWaitingForegroundExecution())
			return true;

	return false;
}

bool Game_Map::IsAnyMovePending() {
	auto check = [](auto& ev) {
		return ev.IsMoveRouteOverwritten() && !ev.IsMoveRouteFinished();
	};
	const auto map_id = GetMapId();
	if (check(*Main_Data::game_player)) {
		return true;
	}
	for (auto& vh: vehicles) {
		if (vh.GetMapId() == map_id && check(vh)) {
			return true;
		}
	}
	for (auto& ev: events) {
		if (check(ev)) {
			return true;
		}
	}

	return false;
}

void Game_Map::RemoveAllPendingMoves() {
	const auto map_id = GetMapId();
	Main_Data::game_player->CancelMoveRoute();
	for (auto& vh: vehicles) {
		if (vh.GetMapId() == map_id) {
			vh.CancelMoveRoute();
		}
	}
	for (auto& ev: events) {
		ev.CancelMoveRoute();
	}
}

static int DoSubstitute(std::vector<uint8_t>& tiles, int old_id, int new_id) {
	int num_subst = 0;
	for (size_t i = 0; i < tiles.size(); ++i) {
		if (tiles[i] == old_id) {
			tiles[i] = (uint8_t) new_id;
			++num_subst;
		}
	}
	return num_subst;
}

int Game_Map::SubstituteDown(int old_id, int new_id) {
	return DoSubstitute(map_info.lower_tiles, old_id, new_id);
}

int Game_Map::SubstituteUp(int old_id, int new_id) {
	return DoSubstitute(map_info.upper_tiles, old_id, new_id);
}

void Game_Map::ReplaceTileAt(int x, int y, int new_id, int layer) {
	auto pos = x + y * map->width;
	auto& layer_vec = layer >= 1 ? map->upper_layer : map->lower_layer;
	layer_vec[pos] = static_cast<int16_t>(new_id);
}

int Game_Map::GetTileIdAt(int x, int y, int layer, bool chip_id_or_index) {
	if (x < 0 || x >= map->width || y < 0 || y >= map->height) {
		return 0;  // Return 0 for out-of-bounds coordinates
	}

	auto pos = x + y * map->width;
	auto& layer_vec = layer >= 1 ? map->upper_layer : map->lower_layer;

	int tile_output = chip_id_or_index ? layer_vec[pos] : ChipIdToIndex(layer_vec[pos]);
	if (layer >= 1) tile_output -= BLOCK_F_INDEX;

	return tile_output;
}

std::vector<int> Game_Map::GetTilesIdAt(Rect coords, int layer, bool chip_id_or_index) {
	std::vector<int> tiles_collection;
	for (int i = 0; i < coords.height; ++i) {
		for (int j = 0; j < coords.width; ++j) {
			tiles_collection.emplace_back(Game_Map::GetTileIdAt(coords.x + j, coords.y + i, layer, chip_id_or_index));
		}
	}
	return tiles_collection;
}

std::string Game_Map::ConstructMapName(int map_id, bool is_easyrpg) {
	std::stringstream ss;
	ss << "Map" << std::setfill('0') << std::setw(4) << map_id;
	if (is_easyrpg) {
		return Player::fileext_map.MakeFilename(ss.str(), SUFFIX_EMU);
	} else {
		return Player::fileext_map.MakeFilename(ss.str(), SUFFIX_LMU);
	}
}

FileRequestAsync* Game_Map::RequestMap(int map_id) {
#ifdef EMSCRIPTEN
	Player::translation.RequestAndAddMap(map_id);
#endif

	auto* request = AsyncHandler::RequestFile(Game_Map::ConstructMapName(map_id, false));
	request->SetImportantFile(true);
	return request;
}

// MapEventCache
//////////////////
void Game_Map::Caching::MapEventCache::AddEvent(const lcf::rpg::Event& ev) {
	auto id = ev.ID;

	if (std::find(event_ids.begin(), event_ids.end(), id) == event_ids.end()) {
		event_ids.emplace_back(id);
	}
}

void Game_Map::Caching::MapEventCache::RemoveEvent(const lcf::rpg::Event& ev) {
	auto id = ev.ID;

	auto it = std::find(event_ids.begin(), event_ids.end(), id);

	if (it != event_ids.end()) {
		event_ids.erase(it);
	}
}

// Parallax
/////////////

namespace {
	int parallax_width;
	int parallax_height;

	bool parallax_fake_x;
	bool parallax_fake_y;
}

/* Helper function to get the current parallax parameters. If the default
 * parallax for the current map was overridden by a "Change Parallax BG"
 * command, the result is filled out from those values in the SaveMapInfo.
 * Otherwise, the result is filled out from the default for the current map.
 */
static Game_Map::Parallax::Params GetParallaxParams() {
	Game_Map::Parallax::Params params = {};

	if (!map_info.parallax_name.empty()) {
		params.name = map_info.parallax_name;
		params.scroll_horz = map_info.parallax_horz;
		params.scroll_horz_auto = map_info.parallax_horz_auto;
		params.scroll_horz_speed = map_info.parallax_horz_speed;
		params.scroll_vert = map_info.parallax_vert;
		params.scroll_vert_auto = map_info.parallax_vert_auto;
		params.scroll_vert_speed = map_info.parallax_vert_speed;
	} else if (map->parallax_flag) {
		// Default case when map parallax hasn't been overwritten.
		params.name = ToString(map->parallax_name);
		params.scroll_horz = map->parallax_loop_x;
		params.scroll_horz_auto = map->parallax_auto_loop_x;
		params.scroll_horz_speed = map->parallax_sx;
		params.scroll_vert = map->parallax_loop_y;
		params.scroll_vert_auto = map->parallax_auto_loop_y;
		params.scroll_vert_speed = map->parallax_sy;
	} else {
		// No BG; use default-constructed Param
	}

	return params;
}

std::string Game_Map::Parallax::GetName() {
	return GetParallaxParams().name;
}

int Game_Map::Parallax::GetX() {
	return (-panorama.pan_x / TILE_SIZE) / 2;
}

int Game_Map::Parallax::GetY() {
	return (-panorama.pan_y / TILE_SIZE) / 2;
}

void Game_Map::Parallax::Initialize(int width, int height) {
	parallax_width = width;
	parallax_height = height;

	if (panorama_on_map_init) {
		SetPositionX(map_info.position_x);
		SetPositionY(map_info.position_y);
	}

	if (reset_panorama_x_on_next_init) {
		ResetPositionX();
	}
	if (reset_panorama_y_on_next_init) {
		ResetPositionY();
	}

	if (Player::IsRPG2k() && !panorama_on_map_init) {
		SetPositionX(panorama.pan_x);
		SetPositionY(panorama.pan_y);
	}

	panorama_on_map_init = false;
}

void Game_Map::Parallax::AddPositionX(int off_x) {
	SetPositionX(panorama.pan_x + off_x);
}

void Game_Map::Parallax::AddPositionY(int off_y) {
	SetPositionY(panorama.pan_y + off_y);
}

void Game_Map::Parallax::SetPositionX(int x) {
	// FIXME: Fixes a crash with ChangeBG commands in events, but not correct.
	// Real fix TBD
	if (parallax_width) {
		const int w = parallax_width * TILE_SIZE * 2;
		panorama.pan_x = (x + w) % w;
	}
}

void Game_Map::Parallax::SetPositionY(int y) {
	// FIXME: Fixes a crash with ChangeBG commands in events, but not correct.
	// Real fix TBD
	if (parallax_height) {
		const int h = parallax_height * TILE_SIZE * 2;
		panorama.pan_y = (y + h) % h;
	}
}

void Game_Map::Parallax::ResetPositionX() {
	Params params = GetParallaxParams();

	if (params.name.empty()) {
		return;
	}

	parallax_fake_x = false;

	if (!params.scroll_horz && !LoopHorizontal()) {
		int pan_screen_width = Player::screen_width;
		if (Player::game_config.fake_resolution.Get()) {
			pan_screen_width = SCREEN_TARGET_WIDTH;
		}

		int tiles_per_screen = pan_screen_width / TILE_SIZE;
		if (pan_screen_width % TILE_SIZE != 0) {
			++tiles_per_screen;
		}

		if (GetTilesX() > tiles_per_screen && parallax_width > pan_screen_width) {
			const int w = (GetTilesX() - tiles_per_screen) * TILE_SIZE;
			const int ph = 2 * std::min(w, parallax_width - pan_screen_width) * map_info.position_x / w;
			if (Player::IsRPG2k()) {
				SetPositionX(ph);
			} else {
				// 2k3 does not do the (% parallax_width * TILE_SIZE * 2) here
				panorama.pan_x = ph;
			}
		} else {
			panorama.pan_x = 0;
			parallax_fake_x = true;
		}
	} else {
		parallax_fake_x = true;
	}
}

void Game_Map::Parallax::ResetPositionY() {
	Params params = GetParallaxParams();

	if (params.name.empty()) {
		return;
	}

	parallax_fake_y = false;

	if (!params.scroll_vert && !Game_Map::LoopVertical()) {
		int pan_screen_height = Player::screen_height;
		if (Player::game_config.fake_resolution.Get()) {
			pan_screen_height = SCREEN_TARGET_HEIGHT;
		}

		int tiles_per_screen = pan_screen_height / TILE_SIZE;
		if (pan_screen_height % TILE_SIZE != 0) {
			++tiles_per_screen;
		}

		if (GetTilesY() > tiles_per_screen && parallax_height > pan_screen_height) {
			const int h = (GetTilesY() - tiles_per_screen) * TILE_SIZE;
			const int pv = 2 * std::min(h, parallax_height - pan_screen_height) * map_info.position_y / h;
			SetPositionY(pv);
		} else {
			panorama.pan_y = 0;
			parallax_fake_y = true;
		}
	} else {
		parallax_fake_y = true;
	}
}

void Game_Map::Parallax::ScrollRight(int distance) {
	if (!distance) {
		return;
	}

	Params params = GetParallaxParams();
	if (params.name.empty()) {
		return;
	}

	if (params.scroll_horz) {
		AddPositionX(distance);
		return;
	}

	if (Game_Map::LoopHorizontal()) {
		return;
	}

	ResetPositionX();
}

void Game_Map::Parallax::ScrollDown(int distance) {
	if (!distance) {
		return;
	}

	Params params = GetParallaxParams();
	if (params.name.empty()) {
		return;
	}

	if (params.scroll_vert) {
		AddPositionY(distance);
		return;
	}

	if (Game_Map::LoopVertical()) {
		return;
	}

	ResetPositionY();
}

void Game_Map::Parallax::Update() {
	Params params = GetParallaxParams();

	if (params.name.empty())
		return;

	auto scroll_amt = [](int speed) {
		return speed < 0 ? (1 << -speed) : -(1 << speed);
	};

	if (params.scroll_horz
			&& params.scroll_horz_auto
			&& params.scroll_horz_speed != 0) {
		AddPositionX(scroll_amt(params.scroll_horz_speed));
	}

	if (params.scroll_vert
			&& params.scroll_vert_auto
			&& params.scroll_vert_speed != 0) {
		if (parallax_height != 0) {
			AddPositionY(scroll_amt(params.scroll_vert_speed));
		}
	}
}

void Game_Map::Parallax::ChangeBG(const Params& params) {
	map_info.parallax_name = params.name;
	map_info.parallax_horz = params.scroll_horz;
	map_info.parallax_horz_auto = params.scroll_horz_auto;
	map_info.parallax_horz_speed = params.scroll_horz_speed;
	map_info.parallax_vert = params.scroll_vert;
	map_info.parallax_vert_auto = params.scroll_vert_auto;
	map_info.parallax_vert_speed = params.scroll_vert_speed;

	reset_panorama_x_on_next_init = !Game_Map::LoopHorizontal() && !map_info.parallax_horz;
	reset_panorama_y_on_next_init = !Game_Map::LoopVertical() && !map_info.parallax_vert;

	Scene_Map* scene = (Scene_Map*)Scene::Find(Scene::Map).get();
	if (!scene || !scene->spriteset)
		return;
	scene->spriteset->ParallaxUpdated();
}

void Game_Map::Parallax::ClearChangedBG() {
	Params params {}; // default Param indicates no override
	ChangeBG(params);
}

bool Game_Map::Parallax::FakeXPosition() {
	return parallax_fake_x;
}

bool Game_Map::Parallax::FakeYPosition() {
	return parallax_fake_y;
}


/*end of file .\game_map.cpp*/

/*start of file .\game_message.cpp*/

/* ... license chunk ... */

// Headers
#include "game_message.h"
#include "game_actor.h"
#include "game_party.h"
#include "game_player.h"
#include "game_battle.h"
#include "game_system.h"
#include "game_strings.h"
#include "main_data.h"
#include "window_message.h"
#include "font.h"
#include "player.h"
#include "game_variables.h"
#include <lcf/data.h>
#include <lcf/reader_util.h>
#include "output.h"
#include "feature.h"

#include <cctype>

static Window_Message* window = nullptr;

void Game_Message::SetWindow(Window_Message* w) {
	window = w;
}

Window_Message* Game_Message::GetWindow() {
	return window;
}

int Game_Message::GetRealPosition() {
	if (Game_Battle::IsBattleRunning()) {
		if (Feature::HasRpg2kBattleSystem()) {
			return 2;
		}
		else {
			return 0;
		}
	}

	if (Main_Data::game_system->IsMessagePositionFixed()) {
		return Main_Data::game_system->GetMessagePosition();
	}
	else {
		// Move Message Box to prevent player hiding
		int disp = Main_Data::game_player->GetScreenY();

		switch (Main_Data::game_system->GetMessagePosition()) {
		case 0: // Up
			return disp > (16 * 7) ? 0 : 2;
		case 1: // Center
			if (disp <= 16 * 7) {
				return 2;
			}
			else if (disp >= 16 * 10) {
				return 0;
			}
			else {
				return 1;
			}
		default: // Down
			return disp >= (16 * 10) ? 0 : 2;
		};
	}
}

int Game_Message::WordWrap(std::string_view line, const int limit, const WordWrapCallback& callback) {
	return WordWrap(line, limit, callback, *Font::Default());
}

int Game_Message::WordWrap(std::string_view line, const int limit, const WordWrapCallback& callback, const Font& font) {
	int start = 0;
	int line_count = 0;

	do {
		int next = start;
		do {
			auto found = line.find(' ', next);
			if (found == std::string::npos) {
				found = line.size();
			}

			auto wrapped = line.substr(start, found - start);
			auto width = Text::GetSize(font, wrapped).width;
			if (width > limit) {
				if (next == start) {
					next = found + 1;
				}
				break;
			}

			next = found + 1;
		} while(next < static_cast<int>(line.size()));

		if (start == (next - 1)) {
			start = next;
			continue;
		}

		auto wrapped = line.substr(start, (next - 1) - start);

		callback(wrapped);
		line_count++;

		start = next;
	} while (start < static_cast<int>(line.size()));

	return line_count;
}

AsyncOp Game_Message::Update() {
	if (window) {
		window->Update();
		return window->GetAsyncOp();
	}
	return {};
}

void Game_Message::SetPendingMessage(PendingMessage&& pm) {
	if (window) {
		// This flag has no known use, but RPG_RT sets it whenever an event message command
		// spawns a message. We replicate it for save game compatibility.
		Main_Data::game_system->SetMessageEventMessageActive(pm.IsEventMessage());

		window->StartMessageProcessing(std::move(pm));
	}
}

bool Game_Message::IsMessagePending() {
	return window ? window->IsMessagePending() : false;
}

bool Game_Message::IsMessageActive() {
	return window ? !window->GetAllowNextMessage(false) : false;
}

bool Game_Message::CanShowMessage(bool foreground) {
	return window ? window->GetAllowNextMessage(foreground) : false;
}

static std::optional<std::string> CommandCodeInserterNoRecurse(char ch, const char** iter, const char* end, uint32_t escape_char) {
	if ((ch == 'T' || ch == 't') && Player::IsPatchManiac()) {
		auto parse_ret = Game_Message::ParseString(*iter, end, escape_char, true);
		*iter = parse_ret.next;
		int value = parse_ret.value;

		std::string str = ToString(Main_Data::game_strings->Get(value));

		// \t[] is evaluated but command codes inside it are not evaluated again
		return PendingMessage::ApplyTextInsertingCommands(str, escape_char, PendingMessage::DefaultCommandInserter);
	}

	return PendingMessage::DefaultCommandInserter(ch, iter, end, escape_char);
}

std::optional<std::string> Game_Message::CommandCodeInserter(char ch, const char** iter, const char* end, uint32_t escape_char) {
	if ((ch == 'T' || ch == 't') && Player::IsPatchManiac()) {
		auto parse_ret = Game_Message::ParseString(*iter, end, escape_char, true);
		*iter = parse_ret.next;
		int value = parse_ret.value;

		std::string str = ToString(Main_Data::game_strings->Get(value));

		// Command codes in \t[] are evaluated once.
		return PendingMessage::ApplyTextInsertingCommands(str, escape_char, CommandCodeInserterNoRecurse);
	}

	return PendingMessage::DefaultCommandInserter(ch, iter, end, escape_char);
}

Game_Message::ParseParamResult Game_Message::ParseParam(
		char upper,
		char lower,
		const char* iter,
		const char* end,
		uint32_t escape_char,
		bool skip_prefix,
		int max_recursion)
{
	if (!skip_prefix) {
		const auto begin = iter;
		if (iter == end) {
			return { begin, 0 };
		}
		auto ret = Utils::UTF8Next(iter, end);
		// Invalid commands
		if (ret.ch != escape_char) {
			return { begin, 0 };
		}
		iter = ret.next;
		if (iter == end || (*iter != upper && *iter != lower)) {
			return { begin, 0 };
		}
		++iter;
	}

	// If no bracket, RPG_RT will return 0.
	if (iter == end || *iter != '[') {
		return { iter, 0 };
	}

	int value = 0;
	++iter;
	bool stop_parsing = false;
	bool got_valid_number = false;

	while (iter != end && *iter != ']') {
		if (stop_parsing) {
			++iter;
			continue;
		}

		// Fast inline isdigit()
		if (*iter >= '0' && *iter <= '9') {
			value *= 10;
			value += (*iter - '0');
			++iter;
			got_valid_number = true;
			continue;
		}

		if (max_recursion > 0) {
			auto ret = Utils::UTF8Next(iter, end);
			auto ch = ret.ch;
			iter = ret.next;

			// Recursive variable case.
			if (ch == escape_char) {
				if (iter != end && (*iter == 'V' || *iter == 'v')) {
					++iter;

					auto ret = ParseParam('V', 'v', iter, end, escape_char, true, max_recursion - 1);
					iter = ret.next;
					int var_val = Main_Data::game_variables->Get(ret.value);

					got_valid_number = true;

					// RPG_RT concatenates the variable value.
					int m = 10;
					if (value != 0) {
						while (m < var_val) {
							m *= 10;
						}
					}
					value = value * m + var_val;
					continue;
				}
			}
		}

		// If we hit a non-digit, RPG_RT will stop parsing until the next closing bracket.
		stop_parsing = true;
	}

	if (iter != end) {
		++iter;
	}

	// Actor 0 references the first party member
	if (upper == 'N' && value == 0 && got_valid_number) {
		auto* party = Main_Data::game_party.get();
		if (party->GetBattlerCount() > 0) {
			value = (*party)[0].GetId();
		}
	}

	return { iter, value };
}

Game_Message::ParseParamStringResult Game_Message::ParseStringParam(
		char upper,
		char lower,
		const char* iter,
		const char* end,
		uint32_t escape_char,
		bool skip_prefix,
		int max_recursion)
{
	if (!skip_prefix) {
		const auto begin = iter;
		if (iter == end) {
			return { begin, "" };
		}
		auto ret = Utils::UTF8Next(iter, end);
		// Invalid commands
		if (ret.ch != escape_char) {
			return { begin, "" };
		}
		iter = ret.next;
		if (iter == end || (*iter != upper && *iter != lower)) {
			return { begin, "" };
		}
		++iter;
	}

	// If no bracket, return empty string
	if (iter == end || *iter != '[') {
		return { iter, "" };
	}

	std::string value;
	++iter;

	while (iter != end && *iter != ']') {
		// Fast inline isdigit()
		value += *iter;

		if (max_recursion > 0) {
			auto ret = Utils::UTF8Next(iter, end);
			auto ch = ret.ch;
			iter = ret.next;

			// Recursive variable case.
			if (ch == escape_char) {
				if (iter != end && (*iter == 'V' || *iter == 'v')) {
					++iter;

					auto ret = ParseParam('V', 'v', iter, end, escape_char, true, max_recursion - 1);
					iter = ret.next;
					int var_val = Main_Data::game_variables->Get(ret.value);

					value += std::to_string(var_val);
					continue;
				}
			}
		}
	}

	if (iter != end) {
		++iter;
	}

	return { iter, value };
}

Game_Message::ParseParamResult Game_Message::ParseVariable(const char* iter, const char* end, uint32_t escape_char, bool skip_prefix, int max_recursion) {
	return ParseParam('V', 'v', iter, end, escape_char, skip_prefix, max_recursion - 1);
}

Game_Message::ParseParamResult Game_Message::ParseString(const char* iter, const char* end, uint32_t escape_char, bool skip_prefix, int max_recursion) {
	return ParseParam('T', 't', iter, end, escape_char, skip_prefix, max_recursion);
}

Game_Message::ParseParamResult Game_Message::ParseColor(const char* iter, const char* end, uint32_t escape_char, bool skip_prefix, int max_recursion) {
	return ParseParam('C', 'c', iter, end, escape_char, skip_prefix, max_recursion);
}

Game_Message::ParseParamResult Game_Message::ParseSpeed(const char* iter, const char* end, uint32_t escape_char, bool skip_prefix, int max_recursion) {
	return ParseParam('S', 's', iter, end, escape_char, skip_prefix, max_recursion);
}

Game_Message::ParseParamResult Game_Message::ParseActor(const char* iter, const char* end, uint32_t escape_char, bool skip_prefix, int max_recursion) {
	return ParseParam('N', 'n', iter, end, escape_char, skip_prefix, max_recursion);
}


/*end of file .\game_message.cpp*/

/*start of file .\game_message_terms.cpp*/

/* ... license chunk ... */
#include "game_message_terms.h"
#include "player.h"
#include "utils.h"
#include "algo.h"
#include "game_actor.h"
#include "game_battler.h"
#include <lcf/rpg/state.h>
#include <lcf/data.h>
#include <lcf/reader_util.h>
#include "feature.h"

namespace ActorMessage {

std::string GetLevelUpMessage(const Game_Actor& actor, int new_level) {
	std::stringstream ss;
	if (Player::IsRPG2k3E()) {
		if (Player::IsPatchManiac() && !lcf::Data::terms.maniac_level_up_a.empty()) {
			ss << lcf::Data::terms.maniac_level_up_a << " ";
		}
		ss << actor.GetName();
		ss << " " << lcf::Data::terms.level_up << " ";
		ss << " " << lcf::Data::terms.level;

		if (Player::IsPatchManiac() && !lcf::Data::terms.maniac_level_up_b.empty()) {
			ss << " " << lcf::Data::terms.maniac_level_up_b;
		}
		ss << " " << new_level;
		if (Player::IsPatchManiac() && !lcf::Data::terms.maniac_level_up_c.empty()) {
			ss << lcf::Data::terms.maniac_level_up_c;
		}
		return ss.str();
	} else if (Player::IsRPG2kE()) {
		ss << new_level;
		return Utils::ReplacePlaceholders(
			lcf::Data::terms.level_up,
			Utils::MakeArray('S', 'V', 'U'),
			Utils::MakeSvArray(actor.GetName(), ss.str(), lcf::Data::terms.level)
		);
	} else {
		std::string particle, space = "";
		if (Player::IsCP932()) {
			particle = "は";
			space += " ";
		} else {
			particle = " ";
		}
		ss << actor.GetName();
		ss << particle << lcf::Data::terms.level << " ";
		ss << new_level << space << lcf::Data::terms.level_up;
		return ss.str();
	}
}

std::string GetLearningMessage(const Game_Actor& actor, const lcf::rpg::Skill& skill) {
	if (Player::IsRPG2kE()) {
		return Utils::ReplacePlaceholders(
			lcf::Data::terms.skill_learned,
			Utils::MakeArray('S', 'O'),
			Utils::MakeSvArray(actor.GetName(), skill.name)
		);
	}
	std::stringstream ss;
	if (Player::IsPatchManiac() && !lcf::Data::terms.maniac_skill_learned_a.empty()) {
		ss << lcf::Data::terms.maniac_skill_learned_a << " ";
	}
	ss << ToString(skill.name) + (Player::IsRPG2k3E() ? " " : "");
	ss << ToString(lcf::Data::terms.skill_learned);
	return ss.str();
}

} // namespace ActorMessage

namespace BattleMessage {

static std::string GetStateMessage(std::string_view target_name, std::string_view message) {
	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
			message,
			Utils::MakeArray('S'),
			Utils::MakeSvArray(target_name)
		);
	}
	else {
		return ToString(target_name) + ToString(message);
	}
}

std::string GetStateInflictMessage(const Game_Battler& target, const lcf::rpg::State& state) {
	if (target.GetType() == Game_Battler::Type_Ally) {
		return GetStateMessage(target.GetName(), state.message_actor);
	}
	if (target.GetType() == Game_Battler::Type_Enemy) {
		return GetStateMessage(target.GetName(), state.message_enemy);
	}
	return "";
}

std::string GetStateRecoveryMessage(const Game_Battler& target, const lcf::rpg::State& state) {
	return GetStateMessage(target.GetName(), state.message_recovery);
}

std::string GetStateAffectedMessage(const Game_Battler& target, const lcf::rpg::State& state) {
	return GetStateMessage(target.GetName(), state.message_affected);
}

std::string GetStateAlreadyMessage(const Game_Battler& target, const lcf::rpg::State& state) {
	return GetStateMessage(target.GetName(), state.message_already);
}

std::string GetDeathMessage(const Game_Battler& target) {
	const auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, 1);
	if (state) {
		return GetStateInflictMessage(target, *state);
	}
	return "";
}

static std::string GetActionFailureMessage(std::string_view source, std::string_view target, std::string_view message) {
	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
			message,
			Utils::MakeArray('S', 'O'),
			Utils::MakeSvArray(source, target)
		);
	}
	else {
		return ToString(target) + ToString(message);
	}
}

std::string GetPhysicalFailureMessage(const Game_Battler& source, const Game_Battler& target) {
	return GetActionFailureMessage(source.GetName(), target.GetName(), lcf::Data::terms.dodge);
}

std::string GetSkillFailureMessage(const Game_Battler& source, const Game_Battler& target, const lcf::rpg::Skill& skill) {
	std::string_view msg;
	switch (skill.failure_message) {
		case 0:
			msg = lcf::Data::terms.skill_failure_a;
			break;
		case 1:
			msg = lcf::Data::terms.skill_failure_b;
			break;
		case 2:
			msg = lcf::Data::terms.skill_failure_c;
			break;
		case 3:
			msg = lcf::Data::terms.dodge;
			break;
		default:
			break;
	}
	return GetActionFailureMessage(source.GetName(), target.GetName(), msg);
}

std::string GetUndamagedMessage(const Game_Battler& target) {
	std::string_view name = target.GetName();
	std::string_view message = (target.GetType() == Game_Battler::Type_Ally)
		? std::string_view(lcf::Data::terms.actor_undamaged)
		: std::string_view(lcf::Data::terms.enemy_undamaged);

	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
			message,
			Utils::MakeArray('S'),
			Utils::MakeSvArray(name)
		);
	}
	else {
		return ToString(name) + ToString(message);
	}
}

std::string GetCriticalHitMessage(const Game_Battler& source, const Game_Battler& target) {
	std::string_view message = (target.GetType() == Game_Battler::Type_Ally)
		? std::string_view(lcf::Data::terms.actor_critical)
		: std::string_view(lcf::Data::terms.enemy_critical);

	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
			message,
			Utils::MakeArray('S', 'O'),
			Utils::MakeSvArray(source.GetName(), target.GetName())
		);
	}
	else {
		return ToString(message);
	}
}

static std::string GetHpSpRecoveredMessage(const Game_Battler& target, int value, std::string_view points) {
	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
			lcf::Data::terms.hp_recovery,
			Utils::MakeArray('S', 'V', 'U'),
			Utils::MakeSvArray(target.GetName(), std::to_string(value), points)
		);
	}
	std::stringstream ss;
	std::string particle, particle2, space = "";

	ss << target.GetName();
	if (Player::IsCP932()) {
		particle = "の";
		particle2 = "が ";
		space += " ";
	}
	else {
		particle = particle2 = " ";
	}
	ss << particle << points << particle2;
	ss << value << space << lcf::Data::terms.hp_recovery;
	return ss.str();
}

std::string GetHpRecoveredMessage(const Game_Battler& target, int value) {
	return GetHpSpRecoveredMessage(target, value, lcf::Data::terms.health_points);
}

std::string GetSpRecoveredMessage(const Game_Battler& target, int value) {
	return GetHpSpRecoveredMessage(target, value, lcf::Data::terms.spirit_points);
}

std::string GetParameterAbsorbedMessage(const Game_Battler& source, const Game_Battler& target, int value, std::string_view points) {
	const auto target_is_ally = (target.GetType() == Game_Battler::Type_Ally);
	std::string_view message = target_is_ally
		? std::string_view(lcf::Data::terms.actor_hp_absorbed)
		: std::string_view(lcf::Data::terms.enemy_hp_absorbed);

	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
			message,
			Utils::MakeArray('S', 'O', 'V', 'U'),
			Utils::MakeSvArray(source.GetName(), target.GetName(), std::to_string(value), points)
		);
	}
	std::stringstream ss;
	std::string particle, particle2, space = "";

	ss << target.GetName();

	if (Player::IsCP932()) {
		particle = (target_is_ally ? "は" : "の");
		particle2 = "を ";
		space += " ";
	} else {
		particle = particle2 = " ";
	}
	ss << particle << points << particle2;
	ss << value << space << message;

	return ss.str();
}

std::string GetHpAbsorbedMessage(const Game_Battler& source, const Game_Battler& target, int value) {
	return GetParameterAbsorbedMessage(source, target, value, lcf::Data::terms.health_points);
}

std::string GetSpAbsorbedMessage(const Game_Battler& source, const Game_Battler& target, int value) {
	return GetParameterAbsorbedMessage(source, target, value, lcf::Data::terms.spirit_points);
}

std::string GetAtkAbsorbedMessage(const Game_Battler& source, const Game_Battler& target, int value) {
	return GetParameterAbsorbedMessage(source, target, value, lcf::Data::terms.attack);
}

std::string GetDefAbsorbedMessage(const Game_Battler& source, const Game_Battler& target, int value) {
	return GetParameterAbsorbedMessage(source, target, value, lcf::Data::terms.defense);
}

std::string GetSpiAbsorbedMessage(const Game_Battler& source, const Game_Battler& target, int value) {
	return GetParameterAbsorbedMessage(source, target, value, lcf::Data::terms.spirit);
}

std::string GetAgiAbsorbedMessage(const Game_Battler& source, const Game_Battler& target, int value) {
	return GetParameterAbsorbedMessage(source, target, value, lcf::Data::terms.agility);
}

std::string GetDamagedMessage(const Game_Battler& target, int value) {
	bool target_is_ally = (target.GetType() == Game_Battler::Type_Ally);
	std::string_view message = target_is_ally
		? std::string_view(lcf::Data::terms.actor_damaged)
		: std::string_view(lcf::Data::terms.enemy_damaged);

	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
			message,
			Utils::MakeArray('S', 'V', 'U'),
			Utils::MakeSvArray(target.GetName(), std::to_string(value), lcf::Data::terms.health_points)
		);
	}
	std::stringstream ss;
	std::string particle, space = "";
	ss << target.GetName();

	if (Player::IsCP932()) {
		particle = (target_is_ally ? "は " : "に ");
		space += " ";
	} else {
		particle = " ";
	}
	ss << particle << value << space << message;
	return ss.str();
}

std::string GetParameterChangeMessage(const Game_Battler& target, int value, std::string_view points) {
	const bool is_positive = (value >= 0);
	value = std::abs(value);
	if (value == 0) {
		return "";
	}

	std::string_view message = is_positive
		? std::string_view(lcf::Data::terms.parameter_increase)
	   	: std::string_view(lcf::Data::terms.parameter_decrease);


	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
			message,
			Utils::MakeArray('S', 'V', 'U'),
			Utils::MakeSvArray(target.GetName(), std::to_string(value), points)
		);
	}
	std::stringstream ss;
	std::string particle, particle2, space = "";
	ss << target.GetName();

	if (Player::IsCP932()) {
		particle = "の";
		particle2 = "が ";
		space += " ";
	}
	else {
		particle = particle2 = " ";
	}
	ss << particle << points << particle2 << value << space;
	ss << message;

	return ss.str();
}

std::string GetSpReduceMessage(const Game_Battler& target, int value) {
	return GetParameterChangeMessage(target, -value, lcf::Data::terms.spirit_points);
}

std::string GetAtkChangeMessage(const Game_Battler& target, int value) {
	return GetParameterChangeMessage(target, value, lcf::Data::terms.attack);
}

std::string GetDefChangeMessage(const Game_Battler& target, int value) {
	return GetParameterChangeMessage(target, value, lcf::Data::terms.defense);
}

std::string GetSpiChangeMessage(const Game_Battler& target, int value) {
	return GetParameterChangeMessage(target, value, lcf::Data::terms.spirit);
}

std::string GetAgiChangeMessage(const Game_Battler& target, int value) {
	return GetParameterChangeMessage(target, value, lcf::Data::terms.agility);
}

std::string GetAttributeShiftMessage(const Game_Battler& target, int value, const lcf::rpg::Attribute& attribute) {
	const bool is_positive = (value >= 0);
	value = std::abs(value);
	if (value == 0) {
		return "";
	}
	std::string_view message = is_positive
		? std::string_view(lcf::Data::terms.resistance_increase)
		: std::string_view(lcf::Data::terms.resistance_decrease);
	std::stringstream ss;

	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
			message,
			Utils::MakeArray('S', 'O'),
			Utils::MakeSvArray(target.GetName(), attribute.name)
		);
	}
	std::string particle, space = "";
	ss << target.GetName();

	if (Player::IsCP932()) {
		particle = "は";
		space += " ";
	}
	else {
		particle = " ";
	}
	ss << particle << attribute.name << space;
	ss << message;

	return ss.str();
}

static std::string GetBasicStartMessage2k(const Game_Battler& source, std::string_view term) {
	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
			term,
			Utils::MakeArray('S'),
			Utils::MakeSvArray(source.GetName())
		);
	}
	return ToString(source.GetName()) + ToString(term);
}

std::string GetNormalAttackStartMessage2k(const Game_Battler& source) {
	return GetBasicStartMessage2k(source, lcf::Data::terms.attacking);
}

std::string GetDefendStartMessage2k(const Game_Battler& source) {
	return GetBasicStartMessage2k(source, lcf::Data::terms.defending);
}

std::string GetObserveStartMessage2k(const Game_Battler& source) {
	return GetBasicStartMessage2k(source, lcf::Data::terms.observing);
}

std::string GetChargeUpStartMessage2k(const Game_Battler& source) {
	return GetBasicStartMessage2k(source, lcf::Data::terms.focus);
}

std::string GetSelfDestructStartMessage2k(const Game_Battler& source) {
	return GetBasicStartMessage2k(source, lcf::Data::terms.autodestruction);
}

std::string GetEscapeStartMessage2k(const Game_Battler& source) {
	return GetBasicStartMessage2k(source, lcf::Data::terms.enemy_escape);
}

std::string GetTransformStartMessage(const Game_Battler& source, const lcf::rpg::Enemy& new_enemy) {
	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
			lcf::Data::terms.enemy_transform,
			Utils::MakeArray('S', 'O'),
			Utils::MakeSvArray(source.GetName(), new_enemy.name)
		);
	}
	return ToString(source.GetName()) + ToString(lcf::Data::terms.enemy_transform);
}

static std::string GetSkillStartMessageGeneric(const Game_Battler& source, const Game_Battler* target, const lcf::rpg::Skill& skill, std::string_view usage, bool second_message = false) {
	std::string_view target_name = "???";
	if (target && Algo::IsNormalOrSubskill(skill) && Algo::SkillTargetsOne(skill)) {
		target_name = target->GetName();
	}
	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
				usage,
				Utils::MakeArray('S', 'O', 'U'),
				Utils::MakeSvArray(source.GetName(), target_name, skill.name)
				);
	}
	if (second_message) {
		return ToString(usage);
	} else {
		return ToString(source.GetName()) + ToString(usage);
	}
}

std::string GetSkillFirstStartMessage2k(const Game_Battler& source, const Game_Battler* target, const lcf::rpg::Skill& skill) {
	return GetSkillStartMessageGeneric(source, target, skill, skill.using_message1);
}

std::string GetSkillSecondStartMessage2k(const Game_Battler& source, const Game_Battler* target, const lcf::rpg::Skill& skill) {
	return GetSkillStartMessageGeneric(source, target, skill, skill.using_message2, true);
}

std::string GetItemStartMessage2k(const Game_Battler& source, const lcf::rpg::Item& item) {
	if (item.easyrpg_using_message != lcf::rpg::Item::kDefaultMessage) {
		return Utils::ReplacePlaceholders(
			item.easyrpg_using_message,
			Utils::MakeArray('S', 'O'),
			Utils::MakeSvArray(source.GetName(), item.name)
		);
	}

	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
			lcf::Data::terms.use_item,
			Utils::MakeArray('S', 'O'),
			Utils::MakeSvArray(source.GetName(), item.name)
		);
	}
	std::string particle;
	if (Player::IsCP932())
		particle = "は";
	else
		particle = " ";
	return ToString(source.GetName()) + particle + ToString(item.name) + ToString(lcf::Data::terms.use_item);
}

std::string GetDoubleAttackStartMessage2k3(const Game_Battler& source) {
	if (lcf::Data::terms.easyrpg_battle2k3_double_attack == lcf::Data::terms.kDefaultTerm) {
		return "Double Attack";
	}
	return Utils::ReplacePlaceholders(
		lcf::Data::terms.easyrpg_battle2k3_double_attack,
		Utils::MakeArray('S'),
		Utils::MakeSvArray(source.GetName())
	);
}

std::string GetSkillStartMessage2k3(const Game_Battler& source, const Game_Battler* target, const lcf::rpg::Skill& skill) {
	std::string_view target_name = "???";
	if (target && Algo::IsNormalOrSubskill(skill) && Algo::SkillTargetsOne(skill)) {
		target_name = target->GetName();
	}
	if (skill.easyrpg_battle2k3_message == lcf::rpg::Skill::kDefaultMessage) {
		if (lcf::Data::terms.easyrpg_battle2k3_skill == lcf::Data::terms.kDefaultTerm) {
			return ToString(skill.name);
		}
		return Utils::ReplacePlaceholders(
			lcf::Data::terms.easyrpg_battle2k3_skill,
			Utils::MakeArray('S', 'O', 'U'),
			Utils::MakeSvArray(source.GetName(), target_name, skill.name)
		);
	}
	return Utils::ReplacePlaceholders(
		skill.easyrpg_battle2k3_message,
		Utils::MakeArray('S', 'O', 'U'),
		Utils::MakeSvArray(source.GetName(), target_name, skill.name)
	);
}

std::string GetItemStartMessage2k3(const Game_Battler& source, const lcf::rpg::Item& item) {
	if (item.easyrpg_using_message == lcf::rpg::Item::kDefaultMessage) {
		if (lcf::Data::terms.easyrpg_battle2k3_item == lcf::Data::terms.kDefaultTerm) {
			return ToString(item.name);
		}
		return Utils::ReplacePlaceholders(
			lcf::Data::terms.easyrpg_battle2k3_item,
			Utils::MakeArray('S', 'O'),
			Utils::MakeSvArray(source.GetName(), item.name)
		);
	}
	return Utils::ReplacePlaceholders(
		item.easyrpg_using_message,
		Utils::MakeArray('S', 'O'),
		Utils::MakeSvArray(source.GetName(), item.name)
	);
}

std::string GetObserveStartMessage2k3(const Game_Battler& source) {
	if (lcf::Data::terms.easyrpg_battle2k3_observe == lcf::Data::terms.kDefaultTerm) {
		return "Observe";
	}
	return Utils::ReplacePlaceholders(
		lcf::Data::terms.easyrpg_battle2k3_observe,
		Utils::MakeArray('S'),
		Utils::MakeSvArray(source.GetName())
	);
}

std::string GetDefendStartMessage2k3(const Game_Battler& source) {
	if (lcf::Data::terms.easyrpg_battle2k3_defend == lcf::Data::terms.kDefaultTerm) {
		return "Defend";
	}
	return Utils::ReplacePlaceholders(
		lcf::Data::terms.easyrpg_battle2k3_defend,
		Utils::MakeArray('S'),
		Utils::MakeSvArray(source.GetName())
	);
}

std::string GetChargeUpStartMessage2k3(const Game_Battler& source) {
	if (lcf::Data::terms.easyrpg_battle2k3_charge == lcf::Data::terms.kDefaultTerm) {
		return "Charge Up";
	}
	return Utils::ReplacePlaceholders(
		lcf::Data::terms.easyrpg_battle2k3_charge,
		Utils::MakeArray('S'),
		Utils::MakeSvArray(source.GetName())
	);
}

std::string GetSelfDestructStartMessage2k3(const Game_Battler& source) {
	if (lcf::Data::terms.easyrpg_battle2k3_selfdestruct == lcf::Data::terms.kDefaultTerm) {
		return "Self-Destruct";
	}
	return Utils::ReplacePlaceholders(
		lcf::Data::terms.easyrpg_battle2k3_selfdestruct,
		Utils::MakeArray('S'),
		Utils::MakeSvArray(source.GetName())
	);
}

std::string GetEscapeStartMessage2k3(const Game_Battler& source) {
	if (lcf::Data::terms.easyrpg_battle2k3_escape == lcf::Data::terms.kDefaultTerm) {
		return "Escape";
	}
	return Utils::ReplacePlaceholders(
		lcf::Data::terms.easyrpg_battle2k3_escape,
		Utils::MakeArray('S'),
		Utils::MakeSvArray(source.GetName())
	);
}

} // namespace BattleMessage

namespace PartyMessage {

std::string GetExperienceGainedMessage(int exp) {
	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
			lcf::Data::terms.exp_received,
			Utils::MakeArray('V', 'U'),
			Utils::MakeSvArray(std::to_string(exp), lcf::Data::terms.exp_short)
		);
	}
	std::string space = Player::IsRPG2k3E() ? " " : "";
	std::stringstream ss;
	if (Player::IsPatchManiac() && !lcf::Data::terms.maniac_exp_received_a.empty()) {
		ss << lcf::Data::terms.maniac_exp_received_a << " ";
	}
	ss << exp << space << lcf::Data::terms.exp_received;
	return ss.str();
}

std::string GetGoldReceivedMessage(int money) {
	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
			lcf::Data::terms.gold_recieved_a,
			Utils::MakeArray('V', 'U'),
			Utils::MakeSvArray(std::to_string(money), lcf::Data::terms.gold)
		);
	}
	std::stringstream ss;
	ss << lcf::Data::terms.gold_recieved_a << " " << money << lcf::Data::terms.gold << lcf::Data::terms.gold_recieved_b;
	return ss.str();
}

std::string GetItemReceivedMessage(const lcf::rpg::Item* item) {
	// No Output::Warning needed here, reported later when the item is added
	std::string_view item_name = item ? std::string_view(item->name) : std::string_view("??? BAD ITEM ???");

	if (Feature::HasPlaceholders()) {
		return Utils::ReplacePlaceholders(
			lcf::Data::terms.item_recieved,
			Utils::MakeArray('S'),
			Utils::MakeSvArray(item_name)
		);
	}
	std::string space = Player::IsRPG2k3E() ? " " : "";
	std::stringstream ss;
	if (Player::IsPatchManiac() && !lcf::Data::terms.maniac_item_received_a.empty()) {
		ss << lcf::Data::terms.maniac_item_received_a << " ";
	}
	ss << item_name << space << lcf::Data::terms.item_recieved;
	return ss.str();
}

} // namespace PartyMessage


/*end of file .\game_message_terms.cpp*/

/*start of file .\game_party.cpp*/

/* ... license chunk ... */

// Headers
#include <algorithm>
#include <array>
#include <cassert>
#include <cmath>
#include "system.h"
#include "game_party.h"
#include "game_actors.h"
#include "game_map.h"
#include "game_player.h"
#include "game_battle.h"
#include "game_targets.h"
#include "game_system.h"
#include "scene_battle.h"
#include <lcf/reader_util.h>
#include "output.h"
#include "algo.h"

Game_Party::Game_Party() {
}

void Game_Party::SetupNewGame() {
	Clear();

	data.party = lcf::Data::system.party;
	RemoveInvalidData();
}

void Game_Party::SetupFromSave(lcf::rpg::SaveInventory save) {
	data = std::move(save);
	RemoveInvalidData();

	// Old versions of player didn't sort the inventory, this ensures inventory is sorted
	// as our Game_Party code relies on that. Items in RPG_RT are always sorted in the inventory.
	if (!std::is_sorted(data.item_ids.begin(), data.item_ids.end())) {
		Output::Debug("Loaded Save Game with unsorted inventory! Sorting ...");
		// Resort the inventory.
		struct ItemData { int id; int count; int usage; };

		auto& ids = data.item_ids;
		auto& counts = data.item_counts;
		auto& usages = data.item_usage;

		auto num_items = std::min(ids.size(), std::min(counts.size(), usages.size()));
		std::vector<ItemData> items;
		for (size_t i = 0; i < num_items; ++i) {
			items.push_back(ItemData{ids[i], counts[i], usages[i]});
		}

		std::sort(items.begin(), items.end(), [](const ItemData& l, const ItemData& r) { return l.id < r.id; });

		ids.clear();
		counts.clear();
		usages.clear();

		for (auto& itd: items) {
			ids.push_back(itd.id);
			counts.push_back(itd.count);
			usages.push_back(itd.usage);
		}
	}
}

Game_Actor& Game_Party::operator[] (const int index) {
	std::vector<Game_Actor*> actors = GetActors();

	if (index < 0 || (size_t)index >= actors.size()) {
		assert(false && "Subscript out of range");
	}

	return *actors[index];
}

int Game_Party::GetBattlerCount() const {
	return (int)GetActors().size();
}

int Game_Party::GetVisibleBattlerCount() const {
	int visible = 0;
	for (const auto& actor: GetActors()) {
		visible += !actor->IsHidden();
	}
	return visible;
}

void Game_Party::SetupBattleTest() {
	Clear();

	for (auto& btdata : lcf::Data::system.battletest_data) {
		AddActor(btdata.actor_id);
		Game_Actor* actor = Main_Data::game_actors->GetActor(btdata.actor_id);

		// Filter garbage btdata inserted by the editor
		// The upper 16 bit look like uninitialized data
		std::array<int, 5> ids = {{
			btdata.weapon_id & 0xFFFF,
			btdata.shield_id & 0xFFFF,
			btdata.armor_id & 0xFFFF,
			btdata.helmet_id & 0xFFFF,
			btdata.accessory_id & 0xFFFF }};
		std::replace_if(ids.begin(), ids.end(), [] (const int& item_id) {
			return lcf::ReaderUtil::GetElement(lcf::Data::items, item_id) == nullptr;
		}, 0);

		actor->SetEquipment(lcf::rpg::Item::Type_weapon, ids[0]);
		actor->SetEquipment(lcf::rpg::Item::Type_shield, ids[1]);
		actor->SetEquipment(lcf::rpg::Item::Type_armor, ids[2]);
		actor->SetEquipment(lcf::rpg::Item::Type_helmet, ids[3]);
		actor->SetEquipment(lcf::rpg::Item::Type_accessory, ids[4]);
		actor->ChangeLevel(btdata.level, nullptr);
		actor->SetHp(actor->GetMaxHp());
		actor->SetSp(actor->GetMaxSp());
	}
}

void Game_Party::GetItems(std::vector<int>& item_list) {
	item_list.clear();

	std::vector<int16_t>::iterator it;
	for (it = data.item_ids.begin(); it != data.item_ids.end(); ++it)
		item_list.push_back(*it);
}

int Game_Party::GetItemCount(int item_id) const {
	auto ip = GetItemIndex(item_id);
	return ip.second ? data.item_counts[ip.first] : 0;
}

int Game_Party::GetEquippedItemCount(int item_id) const {
	int number = 0;
	if (item_id >= 0) {
		for (int i = 0; i < (int) data.party.size(); i++) {
			Game_Actor* actor = Main_Data::game_actors->GetActor(data.party[i]);
			number += actor->GetItemCount(item_id);
		}
	}
	return number;
}

int Game_Party::GetItemTotalCount(int item_id) const {
	return GetItemCount(item_id) + GetEquippedItemCount(item_id);
}

int Game_Party::GetMaxItemCount(int item_id) const {
	const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
	if (!item || item->easyrpg_max_count == -1) {
		return (lcf::Data::system.easyrpg_max_item_count == -1 ? 99 : lcf::Data::system.easyrpg_max_item_count);
	} else {
		return item->easyrpg_max_count;
	}
}

void Game_Party::GainGold(int n) {
	data.gold = data.gold + n;
	data.gold = std::min<int32_t>(std::max<int32_t>(data.gold, 0), 999999);
}

void Game_Party::LoseGold(int n) {
	data.gold = data.gold - n;
	data.gold = std::min<int32_t>(std::max<int32_t>(data.gold, 0), 999999);
}

void Game_Party::AddItem(int item_id, int amount) {
	if (item_id < 1 || item_id > (int) lcf::Data::items.size()) {
		Output::Debug("Can't add item to party. {} is not a valid item ID.", item_id);
		return;
	}

	int item_limit = GetMaxItemCount(item_id);

	auto ip = GetItemIndex(item_id);
	auto idx = ip.first;
	auto has = ip.second;
	if (!has) {
		if (amount > 0) {
			amount = std::min(amount, item_limit);
			data.item_ids.insert(data.item_ids.begin() + idx, (int16_t)item_id);
			data.item_counts.insert(data.item_counts.begin() + idx, (uint8_t)amount);
			data.item_usage.insert(data.item_usage.begin() + idx, 0);
		}
		return;
	}

	int total_items = data.item_counts[idx] + amount;

	if (total_items <= 0) {
		data.item_ids.erase(data.item_ids.begin() + idx);
		data.item_counts.erase(data.item_counts.begin() + idx);
		data.item_usage.erase(data.item_usage.begin() + idx);
		return;
	}

	data.item_counts[idx] = (uint8_t)std::min(total_items, item_limit);
	// If the item was removed, the number of uses resets.
	// (Adding an item never changes the number of uses, even when
	// you already have x99 of them.)
	if (amount < 0) {
		data.item_usage[idx] = 0;
	}
}

void Game_Party::RemoveItem(int item_id, int amount) {
	AddItem(item_id, -amount);
}

void Game_Party::ConsumeItemUse(int item_id) {
	const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);

	if (!item) {
		Output::Warning("ConsumeItemUse: Invalid item ID {}.", item_id);
		return;
	}

	switch (item->type) {
		case lcf::rpg::Item::Type_normal:
		case lcf::rpg::Item::Type_weapon:
		case lcf::rpg::Item::Type_shield:
		case lcf::rpg::Item::Type_armor:
		case lcf::rpg::Item::Type_helmet:
		case lcf::rpg::Item::Type_accessory:
			return;
	}

	if (item->uses == 0) {
		// Unlimited uses
		return;
	}

	auto ip = GetItemIndex(item_id);
	auto idx = ip.first;
	auto has = ip.second;

	if (!has) {
		return;
	}

	data.item_usage[idx]++;

	if (data.item_usage[idx] >= item->uses) {
		if (data.item_counts[idx] == 1) {
			// We just used up the last one
			data.item_ids.erase(data.item_ids.begin() + idx);
			data.item_counts.erase(data.item_counts.begin() + idx);
			data.item_usage.erase(data.item_usage.begin() + idx);
		} else {
			data.item_counts[idx]--;
			data.item_usage[idx] = 0;
		}
	}
}

bool Game_Party::IsItemUsable(int item_id, const Game_Actor* target) const {
	if (target && !target->IsItemUsable(item_id)) {
		return false;
	}

	const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
	if (!item) {
		Output::Warning("IsItemUsable: Invalid item ID {}", item_id);
		return false;
	}

	const auto* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, item->skill_id);
	const bool in_battle = Game_Battle::IsBattleRunning();

	if (item->use_skill) {
		// RPG_RT BUG: Does not check if skill is usable.
		return skill &&
			(in_battle
			 || skill->scope == lcf::rpg::Skill::Scope_self
			 || skill->scope == lcf::rpg::Skill::Scope_ally
			 || skill->scope == lcf::rpg::Skill::Scope_party);
	}

	switch (item->type) {
		case lcf::rpg::Item::Type_medicine:
			return !in_battle || !item->occasion_field1;
		case lcf::rpg::Item::Type_material:
		case lcf::rpg::Item::Type_book:
			return !in_battle;
		case lcf::rpg::Item::Type_switch:
			return in_battle ? item->occasion_battle : item->occasion_field2;
		case lcf::rpg::Item::Type_special:
			if (skill && Algo::IsSkillUsable(*skill, false)) {
				// RPG_RT requires one actor in the party and alive who can use the item.
				// But only if the item invokes a normal or subskill. This check is
				// not performed for escape, teleport, or switch skills!
				if (!Algo::IsNormalOrSubskill(*skill)) {
					return true;
				} else {
					for (auto* actor: GetActors()) {
						if (actor->CanAct() && actor->IsItemUsable(item_id)) {
							return true;
						}
					}
				}
			}
			return false;
		default:
			break;
	}

	return false;
}

bool Game_Party::UseItem(int item_id, Game_Actor* target) {
	bool was_used = false;

	auto* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
	if (!item) {
		Output::Warning("UseItem: Can't use item with invalid ID {}", item_id);
		return false;
	}

	bool do_skill = (item->type == lcf::rpg::Item::Type_special)
		|| (item->use_skill && (
				item->type == lcf::rpg::Item::Type_weapon
				|| item->type == lcf::rpg::Item::Type_shield
				|| item->type == lcf::rpg::Item::Type_armor
				|| item->type == lcf::rpg::Item::Type_helmet
				|| item->type == lcf::rpg::Item::Type_accessory
				)
				);

	const lcf::rpg::Skill* skill = nullptr;
	if (do_skill) {
		skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, item->skill_id);
		if (skill == nullptr) {
			Output::Warning("UseItem: Can't use item {} skill with invalid ID {}", item->ID, item->skill_id);
			return false;
		}
	}

	const Game_Actor* fixed_source = nullptr;
	if (skill && skill->scope != lcf::rpg::Skill::Scope_self) {
		fixed_source = GetHighestLeveledActorWhoCanUse(item);
		if (fixed_source == nullptr) {
			return false;
		}
	}

	if (target) {
		const auto* source = fixed_source ? fixed_source : target;
		if (IsItemUsable(item_id, source)) {
			was_used = target->UseItem(item_id, source);
		}
	} else {
		for (auto* actor: GetActors()) {
			const auto* source = fixed_source ? fixed_source : actor;
			if (IsItemUsable(item_id, source)) {
				was_used |= actor->UseItem(item_id, source);
			}
		}
	}

	if (was_used) {
		ConsumeItemUse(item_id);
	}

	return was_used;
}

bool Game_Party::IsSkillUsable(int skill_id, const Game_Actor* target, bool from_item) const {
	if (skill_id <= 0 || skill_id > (int)lcf::Data::skills.size()) {
		return false;
	}

	if (target && !target->IsSkillUsable(skill_id)) {
		return false;
	}

	const lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, skill_id);
	if (!skill) {
		Output::Warning("IsSkillUsable: Can't use skill with invalid ID {}", skill_id);
		return false;
	}

	if (skill->type == lcf::rpg::Skill::Type_escape) {
		return !Game_Battle::IsBattleRunning() && Main_Data::game_system->GetAllowEscape() && Main_Data::game_targets->HasEscapeTarget() && !Main_Data::game_player->IsFlying();
	} else if (skill->type == lcf::rpg::Skill::Type_teleport) {
		return !Game_Battle::IsBattleRunning() && Main_Data::game_system->GetAllowTeleport() && Main_Data::game_targets->HasTeleportTargets() && !Main_Data::game_player->IsFlying();
	} else if (Algo::IsNormalOrSubskill(*skill)) {
		int scope = skill->scope;

		if (Game_Battle::IsBattleRunning()) {
			return true;
		}

		// Self targeting skills can not cure states only (except if called by an item).
		// RPG_RT logic...

		if (scope == lcf::rpg::Skill::Scope_self) {
			return from_item || skill->affect_hp || skill->affect_sp;
		}

		if (scope == lcf::rpg::Skill::Scope_ally ||
			scope == lcf::rpg::Skill::Scope_party) {

			if (from_item || skill->affect_hp || skill->affect_sp) {
				return true;
			}
			for (size_t i = 0; i < skill->state_effects.size(); ++i) {
				auto& state = lcf::Data::states[i];
				if (skill->state_effects[i] && state.type == lcf::rpg::State::Persistence_persists) {
					return true;
				}
			}
			return false;
		}
	} else if (skill->type == lcf::rpg::Skill::Type_switch) {
		if (Game_Battle::IsBattleRunning()) {
			return skill->occasion_battle;
		}

		return skill->occasion_field;
	}

	return false;
}

bool Game_Party::UseSkill(int skill_id, Game_Actor* source, Game_Actor* target) {
	bool was_used = false;

	if (target) {
		was_used = target->UseSkill(skill_id, source);
	}
	else {
		std::vector<Game_Actor*> actors = GetActors();
		std::vector<Game_Actor*>::iterator it;
		for (it = actors.begin(); it != actors.end(); ++it) {
			was_used |= (*it)->UseSkill(skill_id, source);
		}
	}

	if (was_used) {
		source->SetSp(source->GetSp() - source->CalculateSkillCost(skill_id));
		source->SetHp(source->GetHp() - source->CalculateSkillHpCost(skill_id));
	}

	return was_used;
}

void Game_Party::AddActor(int actor_id) {
	auto* actor = Main_Data::game_actors->GetActor(actor_id);
	if (!actor) {
		return;
	}

	if (IsActorInParty(actor_id))
		return;
	if (data.party.size() >= 4)
		return;
	data.party.push_back((int16_t)actor_id);
	Main_Data::game_player->ResetGraphic();

	auto scene = Scene::Find(Scene::Battle);
	if (scene) {
		scene->OnPartyChanged(actor, true);
	}
}

void Game_Party::RemoveActor(int actor_id) {
	if (!IsActorInParty(actor_id))
		return;
	data.party.erase(std::find(data.party.begin(), data.party.end(), actor_id));
	Main_Data::game_player->ResetGraphic();

	auto* actor = Main_Data::game_actors->GetActor(actor_id);
	if (!actor) {
		return;
	}

	auto scene = Scene::Find(Scene::Battle);
	if (scene) {
		scene->OnPartyChanged(actor, false);
	}
}

void Game_Party::Clear() {
	data.party.clear();
}

bool Game_Party::IsActorInParty(int actor_id) {
	return std::find(data.party.begin(), data.party.end(), actor_id) != data.party.end();
}

int Game_Party::GetActorPositionInParty(int actor_id) {
	std::vector<short>::iterator it = std::find(data.party.begin(), data.party.end(), actor_id);

	return it != data.party.end() ? std::distance(data.party.begin(), it) : -1;
}

std::vector<Game_Actor*> Game_Party::GetActors() const {
	std::vector<Game_Actor*> actors;
	std::vector<int16_t>::const_iterator it;
	for (it = data.party.begin(); it != data.party.end(); ++it)
		actors.push_back(Main_Data::game_actors->GetActor(*it));
	return actors;
}

Game_Actor* Game_Party::GetActor(int idx) const {
	if (idx >= 0 && idx < static_cast<int>(data.party.size())) {
		return Main_Data::game_actors->GetActor(data.party[idx]);
	}
	return nullptr;
}

void Game_Party::ApplyDamage(int damage, bool lethal) {
	if (damage <= 0) {
		return;
	}

	for (auto* actor: GetActors()) {
		actor->ChangeHp(-damage, lethal);
	}
}

void Game_Party::SetTimer(int which, int seconds) {
	switch (which) {
		case Timer1:
			data.timer1_frames = seconds * DEFAULT_FPS + (DEFAULT_FPS - 1);
			Game_Map::SetNeedRefresh(true);
			break;
		case Timer2:
			data.timer2_frames = seconds * DEFAULT_FPS + (DEFAULT_FPS -1);
			Game_Map::SetNeedRefresh(true);
			break;
	}
}

void Game_Party::StartTimer(int which, bool visible, bool battle) {
	switch (which) {
		case Timer1:
			data.timer1_active = true;
			data.timer1_visible = visible;
			data.timer1_battle = battle;
			break;
		case Timer2:
			data.timer2_active = true;
			data.timer2_visible = visible;
			data.timer2_battle = battle;
			break;
	}
}

void Game_Party::StopTimer(int which) {
	switch (which) {
		case Timer1:
			data.timer1_active = false;
			data.timer1_visible = false;
			break;
		case Timer2:
			data.timer2_active = false;
			data.timer2_visible = false;
			break;
	}
}

void Game_Party::UpdateTimers() {
	const bool battle = Game_Battle::IsBattleRunning();
	bool seconds_changed = false;

	if (data.timer1_active && (data.timer1_battle || !battle) && data.timer1_frames > 0) {
		data.timer1_frames = data.timer1_frames - 1;

		const int seconds = data.timer1_frames / DEFAULT_FPS;
		const int mod_frames = data.timer1_frames % DEFAULT_FPS;
		seconds_changed |= (mod_frames == (DEFAULT_FPS - 1));

		if (seconds == 0) {
			StopTimer(Timer1);
		}
	}

	if (data.timer2_active && (data.timer2_battle || !battle) && data.timer2_frames > 0) {
		data.timer2_frames = data.timer2_frames - 1;

		const int seconds = data.timer2_frames / DEFAULT_FPS;
		const int mod_frames = data.timer2_frames % DEFAULT_FPS;
		seconds_changed |= (mod_frames == (DEFAULT_FPS - 1));

		if (seconds == 0) {
			StopTimer(Timer2);
		}
	}

	if (seconds_changed) {
		Game_Map::SetNeedRefresh(true);
	}
}

int Game_Party::GetTimerSeconds(int which) {
	return GetTimerFrames(which) / DEFAULT_FPS;
}

int Game_Party::GetTimerFrames(int which) {
	switch (which) {
		case Timer1:
			return data.timer1_frames;
		case Timer2:
			return data.timer2_frames;
		default:
			return 0;
	}
}

bool Game_Party::GetTimerVisible(int which, bool in_battle) {
	bool visible = false;
	bool battle = false;
	switch (which) {
		case Timer1:
			visible = data.timer1_visible;
			battle = data.timer1_battle;
			break;
		case Timer2:
			visible = data.timer2_visible;
			battle = data.timer2_battle;
			break;
	}
	return visible && (!in_battle || battle);
}

int Game_Party::GetAverageLevel() {
	int party_lvl = 0;

	std::vector<Game_Actor*> actors = GetActors();
	std::vector<Game_Actor*>::iterator it;

	if (actors.empty()) {
		return 0;
	}

	for (it = actors.begin(); it != actors.end(); ++it) {
		party_lvl += (*it)->GetLevel();
	}

	return party_lvl / (int)actors.size();
}

int Game_Party::GetFatigue() {
	const auto& actors = GetActors();

	if (actors.empty()) {
		return 0;
	}

	int hp = 0;
	int total_hp = 0;
	int sp = 0;
	int total_sp = 0;
	for (auto* a : actors) {
		hp += a->GetHp();
		total_hp += a->GetMaxHp();
		sp += a->GetSp();
		total_sp += a->GetMaxSp();
	}

	// SP is always 33.3% of fatigue, which means a 0 SP actor is never above 66%
	if (total_sp == 0) {
		total_sp = 1;
	}

	auto p = Utils::RoundTo<int>(100.0f * ((static_cast<double>(hp) / total_hp * 2.0 + static_cast<double>(sp) / total_sp) / 3.0f));
	return 100 - p;
}

void Game_Party::RemoveInvalidData() {
	// Remove non existing actors
	std::vector<int16_t> temp_party;
	std::swap(temp_party, data.party);
	std::vector<int16_t>::iterator it;
	for (it = temp_party.begin(); it != temp_party.end(); ++it) {
		if (Main_Data::game_actors->ActorExists(*it)) {
			data.party.push_back(*it);
		} else {
			Output::Debug("Removing invalid party member {}", *it);
		}
	}

	// Remove non existing items
	for (it = data.item_ids.begin(); it != data.item_ids.end(); ) {
		if (!lcf::ReaderUtil::GetElement(lcf::Data::items, *it)) {
			Output::Debug("Removing invalid item {} from party", *it);
			it = data.item_ids.erase(it);
		} else {
			++it;
		}
	}
}

std::vector<int16_t> Game_Party::GetInflictedStates() const {
	std::vector<int16_t> states;

	for (auto actor : GetActors()) {
		std::vector<int16_t> actor_states = actor->GetInflictedStates();
		states.insert(states.end(), actor_states.begin(), actor_states.end());
	}

	if (!states.empty()) {
		std::sort(states.begin(), states.end());
		states.erase(std::unique(states.begin(), states.end()), states.end());
	}
	return states;
}

bool Game_Party::ApplyStateDamage() {
	bool damage = false;
	std::vector<int16_t> states = GetInflictedStates();

	const auto steps = GetSteps();

	for (auto state_id : states) {
		lcf::rpg::State *state = lcf::ReaderUtil::GetElement(lcf::Data::states, state_id);

		if (state->hp_change_map_steps > 0
				&& state->hp_change_map_val > 0
				&& ((steps % state->hp_change_map_steps) == 0)
				) {
			for (auto actor : GetActors()) {
				if (actor->HasState(state_id)) {
					if (state->hp_change_type == lcf::rpg::State::ChangeType_lose) {
						actor->ChangeHp(-state->hp_change_map_val, false);
						damage = true;
					}
					else if (state->hp_change_type == lcf::rpg::State::ChangeType_gain) {
						actor->ChangeHp(state->hp_change_map_val, false);
					}
				}
			}
		}

		if (state->sp_change_map_steps > 0
				&& state->sp_change_map_val > 0
				&& ((steps % state->sp_change_map_steps) == 0)
		   ){
			for (auto actor : GetActors()) {
				if (actor->HasState(state_id)) {
					if (state->sp_change_type == lcf::rpg::State::ChangeType_lose) {
						actor->ChangeSp(-state->sp_change_map_val);
						damage = true;
					}
					else if (state->sp_change_type == lcf::rpg::State::ChangeType_gain) {
						actor->ChangeSp(state->sp_change_map_val);
					}
				}
			}
		}
	}

	return damage;
}

bool Game_Party::IsAnyControllable() {
	for (auto& actor: GetActors()) {
		if (actor->IsControllable()) {
			return true;
		}
	}
	return false;
}

Game_Actor* Game_Party::GetHighestLeveledActorWhoCanUse(const lcf::rpg::Item* item) const {
	Game_Actor* best = nullptr;

	for (auto* actor : GetActors()) {
		if (actor->CanAct()
				&& actor->IsItemUsable(item->ID)
				&& (best == nullptr || best->GetLevel() < actor->GetLevel())) {
			best = actor;
		}
	}
	return best;
}

std::pair<int,bool> Game_Party::GetItemIndex(int item_id) const {
	auto& ids = data.item_ids;
	auto iter = std::lower_bound(ids.begin(), ids.end(), item_id);
	return std::make_pair<int,bool>(iter - ids.begin(), (iter != ids.end() && *iter == item_id));
}


/*end of file .\game_party.cpp*/

/*start of file .\game_party_base.cpp*/

/* ... license chunk ... */

#include <algorithm>
#include <list>
#include "game_party_base.h"
#include "utils.h"
#include "rand.h"

Game_Party_Base::~Game_Party_Base() {
}

void Game_Party_Base::GetBattlers(std::vector<Game_Battler*>& out) {
	int count = GetBattlerCount();
	for (int i = 0; i < count; ++i) {
		Game_Battler* battler = &(*this)[i];
		out.push_back(battler);
	}
}

void Game_Party_Base::GetActiveBattlers(std::vector<Game_Battler*>& out) {
	int count = GetBattlerCount();
	for (int i = 0; i < count; ++i) {
		Game_Battler* battler = &(*this)[i];
		if (battler->Exists()) {
			out.push_back(battler);
		}
	}
}

void Game_Party_Base::GetDeadBattlers(std::vector<Game_Battler*>& out) {
	int count = GetBattlerCount();
	for (int i = 0; i < count; ++i) {
		Game_Battler* battler = &(*this)[i];
		if (battler->IsDead()) {
			out.push_back(battler);
		}
	}
}

Game_Battler* Game_Party_Base::GetNextActiveBattler(Game_Battler* battler) {
	std::vector<Game_Battler*> battlers;
	GetBattlers(battlers);

	std::vector<Game_Battler*>::const_iterator it;
	it = std::find(battlers.begin(), battlers.end(), battler);

	if (it == battlers.end()) {
		return NULL;
	}

	for (++it; it != battlers.end(); ++it) {
		Game_Battler* b = *it;
		if (b->Exists()) {
			return b;
		}
	}

	// None found after battler, try from the beginning now
	for (it = battlers.begin(); *it != battler; ++it) {
		Game_Battler* b = *it;
		if (b->Exists()) {
			return b;
		}
	}

	return NULL;
}

Game_Battler* Game_Party_Base::GetRandomActiveBattler() {
	std::vector<Game_Battler*> battlers;
	GetActiveBattlers(battlers);
	if (battlers.empty()) {
		return NULL;
	}
	return battlers[Rand::GetRandomNumber(0, battlers.size() - 1)];
}

Game_Battler* Game_Party_Base::GetRandomDeadBattler() {
	std::vector<Game_Battler*> battlers;
	GetDeadBattlers(battlers);
	if (battlers.empty()) {
		return NULL;
	}

	return battlers[Rand::GetRandomNumber(0, battlers.size() - 1)];
}

bool Game_Party_Base::IsAnyActive() {
	return GetRandomActiveBattler() != NULL;
}

int Game_Party_Base::GetAverageAgility() {
	std::vector<Game_Battler*> battlers;
	int agi = 0;

	GetBattlers(battlers);

	std::vector<Game_Battler*>::const_iterator it;

	for (it = battlers.begin(); it != battlers.end(); ++it) {
		agi += (*it)->GetAgi();
	}

	return battlers.empty() ? 1 : agi /= battlers.size();
}

int Game_Party_Base::GetMemberIndex(Game_Battler* battler) {
	std::vector<Game_Battler*> battlers;
	GetBattlers(battlers);

	auto iterator = std::find(battlers.begin(), battlers.end(), battler);

	if (iterator != battlers.end()) {
		int index = std::distance(battlers.begin(), iterator);
		return index;
	}
	else {
		return -1;
	}
}



/*end of file .\game_party_base.cpp*/

/*start of file .\game_pictures.cpp*/

/* ... license chunk ... */

#include <cmath>
#include "bitmap.h"
#include "options.h"
#include "cache.h"
#include "output.h"
#include "game_map.h"
#include "game_pictures.h"
#include "game_screen.h"
#include "game_windows.h"
#include "player.h"
#include "main_data.h"
#include "scene.h"
#include "drawable_mgr.h"
#include "sprite_picture.h"

static bool IsEmpty(const lcf::rpg::SavePicture& data, int frames) {
	lcf::rpg::SavePicture empty;
	empty.ID = data.ID;
	empty.frames = frames;

	return data == empty;
}

static bool IsEmpty(const lcf::rpg::SavePicture& data) {
	return IsEmpty(data, data.frames);
}

template <bool do_effect>
void SyncCurrentToFinish(lcf::rpg::SavePicture& data) {
	data.current_x = data.finish_x;
	data.current_y = data.finish_y;
	data.current_red = data.finish_red;
	data.current_green = data.finish_green;
	data.current_blue = data.finish_blue;
	data.current_sat = data.finish_sat;
	data.current_magnify = data.finish_magnify;
	data.maniac_current_magnify_height = data.maniac_finish_magnify_height;
	data.current_top_trans = data.finish_top_trans;
	data.current_bot_trans = data.finish_bot_trans;
	if (do_effect) {
		data.current_effect_power = data.finish_effect_power;
	}
}

Game_Pictures::Picture::Picture(lcf::rpg::SavePicture save)
	: data(std::move(save))
{
	// FIXME: Make this more accurate by checking all animating chunks values to see if they all will remain stable.
	// Write unit tests to ensure it's correct.
	// Then add it to ErasePicture()
	needs_update = !IsEmpty(data);
}

void Game_Pictures::InitGraphics() {
	for (auto& pic: pictures) {
		RequestPictureSprite(pic);
	}
}

void Game_Pictures::SetSaveData(std::vector<lcf::rpg::SavePicture> save)
{
	pictures.clear();

	frame_counter = save.empty() ? 0 : save.back().frames;

	// Don't create pictures for empty save picture data at the end of the vector.
	int num_pictures = static_cast<int>(save.size());
	while (num_pictures > 0) {
		if (!IsEmpty(save[num_pictures - 1], frame_counter)) {
			break;
		}
		--num_pictures;
	}

	pictures.reserve(num_pictures);
	for (int i = 0; i < num_pictures; ++i) {
		pictures.emplace_back(std::move(save[i]));
	}
}

std::vector<lcf::rpg::SavePicture> Game_Pictures::GetSaveData() const {
	std::vector<lcf::rpg::SavePicture> save;

	auto data_size = std::max(static_cast<int>(pictures.size()), GetDefaultNumberOfPictures());
	save.reserve(data_size);

	for (auto& pic: pictures) {
		save.push_back(pic.data);
	}

	// RPG_RT Save game data always has a constant number of pictures
	// depending on the engine version. We replicate this, unless we have even
	// more pictures than that.
	while (data_size > static_cast<int>(save.size())) {
		lcf::rpg::SavePicture data;
		data.ID = static_cast<int>(save.size()) + 1;
		if (Player::IsRPG2k3E()) {
			data.frames = frame_counter;
		}
		if (!Player::IsPatchManiac()) {
			// Default the values so they are not stored in the savegame
			data.maniac_current_magnify_height = 100;
			data.maniac_finish_magnify_height = 100;
		}
		save.push_back(std::move(data));
	}

	return save;
}

int Game_Pictures::GetDefaultNumberOfPictures() {
	if (Player::IsEnglish()) {
		return 1000;
	}
	else if (Player::IsMajorUpdatedVersion()) {
		if (Player::IsPatchDynRpg() && Player::IsRPG2k3()) {
			// DynRPG only exists for RPG Maker 2003 1.08
			return 2000;
		}
		return 50;
	}
	else if (Player::IsRPG2k3Legacy()) {
		return 40;
	}
	else if (Player::IsRPG2kLegacy()) {
		return 20;
	}
	return 0;
}

Game_Pictures::Picture& Game_Pictures::GetPicture(int id) {
	if (EP_UNLIKELY(id > static_cast<int>(pictures.size()))) {
		pictures.reserve(id);
		while (static_cast<int>(pictures.size()) < id) {
			pictures.emplace_back(static_cast<int>(pictures.size()) + 1);
		}
	}
	return pictures[id - 1];
}

Game_Pictures::Picture* Game_Pictures::GetPicturePtr(int id) {
	return id <= static_cast<int>(pictures.size())
		? &pictures[id - 1] : nullptr;
}

void Game_Pictures::OnMapChange() {
	for (auto& pic: pictures) {
		if (pic.data.flags.erase_on_map_change) {
			pic.Erase();
		}
	}
}

void Game_Pictures::OnBattleEnd() {
	for (auto& pic: pictures) {
		if (pic.data.flags.erase_on_battle_end) {
			pic.Erase();
		}
	}
}

bool Game_Pictures::Picture::Show(const ShowParams& params) {
	needs_update = true;

	data.name = params.name;
	data.use_transparent_color = params.use_transparent_color;
	data.fixed_to_map = params.fixed_to_map;
	SetNonEffectParams(params, true);

	data.effect_mode = params.effect_mode;
	if (data.effect_mode == lcf::rpg::SavePicture::Effect_none) {
		// params.effect_power seems to contain garbage here
		data.finish_effect_power = 0.0;
	} else {
		data.finish_effect_power = params.effect_power;
	}

	SyncCurrentToFinish<true>(data);
	data.start_x = data.current_x;
	data.start_y = data.current_y;
	if (data.effect_mode == lcf::rpg::SavePicture::Effect_maniac_fixed_angle) {
		data.current_rotation = data.finish_effect_power;
	} else {
		data.current_rotation = 0.0;
	}
	data.current_waver = 0;
	data.time_left = 0;

	// RPG Maker 2k3 1.12
	data.frames = 0;
	data.spritesheet_rows = params.spritesheet_rows;
	data.spritesheet_cols = params.spritesheet_cols;
	data.spritesheet_play_once = params.spritesheet_play_once;
	data.spritesheet_frame = params.spritesheet_frame;
	data.spritesheet_speed = params.spritesheet_speed;
	data.map_layer = params.map_layer;
	data.battle_layer = params.battle_layer;

	if (data.map_layer == 0 && data.battle_layer == 0) {
		data.map_layer = 7;
	}

	data.flags.erase_on_map_change = (params.flags & 1) == 1;
	data.flags.erase_on_battle_end = (params.flags & 2) == 2;
	data.flags.affected_by_tint = (params.flags & 16) == 16;
	data.flags.affected_by_flash = (params.flags & 32) == 32;
	data.flags.affected_by_shake = (params.flags & 64) == 64;

	const auto num_frames = NumSpriteSheetFrames();

	bool result = true;

	// If an invalid frame is specified and no animation, skip loading picture data.
	if (num_frames > 0
			&& data.spritesheet_speed == 0
			&& (data.spritesheet_frame < 0 || data.spritesheet_frame >= num_frames))
	{
		if (sprite) {
			sprite->SetBitmap(nullptr);
		}
		result = false;
	}

	// Extensions
	data.easyrpg_flip = params.flip_x ? lcf::rpg::SavePicture::EasyRpgFlip_x : 0;
	data.easyrpg_flip |= params.flip_y ? lcf::rpg::SavePicture::EasyRpgFlip_y : 0;
	data.easyrpg_blend_mode = params.blend_mode;
	data.easyrpg_type = lcf::rpg::SavePicture::EasyRpgType_default;

	// Not saved as the coordinate system is directly transformed to "center"
	origin = params.origin;

	return result;
}

bool Game_Pictures::Show(int id, const ShowParams& params) {
	auto& pic = GetPicture(id);
	if (pic.Show(params)) {
		if (pic.sprite && !pic.data.name.empty()) {
			// When the name is empty the current image buffer is reused by ShowPicture command (Used by Yume2kki)
			// In all other cases hide the current image until replaced while doing an Async load
			pic.sprite->SetVisible(false);
		}
		RequestPictureSprite(pic);
		return true;
	}
	return false;
}

void Game_Pictures::Picture::Move(const MoveParams& params) {
	const bool ignore_position = Player::IsLegacy() && data.fixed_to_map;

	SetNonEffectParams(params, !ignore_position);
	if (params.duration < 0) {
		data.time_left = -params.duration;
	} else {
		data.time_left = params.duration * DEFAULT_FPS / 10;
	}

	// Not saved as the coordinate system is directly transformed to "center"
	origin = params.origin;
	ApplyOrigin(true);

	// Note that data.effect_mode doesn't necessarily reflect the
	// last effect set. Possible states are:
	//
	// * effect_mode == lcf::rpg::SavePicture::Effect_none && finish_effect_power == 0
	//   Picture has not had an effect set since Show.
	// * effect_mode == lcf::rpg::SavePicture::Effect_none && finish_effect_power != 0
	//   Picture was set to no effect; previously, it was rotating.
	// * effect_mode == lcf::rpg::SavePicture::Effect_wave && finish_effect_power == 0
	//   Picture was set to no effect; previously, it was wavering.
	// * effect_mode == lcf::rpg::SavePicture::Effect_rotation
	//   Picture was set to rotate.
	// * effect_mode == lcf::rpg::SavePicture::Effect_wave && finish_effect_power != 0
	//   Picture was set to waver.

	bool started_with_no_effect =
		data.effect_mode == lcf::rpg::SavePicture::Effect_none && data.finish_effect_power == 0.0;
	if (Player::IsRPG2k() && started_with_no_effect) {
		// Possibly a bug(?) in RM2k: if Show Picture command has no
		// effect, a Move Picture command cannot add one
		return;
	}

	if (data.effect_mode == lcf::rpg::SavePicture::Effect_none && params.effect_mode == lcf::rpg::SavePicture::Effect_none) {
		// Nothing to do
	} else if (data.effect_mode == params.effect_mode) {
		data.finish_effect_power = params.effect_power;
	} else if (data.effect_mode == lcf::rpg::SavePicture::Effect_rotation && params.effect_mode == lcf::rpg::SavePicture::Effect_none) {
		data.effect_mode = lcf::rpg::SavePicture::Effect_none;
	} else if (data.effect_mode == lcf::rpg::SavePicture::Effect_wave && params.effect_mode == lcf::rpg::SavePicture::Effect_none) {
		data.finish_effect_power = 0;
	} else {
		data.effect_mode = params.effect_mode;
		data.current_effect_power = params.effect_power;
		data.finish_effect_power = params.effect_power;
	}

	data.easyrpg_flip = params.flip_x ? lcf::rpg::SavePicture::EasyRpgFlip_x : 0;
	data.easyrpg_flip |= params.flip_y ? lcf::rpg::SavePicture::EasyRpgFlip_y : 0;
	data.easyrpg_blend_mode = params.blend_mode;
}

void Game_Pictures::Move(int id, const MoveParams& params) {
	auto& pic = GetPicture(id);
	pic.Move(params);
}

void Game_Pictures::Picture::Erase() {
	request_id = {};
	data.name.clear();
	if (sprite) {
		sprite->SetBitmap(nullptr);
	}
	if (IsWindowAttached()) {
		data.easyrpg_type = lcf::rpg::SavePicture::EasyRpgType_default;
		Main_Data::game_windows->Erase(data.ID);
	}
}

void Game_Pictures::Erase(int id) {
	auto* pic = GetPicturePtr(id);
	if (EP_LIKELY(pic)) {
		pic->Erase();
	}
}

void Game_Pictures::EraseAll() {
	for (auto& pic: pictures) {
		pic.Erase();
	}
}

bool Game_Pictures::Picture::Exists() const {
	// Incompatible with the Yume2kki edge-case that uses empty filenames
	return !data.name.empty();
}

void Game_Pictures::Picture::CreateSprite() {
	if (!sprite) {
		sprite = std::make_unique<Sprite_Picture>(data.ID, Drawable::Flags::Shared);
	}
}

bool Game_Pictures::Picture::IsRequestPending() const {
	return request_id != nullptr;
}

void Game_Pictures::Picture::MakeRequestImportant() const {
	FileRequestAsync* request = AsyncHandler::RequestFile("Picture", data.name);
	request->SetImportantFile(true);
}

void Game_Pictures::RequestPictureSprite(Picture& pic) {
	const auto& name = pic.data.name;
	if (name.empty()) {
		return;
	}

	FileRequestAsync* request = AsyncHandler::RequestFile("Picture", name);
	request->SetGraphicFile(true);
	pic.request_id = request->Bind(&Game_Pictures::OnPictureSpriteReady, this, pic.data.ID);
	request->Start();
}

void Game_Pictures::Picture::OnPictureSpriteReady() {
	auto bitmap = Cache::Picture(data.name, data.use_transparent_color);

	sprite->SetBitmap(bitmap);
	sprite->OnPictureShow();
	sprite->SetVisible(true);

	ApplyOrigin(false);
}

void Game_Pictures::OnPictureSpriteReady(FileRequestResult*, int id) {
	auto* pic = GetPicturePtr(id);
	if (EP_LIKELY(pic)) {
		pic->request_id = nullptr;
		pic->CreateSprite();
		pic->OnPictureSpriteReady();
	}
}

void Game_Pictures::Picture::ApplyOrigin(bool is_move) {
	if (origin == 0 || !sprite || !sprite->GetBitmap()) {
		return;
	}

	double x;
	double y;

	if (is_move) {
		x = data.finish_x;
		y = data.finish_y;
	} else {
		x = data.current_x;
		y = data.current_y;
	}

	double width = sprite->GetFrameWidth();
	double height = sprite->GetFrameHeight();

	switch (origin) {
		case 1:
			// Top-Left
			x += width / 2;
			y += height / 2;
			break;
		case 2:
			// Bottom-Left
			x += (width / 2);
			y -= (height / 2);
			break;
		case 3:
			// Top-Right
			x -= (width / 2);
			y += (height / 2);
			break;
		case 4:
			// Bottom-Right
			x -= (width / 2);
			y -= (height / 2);
			break;
		case 5:
			// Top
			y += (height / 2);
			break;
		case 6:
			// Bottom
			y -= (height / 2);
			break;
		case 7:
			// Left
			x += (width / 2);
			break;
		case 8:
			// Right
			x -= (width / 2);
			break;
	}

	if (!is_move) {
		data.current_x = x;
		data.current_y = y;
		data.start_x = x;
		data.start_y = y;
	}
	data.finish_x = x;
	data.finish_y = y;
}

void Game_Pictures::Picture::OnMapScrolled(int dx16, int dy16) {
	if (data.fixed_to_map && IsOnMap()) {
		// Instead of modifying the Ox/Oy offset the real position is altered
		// based on map scroll because of savegame compatibility with RPG_RT

		auto dx = static_cast<double>(dx16) / TILE_SIZE;

		data.finish_x = data.finish_x - dx;
		data.current_x = data.current_x - dx;
		data.start_x = data.start_x - dx;

		auto dy = static_cast<double>(dy16) / TILE_SIZE;

		data.finish_y = data.finish_y - dy;
		data.current_y = data.current_y - dy;
		data.start_y = data.start_y - dy;
	}
}

void Game_Pictures::OnMapScrolled(int dx, int dy) {
	for (auto& pic: pictures) {
		pic.OnMapScrolled(dx, dy);
	}
}

void Game_Pictures::Picture::AttachWindow(const Window_Base& window) {
	data.easyrpg_type = lcf::rpg::SavePicture::EasyRpgType_window;

	CreateSprite();

	auto bmp = std::make_shared<Bitmap>(window.GetWidth(), window.GetHeight(), data.use_transparent_color);
	bmp->SetId(fmt::format("Window:addr={},w={},h={}", (void*)&window, window.GetWidth(), window.GetHeight()));

	sprite->SetBitmap(bmp);
	sprite->OnPictureShow();
	sprite->SetVisible(true);

	ApplyOrigin(false);
}

bool Game_Pictures::Picture::IsWindowAttached() const {
	return data.easyrpg_type == lcf::rpg::SavePicture::EasyRpgType_window;
}

void Game_Pictures::Picture::Update(bool is_battle) {
	if ((is_battle && !IsOnBattle()) || (!is_battle && !IsOnMap())) {
		return;
	}

	if (Player::IsRPG2k3ECommands()) {
		++data.frames;
	}

	if (!needs_update) {
		return;
	}

	if (data.time_left > 0) {
		--data.time_left;
	}

	auto interpolate = [dt=static_cast<double>(data.time_left + 1)](double current, double finish) {
		return (finish - current) / dt + current;
	};

	if (data.time_left <= 0) {
		SyncCurrentToFinish<false>(data);
	} else {
		data.current_x = interpolate(data.current_x, data.finish_x);
		data.current_y = interpolate(data.current_y, data.finish_y);
		data.current_red = interpolate(data.current_red, data.finish_red);
		data.current_green = interpolate(data.current_green, data.finish_green);
		data.current_blue = interpolate(data.current_blue, data.finish_blue);
		data.current_sat = interpolate(data.current_sat, data.finish_sat);
		data.current_magnify = interpolate(data.current_magnify, data.finish_magnify);
		data.maniac_current_magnify_height = interpolate(data.maniac_current_magnify_height, data.maniac_finish_magnify_height);
		data.current_top_trans = interpolate(data.current_top_trans, data.finish_top_trans);
		data.current_bot_trans = interpolate(data.current_bot_trans, data.finish_bot_trans);
	}

	// When a move picture disables rotation effect, we continue rotating
	// until one full revolution is done. There is a bug in RPG_RT where this
	// only happens when the current rotation and power is positive. We emulate this for now.
	if (data.effect_mode == lcf::rpg::SavePicture::Effect_none && data.current_effect_power > 0) {
		// RPG_RT calculates this and compares it against remaining time.
		const auto et = 256 / static_cast<int>(data.current_effect_power);

		if (et < data.time_left || data.current_rotation > 0.0) {
			data.current_rotation = std::fmod(data.current_rotation, 256.0);
			data.current_rotation += data.current_effect_power;
			if (et >= data.time_left && data.current_rotation >= 256.0) {
				data.current_rotation = 0;
			}
		}
	}

	if (data.effect_mode != lcf::rpg::SavePicture::Effect_none) {
		data.current_effect_power = interpolate(data.current_effect_power, data.finish_effect_power);
	}

	// Update rotation
	if (data.effect_mode == lcf::rpg::SavePicture::Effect_rotation) {
		data.current_rotation += data.current_effect_power;
	}

	// Update waver phase
	if (data.effect_mode == lcf::rpg::SavePicture::Effect_wave) {
		data.current_waver += 8;
	}

	// Update fixed angle
	if (data.effect_mode == lcf::rpg::SavePicture::Effect_maniac_fixed_angle) {
		data.current_rotation = data.current_effect_power;
	}

	// RPG Maker 2k3 1.12: Animated spritesheets
	if (Player::IsRPG2k3ECommands()
			&& data.spritesheet_speed > 0
			&& data.frames > data.spritesheet_speed)
	{
		data.frames = 1;
		data.spritesheet_frame = data.spritesheet_frame + 1;

		if (data.spritesheet_frame >= data.spritesheet_rows * data.spritesheet_cols) {
			data.spritesheet_frame = 0;
			if (data.spritesheet_play_once && !data.name.empty()) {
				Erase();
			}
		}
	}
}

void Game_Pictures::Update(bool is_battle) {
	++frame_counter;
	for (auto& pic: pictures) {
		pic.Update(is_battle);
	}
}

Game_Pictures::ShowParams Game_Pictures::Picture::GetShowParams() const {
	Game_Pictures::ShowParams params;
	params.position_x = static_cast<int>(data.finish_x);
	params.position_y = static_cast<int>(data.finish_y);
	params.magnify_width = data.finish_magnify;
	params.magnify_height = data.maniac_finish_magnify_height;
	params.top_trans = data.finish_top_trans;
	params.bottom_trans = data.finish_bot_trans;
	params.red = data.finish_red;
	params.green = data.finish_green;
	params.blue = data.finish_blue;
	params.saturation = data.finish_sat;
	params.effect_mode = data.effect_mode;
	params.effect_power = data.finish_effect_power;
	params.name = data.name;
	params.spritesheet_cols = data.spritesheet_cols;
	params.spritesheet_rows = data.spritesheet_rows;
	params.spritesheet_frame = data.spritesheet_frame;
	params.spritesheet_speed = data.spritesheet_speed;
	params.map_layer = data.map_layer;
	params.battle_layer = data.battle_layer;
	for (size_t i = 0; i < data.flags.flags.size(); ++i) {
		params.flags |= data.flags.flags[i] << i;
	}
	params.spritesheet_play_once = data.spritesheet_play_once;
	params.use_transparent_color = data.use_transparent_color;
	params.fixed_to_map = data.fixed_to_map;
	return params;
}

void Game_Pictures::Picture::SetNonEffectParams(const Params& params, bool set_positions) {
	if (set_positions) {
		data.finish_x = params.position_x;
		data.finish_y = params.position_y;
	}
	data.finish_magnify = params.magnify_width;
	data.maniac_finish_magnify_height = params.magnify_height;
	data.finish_top_trans = params.top_trans;
	data.finish_bot_trans = params.bottom_trans;
	data.finish_red = params.red;
	data.finish_green = params.green;
	data.finish_blue = params.blue;
	data.finish_sat = params.saturation;
}


int Game_Pictures::Picture::NumSpriteSheetFrames() const {
	return data.spritesheet_cols * data.spritesheet_rows;
}


/*end of file .\game_pictures.cpp*/

/*start of file .\game_player.cpp*/

/* ... license chunk ... */

// Headers
#include "game_player.h"
#include "async_handler.h"
#include "game_actor.h"
#include "game_map.h"
#include "game_message.h"
#include "game_party.h"
#include "game_system.h"
#include "game_screen.h"
#include "game_pictures.h"
#include "input.h"
#include "main_data.h"
#include "options.h"
#include "player.h"
#include "util_macro.h"
#include "game_switches.h"
#include "output.h"
#include "rand.h"
#include "utils.h"
#include <lcf/reader_util.h>
#include <lcf/scope_guard.h>
#include "scene_battle.h"
#include "scene_menu.h"
#include <lcf/rpg/savetarget.h>
#include <algorithm>
#include <cmath>
#include "scene_gameover.h"

Game_Player::Game_Player(): Game_PlayerBase(Player)
{
	SetDirection(lcf::rpg::EventPage::Direction_down);
	SetMoveSpeed(4);
	SetAnimationType(lcf::rpg::EventPage::AnimType_non_continuous);
}

void Game_Player::SetSaveData(lcf::rpg::SavePartyLocation save)
{
	*data() = std::move(save);

	SanitizeData("Party");

	// RPG_RT will always reset the hero graphic on loading a save, even if
	// a move route changed the graphic.
	ResetGraphic();
}

lcf::rpg::SavePartyLocation Game_Player::GetSaveData() const {
	return *data();
}

Drawable::Z_t Game_Player::GetScreenZ(int x_offset, int y_offset) const {
	// Player is always "same layer as hero".
	// When the Player is on the same Y-coordinate as an event the Player is always rendered first.
	// This is different to events where, when Y is the same, the highest X-coordinate is rendered first.
	// To ensure this, fake a very high X-coordinate of 65535 (all bits set)
	// See base function for full explanation of the bitmask
	return Game_Character::GetScreenZ(x_offset, y_offset) | (0xFFFFu << 16u);
}

void Game_Player::ReserveTeleport(int map_id, int x, int y, int direction, TeleportTarget::Type tt) {
	teleport_target = TeleportTarget(map_id, x, y, direction, tt);

	FileRequestAsync* request = Game_Map::RequestMap(map_id);
	request->Start();
}

void Game_Player::ReserveTeleport(const lcf::rpg::SaveTarget& target) {
	const auto* target_map_info = &Game_Map::GetMapInfo(target.map_id);

	if (target_map_info->type == lcf::rpg::TreeMap::MapType_area) {
		// Area: Obtain the map the area belongs to
		target_map_info = &Game_Map::GetParentMapInfo(*target_map_info);
	}

	ReserveTeleport(target_map_info->ID, target.map_x, target.map_y, Down, TeleportTarget::eSkillTeleport);

	if (target.switch_on) {
		Main_Data::game_switches->Set(target.switch_id, true);
		Game_Map::SetNeedRefresh(true);
	}
}

void Game_Player::PerformTeleport() {
	assert(IsPendingTeleport());
	if (!IsPendingTeleport()) {
		return;
	}

	if (teleport_target.GetMapId() <= 0) {
		Output::Error("Invalid Teleport map id! mapid={} x={} y={} d={}", teleport_target.GetMapId(),
				teleport_target.GetX(), teleport_target.GetY(), teleport_target.GetDirection());
	}

	const auto map_changed = (GetMapId() != teleport_target.GetMapId());
	MoveTo(teleport_target.GetMapId(), teleport_target.GetX(), teleport_target.GetY());


	if (teleport_target.GetDirection() >= 0) {
		SetDirection(teleport_target.GetDirection());
		UpdateFacing();
	}

	if (map_changed && teleport_target.GetType() != TeleportTarget::eAsyncQuickTeleport) {
		Main_Data::game_screen->OnMapChange();
		Main_Data::game_pictures->OnMapChange();
		Game_Map::GetInterpreter().OnMapChange();
	}

	ResetTeleportTarget();
}

void Game_Player::MoveTo(int map_id, int x, int y) {
	const auto map_changed = (GetMapId() != map_id);

	Game_Character::MoveTo(map_id, x, y);
	SetTotalEncounterRate(0);
	SetMenuCalling(false);

	auto* vehicle = GetVehicle();
	if (vehicle) {
		// RPG_RT doesn't check the aboard flag for this one
		vehicle->MoveTo(map_id, x, y);
	}

	if (map_changed) {
		// FIXME: Assert map pre-loaded in cache.

		// pan_state does not reset when you change maps.
		data()->pan_speed = lcf::rpg::SavePartyLocation::kPanSpeedDefault;
		data()->pan_finish_x = GetDefaultPanX();
		data()->pan_finish_y = GetDefaultPanY();
		data()->pan_current_x = GetDefaultPanX();
		data()->pan_current_y = GetDefaultPanY();
		maniac_pan_current_x = static_cast<double>(GetDefaultPanX());
		maniac_pan_current_y = static_cast<double>(GetDefaultPanY());

		ResetAnimation();

		auto map = Game_Map::LoadMapFile(GetMapId());

		Game_Map::Setup(std::move(map));
		Game_Map::PlayBgm();

		// This Fixes an RPG_RT bug where the jumping flag doesn't get reset
		// if you change maps during a jump
		SetJumping(false);
	} else {
		Game_Map::SetPositionX(GetSpriteX() - GetPanX());
		Game_Map::SetPositionY(GetSpriteY() - GetPanY());
	}

	ResetGraphic();
}

bool Game_Player::MakeWay(int from_x, int from_y, int to_x, int to_y) {
	if (IsAboard()) {
		return GetVehicle()->MakeWay(from_x, from_y, to_x, to_y);
	}

	return Game_Character::MakeWay(from_x, from_y, to_x, to_y);
}

void Game_Player::MoveRouteSetSpriteGraphic(std::string sprite_name, int index) {
	auto* vh = GetVehicle();
	if (vh) {
		vh->MoveRouteSetSpriteGraphic(std::move(sprite_name), index);
	} else {
		Game_Character::MoveRouteSetSpriteGraphic(std::move(sprite_name), index);
	}
}

void Game_Player::UpdateScroll(int amount, bool was_jumping) {
	if (IsPanLocked()) {
		return;
	}

	auto dx = (GetX() * SCREEN_TILE_SIZE) - Game_Map::GetPositionX() - GetPanX();
	auto dy = (GetY() * SCREEN_TILE_SIZE) - Game_Map::GetPositionY() - GetPanY();

	const auto w = Game_Map::GetTilesX() * SCREEN_TILE_SIZE;
	const auto h = Game_Map::GetTilesY() * SCREEN_TILE_SIZE;

	dx = Utils::PositiveModulo(dx + w / 2, w) - w / 2;
	dy = Utils::PositiveModulo(dy + h / 2, h) - h / 2;

	const auto sx = Utils::Signum(dx);
	const auto sy = Utils::Signum(dy);

	if (was_jumping) {
		const auto jdx = sx * std::abs(GetX() - GetBeginJumpX());
		const auto jdy = sy * std::abs(GetY() - GetBeginJumpY());

		Game_Map::Scroll(amount * jdx, amount * jdy);

		if (!IsJumping()) {
			// RPG does this to fix rounding errors?
			const auto x = SCREEN_TILE_SIZE * Utils::RoundTo<int>(Game_Map::GetPositionX() / static_cast<double>(SCREEN_TILE_SIZE));
			const auto y = SCREEN_TILE_SIZE * Utils::RoundTo<int>(Game_Map::GetPositionY() / static_cast<double>(SCREEN_TILE_SIZE));

			// RPG_RT does adjust map position, but not panorama!
			Game_Map::SetPositionX(x, false);
			Game_Map::SetPositionY(y, false);
		}
		return;
	}

	int move_sx = 0;
	int move_sy = 0;
	const auto d = GetDirection();
	if (sy < 0 && (d == Up || d == UpRight || d == UpLeft)) {
		move_sy = sy;
	}
	if (sy > 0 && (d == Down || d == DownRight || d == DownLeft)) {
		move_sy = sy;
	}
	if (sx > 0 && (d == Right || d == UpRight || d == DownRight)) {
		move_sx = sx;
	}
	if (sx < 0 && (d == Left || d == UpLeft || d == DownLeft)) {
		move_sx = sx;
	}

	Game_Map::Scroll(move_sx * amount, move_sy * amount);
}

bool Game_Player::UpdateAirship() {
	auto* vehicle = GetVehicle();

	// RPG_RT doesn't check vehicle, but we have to as we don't have another way to fetch it.
	// Also in vanilla RPG_RT it's impossible for the hero to fly without the airship.
	if (vehicle && vehicle->IsFlying()) {
		if (vehicle->AnimateAscentDescent()) {
			if (!vehicle->IsFlying()) {
				// If we landed, them disembark
				Main_Data::game_player->SetFlying(vehicle->IsFlying());
				data()->aboard = false;
				SetFacing(Down);
				data()->vehicle = 0;
				SetMoveSpeed(data()->preboard_move_speed);

				Main_Data::game_system->BgmPlay(Main_Data::game_system->GetBeforeVehicleMusic());
			}

			return true;
		}
	}
	return false;
}

void Game_Player::UpdateNextMovementAction() {
	if (UpdateAirship()) {
		return;
	}

	UpdateMoveRoute(data()->move_route_index, data()->move_route, true);

	if (Game_Map::GetInterpreter().IsRunning()) {
		SetMenuCalling(false);
		return;
	}

	if(IsPaused() || IsMoveRouteOverwritten() || Game_Message::IsMessageActive()) {
		return;
	}

	if (IsEncounterCalling()) {
		SetMenuCalling(false);
		SetEncounterCalling(false);

		BattleArgs args;
		if (Game_Map::PrepareEncounter(args)) {
			Scene::instance->SetRequestedScene(Scene_Battle::Create(std::move(args)));
			return;
		}
	}

	if (IsMenuCalling()) {
		SetMenuCalling(false);

		ResetAnimation();
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
		Game_Map::GetInterpreter().RequestMainMenuScene();
		return;
	}

	CheckEventTriggerHere({ lcf::rpg::EventPage::Trigger_collision }, false);

	if (Game_Map::IsAnyEventStarting()) {
		return;
	}

	int move_dir = -1;
	switch (Input::dir4) {
		case 2:
			move_dir = Down;
			break;
		case 4:
			move_dir = Left;
			break;
		case 6:
			move_dir = Right;
			break;
		case 8:
			move_dir = Up;
			break;
	}
	if (move_dir >= 0) {
		SetThrough((Player::debug_flag && Input::IsPressed(Input::DEBUG_THROUGH)) || data()->move_route_through);
		Move(move_dir);
		ResetThrough();
		if (IsStopping()) {
			int front_x = Game_Map::XwithDirection(GetX(), GetDirection());
			int front_y = Game_Map::YwithDirection(GetY(), GetDirection());
			CheckEventTriggerThere({lcf::rpg::EventPage::Trigger_touched, lcf::rpg::EventPage::Trigger_collision}, front_x, front_y, false);
		}
	}

	if (IsStopping()) {
		if (Input::IsTriggered(Input::DECISION)) {
			if (!GetOnOffVehicle()) {
				CheckActionEvent();
			}
		}
		return;
	}

	Main_Data::game_party->IncSteps();
	if (Main_Data::game_party->ApplyStateDamage()) {
		Main_Data::game_screen->FlashMapStepDamage();
	}
	UpdateEncounterSteps();
}

void Game_Player::UpdateMovement(int amount) {
	const bool was_jumping = IsJumping();

	Game_Character::UpdateMovement(amount);

	UpdateScroll(amount, was_jumping);

	if (!IsMoveRouteOverwritten() && IsStopping()) {
		TriggerSet triggers = { lcf::rpg::EventPage::Trigger_touched, lcf::rpg::EventPage::Trigger_collision };
		CheckEventTriggerHere(triggers, false);
	}
}

void Game_Player::Update() {
	Game_Character::Update();

	if (IsStopping()) {
		if (data()->boarding) {
			// Boarding completed
			data()->aboard = true;
			data()->boarding = false;
			// Note: RPG_RT ignores the lock_facing flag here!
			SetFacing(Left);

			auto* vehicle = GetVehicle();
			SetMoveSpeed(vehicle->GetMoveSpeed());
		}
		if (data()->unboarding) {
			// Unboarding completed
			data()->unboarding = false;
		}
	}

	auto* vehicle = GetVehicle();

	if (IsAboard() && vehicle) {
		vehicle->SyncWithRider(this);
	}

	UpdatePan();

	// ESC-Menu calling
	if (Main_Data::game_system->GetAllowMenu()
			&& !Game_Message::IsMessageActive()
			&& !Game_Map::GetInterpreter().IsRunning())
	{
		if (Input::IsTriggered(Input::CANCEL)) {
			SetMenuCalling(true);
		}
	}
}

bool Game_Player::CheckActionEvent() {
	if (IsFlying()) {
		return false;
	}

	bool result = false;
	int front_x = Game_Map::XwithDirection(GetX(), GetDirection());
	int front_y = Game_Map::YwithDirection(GetY(), GetDirection());

	result |= CheckEventTriggerThere({lcf::rpg::EventPage::Trigger_touched, lcf::rpg::EventPage::Trigger_collision}, front_x, front_y, true);
	result |= CheckEventTriggerHere({lcf::rpg::EventPage::Trigger_action}, true);

	// Counter tile loop stops only if you talk to an action event.
	bool got_action = CheckEventTriggerThere({lcf::rpg::EventPage::Trigger_action}, front_x, front_y, true);
	// RPG_RT allows maximum of 3 counter tiles
	for (int i = 0; !got_action && i < 3; ++i) {
		if (!Game_Map::IsCounter(front_x, front_y)) {
			break;
		}

		front_x = Game_Map::XwithDirection(front_x, GetDirection());
		front_y = Game_Map::YwithDirection(front_y, GetDirection());

		got_action |= CheckEventTriggerThere({lcf::rpg::EventPage::Trigger_action}, front_x, front_y, true);
	}
	return result || got_action;
}

bool Game_Player::CheckEventTriggerHere(TriggerSet triggers, bool triggered_by_decision_key, bool face_player) {
	if (InAirship()) {
		return false;
	}

	bool result = false;

	for (auto& ev: Game_Map::GetEvents()) {
		const auto trigger = ev.GetTrigger();
		if (ev.IsActive()
				&& ev.GetX() == GetX()
				&& ev.GetY() == GetY()
				&& ev.GetLayer() != lcf::rpg::EventPage::Layers_same
				&& trigger >= 0
				&& triggers[trigger]) {
			SetEncounterCalling(false);
			result |= ev.ScheduleForegroundExecution(triggered_by_decision_key, face_player);
		}
	}
	return result;
}

bool Game_Player::CheckEventTriggerThere(TriggerSet triggers, int x, int y, bool triggered_by_decision_key, bool face_player) {
	if (InAirship()) {
		return false;
	}
	bool result = false;

	for (auto& ev : Game_Map::GetEvents()) {
		const auto trigger = ev.GetTrigger();
		if (ev.IsActive()
				&& ev.GetX() == x
				&& ev.GetY() == y
				&& ev.GetLayer() == lcf::rpg::EventPage::Layers_same
				&& trigger >= 0
				&& triggers[trigger]) {
			SetEncounterCalling(false);
			result |= ev.ScheduleForegroundExecution(triggered_by_decision_key, face_player);
		}
	}
	return result;
}

void Game_Player::ResetGraphic() {

	auto* actor = Main_Data::game_party->GetActor(0);
	if (actor == nullptr) {
		SetSpriteGraphic("", 0);
		SetTransparency(0);
		return;
	}

	SetSpriteGraphic(ToString(actor->GetSpriteName()), actor->GetSpriteIndex());
	SetTransparency(actor->GetSpriteTransparency());
}

bool Game_Player::GetOnOffVehicle() {
	if (IsDirectionDiagonal(GetDirection())) {
		SetDirection(GetFacing());
	}

	return IsAboard()
		? GetOffVehicle()
		: GetOnVehicle();
}

bool Game_Player::GetOnVehicle() {
	assert(!IsDirectionDiagonal(GetDirection()));
	assert(!IsAboard());

	auto* vehicle = Game_Map::GetVehicle(Game_Vehicle::Airship);

	if (vehicle->IsInPosition(GetX(), GetY()) && IsStopping() && vehicle->IsStopping()) {
		data()->vehicle = Game_Vehicle::Airship;
		data()->aboard = true;

		// Note: RPG_RT ignores the lock_facing flag here!
		SetFacing(Left);

		data()->preboard_move_speed = GetMoveSpeed();
		SetMoveSpeed(vehicle->GetMoveSpeed());
		vehicle->StartAscent();
		Main_Data::game_player->SetFlying(vehicle->IsFlying());
	} else {
		const auto front_x = Game_Map::XwithDirection(GetX(), GetDirection());
		const auto front_y = Game_Map::YwithDirection(GetY(), GetDirection());

		vehicle = Game_Map::GetVehicle(Game_Vehicle::Ship);
		if (!vehicle->IsInPosition(front_x, front_y)) {
			vehicle = Game_Map::GetVehicle(Game_Vehicle::Boat);
			if (!vehicle->IsInPosition(front_x, front_y)) {
				return false;
			}
		}

		if (!Game_Map::CanEmbarkShip(*this, front_x, front_y)) {
			return false;
		}

		SetThrough(true);
		Move(GetDirection());
		// FIXME: RPG_RT resets through to move_route_through || not visible?
		ResetThrough();

		data()->vehicle = vehicle->GetVehicleType();
		data()->preboard_move_speed = GetMoveSpeed();
		data()->boarding = true;
	}

	Main_Data::game_system->SetBeforeVehicleMusic(Main_Data::game_system->GetCurrentBGM());
	Main_Data::game_system->BgmPlay(vehicle->GetBGM());
	return true;
}

bool Game_Player::GetOffVehicle() {
	assert(!IsDirectionDiagonal(GetDirection()));
	assert(IsAboard());

	auto* vehicle = GetVehicle();
	if (!vehicle) {
		return false;
	}

	if (InAirship()) {
		if (vehicle->IsAscendingOrDescending()) {
			return false;
		}

		// Note: RPG_RT ignores the lock_facing flag here!
		SetFacing(Left);
		vehicle->StartDescent();
		return true;
	}

	const auto front_x = Game_Map::XwithDirection(GetX(), GetDirection());
	const auto front_y = Game_Map::YwithDirection(GetY(), GetDirection());

	if (!Game_Map::CanDisembarkShip(*this, front_x, front_y)) {
		return false;
	}

	vehicle->SetDefaultDirection();
	data()->aboard = false;
	SetMoveSpeed(data()->preboard_move_speed);
	data()->unboarding = true;

	SetThrough(true);
	Move(GetDirection());
	ResetThrough();

	data()->vehicle = 0;
	Main_Data::game_system->BgmPlay(Main_Data::game_system->GetBeforeVehicleMusic());

	return true;
}

void Game_Player::ForceGetOffVehicle() {
	if (!IsAboard()) {
		return;
	}

	auto* vehicle = GetVehicle();
	vehicle->ForceLand();
	vehicle->SetDefaultDirection();

	data()->flying = false;
	data()->aboard = false;
	SetMoveSpeed(data()->preboard_move_speed);
	data()->unboarding = true;
	data()->vehicle = 0;
	Main_Data::game_system->BgmPlay(Main_Data::game_system->GetBeforeVehicleMusic());
}

bool Game_Player::InVehicle() const {
	return data()->vehicle > 0;
}

bool Game_Player::InAirship() const {
	return data()->vehicle == Game_Vehicle::Airship;
}

Game_Vehicle* Game_Player::GetVehicle() const {
	return Game_Map::GetVehicle((Game_Vehicle::Type) data()->vehicle);
}

bool Game_Player::Move(int dir) {
	if (!IsStopping()) {
		return true;
	}

	Game_Character::Move(dir);
	if (IsStopping()) {
		return false;
	}

	if (InAirship()) {
		return true;
	}

	int terrain_id = Game_Map::GetTerrainTag(GetX(), GetY());
	const auto* terrain = lcf::ReaderUtil::GetElement(lcf::Data::terrains, terrain_id);
	bool red_flash = false;

	if (terrain) {
		if (terrain->damage != 0) {
			for (auto hero : Main_Data::game_party->GetActors()) {
				if (terrain->damage < 0 || !hero->PreventsTerrainDamage()) {
					if (terrain->damage > 0) {
						red_flash = true;
					}
					if (terrain->easyrpg_damage_in_percent) {
						int value = std::max<int>(1, std::abs(hero->GetMaxHp() * terrain->damage / 100));
						hero->ChangeHp((terrain->damage > 0 ? -value : value), terrain->easyrpg_damage_can_kill);
					} else {
						hero->ChangeHp(-terrain->damage, terrain->easyrpg_damage_can_kill);
					}
				}
			}
			if (terrain->damage > 0 && terrain->easyrpg_damage_can_kill) {
				if (!Main_Data::game_party->IsAnyActive() && Main_Data::game_party->GetBattlerCount() > 0) {
					Scene::instance->SetRequestedScene(std::make_shared<Scene_Gameover>());
					return true;
				}
			}
		}
		if ((!terrain->on_damage_se || red_flash) && Player::IsRPG2k3()) {
			Main_Data::game_system->SePlay(terrain->footstep);
		}
	} else {
		Output::Warning("Player BeginMove: Invalid terrain ID {} at ({}, {})", terrain_id, GetX(), GetY());
	}

	if (red_flash) {
		Main_Data::game_screen->FlashMapStepDamage();
	}

	return true;
}

bool Game_Player::IsAboard() const {
	return data()->aboard;
}

bool Game_Player::IsBoardingOrUnboarding() const {
	return data()->boarding || data()->unboarding;
}

void Game_Player::UpdateEncounterSteps() {
	if (Player::debug_flag && Input::IsPressed(Input::DEBUG_THROUGH)) {
		return;
	}

	if(IsFlying()) {
		return;
	}

	const auto encounter_steps = Game_Map::GetEncounterSteps();

	if (encounter_steps <= 0) {
		SetTotalEncounterRate(0);
		return;
	}

	int x = GetX();
	int y = GetY();

	const auto* terrain = lcf::ReaderUtil::GetElement(lcf::Data::terrains, Game_Map::GetTerrainTag(x,y));
	if (!terrain) {
		Output::Warning("UpdateEncounterSteps: Invalid terrain at ({}, {})", x, y);
		return;
	}

	data()->total_encounter_rate += terrain->encounter_rate;

	struct Row {
		int ratio;
		float pmod;
	};

#if 1
	static constexpr Row enc_table[] = {
		{ 0, 0.0625},
		{ 20, 0.125 },
		{ 40, 0.25 },
		{ 60, 0.5 },
		{ 100, 2.0 },
		{ 140, 4.0 },
		{ 160, 8.0 },
		{ 180, 16.0 },
		{ INT_MAX, 16.0 }
	};
#else
	//Old versions of RM2k used this table.
	//Left here for posterity.
	static constexpr Row enc_table[] = {
		{ 0, 0.5 },
		{ 20, 2.0 / 3.0 },
		{ 50, 5.0 / 6.0 },
		{ 100, 6.0 / 5.0 },
		{ 200, 3.0 / 2.0 },
		{ INT_MAX, 3.0 / 2.0 }
	};
#endif
	const auto ratio = GetTotalEncounterRate() / encounter_steps;

	auto& idx = last_encounter_idx;
	while (ratio > enc_table[idx+1].ratio) {
		++idx;
	}
	const auto& row = enc_table[idx];

	const auto pmod = row.pmod;
	const auto p = (1.0f / float(encounter_steps)) * pmod * (float(terrain->encounter_rate) / 100.0f);

	if (!Rand::PercentChance(p)) {
		return;
	}

	SetTotalEncounterRate(0);
	SetEncounterCalling(true);
}

void Game_Player::SetTotalEncounterRate(int rate) {
	last_encounter_idx = 0;
	data()->total_encounter_rate = rate;
}

int Game_Player::GetDefaultPanX() {
	return static_cast<int>(std::ceil(static_cast<float>(Player::screen_width) / TILE_SIZE / 2) - 1) * SCREEN_TILE_SIZE;
}

int Game_Player::GetDefaultPanY() {
	return static_cast<int>(std::ceil(static_cast<float>(Player::screen_height) / TILE_SIZE / 2) - 1) * SCREEN_TILE_SIZE;
}

void Game_Player::LockPan() {
	data()->pan_state = lcf::rpg::SavePartyLocation::PanState_fixed;
}

void Game_Player::UnlockPan() {
	data()->pan_state = lcf::rpg::SavePartyLocation::PanState_follow;
}

void Game_Player::StartPan(int direction, int distance, int speed) {
	distance *= SCREEN_TILE_SIZE;

	if (direction == PanUp) {
		int new_pan = data()->pan_finish_y + distance;
		data()->pan_finish_y = new_pan;
	} else if (direction == PanRight) {
		int new_pan = data()->pan_finish_x - distance;
		data()->pan_finish_x = new_pan;
	} else if (direction == PanDown) {
		int new_pan = data()->pan_finish_y - distance;
		data()->pan_finish_y = new_pan;
	} else if (direction == PanLeft) {
		int new_pan = data()->pan_finish_x + distance;
		data()->pan_finish_x = new_pan;
	}

	data()->pan_speed = 2 << speed;

	if (Player::IsPatchManiac()) {
		// Maniac uses separate horizontal/vertical pan for everything
		data()->maniac_horizontal_pan_speed = data()->pan_speed;
		data()->maniac_vertical_pan_speed = data()->pan_speed;
	}
}

void Game_Player::StartPixelPan(int h, int v, int speed, bool interpolated, bool centered, bool relative) {
	if (!Player::IsPatchManiac()) {
		return;
	}

	h *= TILE_SIZE;
	v *= TILE_SIZE;

	maniac_pan_current_x = static_cast<double>(data()->pan_current_x);
	maniac_pan_current_y = static_cast<double>(data()->pan_current_y);

	int new_pan_x;
	int new_pan_y;

	if (relative && centered) {
		int screen_width = static_cast<int>(std::ceil(static_cast<float>(Player::screen_width) / 2)) * TILE_SIZE;
		int screen_height = static_cast<int>(std::ceil(static_cast<float>(Player::screen_height) / 2)) * TILE_SIZE;
		new_pan_x = data()->pan_finish_x - (h - screen_width) * 0.5;
		new_pan_y = data()->pan_finish_y - (v - screen_height) * 0.5;
	} else if (relative) {
		new_pan_x = data()->pan_finish_x - h;
		new_pan_y = data()->pan_finish_y - v;
	} else if (centered) {
		new_pan_x = GetSpriteX() + GetDefaultPanX() - h;
		new_pan_y = GetSpriteY() + GetDefaultPanY() - v;
	} else {
		new_pan_x = GetSpriteX() - h;
		new_pan_y = GetSpriteY() - v;
	}

	double h_speed;
	double v_speed;

	if (speed == 0) {
		// Instant pan if speed is zero
		h_speed = std::abs((static_cast<double>(new_pan_x) - maniac_pan_current_x));
		v_speed = std::abs((static_cast<double>(new_pan_y) - maniac_pan_current_y));
	} else if (interpolated) {
		// Interpolate distance by number of frames
		h_speed = std::abs((static_cast<double>(new_pan_x) - maniac_pan_current_x)) / (speed + 1);
		v_speed = std::abs((static_cast<double>(new_pan_y) - maniac_pan_current_y)) / (speed + 1);
	} else {
		// Multiply speed by 0.001
		h_speed = std::max(static_cast<double>(speed * TILE_SIZE * 0.001), 1.0);
		v_speed = std::max(static_cast<double>(speed * TILE_SIZE * 0.001), 1.0);
	}

	data()->pan_finish_x = new_pan_x;
	data()->pan_finish_y = new_pan_y;
	data()->maniac_horizontal_pan_speed = h_speed;
	data()->maniac_vertical_pan_speed = v_speed;
}

void Game_Player::ResetPan(int speed) {
	data()->pan_finish_x = GetDefaultPanX();
	data()->pan_finish_y = GetDefaultPanY();
	data()->pan_speed = 2 << speed;

	if (Player::IsPatchManiac()) {
		// Maniac uses separate horizontal/vertical pan for everything
		data()->maniac_horizontal_pan_speed = data()->pan_speed;
		data()->maniac_vertical_pan_speed = data()->pan_speed;
	}
}

int Game_Player::GetPanWait() {
	bool is_maniac = Player::IsPatchManiac();
	const auto distance = std::max(
			std::abs(data()->pan_current_x - data()->pan_finish_x),
			std::abs(data()->pan_current_y - data()->pan_finish_y));
	const auto speed = !is_maniac ? data()->pan_speed : static_cast<int>(std::max(
			std::abs(data()->maniac_horizontal_pan_speed),
			std::abs(data()->maniac_vertical_pan_speed)));
	assert(speed > 0);
	return distance / speed + (distance % speed != 0);
}

void Game_Player::UpdatePan() {
	if (!IsPanActive())
		return;

	const int step = data()->pan_speed;
	const int pan_remain_x = data()->pan_current_x - data()->pan_finish_x;
	const int pan_remain_y = data()->pan_current_y - data()->pan_finish_y;

	int dx;
	int dy;

	if (Player::IsPatchManiac()) {
		const double step_x = data()->maniac_horizontal_pan_speed;
		const double step_y = data()->maniac_vertical_pan_speed;

		// Maniac uses doubles for smoother screen scrolling
		double dx2 = std::min(step_x, std::abs(static_cast<double>(pan_remain_x)));
		double dy2 = std::min(step_y, std::abs(static_cast<double>(pan_remain_y)));

		dx2 = pan_remain_x >= 0 ? dx2 : -dx2;
		dy2 = pan_remain_y >= 0 ? dy2 : -dy2;

		maniac_pan_current_x -= dx2;
		maniac_pan_current_y -= dy2;

		// Depending on the position, floor or ceil the value
		dx = Utils::RoundTo<double>(std::abs(maniac_pan_current_x)) == std::ceil(std::abs(maniac_pan_current_x)) ? static_cast<int>(std::floor(dx2)) : static_cast<int>(std::ceil(dx2));
		dy = Utils::RoundTo<double>(std::abs(maniac_pan_current_y)) == std::ceil(std::abs(maniac_pan_current_y)) ? static_cast<int>(std::floor(dy2)) : static_cast<int>(std::ceil(dy2));
	} else {
		dx = std::min(step, std::abs(pan_remain_x));
		dy = std::min(step, std::abs(pan_remain_y));

		dx = pan_remain_x >= 0 ? dx : -dx;
		dy = pan_remain_y >= 0 ? dy : -dy;
	}

	int screen_x = Game_Map::GetPositionX();
	int screen_y = Game_Map::GetPositionY();

	Game_Map::AddScreenX(screen_x, dx);
	Game_Map::AddScreenY(screen_y, dy);

	// If we hit the edge of the map before pan finishes.
	if (dx == 0 && dy == 0) {
		return;
	}

	Game_Map::Scroll(dx, dy);

	data()->pan_current_x -= dx;
	data()->pan_current_y -= dy;
}

bool Game_Player::TriggerEventAt(int x, int y, bool triggered_by_decision_key, bool face_player) {
	return CheckEventTriggerThere({ lcf::rpg::EventPage::Trigger_action }, x, y, triggered_by_decision_key, face_player);
}


/*end of file .\game_player.cpp*/

/*start of file .\game_quit.cpp*/

/* ... license chunk ... */

#include "game_quit.h"
#include "options.h"
#include "input.h"
#include "scene.h"
#include <player.h>

constexpr int num_seconds = 2;
constexpr int start_time = num_seconds * DEFAULT_FPS;

constexpr int window_width = SCREEN_TARGET_WIDTH / 2;
constexpr int window_height = 32;

Game_Quit::Game_Quit()
	: window(0, 0, window_width, window_height, Drawable::Flags::Global)
{
	window.SetBackOpacity(128);
	window.SetZ(Priority_Overlay - 20);
	OnResolutionChange();
	Reset();
}

void Game_Quit::Update() {
	if (Scene::instance == nullptr || Scene::instance->type == Scene::Title || !Scene::Find(Scene::Title) || !Input::IsPressed(Input::RESET)) {
		if (time_left != start_time) {
			Reset();
		}
		return;
	}

	window.SetVisible(true);

	if (time_left > 0) {
		--time_left;
	}

	// FIXME Need to write the text every frame in case system graphic changes..
	auto s = (time_left + DEFAULT_FPS - 1) / DEFAULT_FPS;
	window.SetText("Restarting in " + std::to_string(s) + " sec ...");
	window.Update();
}

void Game_Quit::OnResolutionChange() {
	window.SetX(Player::screen_width / 2 - window_width / 2);
	window.SetY(Player::screen_height / 2 - window_height / 2);
}

void Game_Quit::Reset() {
	window.SetVisible(false);
	time_left = DEFAULT_FPS * num_seconds;
}


/*end of file .\game_quit.cpp*/

/*start of file .\game_runtime_patches.cpp*/

/* ... license chunk ... */

// Headers
#include "game_runtime_patches.h"

#include "game_map.h"
#include "game_party.h"
#include "game_switches.h"
#include "game_variables.h"
#include "game_actor.h"
#include "game_battler.h"
#include "game_enemy.h"
#include "main_data.h"
#include "player.h"

namespace {
	template<size_t C>
	void LockPatchArguments(std::array<RuntimePatches::PatchArg, C> const& patch_args) {
		for (auto& patch_arg : patch_args) {
			patch_arg.config_param.Lock(0);
		}
	}

	template<size_t C>
	bool ParsePatchArguments(CmdlineParser& cp, CmdlineArg arg, std::array<RuntimePatches::PatchArg, C> const& patch_args) {
		if (arg.ArgIsOff()) {
			for (auto& patch_arg : patch_args) {
				patch_arg.config_param.Set(0);
			}
			return true;
		}
		if (arg.ArgIsOn()) {
			for (auto& patch_arg : patch_args) {
				patch_arg.config_param.Set(patch_arg.default_value);
			}
			bool parsed;
			long li_value = 0;
			do {
				parsed = false;
				for (int i = 0; i < static_cast<int>(patch_args.size()); ++i) {
					if (cp.ParseNext(arg, 1, patch_args[i].cmd_arg)) {
						parsed = true;
						if (arg.ParseValue(0, li_value)) {
							patch_args[i].config_param.Set(li_value);
						}
					}
				}
			} while (parsed);

			return true;
		}
		return false;
	}

	template<size_t C>
	bool ParsePatchFromIni(lcf::INIReader& ini, std::array<RuntimePatches::PatchArg, C> const& patch_args) {
		bool patch_override = false;
		for (auto& patch_arg : patch_args) {
			patch_override |= patch_arg.config_param.FromIni(ini);
		}
		return patch_override;
	}

	template<size_t C>
	void PrintPatch(std::vector<std::string>& patches, std::array<RuntimePatches::PatchArg, C> const& patch_args) {
		assert(patch_args.size() > 0);

		bool is_set = false;
		for (auto& patch_arg : patch_args) {
			if (patch_arg.config_param.Get() > 0) {
				is_set = true;
				break;
			}
		}
		if (!is_set) {
			return;
		}

		if (patch_args.size() == 1) {
			patches.push_back(fmt::format("{} ({})", patch_args[0].config_param.GetName(), patch_args[0].config_param.Get()));
			return;
		}

		std::string out = fmt::format("{} (", patch_args[0].config_param.GetName());
		for (int i = 0; i < static_cast<int>(patch_args.size()); ++i) {
			if (i > 0) {
				out += ", ";
			}
			out += fmt::format("{}", patch_args[i].config_param.Get());
		}
		out += ")";

		patches.push_back(out);
	}
}

void RuntimePatches::LockPatchesAsDiabled() {
	LockPatchArguments(EncounterRandomnessAlert::patch_args);
	LockPatchArguments(MonSca::patch_args);
	LockPatchArguments(EXPlus::patch_args);
	LockPatchArguments(GuardRevamp::patch_args);
}

bool RuntimePatches::ParseFromCommandLine(CmdlineParser& cp) {
	CmdlineArg arg;
	if (cp.ParseNext(arg, 1, { "--patch-encounter-alert", "--no-patch-encounter-alert" })) {
		return ParsePatchArguments(cp, arg, EncounterRandomnessAlert::patch_args);
	}
	if (cp.ParseNext(arg, 1, { "--patch-monsca", "--no-patch-monsca" })) {
		return ParsePatchArguments(cp, arg, MonSca::patch_args);
	}
	if (cp.ParseNext(arg, 1, { "--patch-explus", "--no-patch-explus" })) {
		return ParsePatchArguments(cp, arg, EXPlus::patch_args);
	}
	if (cp.ParseNext(arg, 1, { "--patch-guardrevamp", "--no-patch-guardrevamp" })) {
		return ParsePatchArguments(cp, arg, GuardRevamp::patch_args);
	}
	return false;
}

bool RuntimePatches::ParseFromIni(lcf::INIReader& ini) {
	bool patch_override = false;
	patch_override |= ParsePatchFromIni(ini, EncounterRandomnessAlert::patch_args);
	patch_override |= ParsePatchFromIni(ini, MonSca::patch_args);
	patch_override |= ParsePatchFromIni(ini, EXPlus::patch_args);
	patch_override |= ParsePatchFromIni(ini, GuardRevamp::patch_args);
	return patch_override;
}

void RuntimePatches::DetermineActivePatches(std::vector<std::string>& patches) {
	PrintPatch(patches, EncounterRandomnessAlert::patch_args);
	PrintPatch(patches, MonSca::patch_args);
	PrintPatch(patches, EXPlus::patch_args);
	PrintPatch(patches, GuardRevamp::patch_args);
}

bool RuntimePatches::EncounterRandomnessAlert::HandleEncounter(int troop_id) {
	if (auto var_id = Player::game_config.patch_encounter_random_alert_var.Get(); var_id > 0) {
		Main_Data::game_player->SetTotalEncounterRate(0);
		Main_Data::game_player->SetEncounterCalling(false);

		Main_Data::game_variables->Set(var_id, troop_id);
		Game_Map::SetNeedRefreshForVarChange(var_id);

		if (auto switch_id = Player::game_config.patch_encounter_random_alert_sw.Get(); switch_id > 0) {
			Main_Data::game_switches->Set(switch_id, true);
			Game_Map::SetNeedRefreshForSwitchChange(switch_id);
		}
		// Always refresh the map (Original patch does this only for the MEPR variant)
		Game_Map::Refresh();
		return true;
	}
	return false;
}

namespace RuntimePatches::MonSca {
	bool UseLevelBasedFormula() {
		auto switch_id = Player::game_config.patch_monsca_levelscaling.Get();
		return switch_id > 0 && Main_Data::game_switches->Get(switch_id);
	}

	int GetVariableId(Game_Enemy const& enemy, int var_id) {
		if (Player::game_config.patch_monsca_plus.Get() > 0) {
			return var_id + enemy.GetTroopMemberId();
		}
		return var_id;
	}

	template<typename T>
	void ApplyScaling(Game_Enemy const& enemy, T& val, int var_id) {
		int mod = Main_Data::game_variables->Get(GetVariableId(enemy, var_id));
		if (mod == 0) {
			return;
		}
		if (UseLevelBasedFormula()) {
			mod *= Main_Data::game_party->GetAverageLevel();
		}
		val *= mod;
		val /= 1000;
	}
}

void RuntimePatches::MonSca::ModifyMaxHp(Game_Enemy const& enemy, int32_t& val) {
	if (auto var_id = Player::game_config.patch_monsca_maxhp.Get(); var_id > 0) {
		ApplyScaling(enemy, val, var_id);
	}
}

void RuntimePatches::MonSca::ModifyMaxSp(Game_Enemy const& enemy, int32_t& val) {
	if (auto var_id = Player::game_config.patch_monsca_maxsp.Get(); var_id > 0) {
		ApplyScaling(enemy, val, var_id);
	}
}

void RuntimePatches::MonSca::ModifyAtk(Game_Enemy const& enemy, int32_t& val) {
	if (auto var_id = Player::game_config.patch_monsca_atk.Get(); var_id > 0) {
		ApplyScaling(enemy, val, var_id);
	}
}

void RuntimePatches::MonSca::ModifyDef(Game_Enemy const& enemy, int32_t& val) {
	if (auto var_id = Player::game_config.patch_monsca_def.Get(); var_id > 0) {
		ApplyScaling(enemy, val, var_id);
	}
}

void RuntimePatches::MonSca::ModifySpi(Game_Enemy const& enemy, int32_t& val) {
	if (auto var_id = Player::game_config.patch_monsca_spi.Get(); var_id > 0) {
		ApplyScaling(enemy, val, var_id);
	}
}

void RuntimePatches::MonSca::ModifyAgi(Game_Enemy const& enemy, int32_t& val) {
	if (auto var_id = Player::game_config.patch_monsca_agi.Get(); var_id > 0) {
		ApplyScaling(enemy, val, var_id);
	}
}

void RuntimePatches::MonSca::ModifyExpGained(Game_Enemy const& enemy, int& val) {
	if (auto var_id = Player::game_config.patch_monsca_exp.Get(); var_id > 0) {
		ApplyScaling(enemy, val, var_id);
	}
}

void RuntimePatches::MonSca::ModifyMoneyGained(Game_Enemy const& enemy, int& val) {
	if (auto var_id = Player::game_config.patch_monsca_gold.Get(); var_id > 0) {
		ApplyScaling(enemy, val, var_id);
	}
}

void RuntimePatches::MonSca::ModifyItemGained(Game_Enemy const& enemy, int& item_id) {
	if (auto var_id = Player::game_config.patch_monsca_item.Get(); var_id > 0) {
		 item_id += Main_Data::game_variables->Get(GetVariableId(enemy, var_id));
	}
}

void RuntimePatches::MonSca::ModifyItemDropRate(Game_Enemy const& enemy, int& val) {
	if (auto var_id = Player::game_config.patch_monsca_droprate.Get(); var_id > 0) {
		ApplyScaling(enemy, val, var_id);
	}
}

void RuntimePatches::EXPlus::ModifyExpGain(Game_Actor& actor, int& exp_gain) {
	if (auto base_var_id = Player::game_config.patch_explus_var.Get(); base_var_id > 0) {
		exp_gain *= (100 + Main_Data::game_variables->Get(base_var_id + actor.GetPartyIndex()));
		exp_gain /= 100;
	}
}

void RuntimePatches::EXPlus::StoreActorPosition(int actor_id) {
	if (auto var_id = Player::game_config.patch_explusplus_var.Get(); var_id > 0) {
		Main_Data::game_variables->Set(var_id, Main_Data::game_party->GetActorPositionInParty(actor_id) + 1);
	}
}

bool RuntimePatches::GuardRevamp::OverrideDamageAdjustment(int& dmg, const Game_Battler& target) {
	auto rate_normal = Player::game_config.patch_guardrevamp_normal.Get();
	auto rate_strong = Player::game_config.patch_guardrevamp_strong.Get();

	if ((rate_normal > 0 || rate_strong > 0) && target.IsDefending()) {
		if (!target.HasStrongDefense()) {
			if (rate_normal == 0) {
				return false;
			}
			dmg *= rate_normal;
		} else {
			if (rate_strong == 0) {
				return false;
			}
			dmg *= rate_strong;
		}
		dmg /= 100;
		return true;
	}
	return false;
}


/*end of file .\game_runtime_patches.cpp*/

/*start of file .\game_screen.cpp*/

/* ... license chunk ... */

// Headers
#include <cmath>
#include "bitmap.h"
#include <lcf/data.h>
#include "player.h"
#include "game_battle.h"
#include "game_battler.h"
#include "game_screen.h"
#include "game_system.h"
#include "game_variables.h"
#include "game_map.h"
#include "output.h"
#include "utils.h"
#include "options.h"
#include <lcf/reader_util.h>
#include "scene.h"
#include "weather.h"
#include "flash.h"
#include "shake.h"
#include "rand.h"

Game_Screen::Game_Screen()
{
}

Game_Screen::~Game_Screen() {
}

void Game_Screen::SetSaveData(lcf::rpg::SaveScreen screen)
{
	CancelBattleAnimation();

	data = std::move(screen);
}

void Game_Screen::InitGraphics() {
	weather = std::make_unique<Weather>();
	OnWeatherChanged();

	if (data.battleanim_active) {
		ShowBattleAnimation(data.battleanim_id,
				data.battleanim_target,
				data.battleanim_global,
				data.battleanim_frame);
	}
}

void Game_Screen::OnMapChange() {
	data.flash_red = 0;
	data.flash_green = 0;
	data.flash_blue = 0;
	data.flash_time_left = 0;
	data.flash_current_level = 0;
	flash_sat = 0;
	flash_period = 0;

	if (data.tint_current_red < 0 ||
		data.tint_current_green < 0 ||
		data.tint_current_blue < 0 ||
		data.tint_current_sat < 0) {
		data.tint_current_red = 100;
		data.tint_current_green = 100;
		data.tint_current_blue = 100;
		data.tint_current_sat = 100;
	}

	movie_filename = "";
	movie_pos_x = 0;
	movie_pos_y = 0;
	movie_res_x = 0;
	movie_res_y = 0;

	data.battleanim_active = false;
	animation.reset();
}

void Game_Screen::TintScreen(int r, int g, int b, int s, int tenths) {
	data.tint_finish_red = r;
	data.tint_finish_green = g;
	data.tint_finish_blue = b;
	data.tint_finish_sat = s;

	data.tint_time_left = tenths;

	if (data.tint_time_left == 0) {
		data.tint_current_red = data.tint_finish_red;
		data.tint_current_green = data.tint_finish_green;
		data.tint_current_blue = data.tint_finish_blue;
		data.tint_current_sat = data.tint_finish_sat;
	}
}

void Game_Screen::FlashOnce(int r, int g, int b, int s, int frames) {
	data.flash_red = r;
	data.flash_green = g;
	data.flash_blue = b;
	flash_sat = s;
	data.flash_current_level = s;
	data.flash_time_left = frames;
	data.flash_continuous = false;
	flash_period = 0;
}

void Game_Screen::FlashBegin(int r, int g, int b, int s, int frames) {
	FlashOnce(r, g, b, s, frames);

	flash_period = frames;
	data.flash_continuous = true;
}

void Game_Screen::FlashEnd() {
	data.flash_time_left = 0;
	data.flash_current_level = 0;
	flash_period = 0;
	data.flash_continuous = false;
}

void Game_Screen::FlashMapStepDamage() {
	FlashOnce(31, 10, 10, 20, 6);
}

void Game_Screen::ShakeOnce(int power, int speed, int tenths) {
	data.shake_strength = power;
	data.shake_speed = speed;
	data.shake_time_left = tenths;
	data.shake_continuous = false;
	// Shake position is not reset in RPG_RT, so that multiple shakes
	// which interrupt each other flow smoothly.
}

void Game_Screen::ShakeBegin(int power, int speed) {
	data.shake_strength = power;
	data.shake_speed = speed;
	data.shake_time_left = Shake::kShakeContinuousTimeStart;
	data.shake_continuous = true;
	// Shake position is not reset in RPG_RT, so that multiple shakes
	// which interrupt each other flow smoothly.
}

void Game_Screen::ShakeEnd() {
	data.shake_position = 0;
	data.shake_time_left = 0;
	// RPG_RT does not turn off the continuous shake flag when shake is disabled.
}

void Game_Screen::SetWeatherEffect(int type, int strength) {
	// Some games call weather effects in a parallel process
	// This causes issues in the rendering (weather rendered too fast)
	if (data.weather != type ||
		data.weather_strength != strength) {
		data.weather = type;
		data.weather_strength = strength;
		OnWeatherChanged();
	}
}

void Game_Screen::PlayMovie(std::string filename,
							int pos_x, int pos_y, int res_x, int res_y) {
	movie_filename = std::move(filename);
	movie_pos_x = pos_x;
	movie_pos_y = pos_y;
	movie_res_x = res_x;
	movie_res_y = res_y;
}

static double interpolate(double d, double x0, double x1)
{
	return (x0 * (d - 1) + x1) / d;
}

void Game_Screen::StopWeather() {
	data.weather = Weather_None;
	OnWeatherChanged();
}

void Game_Screen::OnWeatherChanged() {
	int num_particles = Weather::GetMaxNumParticles(data.weather);

	InitParticles(num_particles);

	if (weather) {
		weather->OnWeatherChanged();
	}
}

void Game_Screen::InitParticles(int num_particles) {
	// RPG_RT initializes all particles on new game / load game.
	// We do it lazily instead. That way for games which don't use
	// weather effects, we never consume memory for those effects.
	auto sz = static_cast<int>(particles.size());

	if (num_particles <= sz) {
		return;
	}

	particles.resize(num_particles);

	for (int i = sz; i < num_particles; ++i) {
		auto& p = particles[i];
		// RPG_RT always initializes all particles to these values on startup.
		// This can cause minor visual glitches for the first few frames the
		// first time you start the sandstorm effect. We're bug compatible with RPG_RT.
		p.t = Rand::GetRandomNumber(0, 39);
		p.x = Rand::GetRandomNumber(0, GetPanLimitX() / 16 - 1);
		p.y = Rand::GetRandomNumber(0, GetPanLimitY() / 16 - 1);
	}
}

void Game_Screen::UpdateRain() {
	for (auto& p: particles) {
		if (p.t > 0) {
			--p.t;
			p.y += 4;
			p.x -= 1;
		} else if (Rand::PercentChance(10)) {
			p.t = 12;
			p.x = Rand::GetRandomNumber(0, GetPanLimitX() / 16 - 1);
			p.y = Rand::GetRandomNumber(0, GetPanLimitY() / 16 - 1);
		}
	}
}

void Game_Screen::UpdateSnow() {
	for (auto& p: particles) {
		if (p.t > 0) {
			--p.t;
			p.x -= Rand::GetRandomNumber(0, 1);
			p.y += Rand::GetRandomNumber(2, 3);
		} else if (Rand::PercentChance(5)) {
			p.t = 30;
			p.x = Rand::GetRandomNumber(0, GetPanLimitX() / 16 - 1);
			p.y = Rand::GetRandomNumber(0, GetPanLimitY() / 16 - 1);
		}
	}
}

void Game_Screen::UpdateFog() {
	++particles[0].x;
	++particles[1].x;
}

void Game_Screen::UpdateSandstorm() {
	// RPG_RT takes random numbers in the inclusive range [1, 127] and has a function
	// which takes [0, 255) -> [0, 2 * M_PI) and computes sin or cos. This epsilson
	// accounts for the range starting at 1 (not 0) and ending at 127 (not 128).

	constexpr auto epsilon = 1.0f / 128.0f;
	auto& rng = Rand::GetRNG();
	auto dist = std::uniform_real_distribution<float>(epsilon, M_PI - epsilon);

	UpdateFog();

	for (size_t i = 2; i < particles.size(); ++i) {
		auto& p = particles[i];
		if (p.t > 0) {
			--p.t;
			p.alpha += 2;
			p.x += static_cast<int>(p.vx);
			p.y += static_cast<int>(p.vy);
			p.vx += p.ax;
			p.vy += p.ay;
		} else if (Rand::PercentChance(10)) {
			p.t = 80;

			auto c = std::cos(dist(rng));
			auto s = std::sin(dist(rng));
			auto d = Rand::GetRandomNumber(16, 95);

			p.x = static_cast<int>(d * c * 2.0f) * Player::screen_width / 320 + Player::screen_width / 2;
			p.y = static_cast<int>(d * s) * Player::screen_height / 240;

			p.alpha = 180;
			p.vx = 0.0;
			p.vy = 0.0;
			p.ax = c * 2.0f * Player::screen_width / 320;
			p.ay = s * 2.0f * Player::screen_height / 240;
		}
	}
}

void Game_Screen::OnMapScrolled(int dx, int dy) {
	auto pan_limit_x = GetPanLimitX();
	auto pan_limit_y = GetPanLimitY();

	data.pan_x = (data.pan_x - dx + pan_limit_x) % pan_limit_x;
	data.pan_y = (data.pan_y - dy + pan_limit_y) % pan_limit_y;
}

void Game_Screen::UpdateScreenEffects() {
	if (data.tint_time_left > 0) {
		data.tint_current_red = interpolate(data.tint_time_left, data.tint_current_red, data.tint_finish_red);
		data.tint_current_green = interpolate(data.tint_time_left, data.tint_current_green, data.tint_finish_green);
		data.tint_current_blue = interpolate(data.tint_time_left, data.tint_current_blue, data.tint_finish_blue);
		data.tint_current_sat = interpolate(data.tint_time_left, data.tint_current_sat, data.tint_finish_sat);
		data.tint_time_left = data.tint_time_left - 1;
	}

	Flash::Update(data.flash_current_level,
			data.flash_time_left,
			data.flash_continuous,
			flash_period,
			flash_sat);

	Shake::Update(data.shake_position,
			data.shake_time_left,
			data.shake_strength,
			data.shake_speed,
			data.shake_continuous);
}

void Game_Screen::UpdateMovie() {
	if (!movie_filename.empty()) {
		/* update movie */
	}
}

void Game_Screen::UpdateWeather() {
	switch (data.weather) {
		case Weather_None:
			break;
		case Weather_Rain:
			UpdateRain();
			break;
		case Weather_Snow:
			UpdateSnow();
			break;
		case Weather_Fog:
			UpdateFog();
			break;
		case Weather_Sandstorm:
			UpdateSandstorm();
			break;
	}
}

void Game_Screen::Update() {
	UpdateScreenEffects();
	UpdateMovie();
	UpdateWeather();
	UpdateBattleAnimation();
}

int Game_Screen::ShowBattleAnimation(int animation_id, int target_id, bool global, int start_frame) {
	const lcf::rpg::Animation* anim = lcf::ReaderUtil::GetElement(lcf::Data::animations, animation_id);
	if (!anim) {
		Output::Warning("ShowBattleAnimation: Invalid battle animation ID {}", animation_id);
		return 0;
	}

	auto* chara = Game_Character::GetCharacter(target_id, target_id);
	if (!chara) {
		Output::Warning("ShowBattleAnimation: Invalid target event ID {}", target_id);
		CancelBattleAnimation();
		return 0;
	}

	data.battleanim_id = animation_id;
	data.battleanim_target = target_id;
	data.battleanim_global = global;
	data.battleanim_active = true;
	data.battleanim_frame = start_frame;

	animation.reset(new BattleAnimationMap(*anim, *chara, global));

	if (start_frame) {
		animation->SetFrame(start_frame);
	}

	return animation->GetFrames();
}

void Game_Screen::UpdateBattleAnimation() {
	if (animation) {
		if (!animation->IsDone()) {
			animation->Update();
			data.battleanim_frame = animation->GetFrame();
		}

		if (animation->IsDone() && !Game_Battle::IsBattleRunning()) {
			// FIXME: Lifetime is flawed but we need the animation in battle for
			// SE and flash. Delay destruction until back on the map.
			CancelBattleAnimation();
		}
	}
}

void Game_Screen::CancelBattleAnimation() {
	data.battleanim_frame = animation ?
		animation->GetFrames() : 0;
	data.battleanim_active = false;
	animation.reset();
}

void Game_Screen::UpdateUnderlyingEventReferences() {
	if (!IsBattleAnimationWaiting()) {
		return;
	}

	auto* chara = Game_Character::GetCharacter(data.battleanim_target, data.battleanim_target);
	if (!chara) {
		// Event was deleted
		CancelBattleAnimation();
	} else {
		animation->SetTarget(*chara);
	}
}


/*end of file .\game_screen.cpp*/

/*start of file .\game_strings.cpp*/

/* ... license chunk ... */

 // Headers
#include <regex>
#include <lcf/encoder.h>
#include <lcf/reader_util.h>
#include "async_handler.h"
#include "game_map.h"
#include "game_message.h"
#include "game_strings.h"
#include "game_switches.h"
#include "game_variables.h"
#include "output.h"
#include "player.h"
#include "utils.h"

#ifdef HAVE_NLOHMANN_JSON
#include "json_helper.h"
#endif

void Game_Strings::WarnGet(int id) const {
	Output::Debug("Invalid read strvar[{}]!", id);
	--_warnings;
}

#ifdef HAVE_NLOHMANN_JSON
nlohmann::ordered_json* Game_Strings::ParseJson(int id) {
	auto it = _json_cache.find(id);
	if (it != _json_cache.end()) {
		return &(it->second);
	}

	auto str = ToString(Get(id));
	auto res = Json_Helper::Parse(str);

	if (!res) {
		return nullptr;
	} else {
		_json_cache[id] = *res;
		return &_json_cache[id];
	}
}
#endif

std::string_view Game_Strings::Asg(Str_Params params, std::string_view string) {
	Set(params, string);
	return Get(params.string_id);
}

std::string_view Game_Strings::Cat(Str_Params params, std::string_view string) {
	if (params.string_id <= 0) {
		return {};
	}

	auto it = _strings.find(params.string_id);
	if (it == _strings.end()) {
		Set(params, string);
		return Get(params.string_id);
	}
	it->second += ToString(string);
	return it->second;
}

int Game_Strings::ToNum(Str_Params params, int var_id, Game_Variables& variables) {
	if (params.string_id <= 0) {
		return -1;
	}

	auto it = _strings.find(params.string_id);
	if (it == _strings.end()) {
		return 0;
	}

	int num;
	if (params.hex)
		num = static_cast<int>(std::strtol(it->second.c_str(), nullptr, 16));
	else
		num = static_cast<int>(std::strtol(it->second.c_str(), nullptr, 0));

	variables.Set(var_id, num);

	Game_Map::SetNeedRefreshForVarChange(var_id);

	return num;
}

int Game_Strings::GetLen(Str_Params params, int var_id, Game_Variables& variables) const {
	if (params.string_id <= 0) {
		return -1;
	}

	int len = Utils::UTF8Length(Get(params.string_id));
	variables.Set(var_id, len);

	Game_Map::SetNeedRefreshForVarChange(var_id);

	return len;
}

int Game_Strings::InStr(Str_Params params, std::string search, int var_id, int begin, Game_Variables& variables) const {
	if (params.string_id <= 0) {
		return -1;
	}

	if (params.extract) {
		search = Extract(search, params.hex);
	}

	auto search32 = Utils::DecodeUTF32(search);
	auto string32 = Utils::DecodeUTF32(Get(params.string_id));

	int index = string32.find(search32, begin);
	variables.Set(var_id, index);

	Game_Map::SetNeedRefreshForVarChange(var_id);

	return index;
}

int Game_Strings::Split(Str_Params params, const std::string& delimiter, int string_out_id, int var_id, Game_Variables& variables) {
	if (params.string_id <= 0) {
		return -1;
	}

	std::string str = ToString(Get(params.string_id));

	params.string_id = string_out_id;

	int components = 0;

	if (delimiter.empty()) {
		// Count the characters (or the codepoints in our case)
		components = 0;
		const char* iter = str.data();
		const auto end = str.data() + str.size();

		while (iter != end) {
			const char* start_copy = iter;
			auto ret = Utils::UTF8Next(iter, end);
			iter = ret.next;

			if (iter == end) {
				break;
			}

			Set(params, std::string(start_copy, iter - start_copy));

			params.string_id++;
			components++;
		}
	} else {
		components = 1;

		if (str.find(delimiter) == std::string::npos) {
			// token not found
		} else {
			// This works for UTF-8
			std::string token;
			for (auto index = str.find(delimiter); index != std::string::npos; index = str.find(delimiter)) {
				token = str.substr(0, index);
				Set(params, token);
				params.string_id++;
				components++;
				str.erase(0, index + delimiter.length());
			}
		}
	}

	// set the remaining string
	Set(params, str);
	variables.Set(var_id, components);

	Game_Map::SetNeedRefreshForVarChange(var_id);

	return components;
}

std::string Game_Strings::FromFile(std::string_view filename, int encoding, bool& do_yield) {
	do_yield = false;

	Filesystem_Stream::InputStream is = FileFinder::OpenText(filename);
	if (!is) {
		// Emscripten: Try to async fetch the file
		auto* request = AsyncHandler::RequestFile("Text", filename);
		request->SetImportantFile(true);
		request->Start();
		do_yield = !request->IsReady();

		return {};
	}

	auto vec = Utils::ReadStream(is);
	std::string file_content(vec.begin(), vec.end());

	if (encoding == 0) {
		lcf::Encoder enc(Player::encoding);
		enc.Encode(file_content);
	} else {
		// UTF-8: Remove Byte Order Mask
		if (file_content.size() >= 3 && file_content[0] == '\xEF' && file_content[1] == '\xBB' && file_content[2] == '\xBF') {
			file_content.erase(0, 3);
		}
	}

	return file_content;
}

bool Game_Strings::ToFile(Str_Params params, std::string filename, int encoding) {
	std::string str = ToString(Get(params.string_id));

	if (params.extract) {
		filename = Extract(filename, params.hex);
	}

	// Maniacs forces the File in Text/ folder with .txt extension
	filename = "Text/" + filename;

	// EasyRPG Extension: When "*" is at the end of filename, ".txt" is not appended
	if (Player::HasEasyRpgExtensions() && filename.back() == '*') {
		filename.pop_back();
	} else {
		filename += ".txt";
	}

	auto txt_out = FileFinder::Save().OpenOutputStream(filename);
	auto txt_dir = FileFinder::GetPathAndFilename(filename).first;

	if (!txt_out) {
		if (!FileFinder::Save().MakeDirectory(txt_dir, false)) {
			Output::Warning("Maniac String Op ToFile failed. Cannot create directory {}", txt_dir);
			return false;
		}

		txt_out = FileFinder::Save().OpenOutputStream(filename);
		if (!txt_out) {
			Output::Warning("Maniac String Op ToFile failed. Cannot write to {}", filename);
			return false;
		}
	}

	if (encoding == 0) {
		lcf::Encoder enc(Player::encoding);
		enc.Decode(str);
	}

	txt_out << str;
	txt_out.Close();

	AsyncHandler::SaveFilesystem();

	return true;
}

std::string_view Game_Strings::PopLine(Str_Params params, int offset, int string_out_id) {
	// FIXME: consideration needed around encoding -- what mode are files read in?
	if (params.string_id <= 0) {
		return {};
	}

	std::string result;
	std::string_view str = Get(params.string_id);

	std::stringstream ss(ToString(str));

	while (offset >= 0 && Utils::ReadLine(ss, result)) { offset--; }

	offset = ss.rdbuf()->in_avail();

	Set(params, ss.str().substr(str.length() - offset));

	// the maniacs implementation is to always preserve the mutated base string
	// so in the case where the out_id matches the base string id, the popped line is discarded.
	if (string_out_id != params.string_id) {
		params.string_id = string_out_id;
		Set(params, result);
	}
	return Get(params.string_id);
}

std::string_view Game_Strings::ExMatch(Str_Params params, std::string expr, int var_id, int begin, int string_out_id, Game_Variables& variables) {
	// std::regex only works with char and wchar, not char32
	// For full Unicode support requires the w-API, even on non-Windows systems
	int var_result;
	std::string str_result;

	if (params.extract) {
		expr = Extract(expr, params.hex);
	}

	auto source = Get(params.string_id);
	std::string base = Substring(source, begin, Utils::UTF8Length(source));

	std::wsmatch match;
	auto wbase = Utils::ToWideString(base);
	auto wexpr = Utils::ToWideString(expr);

	std::wregex r(wexpr);

	std::regex_search(wbase, match, r);
	str_result = Utils::FromWideString(match.str());

	var_result = match.position() + begin;
	variables.Set(var_id, var_result);
	Game_Map::SetNeedRefreshForVarChange(var_id);

	if (string_out_id > 0) {
		params.string_id = string_out_id;
		Set(params, str_result);

		return Get(params.string_id);
	}
	return {};
}

const Game_Strings::Strings_t& Game_Strings::RangeOp(Str_Params params, int string_id_1, std::string string, int op, int args[], Game_Variables& variables) {
	if (EP_UNLIKELY(ShouldWarn(params.string_id))) {
		WarnGet(params.string_id);
	}
	if (EP_UNLIKELY(ShouldWarn(string_id_1))) {
		WarnGet(string_id_1);
	}
	if (params.string_id <= 0 && string_id_1 <= 0) { return GetData(); }

	// maniacs just ignores if only one of the params is <= 0
	if (params.string_id <= 0) { params.string_id = 1; }
	if (string_id_1 <= 0) {	string_id_1 = 1; }

	// swap so that id_0 is < id_1
	if (params.string_id > string_id_1) {
		std::swap(params.string_id, string_id_1);
	}

	for (int start = params.string_id; params.string_id <= string_id_1; params.string_id++) {
		switch (op) {
		case 0:  Asg(params, string); break;
		case 1:  Cat(params, string); break;
		case 2:  ToNum(params, args[0] + (params.string_id - start), variables); break;
		case 3:  GetLen(params, args[0] + (params.string_id - start), variables); break;
		case 4:  InStr(params, string, args[1], args[2], variables); break;
		case 5:  params.string_id += Split(params, string, args[1], args[2], variables); break;
		case 8:  break; // range case not applicable for popLine; see case in game_interpreter.cpp
		case 9:  ExMatch(params, string, args[1] + (params.string_id - start), args[2], -1, variables); break;
		case 10: ExMatch(params, string, args[1] + (params.string_id - start), args[2], args[3], variables); break;
		}
	}
	return GetData();
}

std::string Game_Strings::PrependMin(std::string_view string, int min_size, char c) {
	int len = Utils::UTF8Length(string);

	if (min_size < 0) {
		// Left adjust
		min_size = abs(min_size);
		if (len < min_size) {
			int s = min_size - len;
			return ToString(string) + std::string(s, c);
		}
	} else if (len < min_size) {
		// Right adjust
		int s = min_size - len;
		return std::string(s, c) + ToString(string);
	}
	return ToString(string);
}

std::string Game_Strings::Extract(std::string_view string, bool as_hex) {
	PendingMessage::CommandInserter cmd_fn;

	if (as_hex) {
		cmd_fn = ManiacsCommandInserterHex;
	} else {
		cmd_fn = ManiacsCommandInserter;
	}

	return PendingMessage::ApplyTextInsertingCommands(ToString(string), Player::escape_char, cmd_fn);
}

std::string Game_Strings::Substring(std::string_view source, int begin, int length) {
	const char* iter = source.data();
	const auto end = source.data() + source.size();

	begin = AdjustIndex(source, begin);

	if (length < 0) {
		length = 0;
	}

	// Points at start of the substring
	auto left = Utils::UTF8Skip(iter, end, begin);

	// Points at end of the substring
	auto right = Utils::UTF8Skip(left.next, end, length);

	if (right.next == nullptr) {
		return std::string(left.next, end);
	} else {
		return std::string(left.next, right.next);
	}
}

std::string Game_Strings::Insert(std::string_view source, std::string_view what, int where) {
	const char* iter = source.data();
	const auto end = source.data() + source.size();

	where = AdjustIndex(source, where);

	// Points at insertion location
	auto ret = Utils::UTF8Skip(iter, end, where);

	return std::string(source.data(), ret.next) + ToString(what) + std::string(ret.next, end);
}

std::string Game_Strings::Erase(std::string_view source, int begin, int length) {
	const char* iter = source.data();
	const auto end = source.data() + source.size();

	begin = AdjustIndex(source, begin);

	if (length < 0) {
		length = 0;
	}

	// Points at start of deletion
	auto left = Utils::UTF8Skip(iter, end, begin);

	if (left.next == nullptr) {
		return ToString(source);
	}

	// Points at end of deletion
	auto right = Utils::UTF8Skip(left.next, end, length);

	std::string ret = std::string(source.data(), left.next);
	if (right.next != nullptr) {
		ret += std::string(right.next, end);
	}

	return ret;
}

std::string Game_Strings::RegExReplace(std::string_view str, std::string_view search, std::string_view replace, std::regex_constants::match_flag_type flags) {
	// std::regex only works with char and wchar, not char32
	// For full Unicode support requires the w-API, even on non-Windows systems
	auto wstr = Utils::ToWideString(str);
	auto wsearch = Utils::ToWideString(search);
	auto wreplace = Utils::ToWideString(replace);

	std::wregex rexp(wsearch);

	auto result = std::regex_replace(wstr, rexp, wreplace, flags);

	return Utils::FromWideString(result);
}

int Game_Strings::AdjustIndex(std::string_view str, int index) {
	if (index >= 0) {
		return index;
	}

	return std::max(Utils::UTF8Length(str) - abs(index), 0);
}

std::optional<std::string> Game_Strings::ManiacsCommandInserter(char ch, const char** iter, const char* end, uint32_t escape_char) {
	if (ch == 'S' || ch == 's') {
		// \s in a normal message is the speed modifier
		// parsing a switch within an extracted string var command will parse \s[N] as a switch (ON/OFF)
		auto parse_ret = Game_Message::ParseSpeed(*iter, end, escape_char, true);
		*iter = parse_ret.next;
		int value = parse_ret.value;

		return Main_Data::game_switches->Get(value) ? "ON" : "OFF";
	} else if (ch == 'T' || ch == 't') {
		auto parse_ret = Game_Message::ParseString(*iter, end, escape_char, true);
		*iter = parse_ret.next;
		int value = parse_ret.value;

		// Contrary to Messages, the content of \t[]-strings is not evaluated
		return ToString(Main_Data::game_strings->Get(value));
	}

	return Game_Message::CommandCodeInserter(ch, iter, end, escape_char);
};

std::optional<std::string> Game_Strings::ManiacsCommandInserterHex(char ch, const char** iter, const char* end, uint32_t escape_char) {
	if (ch == 'V' || ch == 'v') {
		auto parse_ret = Game_Message::ParseVariable(*iter, end, escape_char, true);
		*iter = parse_ret.next;
		int value = parse_ret.value;

		int variable_value = Main_Data::game_variables->Get(value);
		std::ostringstream ss;
		ss << std::hex << variable_value;
		return ss.str();
	}

	return ManiacsCommandInserter(ch, iter, end, escape_char);
};

int Game_Strings::GetSizeWithLimit() {
	if (_size < 0) {
		_size = 0;
		for (auto& [index, value] : _strings) {
			assert(index > 0);
			if (index > _size) {
				_size = index;
			}
		}
	}
	return std::max(_size, static_cast<int>(lcf::Data::maniac_string_variables.size()));
}

std::string_view Game_Strings::GetName(int id) const {
	const auto* strvar = lcf::ReaderUtil::GetElement(lcf::Data::maniac_string_variables, id);

	if (!strvar) {
		return {};
	} else {
		return strvar->name;
	}
}


/*end of file .\game_strings.cpp*/

/*start of file .\game_switches.cpp*/

/* ... license chunk ... */

// Headers
#include "game_switches.h"
#include "output.h"
#include <lcf/reader_util.h>
#include <lcf/data.h>

void Game_Switches::WarnGet(int variable_id) const {
	Output::Debug("Invalid read sw[{}]!", variable_id);
	--_warnings;
}

bool Game_Switches::Set(int switch_id, bool value) {
	if (EP_UNLIKELY(ShouldWarn(switch_id, switch_id))) {
		Output::Debug("Invalid write sw[{}] = {}!", switch_id, value);
		--_warnings;
	}
	if (switch_id <= 0) {
		return false;
	}
	auto& ss = _switches;
	if (switch_id > static_cast<int>(ss.size())) {
		ss.resize(switch_id);
	}
	ss[switch_id - 1] = value;
	return value;
}

void Game_Switches::SetRange(int first_id, int last_id, bool value) {
	if (EP_UNLIKELY(ShouldWarn(first_id, last_id))) {
		Output::Debug("Invalid write sw[{},{}] = {}!", first_id, last_id, value);
		--_warnings;
	}
	auto& ss = _switches;
	if (last_id > static_cast<int>(ss.size())) {
		ss.resize(last_id, false);
	}
	for (int i = std::max(0, first_id - 1); i < last_id; ++i) {
		ss[i] = value;
	}
}

bool Game_Switches::Flip(int switch_id) {
	if (EP_UNLIKELY(ShouldWarn(switch_id, switch_id))) {
		Output::Debug("Invalid flip sw[{}]!", switch_id);
		--_warnings;
	}
	if (switch_id <= 0) {
		return false;
	}
	auto& ss = _switches;
	if (switch_id > static_cast<int>(ss.size())) {
		ss.resize(switch_id);
	}
	ss[switch_id - 1].flip();
	return ss[switch_id - 1];
}

void Game_Switches::FlipRange(int first_id, int last_id) {
	if (EP_UNLIKELY(ShouldWarn(first_id, last_id))) {
		Output::Debug("Invalid flip sw[{},{}]!", first_id, last_id);
		--_warnings;
	}
	auto& ss = _switches;
	if (last_id > static_cast<int>(ss.size())) {
		ss.resize(last_id);
	}
	for (int i = std::max(0, first_id - 1); i < last_id; ++i) {
		ss[i].flip();
	}
}

std::string_view Game_Switches::GetName(int _id) const {
	const auto* sw = lcf::ReaderUtil::GetElement(lcf::Data::switches, _id);

	if (!sw) {
		// No warning, is valid because the switch array resizes dynamic during runtime
		return {};
	} else {
		return sw->name;
	}
}



/*end of file .\game_switches.cpp*/

/*start of file .\game_system.cpp*/

/* ... license chunk ... */

// Headers
#include <fstream>
#include <functional>
#include "game_system.h"
#include "async_handler.h"
#include "game_battle.h"
#include "audio.h"
#include "baseui.h"
#include "bitmap.h"
#include "cache.h"
#include "output.h"
#include "game_ineluki.h"
#include "transition.h"
#include "main_data.h"
#include "player.h"
#include <lcf/reader_util.h>
#include "scene_save.h"
#include "scene_map.h"
#include "utils.h"
#include "audio_secache.h"
#include "feature.h"

Game_System::Game_System()
	: dbsys(&lcf::Data::system)
{ }

void Game_System::SetupFromSave(lcf::rpg::SaveSystem save) {
	data = std::move(save);
	loaded_frame_count = data.frame_count;
}

const lcf::rpg::SaveSystem& Game_System::GetSaveData() const {
	return data;
}

bool Game_System::IsStopFilename(std::string_view name, Filesystem_Stream::InputStream (*find_func) (std::string_view), Filesystem_Stream::InputStream& found_stream) {
	if (name.empty() || name == "(OFF)") {
		found_stream = Filesystem_Stream::InputStream();
		return true;
	}

	found_stream = find_func(name);

	return !found_stream && (StartsWith(name, '(') && EndsWith(name, ')'));
}

bool Game_System::IsStopMusicFilename(std::string_view name, Filesystem_Stream::InputStream& found_stream) {
	return IsStopFilename(name, FileFinder::OpenMusic, found_stream);
}

bool Game_System::IsStopSoundFilename(std::string_view name, Filesystem_Stream::InputStream& found_stream) {
	return IsStopFilename(name, FileFinder::OpenSound, found_stream);
}

void Game_System::BgmPlay(lcf::rpg::Music const& bgm) {
	lcf::rpg::Music previous_music = data.current_music;
	data.current_music = bgm;

	// Validate
	if (bgm.volume < 0 || bgm.volume > 100) {
		data.current_music.volume = Utils::Clamp<int32_t>(bgm.volume, 0, 100);

		Output::Debug("BGM {} has invalid volume {}", bgm.name, bgm.volume);
	}

	if (bgm.fadein < 0 || bgm.fadein > 10000) {
		data.current_music.fadein = Utils::Clamp<int32_t>(bgm.fadein, 0, 10000);

		Output::Debug("BGM {} has invalid fadein {}", bgm.name, bgm.fadein);
	}

	// Normal pitch is 50 to 200 but Yume2kki uses out of range values
	if (bgm.tempo < 10 || bgm.tempo > 400) {
		data.current_music.tempo = Utils::Clamp<int32_t>(bgm.tempo, 10, 400);

		Output::Debug("BGM {} has invalid tempo {}", bgm.name, bgm.tempo);
	}

	if (bgm.balance < 0 || bgm.balance > 100) {
		data.current_music.balance = Utils::Clamp<int32_t>(bgm.balance, 0, 100);

		Output::Debug("BGM {} has invalid balance {}", bgm.name, bgm.balance);
	}

	// (OFF) means play nothing
	if (!bgm.name.empty() && bgm.name != "(OFF)") {
		// Same music: Only adjust volume and speed
		if (!data.music_stopping && previous_music.name == bgm.name) {
			if (previous_music.volume != data.current_music.volume) {
				if (!bgm_pending) { // Delay if not ready
					Audio().BGM_Volume(data.current_music.volume);
				}
			}
			if (previous_music.tempo != data.current_music.tempo) {
				if (!bgm_pending) { // Delay if not ready
					Audio().BGM_Pitch(data.current_music.tempo);
				}
			}
			if (previous_music.balance != data.current_music.balance) {
				if (!bgm_pending) {
					Audio().BGM_Balance(data.current_music.balance);
				}
			}
		} else {
			Audio().BGM_Stop();
			bgm_pending = true;
			FileRequestAsync* request = AsyncHandler::RequestFile("Music", bgm.name);
			music_request_id = request->Bind(&Game_System::OnBgmReady, this);
			request->Start();
		}
	} else {
		BgmStop();
	}

	data.music_stopping = false;
}

void Game_System::BgmStop() {
	music_request_id = FileRequestBinding();
	data.current_music.name = "(OFF)";
	Audio().BGM_Stop();
}

void Game_System::BgmFade(int duration, bool clear_current_music) {
	Audio().BGM_Fade(duration);
	if (clear_current_music) {
		data.current_music.name = "(OFF)";
	}
	data.music_stopping = true;
}

bool Game_System::BgmPlayedOnce() {
	if (Audio().BGM_PlayedOnce()) {
		if (Audio().BGM_GetType() == "wav") {
			// RPG_RT does not report looping for WAV
			return false;
		}
		return true;
	}

	return false;
}

void Game_System::SePlay(const lcf::rpg::Sound& se, bool stop_sounds) {
	if (se.name.empty()) {
		return;
	} else if (se.name == "(OFF)") {
		if (stop_sounds) {
			Audio().SE_Stop();
		}
		return;
	}

	// NOTE: Yume Nikki plays hundreds of sound effects at 0% volume on startup,
	// probably for caching. This avoids "No free channels" warnings.
	if (se.volume == 0)
		return;

	int32_t volume = se.volume;
	int32_t tempo = se.tempo;
	int32_t balance = se.balance;

	// Validate
	if (volume < 0 || volume > 100) {
		Output::Debug("SE {} has invalid volume {}", se.name, volume);
		volume = Utils::Clamp<int32_t>(volume, 0, 100);
	}

	// Normal pitch is 50 to 200 but Yume2kki uses out of range values
	if (tempo < 10 || tempo > 400) {
		Output::Debug("SE {} has invalid tempo {}", se.name, tempo);
		tempo = Utils::Clamp<int32_t>(se.tempo, 10, 400);
	}

	if (balance < 0 || balance > 100) {
		Output::Debug("SE {} has invalid balance {}", se.name, balance);
		balance = Utils::Clamp<int32_t>(se.balance, 0, 100);
	}

	FileRequestAsync* request = AsyncHandler::RequestFile("Sound", se.name);
	lcf::rpg::Sound se_adj = se;
	se_adj.volume = volume;
	se_adj.tempo = tempo;
	se_adj.balance = balance;
	se_request_ids[se.name] = request->Bind(&Game_System::OnSeReady, this, se_adj, stop_sounds);
	if (EndsWith(se.name, ".script")) {
		// Is a Ineluki Script File
		request->SetImportantFile(true);
	}
	request->Start();
}

void Game_System::SePlay(const lcf::rpg::Animation &animation) {
	Filesystem_Stream::InputStream stream;
	for (const auto& anim : animation.timings) {
		if (!IsStopSoundFilename(anim.se.name, stream)) {
			SePlay(anim.se);
			return;
		}
	}
}

std::string_view Game_System::GetSystemName() {
	return !data.graphics_name.empty() ?
		std::string_view(data.graphics_name) : std::string_view(lcf::Data::system.system_name);
}

void Game_System::OnChangeSystemGraphicReady(FileRequestResult* result) {
	Cache::SetSystemName(result->file);
	bg_color = Cache::SystemOrBlack()->GetBackgroundColor();

	Scene_Map* scene = (Scene_Map*)Scene::Find(Scene::Map).get();
	if (!scene || !scene->spriteset)
		return;
	scene->spriteset->SystemGraphicUpdated();
}

void Game_System::ReloadSystemGraphic() {
	FileRequestAsync* request = AsyncHandler::RequestFile("System", GetSystemName());
	system_request_id = request->Bind(&Game_System::OnChangeSystemGraphicReady, this);
	request->SetImportantFile(true);
	request->SetGraphicFile(true);
	request->Start();
}

void Game_System::SetSystemGraphic(const std::string& new_system_name,
		lcf::rpg::System::Stretch message_stretch,
		lcf::rpg::System::Font font) {

	bool changed = (GetSystemName() != new_system_name);

	data.graphics_name = new_system_name;
	data.message_stretch = message_stretch;
	data.font_id = font;

	if (changed) {
		ReloadSystemGraphic();
	}
}

void Game_System::ResetSystemGraphic() {
	data.graphics_name = "";
	data.message_stretch = (lcf::rpg::System::Stretch)0;
	data.font_id = (lcf::rpg::System::Font)0;

	ReloadSystemGraphic();
}

template <typename T>
static const T& GetAudio(const T& save, const T& db) {
	return save.name.empty() ? db : save;
}

template <typename T>
static void SetAudio(T& save, const T& db, T update) {
	if (update == db) {
		// RPG_RT only clears the name, but leaves the rest of the values alone
		save.name = {};
	} else {
		save = std::move(update);
	}
}

const lcf::rpg::Music& Game_System::GetSystemBGM(int which) {
	switch (which) {
		case BGM_Battle:
			return GetAudio(data.battle_music, dbsys->battle_music);
		case BGM_Victory:
			return GetAudio(data.battle_end_music, dbsys->battle_end_music);
		case BGM_Inn:
			return GetAudio(data.inn_music, dbsys->inn_music);
		case BGM_Boat:
			return GetAudio(data.boat_music, dbsys->boat_music);
		case BGM_Ship:
			return GetAudio(data.ship_music, dbsys->ship_music);
		case BGM_Airship:
			return GetAudio(data.airship_music, dbsys->airship_music);
		case BGM_GameOver:
			return GetAudio(data.gameover_music, dbsys->gameover_music);
	}

	static lcf::rpg::Music empty;
	return empty;
}

void Game_System::SetSystemBGM(int which, lcf::rpg::Music bgm) {
	switch (which) {
		case BGM_Battle:
			SetAudio(data.battle_music, dbsys->battle_music, std::move(bgm));
			break;
		case BGM_Victory:
			SetAudio(data.battle_end_music, dbsys->battle_end_music, std::move(bgm));
			break;
		case BGM_Inn:
			SetAudio(data.inn_music, dbsys->inn_music, std::move(bgm));
			break;
		case BGM_Boat:
			SetAudio(data.boat_music, dbsys->boat_music, std::move(bgm));
			break;
		case BGM_Ship:
			SetAudio(data.ship_music, dbsys->ship_music, std::move(bgm));
			break;
		case BGM_Airship:
			SetAudio(data.airship_music, dbsys->airship_music, std::move(bgm));
			break;
		case BGM_GameOver:
			SetAudio(data.gameover_music, dbsys->gameover_music, std::move(bgm));
			break;
	}
}

const lcf::rpg::Sound& Game_System::GetSystemSE(int which) {
	switch (which) {
		case SFX_Cursor:
			return GetAudio(data.cursor_se, dbsys->cursor_se);
		case SFX_Decision:
			return GetAudio(data.decision_se, dbsys->decision_se);
		case SFX_Cancel:
			return GetAudio(data.cancel_se, dbsys->cancel_se);
		case SFX_Buzzer:
			return GetAudio(data.buzzer_se, dbsys->buzzer_se);
		case SFX_BeginBattle:
			return GetAudio(data.battle_se, dbsys->battle_se);
		case SFX_Escape:
			return GetAudio(data.escape_se, dbsys->escape_se);
		case SFX_EnemyAttacks:
			return GetAudio(data.enemy_attack_se, dbsys->enemy_attack_se);
		case SFX_EnemyDamage:
			return GetAudio(data.enemy_damaged_se, dbsys->enemy_damaged_se);
		case SFX_AllyDamage:
			return GetAudio(data.actor_damaged_se, dbsys->actor_damaged_se);
		case SFX_Evasion:
			return GetAudio(data.dodge_se, dbsys->dodge_se);
		case SFX_EnemyKill:
			return GetAudio(data.enemy_death_se, dbsys->enemy_death_se);
		case SFX_UseItem:
			return GetAudio(data.item_se, dbsys->item_se);
	}

	static lcf::rpg::Sound empty;
	return empty;
}

void Game_System::SetSystemSE(int which, lcf::rpg::Sound sfx) {
	switch (which) {
		case SFX_Cursor:
			SetAudio(data.cursor_se, dbsys->cursor_se, std::move(sfx));
			break;
		case SFX_Decision:
			SetAudio(data.decision_se, dbsys->decision_se, std::move(sfx));
			break;
		case SFX_Cancel:
			SetAudio(data.cancel_se, dbsys->cancel_se, std::move(sfx));
			break;
		case SFX_Buzzer:
			SetAudio(data.buzzer_se, dbsys->buzzer_se, std::move(sfx));
			break;
		case SFX_BeginBattle:
			SetAudio(data.battle_se, dbsys->battle_se, std::move(sfx));
			break;
		case SFX_Escape:
			SetAudio(data.escape_se, dbsys->escape_se, std::move(sfx));
			break;
		case SFX_EnemyAttacks:
			SetAudio(data.enemy_attack_se, dbsys->enemy_attack_se, std::move(sfx));
			break;
		case SFX_EnemyDamage:
			SetAudio(data.enemy_damaged_se, dbsys->enemy_damaged_se, std::move(sfx));
			break;
		case SFX_AllyDamage:
			SetAudio(data.actor_damaged_se, dbsys->actor_damaged_se, std::move(sfx));
			break;
		case SFX_Evasion:
			SetAudio(data.dodge_se, dbsys->dodge_se, std::move(sfx));
			break;
		case SFX_EnemyKill:
			SetAudio(data.enemy_death_se, dbsys->enemy_death_se, std::move(sfx));
			break;
		case SFX_UseItem:
			SetAudio(data.item_se, dbsys->item_se, std::move(sfx));
			break;
	}
}

lcf::rpg::System::Stretch Game_System::GetMessageStretch() {
	return static_cast<lcf::rpg::System::Stretch>(!data.graphics_name.empty()
		? data.message_stretch
		: lcf::Data::system.message_stretch);
}

lcf::rpg::System::Font Game_System::GetFontId() {
	return static_cast<lcf::rpg::System::Font>(!data.graphics_name.empty()
		? data.font_id
		: lcf::Data::system.font_id);
}

Transition::Type Game_System::GetTransition(int which) {
	int transition = 0;

	auto get = [&](int local, int db) {
		return local >= 0 ? local : db;
	};

	switch (which) {
		case Transition_TeleportErase:
			transition = get(data.transition_out, lcf::Data::system.transition_out);
			break;
		case Transition_TeleportShow:
			transition = get(data.transition_in, lcf::Data::system.transition_in);
			break;
		case Transition_BeginBattleErase:
			transition = get(data.battle_start_fadeout, lcf::Data::system.battle_start_fadeout);
			break;
		case Transition_BeginBattleShow:
			transition = get(data.battle_start_fadein, lcf::Data::system.battle_start_fadein);
			break;
		case Transition_EndBattleErase:
			transition = get(data.battle_end_fadeout, lcf::Data::system.battle_end_fadeout);
			break;
		case Transition_EndBattleShow:
			transition = get(data.battle_end_fadein, lcf::Data::system.battle_end_fadein);
			break;
		default: assert(false && "Bad transition");
	}

	constexpr int num_types = 21;

	if (transition < 0 || transition >= num_types) {
		Output::Warning("Invalid transition value {}", transition);
		transition = Utils::Clamp(transition, 0, num_types - 1);
	}

	constexpr Transition::Type fades[2][num_types] = {
		{
			Transition::TransitionFadeOut,
			Transition::TransitionRandomBlocks,
			Transition::TransitionRandomBlocksDown,
			Transition::TransitionRandomBlocksUp,
			Transition::TransitionBlindClose,
			Transition::TransitionVerticalStripesOut,
			Transition::TransitionHorizontalStripesOut,
			Transition::TransitionBorderToCenterOut,
			Transition::TransitionCenterToBorderOut,
			Transition::TransitionScrollUpOut,
			Transition::TransitionScrollDownOut,
			Transition::TransitionScrollLeftOut,
			Transition::TransitionScrollRightOut,
			Transition::TransitionVerticalDivision,
			Transition::TransitionHorizontalDivision,
			Transition::TransitionCrossDivision,
			Transition::TransitionZoomIn,
			Transition::TransitionMosaicOut,
			Transition::TransitionWaveOut,
			Transition::TransitionCutOut,
			Transition::TransitionNone
		},
		{
			Transition::TransitionFadeIn,
			Transition::TransitionRandomBlocks,
			Transition::TransitionRandomBlocksDown,
			Transition::TransitionRandomBlocksUp,
			Transition::TransitionBlindOpen,
			Transition::TransitionVerticalStripesIn,
			Transition::TransitionHorizontalStripesIn,
			Transition::TransitionBorderToCenterIn,
			Transition::TransitionCenterToBorderIn,
			Transition::TransitionScrollUpIn,
			Transition::TransitionScrollDownIn,
			Transition::TransitionScrollLeftIn,
			Transition::TransitionScrollRightIn,
			Transition::TransitionVerticalCombine,
			Transition::TransitionHorizontalCombine,
			Transition::TransitionCrossCombine,
			Transition::TransitionZoomOut,
			Transition::TransitionMosaicIn,
			Transition::TransitionWaveIn,
			Transition::TransitionCutIn,
			Transition::TransitionNone,
		}
	};

	return fades[which % 2][transition];
}

void Game_System::SetTransition(int which, int transition) {
	auto set = [&](int t, int db) {
		return t != db ? t : -1;
	};
	switch (which) {
		case Transition_TeleportErase:
			data.transition_out = set(transition, lcf::Data::system.transition_out);
			break;
		case Transition_TeleportShow:
			data.transition_in = set(transition, lcf::Data::system.transition_in);
			break;
		case Transition_BeginBattleErase:
			data.battle_start_fadeout = set(transition, lcf::Data::system.battle_start_fadeout);
			break;
		case Transition_BeginBattleShow:
			data.battle_start_fadein = set(transition, lcf::Data::system.battle_start_fadein);
			break;
		case Transition_EndBattleErase:
			data.battle_end_fadeout = set(transition, lcf::Data::system.battle_end_fadeout);
			break;
		case Transition_EndBattleShow:
			data.battle_end_fadein = set(transition, lcf::Data::system.battle_end_fadein);
			break;
		default: assert(false && "Bad transition");
	}
}

std::string Game_System::InelukiReadLink(Filesystem_Stream::InputStream& stream) {
	// The first line contains the path to the actual audio file to play
	std::string line;
	if (!Utils::ReadLine(stream, line)) {
		Output::Warning("Ineluki MP3: Link file is empty: {}", stream.GetName());
		return {};
	}
	line = lcf::ReaderUtil::Recode(line, Player::encoding);

	Output::Debug("Ineluki MP3: Link file: {} -> {}", stream.GetName(), line);
	std::string line_canonical = FileFinder::MakeCanonical(line, 1);

	return line_canonical;
}

void Game_System::OnBgmReady(FileRequestResult* result) {
	// Take from current_music, params could have changed over time
	bgm_pending = false;

	Filesystem_Stream::InputStream stream;
	if (IsStopMusicFilename(result->file, stream)) {
		Audio().BGM_Stop();
		return;
	} else if (!stream) {
		Output::Debug("Music not found: {}", result->file);
		return;
	}

	if (Player::IsPatchKeyPatch() && EndsWith(result->file, ".link") && stream.GetSize() < 500) {
		// Handle Ineluki's MP3 patch
		std::string line = InelukiReadLink(stream);

		// Needs another Async roundtrip
		bgm_pending = true;
		FileRequestAsync *request = AsyncHandler::RequestFile(line);
		music_request_id = request->Bind(&Game_System::OnBgmInelukiReady, this);
		request->Start();
		return;
	}

	Audio().BGM_Play(std::move(stream), data.current_music.volume, data.current_music.tempo, data.current_music.fadein, data.current_music.balance);
}

void Game_System::OnBgmInelukiReady(FileRequestResult* result) {
	bgm_pending = false;
	Audio().BGM_Play(FileFinder::Game().OpenFile(result->file), data.current_music.volume, data.current_music.tempo, data.current_music.fadein, data.current_music.balance);
}

void Game_System::OnSeReady(FileRequestResult* result, lcf::rpg::Sound se, bool stop_sounds) {
	auto item = se_request_ids.find(result->file);
	if (item != se_request_ids.end()) {
		se_request_ids.erase(item);
	}

	if (Player::IsPatchKeyPatch() && EndsWith(result->file, ".script")) {
		// Is a Ineluki Script File
		Main_Data::game_ineluki->Execute(se);
		return;
	}

	auto se_cache = AudioSeCache::GetCachedSe(result->file);
	if (!se_cache) {
		Filesystem_Stream::InputStream stream;
		if (IsStopSoundFilename(result->file, stream)) {
			if (stop_sounds) {
				Audio().SE_Stop();
			}
			return;
		} else if (!stream) {
			Output::Debug("Sound not found: {}", result->file);
			return;
		}

		if (Player::IsPatchKeyPatch() && EndsWith(result->file, ".link") && stream.GetSize() < 500) {
			// Handle Ineluki's MP3 patch
			std::string line = InelukiReadLink(stream);

			// Needs another Async roundtrip
			FileRequestAsync* request = AsyncHandler::RequestFile(line);
			se_request_ids[line] = request->Bind(&Game_System::OnSeInelukiReady, this, se);
			request->Start();
			return;
		}

		se_cache = AudioSeCache::Create(std::move(stream), result->file);
	}

	if (!se_cache) {
		Output::Warning("Sound {}: Format not supported", result->file);
		return;
	}

	Audio().SE_Play(std::move(se_cache), se.volume, se.tempo, se.balance);
}

void Game_System::OnSeInelukiReady(FileRequestResult* result, lcf::rpg::Sound se) {
	auto item = se_request_ids.find(result->file);
	if (item != se_request_ids.end()) {
		se_request_ids.erase(item);
	}

	auto se_cache = AudioSeCache::GetCachedSe(result->file);
	if (!se_cache) {
		auto stream = FileFinder::Game().OpenFile(result->file);
		se_cache = AudioSeCache::Create(std::move(stream), result->file);
	}

	if (!se_cache) {
		Output::Warning("Sound {}: Format not supported", result->file);
		return;
	}

	Audio().SE_Play(std::move(se_cache), se.volume, se.tempo, se.balance);
}

bool Game_System::IsMessageTransparent() {
	if (Feature::HasRpg2kBattleSystem() && Game_Battle::IsBattleRunning()) {
		return false;
	}

	return data.message_transparent != 0;
}



/*end of file .\game_system.cpp*/

/*start of file .\game_targets.cpp*/

/* ... license chunk ... */

// Headers
#include "game_targets.h"
#include <algorithm>

template <typename T>
static auto FindTarget(T&& targets, int map_id) {
	return std::find_if(targets.begin(), targets.end(),
			[map_id](auto& tgt) { return tgt.map_id == map_id; }
			);
}

void Game_Targets::AddTeleportTarget(int map_id, int x, int y, bool switch_on, int switch_id) {
	auto iter = FindTarget(teleports, map_id);
	if (iter == teleports.end()) {
		lcf::rpg::SaveTarget tgt;
		// RPG_RT duplicates the map_id into the save object's id.
		tgt.ID = map_id;
		iter = teleports.insert(iter, std::move(tgt));
	}

	iter->map_id = map_id;
	iter->map_x = x;
	iter->map_y = y;
	iter->switch_on = switch_on;
	iter->switch_id = switch_id;

	// Teleports must be sorted by map id.
	std::sort(teleports.begin(), teleports.end(), [](auto& l, auto& r) { return l.map_id < r.map_id; });
}

void Game_Targets::RemoveTeleportTarget(int map_id) {
	auto iter = FindTarget(teleports, map_id);
	if (iter != teleports.end()) {
		teleports.erase(iter);
	}
}

const lcf::rpg::SaveTarget* Game_Targets::GetTeleportTarget(int map_id) const {
	auto iter = FindTarget(teleports, map_id);
	return (iter != teleports.end()) ? &*iter : nullptr;
}

void Game_Targets::SetEscapeTarget(int map_id, int x, int y, bool switch_on, int switch_id) {
	escape.map_id = map_id;
	escape.map_x = x;
	escape.map_y = y;
	escape.switch_on = switch_on;
	escape.switch_id = switch_id;
}

void Game_Targets::SetSaveData(std::vector<lcf::rpg::SaveTarget> save) {
	for (auto& data: save) {
		if (data.ID == 0) {
			escape = std::move(data);
		} else {
			teleports.push_back(data);
			// Protect against bad save data. Teleports must be sorted by map id.
			std::sort(teleports.begin(), teleports.end(), [](auto& l, auto& r) { return l.map_id < r.map_id; });
		}
	}
}

std::vector<lcf::rpg::SaveTarget> Game_Targets::GetSaveData() const {
	std::vector<lcf::rpg::SaveTarget> save;
	save.push_back(escape);
	save.insert(save.end(), teleports.begin(), teleports.end());
	return save;
}



/*end of file .\game_targets.cpp*/

/*start of file .\game_variables.cpp*/

/* ... license chunk ... */

// Headers
#include "game_variables.h"
#include "output.h"
#include <lcf/reader_util.h>
#include <lcf/data.h>
#include "utils.h"
#include "rand.h"
#include <cmath>

namespace {
using Var_t = Game_Variables::Var_t;

constexpr Var_t VarSet(Var_t o, Var_t n) {
	(void)o;
	return n;
}

constexpr Var_t VarAdd(Var_t l, Var_t r) {
	Var_t res = 0;

#ifdef _MSC_VER
	res = l + r;
	if (res < 0 && l > 0 && r > 0) {
		return std::numeric_limits<Var_t>::max();
	} else if (res > 0 && l < 0 && r < 0) {
		return std::numeric_limits<Var_t>::min();
	}
#else
	if (EP_UNLIKELY(__builtin_add_overflow(l, r, &res))) {
		if (l >= 0 && r >= 0) {
			return std::numeric_limits<Var_t>::max();
		}
		return std::numeric_limits<Var_t>::min();
	}
#endif

	return res;
}

constexpr Var_t VarSub(Var_t l, Var_t r) {
	Var_t res = 0;

#ifdef _MSC_VER
	res = l - r;
	if (res < 0 && l > 0 && r < 0) {
		return std::numeric_limits<Var_t>::max();
	} else if (res > 0 && l < 0 && r > 0) {
		return std::numeric_limits<Var_t>::min();
	}
#else
	if (EP_UNLIKELY(__builtin_sub_overflow(l, r, &res))) {
		if (r < 0) {
			return std::numeric_limits<Var_t>::max();
		}
		return std::numeric_limits<Var_t>::min();
	}
#endif

	return res;
}

constexpr Var_t VarMult(Var_t l, Var_t r) {
	Var_t res = 0;

#ifdef _MSC_VER
	res = l * r;
	if (l != 0 && res / l != r) {
		if ((l > 0 && r > 0) || (l < 0 && r < 0)) {
			return std::numeric_limits<Var_t>::max();
		} else {
			return std::numeric_limits<Var_t>::min();
		}
	}
#else
	if (EP_UNLIKELY(__builtin_mul_overflow(l, r, &res))) {
		if ((l > 0 && r > 0) || (l < 0 && r < 0)) {
			return std::numeric_limits<Var_t>::max();
		}
		return std::numeric_limits<Var_t>::min();
	}
#endif

	return res;
}

constexpr Var_t VarDiv(Var_t n, Var_t d) {
	return EP_LIKELY(d != 0) ? n / d : n;
};

constexpr Var_t VarMod(Var_t n, Var_t d) {
	return EP_LIKELY(d != 0) ? n % d : 0;
};

constexpr Var_t VarBitOr(Var_t n, Var_t d) {
	return n | d;
};

constexpr Var_t VarBitAnd(Var_t n, Var_t d) {
	return n & d;
};

constexpr Var_t VarBitXor(Var_t n, Var_t d) {
	return n ^ d;
};

constexpr Var_t VarBitShiftLeft(Var_t n, Var_t d) {
	return n << d;
};

constexpr Var_t VarBitShiftRight(Var_t n, Var_t d) {
	return n >> d;
};

}

Game_Variables::Game_Variables(Var_t minval, Var_t maxval)
	: _min(minval), _max(maxval)
{
	if (minval >= maxval) {
		Output::Error("Variables: Invalid var range: [{}, {}]", minval, maxval);
	}
}

void Game_Variables::WarnGet(int variable_id) const {
	Output::Debug("Invalid read var[{}]!", variable_id);
	--_warnings;
}

template <typename F>
Game_Variables::Var_t Game_Variables::SetOp(int variable_id, Var_t value, F&& op, const char* warn) {
	if (EP_UNLIKELY(ShouldWarn(variable_id, variable_id))) {
		Output::Debug(warn, variable_id, value);
		--_warnings;
	}
	if (variable_id <= 0) {
		return 0;
	}
	if (EP_UNLIKELY(variable_id > static_cast<int>(_variables.size()))) {
		_variables.resize(variable_id, 0);
	}
	auto& v = _variables[variable_id - 1];
	value = op(v, value);
	v = Utils::Clamp(value, _min, _max);
	return v;
}

template <typename... Args>
void Game_Variables::PrepareRange(const int first_id, const int last_id, const char* warn, Args... args) {
	if (EP_UNLIKELY(ShouldWarn(first_id, last_id))) {
		Output::Debug(warn, first_id, last_id, args...);
		--_warnings;
	}
	auto& vv = _variables;
	if (EP_UNLIKELY(last_id > static_cast<int>(vv.size()))) {
		vv.resize(last_id, 0);
	}
}

template <typename... Args>
void Game_Variables::PrepareArray(const int first_id_a, const int last_id_a, const int first_id_b, const char* warn, Args... args) {
	const int last_id_b = first_id_b + last_id_a - first_id_a;
	if (EP_UNLIKELY(ShouldWarn(first_id_a, last_id_a) || ShouldWarn(first_id_b, last_id_b))) {
		Output::Debug(warn, first_id_a, last_id_a, first_id_b, last_id_b, args...);
		--_warnings;
	}
	auto& vv = _variables;
	if (EP_UNLIKELY(last_id_a > static_cast<int>(vv.size()))) {
		vv.resize(last_id_a, 0);
	}
	if (EP_UNLIKELY(last_id_b > static_cast<int>(vv.size()))) {
		vv.resize(last_id_b, 0);
	}
}

template <typename V, typename F>
void Game_Variables::WriteRange(const int first_id, const int last_id, V&& value, F&& op) {
	auto& vv = _variables;
	for (int i = std::max(0, first_id - 1); i < last_id; ++i) {
		auto& v = vv[i];
		v = Utils::Clamp(op(v, value()), _min, _max);
	}
}

template <typename F>
void Game_Variables::WriteArray(const int first_id_a, const int last_id_a, const int first_id_b, F&& op) {
	auto& vv = _variables;
	int out_b = std::max(0, first_id_b - 1);
	for (int i = std::max(0, first_id_a - 1); i < last_id_a; ++i) {
		auto& v_a = vv[i];
		auto v_b = vv[out_b++];
		v_a = Utils::Clamp(op(v_a, v_b), _min, _max);
	}
}

std::vector<Var_t> Game_Variables::GetRange(int variable_id, int length) {
	std::vector<Var_t> vars;
	for (int i = 0; i < length; ++i) {
		vars.push_back(Get(variable_id + i));
	}
	return vars;
}

Game_Variables::Var_t Game_Variables::Set(int variable_id, Var_t value) {
	return SetOp(variable_id, value, VarSet, "Invalid write var[{}] = {}!");
}

Game_Variables::Var_t Game_Variables::Add(int variable_id, Var_t value) {
	return SetOp(variable_id, value, VarAdd, "Invalid write var[{}] += {}!");
}

Game_Variables::Var_t Game_Variables::Sub(int variable_id, Var_t value) {
	return SetOp(variable_id, value, VarSub, "Invalid write var[{}] -= {}!");
}

Game_Variables::Var_t Game_Variables::Mult(int variable_id, Var_t value) {
	return SetOp(variable_id, value, VarMult, "Invalid write var[{}] *= {}!");
}

Game_Variables::Var_t Game_Variables::Div(int variable_id, Var_t value) {
	return SetOp(variable_id, value, VarDiv, "Invalid write var[{}] /= {}!");
}

Game_Variables::Var_t Game_Variables::Mod(int variable_id, Var_t value) {
	return SetOp(variable_id, value, VarMod, "Invalid write var[{}] %= {}!");
}

Game_Variables::Var_t Game_Variables::BitOr(int variable_id, Var_t value) {
	return SetOp(variable_id, value, VarBitOr, "Invalid write var[{}] |= {}!");
}

Game_Variables::Var_t Game_Variables::BitAnd(int variable_id, Var_t value) {
	return SetOp(variable_id, value, VarBitAnd, "Invalid write var[{}] &= {}!");
}

Game_Variables::Var_t Game_Variables::BitXor(int variable_id, Var_t value) {
	return SetOp(variable_id, value, VarBitXor, "Invalid write var[{}] ^= {}!");
}

Game_Variables::Var_t Game_Variables::BitShiftLeft(int variable_id, Var_t value) {
	return SetOp(variable_id, value, VarBitShiftLeft, "Invalid write var[{}] <<= {}!");
}

Game_Variables::Var_t Game_Variables::BitShiftRight(int variable_id, Var_t value) {
	return SetOp(variable_id, value, VarBitShiftRight, "Invalid write var[{}] >>= {}!");
}

void Game_Variables::SetRange(int first_id, int last_id, Var_t value) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] = {}!", value);
	WriteRange(first_id, last_id, [value](){ return value; }, VarSet);
}

void Game_Variables::AddRange(int first_id, int last_id, Var_t value) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] += {}!", value);
	WriteRange(first_id, last_id, [value](){ return value; }, VarAdd);
}

void Game_Variables::SubRange(int first_id, int last_id, Var_t value) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] -= {}!", value);
	WriteRange(first_id, last_id, [value](){ return value; }, VarSub);
}

void Game_Variables::MultRange(int first_id, int last_id, Var_t value) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] *= {}!", value);
	WriteRange(first_id, last_id, [value](){ return value; }, VarMult);
}

void Game_Variables::DivRange(int first_id, int last_id, Var_t value) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] /= {}!", value);
	WriteRange(first_id, last_id, [value](){ return value; }, VarDiv);
}

void Game_Variables::ModRange(int first_id, int last_id, Var_t value) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] %= {}!", value);
	WriteRange(first_id, last_id, [value](){ return value; }, VarMod);
}

void Game_Variables::BitOrRange(int first_id, int last_id, Var_t value) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] |= {}!", value);
	WriteRange(first_id, last_id, [value](){ return value; }, VarBitOr);
}

void Game_Variables::BitAndRange(int first_id, int last_id, Var_t value) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] &= {}!", value);
	WriteRange(first_id, last_id, [value](){ return value; }, VarBitAnd);
}

void Game_Variables::BitXorRange(int first_id, int last_id, Var_t value) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] ^= {}!", value);
	WriteRange(first_id, last_id, [value](){ return value; }, VarBitXor);
}

void Game_Variables::BitShiftLeftRange(int first_id, int last_id, Var_t value) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] <<= {}!", value);
	WriteRange(first_id, last_id, [value](){ return value; }, VarBitShiftLeft);
}

void Game_Variables::BitShiftRightRange(int first_id, int last_id, Var_t value) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] >>= {}!", value);
	WriteRange(first_id, last_id, [value](){ return value; }, VarBitShiftRight);
}

template <typename F>
void Game_Variables::WriteRangeVariable(int first_id, const int last_id, const int var_id, F&& op) {
	if (var_id >= first_id && var_id <= last_id) {
		auto value = Get(var_id);
		WriteRange(first_id, var_id, [value](){ return value; }, std::forward<F>(op));
		first_id = var_id + 1;
	}
	auto value = Get(var_id);
	WriteRange(first_id, last_id, [value](){ return value; }, std::forward<F>(op));
}


void Game_Variables::SetRangeVariable(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] = Var({})!", var_id);
	WriteRangeVariable(first_id, last_id, var_id, VarSet);
}

void Game_Variables::AddRangeVariable(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] += var[{}]!", var_id);
	WriteRangeVariable(first_id, last_id, var_id, VarAdd);
}

void Game_Variables::SubRangeVariable(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] -= var[{}]!", var_id);
	WriteRangeVariable(first_id, last_id, var_id, VarSub);
}

void Game_Variables::MultRangeVariable(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] *= var[{}]!", var_id);
	WriteRangeVariable(first_id, last_id, var_id, VarMult);
}

void Game_Variables::DivRangeVariable(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] /= var[{}]!", var_id);
	WriteRangeVariable(first_id, last_id, var_id, VarDiv);
}

void Game_Variables::ModRangeVariable(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] /= var[{}]!", var_id);
	WriteRangeVariable(first_id, last_id, var_id, VarMod);
}

void Game_Variables::BitOrRangeVariable(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] |= var[{}]!", var_id);
	WriteRangeVariable(first_id, last_id, var_id, VarBitOr);
}

void Game_Variables::BitAndRangeVariable(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] &= var[{}]!", var_id);
	WriteRangeVariable(first_id, last_id, var_id, VarBitAnd);
}

void Game_Variables::BitXorRangeVariable(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] ^= var[{}]!", var_id);
	WriteRangeVariable(first_id, last_id, var_id, VarBitXor);
}

void Game_Variables::BitShiftLeftRangeVariable(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] <<= var[{}]!", var_id);
	WriteRangeVariable(first_id, last_id, var_id, VarBitShiftLeft);
}

void Game_Variables::BitShiftRightRangeVariable(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] >>= var[{}]!", var_id);
	WriteRangeVariable(first_id, last_id, var_id, VarBitShiftRight);
}

void Game_Variables::SetRangeVariableIndirect(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] = var[var[{}]]!", var_id);
	WriteRange(first_id, last_id, [this,var_id](){ return Get(Get(var_id)); }, VarSet);
}

void Game_Variables::AddRangeVariableIndirect(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] += var[var[{}]]!", var_id);
	WriteRange(first_id, last_id, [this,var_id](){ return Get(Get(var_id)); }, VarAdd);
}

void Game_Variables::SubRangeVariableIndirect(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] -= var[var[{}]]!", var_id);
	WriteRange(first_id, last_id, [this,var_id](){ return Get(Get(var_id)); }, VarSub);
}

void Game_Variables::MultRangeVariableIndirect(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] *= var[var[{}]]!", var_id);
	WriteRange(first_id, last_id, [this,var_id](){ return Get(Get(var_id)); }, VarMult);
}

void Game_Variables::DivRangeVariableIndirect(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] /= var[var[{}]]!", var_id);
	WriteRange(first_id, last_id, [this,var_id](){ return Get(Get(var_id)); }, VarDiv);
}

void Game_Variables::ModRangeVariableIndirect(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] %= var[var[{}]]!", var_id);
	WriteRange(first_id, last_id, [this,var_id](){ return Get(Get(var_id)); }, VarMod);
}

void Game_Variables::BitOrRangeVariableIndirect(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] |= var[var[{}]]!", var_id);
	WriteRange(first_id, last_id, [this,var_id](){ return Get(Get(var_id)); }, VarBitOr);
}

void Game_Variables::BitAndRangeVariableIndirect(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] &= var[var[{}]]!", var_id);
	WriteRange(first_id, last_id, [this,var_id](){ return Get(Get(var_id)); }, VarBitAnd);
}

void Game_Variables::BitXorRangeVariableIndirect(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] ^= var[var[{}]]!", var_id);
	WriteRange(first_id, last_id, [this,var_id](){ return Get(Get(var_id)); }, VarBitXor);
}

void Game_Variables::BitShiftLeftRangeVariableIndirect(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] <<= var[var[{}]]!", var_id);
	WriteRange(first_id, last_id, [this,var_id](){ return Get(Get(var_id)); }, VarBitShiftLeft);
}

void Game_Variables::BitShiftRightRangeVariableIndirect(int first_id, int last_id, int var_id) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] >>= var[var[{}]]!", var_id);
	WriteRange(first_id, last_id, [this,var_id](){ return Get(Get(var_id)); }, VarBitShiftRight);
}

void Game_Variables::SetRangeRandom(int first_id, int last_id, Var_t minval, Var_t maxval) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] = rand({},{})!", minval, maxval);
	WriteRange(first_id, last_id, [minval,maxval](){ return Rand::GetRandomNumber(minval, maxval); }, VarSet);
}

void Game_Variables::AddRangeRandom(int first_id, int last_id, Var_t minval, Var_t maxval) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] += rand({},{})!", minval, maxval);
	WriteRange(first_id, last_id, [minval,maxval](){ return Rand::GetRandomNumber(minval, maxval); }, VarAdd);
}

void Game_Variables::SubRangeRandom(int first_id, int last_id, Var_t minval, Var_t maxval) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] -= rand({},{})!", minval, maxval);
	WriteRange(first_id, last_id, [minval,maxval](){ return Rand::GetRandomNumber(minval, maxval); }, VarSub);
}

void Game_Variables::MultRangeRandom(int first_id, int last_id, Var_t minval, Var_t maxval) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] *= rand({},{})!", minval, maxval);
	WriteRange(first_id, last_id, [minval,maxval](){ return Rand::GetRandomNumber(minval, maxval); }, VarMult);
}

void Game_Variables::DivRangeRandom(int first_id, int last_id, Var_t minval, Var_t maxval) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] /= rand({},{})!", minval, maxval);
	WriteRange(first_id, last_id, [minval,maxval](){ return Rand::GetRandomNumber(minval, maxval); }, VarDiv);
}

void Game_Variables::ModRangeRandom(int first_id, int last_id, Var_t minval, Var_t maxval) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] %= rand({},{})!", minval, maxval);
	WriteRange(first_id, last_id, [minval,maxval](){ return Rand::GetRandomNumber(minval, maxval); }, VarMod);
}

void Game_Variables::BitOrRangeRandom(int first_id, int last_id, Var_t minval, Var_t maxval) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] |= rand({},{})!", minval, maxval);
	WriteRange(first_id, last_id, [minval,maxval](){ return Rand::GetRandomNumber(minval, maxval); }, VarBitOr);
}

void Game_Variables::BitAndRangeRandom(int first_id, int last_id, Var_t minval, Var_t maxval) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] &= rand({},{})!", minval, maxval);
	WriteRange(first_id, last_id, [minval,maxval](){ return Rand::GetRandomNumber(minval, maxval); }, VarBitAnd);
}

void Game_Variables::BitXorRangeRandom(int first_id, int last_id, Var_t minval, Var_t maxval) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] ^= rand({},{})!", minval, maxval);
	WriteRange(first_id, last_id, [minval,maxval](){ return Rand::GetRandomNumber(minval, maxval); }, VarBitXor);
}

void Game_Variables::BitShiftLeftRangeRandom(int first_id, int last_id, Var_t minval, Var_t maxval) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] <<= rand({},{})!", minval, maxval);
	WriteRange(first_id, last_id, [minval,maxval](){ return Rand::GetRandomNumber(minval, maxval); }, VarBitShiftLeft);
}

void Game_Variables::BitShiftRightRangeRandom(int first_id, int last_id, Var_t minval, Var_t maxval) {
	PrepareRange(first_id, last_id, "Invalid write var[{},{}] >>= rand({},{})!", minval, maxval);
	WriteRange(first_id, last_id, [minval,maxval](){ return Rand::GetRandomNumber(minval, maxval); }, VarBitShiftRight);
}

void Game_Variables::EnumerateRange(int first_id, int last_id, Var_t value) {
	PrepareRange(first_id, last_id, "Invalid write enumerate(var[{},{}])!");
	Var_t out_value = value;
	WriteRange(first_id, last_id, [&out_value](){ return out_value++; }, VarSet);
}

void Game_Variables::SortRange(int first_id, int last_id, bool asc) {
	PrepareRange(first_id, last_id, "Invalid write sort(var[{},{}])!");
	auto& vv = _variables;
	int i = std::max(0, first_id - 1);
	if (i < last_id) {
		auto sorter = [&](auto&& fn) {
			std::stable_sort(vv.begin() + i, vv.begin() + last_id, fn);
		};
		if (asc) {
			sorter(std::less<>());
		} else {
			sorter(std::greater<>());
		}
	}
}

void Game_Variables::ShuffleRange(int first_id, int last_id) {
	PrepareRange(first_id, last_id, "Invalid write shuffle(var[{},{}])!");
	auto& vv = _variables;
	for (int i = std::max(0, first_id - 1); i < last_id; ++i) {
		int rnd_num = Rand::GetRandomNumber(first_id, last_id) - 1;
		std::swap(vv[i], vv[rnd_num]);
	}
}

void Game_Variables::SetArray(int first_id_a, int last_id_a, int first_id_b) {
	PrepareArray(first_id_a, last_id_a, first_id_b, "Invalid write var[{},{}] = var[{},{}]!");
	// Maniac Patch uses memcpy which is actually a memmove
	// This ensures overlapping areas are copied properly
	if (first_id_a < first_id_b) {
		WriteArray(first_id_a, last_id_a, first_id_b, VarSet);
	} else {
		auto& vv = _variables;
		const int steps = std::max(0, last_id_a - first_id_a + 1);
		int out_b = std::max(0, first_id_b + steps - 2);
		int out_a = std::max(0, last_id_a - 1);
		for (int i = 0; i < steps; ++i) {
			auto& v_a = vv[out_a--];
			auto v_b = vv[out_b--];
			v_a = Utils::Clamp(VarSet(v_a, v_b), _min, _max);
		}
	}
}

void Game_Variables::AddArray(int first_id_a, int last_id_a, int first_id_b) {
	PrepareArray(first_id_a, last_id_a, first_id_b, "Invalid write var[{},{}] += var[{},{}]!");
	WriteArray(first_id_a, last_id_a, first_id_b, VarAdd);
}

void Game_Variables::SubArray(int first_id_a, int last_id_a, int first_id_b) {
	PrepareArray(first_id_a, last_id_a, first_id_b, "Invalid write var[{},{}] -= var[{},{}]!");
	WriteArray(first_id_a, last_id_a, first_id_b, VarSub);
}

void Game_Variables::MultArray(int first_id_a, int last_id_a, int first_id_b) {
	PrepareArray(first_id_a, last_id_a, first_id_b, "Invalid write var[{},{}] *= var[{},{}]!");
	WriteArray(first_id_a, last_id_a, first_id_b, VarMult);
}

void Game_Variables::DivArray(int first_id_a, int last_id_a, int first_id_b) {
	PrepareArray(first_id_a, last_id_a, first_id_b, "Invalid write var[{},{}] /= var[{},{}]!");
	WriteArray(first_id_a, last_id_a, first_id_b, VarDiv);
}

void Game_Variables::ModArray(int first_id_a, int last_id_a, int first_id_b) {
	PrepareArray(first_id_a, last_id_a, first_id_b, "Invalid write var[{},{}] %= var[{},{}]!");
	WriteArray(first_id_a, last_id_a, first_id_b, VarMod);
}

void Game_Variables::BitOrArray(int first_id_a, int last_id_a, int first_id_b) {
	PrepareArray(first_id_a, last_id_a, first_id_b, "Invalid write var[{},{}] |= var[{},{}]!");
	WriteArray(first_id_a, last_id_a, first_id_b, VarBitOr);
}

void Game_Variables::BitAndArray(int first_id_a, int last_id_a, int first_id_b) {
	PrepareArray(first_id_a, last_id_a, first_id_b, "Invalid write var[{},{}] &= var[{},{}]!");
	WriteArray(first_id_a, last_id_a, first_id_b, VarBitAnd);
}

void Game_Variables::BitXorArray(int first_id_a, int last_id_a, int first_id_b) {
	PrepareArray(first_id_a, last_id_a, first_id_b, "Invalid write var[{},{}] ^= var[{},{}]!");
	WriteArray(first_id_a, last_id_a, first_id_b, VarBitXor);
}

void Game_Variables::BitShiftLeftArray(int first_id_a, int last_id_a, int first_id_b) {
	PrepareArray(first_id_a, last_id_a, first_id_b, "Invalid write var[{},{}] <<= var[{},{}]!");
	WriteArray(first_id_a, last_id_a, first_id_b, VarBitShiftLeft);
}

void Game_Variables::BitShiftRightArray(int first_id_a, int last_id_a, int first_id_b) {
	PrepareArray(first_id_a, last_id_a, first_id_b, "Invalid write var[{},{}] >>= var[{},{}]!");
	WriteArray(first_id_a, last_id_a, first_id_b, VarBitShiftRight);
}

void Game_Variables::SwapArray(int first_id_a, int last_id_a, int first_id_b) {
	PrepareArray(first_id_a, last_id_a, first_id_b, "Invalid write var[{},{}] <-> var[{},{}]!");
	auto& vv = _variables;
	const int steps = std::max(0, last_id_a - first_id_a + 1);
	int out_b = std::max(0, first_id_b + steps - 2);
	int out_a = std::max(0, last_id_a - 1);
	for (int i = 0; i < steps; ++i) {
		std::swap(vv[out_a--], vv[out_b--]);
	}
}

std::string_view Game_Variables::GetName(int _id) const {
	const auto* var = lcf::ReaderUtil::GetElement(lcf::Data::variables, _id);

	if (!var) {
		// No warning, is valid because the variable array resizes dynamic during runtime
		return {};
	} else {
		return var->name;
	}
}

int Game_Variables::GetMaxDigits() const {
	auto val = std::max(std::llabs(_max), std::llabs(_min));
	return static_cast<int>(std::log10(val) + 1);
}


/*end of file .\game_variables.cpp*/

/*start of file .\game_vehicle.cpp*/

/* ... license chunk ... */

// Headers
#include <cassert>
#include <lcf/data.h>
#include "main_data.h"
#include "game_system.h"
#include "game_map.h"
#include "game_player.h"
#include "game_vehicle.h"
#include "output.h"

const char Game_Vehicle::TypeNames[4][8] {
	"Party", // RPG_RT special case, see CommandSetVehicleLocation
	"Boat",
	"Ship",
	"Airship"
};

Game_Vehicle::Game_Vehicle(Type type)
	: Game_VehicleBase(Vehicle)
{
	data()->vehicle = static_cast<int>(type);
	SetDirection(Left);
	SetFacing(Left);
	SetAnimationType(AnimType::AnimType_non_continuous);
	SetLayer(lcf::rpg::EventPage::Layers_same);

	switch (GetVehicleType()) {
		case None:
			break;
		case Boat:
			SetSpriteGraphic(ToString(lcf::Data::system.boat_name), lcf::Data::system.boat_index);
			SetMapId(lcf::Data::treemap.start.boat_map_id);
			SetX(lcf::Data::treemap.start.boat_x);
			SetY(lcf::Data::treemap.start.boat_y);
			SetMoveSpeed(lcf::rpg::EventPage::MoveSpeed_normal);
			break;
		case Ship:
			SetSpriteGraphic(ToString(lcf::Data::system.ship_name), lcf::Data::system.ship_index);
			SetMapId(lcf::Data::treemap.start.ship_map_id);
			SetX(lcf::Data::treemap.start.ship_x);
			SetY(lcf::Data::treemap.start.ship_y);
			SetMoveSpeed(lcf::rpg::EventPage::MoveSpeed_normal);
			break;
		case Airship:
			SetSpriteGraphic(ToString(lcf::Data::system.airship_name), lcf::Data::system.airship_index);
			SetMapId(lcf::Data::treemap.start.airship_map_id);
			SetX(lcf::Data::treemap.start.airship_x);
			SetY(lcf::Data::treemap.start.airship_y);
			SetMoveSpeed(lcf::rpg::EventPage::MoveSpeed_double);
			break;
	}
}

void Game_Vehicle::SetSaveData(lcf::rpg::SaveVehicleLocation save) {
	auto type = data()->vehicle;
	*data() = std::move(save);

	// Old EasyRPG savegames pre 6.0 didn't write the vehicle chunk.
	data()->vehicle = type;

	SanitizeData(TypeNames[type]);
}

bool Game_Vehicle::IsInCurrentMap() const {
	return GetMapId() == Game_Map::GetMapId();
}

const lcf::rpg::Music& Game_Vehicle::GetBGM() {
	switch (GetVehicleType()) {
	case None:
		assert(false);
		break;
	case Boat:
		return Main_Data::game_system->GetSystemBGM(Main_Data::game_system->BGM_Boat);
	case Ship:
		return Main_Data::game_system->GetSystemBGM(Main_Data::game_system->BGM_Ship);
	case Airship:
		return Main_Data::game_system->GetSystemBGM(Main_Data::game_system->BGM_Airship);
	}

	static lcf::rpg::Music empty;
	return empty;
}

void Game_Vehicle::StartDescent() {
	if (IsFlying()) {
		SetFacing(Left);
		data()->remaining_descent = SCREEN_TILE_SIZE;
	}
}

void Game_Vehicle::StartAscent() {
	if (!IsFlying()) {
		data()->remaining_ascent = SCREEN_TILE_SIZE;
		SetFlying(true);
	}
}

bool Game_Vehicle::IsInUse() const {
	return Main_Data::game_player->GetVehicle() == this;
}

bool Game_Vehicle::IsAboard() const {
	return IsInUse() && Main_Data::game_player->IsAboard();
}

void Game_Vehicle::SyncWithRider(const Game_Character* rider) {
	SetProcessed(true);
	SetMapId(rider->GetMapId());
	SetX(rider->GetX());
	SetY(rider->GetY());
	SetDirection(rider->GetDirection());
	SetFacing(rider->GetFacing());
	SetRemainingStep(rider->GetRemainingStep());

	// RPG_RT doesn't copy jumping chunks

	UpdateAnimation();
	CancelMoveRoute();
}

int Game_Vehicle::GetAltitude() const {
	if (!IsFlying())
		return 0;
	else if (IsAscending())
		return (SCREEN_TILE_SIZE - data()->remaining_ascent) / (SCREEN_TILE_SIZE / TILE_SIZE);
	else if (IsDescending())
		return data()->remaining_descent / (SCREEN_TILE_SIZE / TILE_SIZE);
	else
		return SCREEN_TILE_SIZE / (SCREEN_TILE_SIZE / TILE_SIZE);
}

int Game_Vehicle::GetScreenY(bool apply_jump) const {
	return Game_Character::GetScreenY(apply_jump) - GetAltitude();
}

bool Game_Vehicle::CanLand() const {
	return Game_Map::CanLandAirship(GetX(), GetY());
}

void Game_Vehicle::UpdateNextMovementAction() {
	UpdateMoveRoute(data()->move_route_index, data()->move_route, true);
}

void Game_Vehicle::UpdateAnimation() {
	if (!IsJumping() && (GetVehicleType() != Airship || IsFlying())) {
		// RPG_RT Animates vehicles slower when moving
		const auto limit = GetStopCount() ? 16 : 12;

		IncAnimCount();

		if (GetAnimCount() >= limit) {
			IncAnimFrame();
		}
	} else {
		ResetAnimation();
	}
}

bool Game_Vehicle::AnimateAscentDescent() {
	if (IsAscending()) {
		data()->remaining_ascent = data()->remaining_ascent - 8;
		return true;
	} else if (IsDescending()) {
		data()->remaining_descent = data()->remaining_descent - 8;
		if (!IsDescending()) {
			SetFlying(false);
			if (CanLand()) {
				SetDefaultDirection();
			} else {
				StartAscent();
			}
		}
		return true;
	}
	return false;
}

void Game_Vehicle::ForceLand() {
	data()->remaining_descent = 0;
	data()->remaining_ascent = 0;
	data()->flying = 0;
}

void Game_Vehicle::Update() {
	Game_Character::Update();
}

std::string_view Game_Vehicle::GetOrigSpriteName() const {
	if (!data()->orig_sprite_name.empty()) {
		return data()->orig_sprite_name;
	}
	switch (GetVehicleType()) {
		case Boat:
			return lcf::Data::system.boat_name;
		case Ship:
			return lcf::Data::system.ship_name;
		case Airship:
			return lcf::Data::system.airship_name;
		default:
			break;
	}
	return {};
}

int Game_Vehicle::GetOrigSpriteIndex() const {
	if (!data()->orig_sprite_name.empty()) {
		return data()->orig_sprite_id;
	}
	switch (GetVehicleType()) {
		case Boat:
			return lcf::Data::system.boat_index;
		case Ship:
			return lcf::Data::system.ship_index;
		case Airship:
			return lcf::Data::system.airship_index;
		default:
			break;
	}
	return 0;
}


/*end of file .\game_vehicle.cpp*/

/*start of file .\game_windows.cpp*/

/* ... license chunk ... */

#include "game_windows.h"
#include "game_message.h"
#include "game_strings.h"
#include "main_data.h"
#include "compiler.h"
#include "text.h"
#include "cache.h"
#include "pending_message.h"
#include "filefinder.h"
#include "output.h"
#include "player.h"

static std::optional<std::string> CommandCodeInserter(char ch, const char **iter, const char *end, uint32_t escape_char) {
	if ((ch == 'T' || ch == 't') && Player::IsPatchManiac()) {
		auto parse_ret = Game_Message::ParseString(*iter, end, escape_char, true);
		*iter = parse_ret.next;
		int value = parse_ret.value;

		// Contrary to Messages, the content of \t[]-strings is not evaluated
		return ToString(Main_Data::game_strings->Get(value));
	}

	return PendingMessage::DefaultCommandInserter(ch, iter, end, escape_char);
}

Game_Windows::Window_User::Window_User(lcf::rpg::SaveEasyRpgWindow save)
	: data(std::move(save))
{

}

void Game_Windows::SetSaveData(std::vector<lcf::rpg::SaveEasyRpgWindow> save) {
	windows.clear();

	int num_windows = static_cast<int>(save.size());
	windows.reserve(num_windows);
	for (int i = 0; i < num_windows; ++i) {
		windows.emplace_back(std::move(save[i]));
		auto& win = windows.back();
		int id = win.data.ID;
		if (id > 0) {
			auto pic = Main_Data::game_pictures->GetPicturePtr(id);
			if (pic && pic->IsWindowAttached()) {
				// no special async handling needed, loading will already yield
				bool async_wait;
				win.Refresh(async_wait);
			}
		}
	}
}

std::vector<lcf::rpg::SaveEasyRpgWindow> Game_Windows::GetSaveData() const {
	std::vector<lcf::rpg::SaveEasyRpgWindow> save;

	auto data_size = static_cast<int>(windows.size());
	save.reserve(data_size);

	for (auto& win: windows) {
		save.push_back(win.data);
	}

	// RPG_RT Save game data always has a constant number of pictures
	// depending on the engine version. We replicate this, unless we have even
	// more pictures than that.
	while (data_size > static_cast<int>(save.size())) {
		lcf::rpg::SaveEasyRpgWindow data;
		data.ID = static_cast<int>(save.size()) + 1;
		save.push_back(std::move(data));
	}

	return save;
}

Game_Windows::Window_User& Game_Windows::GetWindow(int id) {
	if (EP_UNLIKELY(id > static_cast<int>(windows.size()))) {
		windows.reserve(id);
		while (static_cast<int>(windows.size()) < id) {
			windows.emplace_back(static_cast<int>(windows.size()) + 1);
		}
	}
	return windows[id - 1];
}

Game_Windows::Window_User* Game_Windows::GetWindowPtr(int id) {
	return id <= static_cast<int>(windows.size())
		? &windows[id - 1] : nullptr;
}

bool Game_Windows::Window_User::Create(const WindowParams& params) {
	Erase();

	data.width = params.width;
	data.height = params.height;
	data.system_name = lcf::DBString(params.system_name);
	data.message_stretch = params.message_stretch;
	data.flags.draw_frame = params.draw_frame;
	data.flags.border_margin = params.border_margin;

	for (const auto& text: params.texts) {
		lcf::rpg::SaveEasyRpgText data_text;

		data_text.text = lcf::DBString(text.text);
		data_text.position_x = text.position_x;
		data_text.position_y = text.position_y;
		data_text.font_name = lcf::DBString(text.font_name);
		data_text.font_size = text.font_size;
		data_text.letter_spacing = text.letter_spacing;
		data_text.line_spacing = text.line_spacing;
		data_text.flags.draw_gradient = text.draw_gradient;
		data_text.flags.draw_shadow = text.draw_shadow;
		data_text.flags.bold = text.bold;
		data_text.flags.italic = text.italic;

		data.texts.push_back(data_text);
	}

	return true;
}

bool Game_Windows::Create(int id, const WindowParams& params, bool& async_wait) {
	auto& window = GetWindow(id);

	if (window.Create(params)) {
		if (Main_Data::game_pictures->Show(id, params)) {
			window.Refresh(async_wait);
			return true;
		} else {
			window.Erase();
			return false;
		}
	}

	return false;
}

void Game_Windows::Window_User::Erase() {
	int id = data.ID;
	data = {};
	data.ID = id;

	request_ids.clear();
}

void Game_Windows::Window_User::Refresh(bool& async_wait) {
	async_wait = !Request();

	if (async_wait) {
		// Create fake window to prevent crashes
		if (!window) {
			window = std::make_unique<Window_Selectable>(0, 0, 0, 0);
		}
		return;
	}

	std::vector<FontRef> fonts;
	std::vector<PendingMessage> messages;

	// Preprocessing
	for (const auto& text: data.texts) {
		FontRef font;

		Filesystem_Stream::InputStream font_file;
		std::string font_name = ToString(text.font_name);

		if (!font_name.empty()) {
			// Try to find best fitting font
			if (text.flags.bold && text.flags.italic) {
				font_file = FileFinder::OpenFont(font_name + "-BoldItalic");
			}

			if (!font_file && text.flags.bold) {
				font_file = FileFinder::OpenFont(font_name + "-Bold");
			}

			if (!font_file && text.flags.italic) {
				font_file = FileFinder::OpenFont(font_name + "-Italic");
			}

			if (!font_file) {
				font_file = FileFinder::OpenFont(font_name+ "-Regular");
			}

			if (!font_file) {
				font_file = FileFinder::OpenFont(font_name);
			}

			if (!font_file) {
				Output::Warning("Font not found: {}", text.font_name);
				font = Font::Default();
			} else {
				font = Font::CreateFtFont(std::move(font_file), text.font_size, text.flags.bold, text.flags.italic);
				if (!font) {
					Output::Warning("Error loading font: {}", text.font_name);
					font = Font::Default();
				}
			}
		} else {
			font = Font::Default();
		}

		fonts.emplace_back(font);

		std::stringstream ss(ToString(text.text));
		std::string out;
		PendingMessage pm(CommandCodeInserter);
		while (Utils::ReadLine(ss, out)) {
			pm.PushLine(out);
		}
		messages.emplace_back(pm);
	}

	auto apply_style = [](auto& font, const auto& text) {
		Font::Style style = font->GetCurrentStyle();
		style.size = text.font_size;
		style.bold = text.flags.bold;
		style.italic = text.flags.italic;
		style.draw_shadow = text.flags.draw_shadow;
		style.draw_gradient = text.flags.draw_gradient;
		style.color_offset = {};
		style.letter_spacing = text.letter_spacing;
		return font->ApplyStyle(style);
	};

	if (data.width == 0 || data.height == 0) {
		// Automatic window size
		int x_max = 0;
		int y_max = 0;

		for (size_t i = 0; i < data.texts.size(); ++i) {
			// Lots of duplication with the rendering code below but cannot be easily reduced more
			auto& font = fonts[i];
			const auto& pm = messages[i];
			const auto& text = data.texts[i];
			auto style_guard = apply_style(font, text);

			int x = text.position_x;
			int y = text.position_y;
			for (const auto& line: pm.GetLines()) {
				std::u32string line32;
				auto* text_index = line.data();
				const auto* end = line.data() + line.size();

				while (text_index != end) {
					auto tret = Utils::TextNext(text_index, end, Player::escape_char);
					text_index = tret.next;

					if (EP_UNLIKELY(!tret)) {
						continue;
					}

					const auto ch = tret.ch;

					if (ch == '\n') {
						if (!line32.empty()) {
							x += Text::GetSize(*font, Utils::EncodeUTF(line32)).width;
							line32.clear();
						}

						x_max = std::max(x, x_max);
						x = 0;
						y += text.font_size + text.line_spacing;

						continue;
					}

					if (Utils::IsControlCharacter(ch)) {
						// control characters not handled
						continue;
					}

					if (tret.is_exfont) {
						// exfont processed later
						line32 += '$';
					}

					if (tret.is_escape && ch != Player::escape_char) {
						if (!line32.empty()) {
							x += Text::GetSize(*font, Utils::EncodeUTF(line32)).width;
							line32.clear();
						}

						// Special message codes
						switch (ch) {
							case 'c':
							case 'C':
							{
								// Color
								text_index = Game_Message::ParseColor(text_index, end, Player::escape_char, true).next;
							}
							break;
						}
						continue;
					}

					line32 += static_cast<char32_t>(ch);
				}

				if (!line32.empty()) {
					x += Text::GetSize(*font, Utils::EncodeUTF(line32)).width;
				}

				x_max = std::max(x, x_max);

				x = 0;
				y += text.font_size + text.line_spacing;
			}

			y -= text.line_spacing;

			y_max = std::max(y, y_max);
		}

		// Border size
		if (data.flags.border_margin) {
			x_max += 16;
			y_max += 20; // 16 looks better but this matches better with Maniac Patch
		} else {
			x_max += 1;
			y_max += 1;
		}

		if (data.width == 0) {
			data.width = x_max;
		}

		if (data.height == 0) {
			data.height = y_max;
		}
	}

	window = std::make_unique<Window_Selectable>(0, 0, data.width, data.height);
	if (!data.flags.border_margin) {
		window->SetBorderX(0);
		// FIXME: Figure out why 0 does not work here (bug in Window class)
		window->SetBorderY(-3);
	}
	window->CreateContents();
	window->SetVisible(false);

	BitmapRef system;
	if (!data.system_name.empty()) {
		system = Cache::System(data.system_name);
	} else {
		system = Cache::SystemOrBlack();
	}

	auto& pic = Main_Data::game_pictures->GetPicture(data.ID);

	window->SetWindowskin(system);
	window->SetStretch(data.message_stretch == lcf::rpg::System::Stretch_stretch);
	window->SetBackgroundAlpha(pic.data.use_transparent_color);

	if (data.message_stretch == lcf::rpg::System::Stretch_easyrpg_none) {
		window->SetBackOpacity(0);
	}

	if (!data.flags.draw_frame) {
		window->SetFrameOpacity(0);
	}

	// Draw text
	for (size_t i = 0; i < data.texts.size(); ++i) {
		auto& font = fonts[i];
		const auto& pm = messages[i];
		const auto& text = data.texts[i];
		auto style_guard = apply_style(font, text);

		int x = text.position_x;
		int y = text.position_y + 2; // +2 to match the offset RPG_RT uses
		int text_color = 0;
		for (const auto& line: pm.GetLines()) {
			std::u32string line32;
			auto* text_index = line.data();
			const auto* end = line.data() + line.size();

			while (text_index != end) {
				auto tret = Utils::TextNext(text_index, end, Player::escape_char);
				text_index = tret.next;

				if (EP_UNLIKELY(!tret)) {
					continue;
				}

				const auto ch = tret.ch;

				if (ch == '\n') {
					if (!line32.empty()) {
						Text::Draw(*window->GetContents(), x, y, *font, *system, text_color, Utils::EncodeUTF(line32));
						line32.clear();
					}

					x = 0;
					y += text.font_size + text.line_spacing;
					continue;
				}

				if (Utils::IsControlCharacter(ch)) {
					// control characters not handled
					continue;
				}

				if (tret.is_exfont) {
					// exfont processed later
					line32 += '$';
				}

				if (tret.is_escape && ch != Player::escape_char) {
					if (!line32.empty()) {
						x += Text::Draw(*window->GetContents(), x, y, *font, *system, text_color, Utils::EncodeUTF(line32)).x;
						line32.clear();
					}

					// Special message codes
					switch (ch) {
						case 'c':
						case 'C':
						{
							// Color
							auto pres = Game_Message::ParseColor(text_index, end, Player::escape_char, true);
							auto value = pres.value;
							text_index = pres.next;
							text_color = value > 19 ? 0 : value;
						}
						break;
					}
					continue;
				}

				line32 += static_cast<char32_t>(ch);
			}

			if (!line32.empty()) {
				Text::Draw(*window->GetContents(), x, y, *font, *system, text_color, Utils::EncodeUTF(line32));
			}

			x = 0;
			y += text.font_size + text.line_spacing;
		}
	}

	// Add to picture
	pic.AttachWindow(*window);
}

bool Game_Windows::Window_User::Request() {
	if (!request_ids.empty()) {
		return true;
	}

	std::vector<FileRequestAsync*> requests;

	for (const auto& text: data.texts) {
		// Create Async requests for all needed resources
		std::string font_name = ToString(text.font_name);
		if (!font_name.empty()) {
			// Request all possible candidates of fonts
			auto bind = [this, &font_name, &requests](const char* suffix) {
				std::string name = font_name + suffix;
				FileRequestAsync* request = AsyncHandler::RequestFile("Font",  name);
				if (!request->IsReady()) {
					request->SetImportantFile(true);
					request_ids.push_back(request->Bind(&Window_User::OnRequestReady, this));
					requests.push_back(request);
				}
			};

			if (text.flags.bold && text.flags.italic) {
				bind("-BoldItalic");
			}

			if (text.flags.bold) {
				bind("-Bold");
			}

			if (text.flags.italic) {
				bind("-Italic");
			}

			bind("-Regular");
			bind("");
		}
	}

	if (!data.system_name.empty()) {
		FileRequestAsync* request = AsyncHandler::RequestFile("System", data.system_name);
		if (!request->IsReady()) {
			request->SetImportantFile(true);
			request->SetGraphicFile(true);
			request_ids.push_back(request->Bind(&Window_User::OnRequestReady, this));
			requests.push_back(request);
		}
	}

	if (request_ids.empty()) {
		// Every request is already finished
		return true;
	}

	for (auto& request: requests) {
		request->Start();
	}

	return false;
}

void Game_Windows::Window_User::OnRequestReady(FileRequestResult* result) {
	auto it = std::find_if(request_ids.begin(), request_ids.end(), [&result](const auto& what) {
		return *what == result->request_id;
	});

	assert(it != request_ids.end());

	request_ids.erase(it);

	if (request_ids.empty()) {
		// All assets requested, repeat Refresh call
		bool async_wait;
		Refresh(async_wait);

		assert(!async_wait);
	}
}

void Game_Windows::Erase(int id) {
	auto* window = GetWindowPtr(id);
	if (EP_LIKELY(window)) {
		window->Erase();
	}
}


/*end of file .\game_windows.cpp*/

/*start of file .\graphics.cpp*/

/* ... license chunk ... */

// Headers
#include <memory>
#include <sstream>
#include <chrono>

#include "graphics.h"
#include "cache.h"
#include "player.h"
#include "fps_overlay.h"
#include "message_overlay.h"
#include "transition.h"
#include "scene.h"
#include "drawable_mgr.h"
#include "baseui.h"
#include "game_clock.h"

using namespace std::chrono_literals;

namespace Graphics {
	void UpdateTitle();

	std::shared_ptr<Scene> current_scene;

	std::unique_ptr<MessageOverlay> message_overlay;
	std::unique_ptr<FpsOverlay> fps_overlay;

	std::string window_title_key;
}

void Graphics::Init() {
	Scene::Push(std::make_shared<Scene>());
	UpdateSceneCallback();

	message_overlay = std::make_unique<MessageOverlay>();
	fps_overlay = std::make_unique<FpsOverlay>();
}

void Graphics::Quit() {
	fps_overlay.reset();
	message_overlay.reset();

	Cache::ClearAll();

	Scene::PopUntil(Scene::Null);
	Scene::Pop();
}

void Graphics::Update() {
	fps_overlay->SetDrawFps(DisplayUi->RenderFps());

	//Update Graphics:
	if (fps_overlay->Update()) {
		UpdateTitle();
	}
}

void Graphics::UpdateTitle() {
	if (DisplayUi->IsFullscreen()) {
		return;
	}

#ifdef EMSCRIPTEN
	return;
#else
	std::string fps;
	if (DisplayUi->ShowFpsOnTitle()) {
		fps += fps_overlay->GetFpsString();
	}

	if (window_title_key == (Player::game_title + fps)) {
		return;
	}

	std::stringstream title;
	if (!Player::game_title.empty()) {
		title << Player::game_title << " - ";
	}
	title << GAME_TITLE;

	if (DisplayUi->ShowFpsOnTitle()) {
		title << " - " << fps;
	}

	DisplayUi->SetTitle(title.str());

	window_title_key = (Player::game_title + fps);
#endif
}

void Graphics::Draw(Bitmap& dst) {
	auto& transition = Transition::instance();

	auto min_z = std::numeric_limits<Drawable::Z_t>::min();
	auto max_z = std::numeric_limits<Drawable::Z_t>::max();
	if (transition.IsActive()) {
		min_z = transition.GetZ();
	} else if (transition.IsErasedNotActive()) {
		min_z = transition.GetZ() + 1;
		dst.Clear();
	}
	LocalDraw(dst, min_z, max_z);
}

void Graphics::LocalDraw(Bitmap& dst, Drawable::Z_t min_z, Drawable::Z_t max_z) {
	auto& drawable_list = DrawableMgr::GetLocalList();

	if (!drawable_list.empty() && min_z == std::numeric_limits<Drawable::Z_t>::min()) {
		current_scene->DrawBackground(dst);
	}

	drawable_list.Draw(dst, min_z, max_z);
}

std::shared_ptr<Scene> Graphics::UpdateSceneCallback() {
	auto prev_scene = current_scene;
	current_scene = Scene::instance;

	if (current_scene) {
		if (prev_scene) {
			prev_scene->Suspend(current_scene->type);
			current_scene->TransferDrawablesFrom(*prev_scene);
		}
		DrawableMgr::SetLocalList(&current_scene->GetDrawableList());
	} else {
		DrawableMgr::SetLocalList(nullptr);
	}

	return prev_scene;
}

MessageOverlay& Graphics::GetMessageOverlay() {
	return *message_overlay;
}



/*end of file .\graphics.cpp*/

/*start of file .\hslrgb.cpp*/

/* ... license chunk ... */

// Headers
#include "hslrgb.h"
#include "util_macro.h"

struct ColorHSL {
	double h;
	double s;
	double l;
};

/**
 ** RGB to HSL.
 */
ColorHSL RGB2HSL(Color col) {
	ColorHSL ncol;
	double vmin, vmax, delta;
	double r, g, b;
	r = col.red / 255.0;
	g = col.green / 255.0;
	b = col.blue / 255.0;
	vmin = min(min(r, g), b);
	vmax = max(max(r, g), b);
	delta = vmax - vmin;
	ncol.l = (vmax + vmin) / 2;
	if (delta == 0) {
		ncol.h = 0;
		ncol.s = 0;
	} else {
		double dr, dg, db;
		if (ncol.l < 0.5) {
			ncol.s = delta / (vmax + vmin);
		} else {
			ncol.s = delta / (2 - vmax - vmin);
		}
		dr = (((vmax - r) / 6) + (delta / 2)) / delta;
		dg = (((vmax - g) / 6) + (delta / 2)) / delta;
		db = (((vmax - b) / 6) + (delta / 2)) / delta;
		if (r == vmax) {
			ncol.h = db - dg;
		} else if (g == vmax) {
			ncol.h = (1.0 / 3) + dr - db;
		} else if (b == vmax) {
			ncol.h = (2.0 / 3) + dg - dr;
		}
	}
	return ncol;
}

/**
 * Hue to RGB.
 */
double Hue_2_RGB(double v1, double v2, double vH) {
	if (vH < 0) vH += 1;
	if (vH > 1) vH -= 1;
	if ((6 * vH) < 1) return (v1 + (v2 - v1) * 6 * vH);
	if ((2 * vH) < 1) return (v2);
	if ((3 * vH) < 2) return (v1 + (v2 - v1) * ((2.0 / 3) - vH ) * 6);
	return v1;
}

/**
 * HSL to RGB.
 */
Color HSL2RGB(ColorHSL col) {
	Color ncol(0, 0, 0, 0);
	if (col.s == 0) {
		ncol.red = (unsigned char)(col.l * 255);
		ncol.green = (unsigned char)(col.l * 255);
		ncol.blue = (unsigned char)(col.l * 255);
	} else {
		double v1, v2;
		if (col.l < 0.5) {
			v2 = col.l * (1 + col.s);
		} else {
			v2 = (col.l + col.s) - (col.s * col.l);
		}
		v1 = 2 * col.l - v2;
		ncol.red = (unsigned char)(255 * Hue_2_RGB(v1, v2, col.h + (1.0 / 3)));
		ncol.green = (unsigned char)(255 * Hue_2_RGB(v1, v2, col.h));
		ncol.blue = (unsigned char)(255 * Hue_2_RGB(v1, v2, col.h - (1.0 / 3)));
	}
	return ncol;
}

Color RGBAdjustHSL(Color col, double h, double s, double l) {
	ColorHSL hsl;
	Color rgb = col;
	hsl = RGB2HSL(rgb);
	hsl.h = hsl.h + h / 360.0;
	while (hsl.h > 1) hsl.h -= 1;
	while (hsl.h < 0) hsl.h += 1;
	hsl.s = hsl.s + s;
	if (hsl.s > 1) hsl.s = 1;
	if (hsl.s < 0) hsl.s = 0;
	hsl.l = hsl.l * l;
	if (hsl.l > 1) hsl.l = 1;
	if (hsl.l < 0) hsl.l = 0;
	rgb = HSL2RGB(hsl);
	rgb.alpha = col.alpha;
	return rgb;
}


/*end of file .\hslrgb.cpp*/

/*start of file .\image_bmp.cpp*/

/* ... license chunk ... */

// Headers
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include "output.h"
#include "image_bmp.h"

static uint16_t get_2(const uint8_t *&p, const uint8_t* e) {
	if (e - p < 2) {
		p = e;
		return 0;
	}
	auto value = static_cast<uint16_t>(p[0] | (p[1] << 8));
	p += 2;
	return value;
}

static uint32_t get_4(const uint8_t *&p, const uint8_t* e) {
	if (e - p < 4) {
		p = e;
		return 0;
	}
	auto value = static_cast<uint32_t>(p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24));
	p+= 4;
	return value;
}

ImageBMP::BitmapHeader ImageBMP::ParseHeader(const uint8_t*& ptr, uint8_t const* const e) {
	BitmapHeader hdr;

	auto* hdr_start = ptr;

	auto size = get_4(ptr, e);

	hdr.size = size;
	if (size == 12) {
		// BITMAPCOREHEADER
		hdr.w = get_2(ptr, e);
		hdr.h = get_2(ptr, e);
		hdr.planes = get_2(ptr, e);
		hdr.depth = get_2(ptr, e);
		hdr.num_colors = (1 << hdr.depth);
		hdr.palette_size = 3;
	} else {
		// BITMAPINFOHEADER, BITMAPV4HEADER, or BITMAPV5HEADER
		hdr.w = get_4(ptr, e);
		hdr.h = get_4(ptr, e);
		hdr.planes = get_2(ptr, e);
		hdr.depth = get_2(ptr, e);
		hdr.compression = get_4(ptr, e);
		ptr += 12;
		hdr.num_colors = std::min(uint32_t(256), get_4(ptr, e));
		hdr.palette_size = 4;
		if (hdr.num_colors == 0) {
			// When 0 number of colors is the maximum allowed
			if (hdr.depth == 4) {
				hdr.num_colors = 16;
			} else if (hdr.depth == 8) {
				hdr.num_colors = 256;
			}
		}
	}

	ptr = hdr_start + size;
	return hdr;
}

bool ImageBMP::Read(const uint8_t* data, unsigned len, bool transparent, ImageOut& output) {
	output.pixels = nullptr;

	if (len < 64) {
		Output::Warning("Not a valid BMP file.");
		return false;
	}
	auto* ptr = data;
	auto* e = data + len;

	static const unsigned BITMAPFILEHEADER_SIZE = 14;

	ptr += BITMAPFILEHEADER_SIZE - 4;
	const unsigned bits_offset = get_4(ptr, e);

	auto hdr = ParseHeader(ptr, e);

	bool vflip = hdr.h > 0;
	if (!vflip)
		hdr.h = -hdr.h;

	if (hdr.planes != 1) {
		Output::Warning("BMP planes is not 1.");
		return false;
	}

	if (hdr.depth != 8 && hdr.depth != 4) {
		Output::Warning("BMP image depth unsupported: {} bit.", hdr.depth);
		return false;
	}

	if (hdr.compression) {
		Output::Warning("BMP image is compressed.");
		return false;
	}

	auto* palette = ptr;

	auto get_palette = [&](int idx) {
		return palette + idx * hdr.palette_size;
	};

	// Ensure no palette entry is an exact duplicate of the transparent color at #0
	for (int i = 1; i < hdr.num_colors; i++) {
		auto* p = get_palette(i);
		if (p[0] == palette[0] && p[1] == palette[1] && p[2] == palette[2]) {
			// FIXME: Remove the need for this const_cast
			const_cast<uint8_t*>(p)[0] ^= 1;
		}
	}

	const uint8_t* src_pixels = &data[bits_offset];

	// bitmap scan lines need to be aligned to 32 bit boundaries, add padding if needed
	int line_width = (hdr.depth == 4) ? (hdr.w + 1) >> 1 : hdr.w;
	int padding = (-line_width)&3;

	output.pixels = malloc(hdr.w * hdr.h * 4);
	if (!output.pixels) {
		Output::Warning("Error allocating BMP pixel buffer.");
		return false;
	}

	uint8_t* dst = (uint8_t*) output.pixels;
	for (int y = 0; y < hdr.h; y++) {
		const uint8_t* src = src_pixels + (vflip ? hdr.h - 1 - y : y) * (line_width + padding);
		for (int x = 0; x < hdr.w; x += 2) {
			uint8_t pix = *src++;
			uint8_t pix2 = 0;
			const uint8_t* color;

			// split up packed pixel
			if (hdr.depth == 4) {
				pix2 = pix & 15;
				pix >>= 4;
			}

			color = get_palette(pix);
			*dst++ = color[2];
			*dst++ = color[1];
			*dst++ = color[0];
			*dst++ = (transparent && pix == 0) ? 0 : 255;

			// end of line
			if (x + 1 == hdr.w)
				break;

			pix = (hdr.depth == 8) ? *src++ : pix2;

			color = get_palette(pix);
			*dst++ = color[2];
			*dst++ = color[1];
			*dst++ = color[0];
			*dst++ = (transparent && pix == 0) ? 0 : 255;
		}
	}

	output.width = hdr.w;
	output.height = hdr.h;
	output.bpp = hdr.depth; // Currently only 4 and 8 bit (indexed) are supported
	return true;
}

bool ImageBMP::Read(Filesystem_Stream::InputStream& stream, bool transparent, ImageOut& output) {
	std::vector<uint8_t> buffer = Utils::ReadStream(stream);
	return Read(&buffer.front(), (unsigned) buffer.size(), transparent, output);
}


/*end of file .\image_bmp.cpp*/

/*start of file .\image_png.cpp*/

/* ... license chunk ... */

// Headers
#include <png.h>
#include <cstdlib>
#include <cstring>
#include <csetjmp>
#include <vector>
#include <fstream>

#include "output.h"
#include "image_png.h"

static void read_data(png_structp png_ptr, png_bytep data, png_size_t length) {
	png_bytep* bufp = (png_bytep*) png_get_io_ptr(png_ptr);
	memcpy(data, *bufp, length);
	*bufp += length;
}

static void read_data_istream(png_structp png_ptr, png_bytep data, png_size_t length) {
	auto* bufp = reinterpret_cast<Filesystem_Stream::InputStream*>(png_get_io_ptr(png_ptr));
	if (bufp != nullptr && *bufp) {
		bufp->read(reinterpret_cast<char*>(data), length);
	}
}

static void on_png_warning(png_structp, png_const_charp warn_msg) {
	Output::Debug("libpng: {}", warn_msg);
}

static void on_png_error(png_structp, png_const_charp error_msg) {
	Output::Warning("libpng: {}", error_msg);
}

static bool ReadPNGWithReadFunction(png_voidp,png_rw_ptr, bool, ImageOut&);
static void ReadPalettedData(png_struct*, png_info*, png_uint_32, png_uint_32, bool, uint32_t*);
static void ReadGrayData(png_struct*, png_info*, png_uint_32, png_uint_32, bool, uint32_t*);
static void ReadGrayAlphaData(png_struct*, png_info*, png_uint_32, png_uint_32, uint32_t*);
static void ReadRGBData(png_struct*, png_info*, png_uint_32, png_uint_32, uint32_t*);
static void ReadRGBAData(png_struct*, png_info*, png_uint_32, png_uint_32, uint32_t*);

bool ImagePNG::Read(const void* buffer, bool transparent, ImageOut& output) {
	return ReadPNGWithReadFunction((png_voidp)&buffer, read_data, transparent, output);
}

bool ImagePNG::Read(Filesystem_Stream::InputStream& stream, bool transparent, ImageOut& output) {
	return ReadPNGWithReadFunction(&stream, read_data_istream, transparent, output);
}

static bool ReadPNGWithReadFunction(png_voidp user_data, png_rw_ptr fn, bool transparent, ImageOut& output) {
	output.pixels = nullptr;

	png_struct *png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, on_png_error, on_png_warning);
	if (png_ptr == NULL) {
		Output::Warning("Couldn't allocate PNG structure");
		return false;
	}

	png_info *info_ptr = png_create_info_struct(png_ptr);
	if (info_ptr == NULL) {
		Output::Warning("Couldn't allocate PNG info structure");
		return false;
	}

	if (setjmp(png_jmpbuf(png_ptr))) {
		png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
		return false;
	}

	png_set_read_fn(png_ptr, user_data, fn);

	png_read_info(png_ptr, info_ptr);

	png_uint_32 w, h;
	int bit_depth, color_type;
	png_get_IHDR(png_ptr, info_ptr, &w, &h,
				 &bit_depth, &color_type, NULL, NULL, NULL);

	output.pixels = malloc(w * h * 4);
	if (!output.pixels) {
		Output::Warning("Error allocating PNG pixel buffer.");
		return false;
	}

	switch (color_type) {
		case PNG_COLOR_TYPE_PALETTE:
			ReadPalettedData(png_ptr, info_ptr, w, h, transparent, (uint32_t*)output.pixels);
			output.bpp = 8;
			break;
		case PNG_COLOR_TYPE_GRAY:
			ReadGrayData(png_ptr, info_ptr, w, h, transparent, (uint32_t*)output.pixels);
			output.bpp = 8;
			break;
		case PNG_COLOR_TYPE_GRAY_ALPHA:
			ReadGrayAlphaData(png_ptr, info_ptr, w, h, (uint32_t*)output.pixels);
			output.bpp = 8;
			break;
		case PNG_COLOR_TYPE_RGB:
			ReadRGBData(png_ptr, info_ptr, w, h, (uint32_t*)output.pixels);
			output.bpp = 24;
			break;
		case PNG_COLOR_TYPE_RGB_ALPHA:
			ReadRGBAData(png_ptr, info_ptr, w, h, (uint32_t*)output.pixels);
			output.bpp = 32;
			break;
	}

	png_read_end(png_ptr, NULL);
	png_destroy_read_struct(&png_ptr, &info_ptr, NULL);

	output.width = w;
	output.height = h;
	return true;
}

static void ReadPalettedData(
	png_struct* png_ptr, png_info* info_ptr,
	png_uint_32 w, png_uint_32 h,
	bool transparent,
	uint32_t* pixels
) {
	// For transparent images, all the colors are opaque, except the
	// color with index 0. So we'll need to do index->RGB conversion
	// on our own.
	png_set_packing(png_ptr);
	png_read_update_info(png_ptr, info_ptr);

	if (!png_get_valid(png_ptr, info_ptr, PNG_INFO_PLTE)) {
		Output::Warning("Palette PNG without PLTE block");
		return;
	}

	png_colorp palette;
	int num_palette;
	png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette);

	for (png_uint_32 y = 0; y < h; y++) {
		// We read the indices (w bytes) into the end of the pixel
		// data for this row (4w bytes), then scan over them
		// converting them into RGBA values. Putting them at the end
		// gives us enough room that we don't overwrite an index
		// we'll need later with an RGBA value.

		uint32_t* beginning_of_row = pixels + y * w;

		uint8_t* indices = (uint8_t*)beginning_of_row + w * 3;
		png_read_row(png_ptr, (png_bytep)indices, NULL);

		uint32_t* dst = beginning_of_row;
		for (png_uint_32 x = 0; x < w; x++, dst++) {
			uint8_t idx = indices[x];
			png_color& color = palette[idx];
			uint8_t alpha = (idx == 0 && transparent) ? 0 : 255;
			uint8_t rgba[4] = { color.red, color.green, color.blue, alpha };
			*dst = *(uint32_t*)rgba;
		}
	}
}

static void ReadGrayData(
	png_struct* png_ptr, png_info* info_ptr,
	png_uint_32 w, png_uint_32 h,
	bool transparent,
	uint32_t* pixels
) {
	png_set_strip_16(png_ptr);
	png_set_expand(png_ptr);
	png_set_gray_to_rgb(png_ptr);
	png_set_filler(png_ptr, 0xFF, PNG_FILLER_AFTER);
	png_read_update_info(png_ptr, info_ptr);

	for (png_uint_32 y = 0; y < h; y++) {
		png_bytep dst = (png_bytep) pixels + y * w * 4;
		png_read_row(png_ptr, dst, NULL);
	}

	// Black pixels are transparent
	if (transparent) {
		uint8_t ck1[4] = {0, 0, 0, 255};
		uint8_t ck2[4] = {0, 0, 0,   0};
		uint32_t srckey = *(uint32_t*)ck1;
		uint32_t dstkey = *(uint32_t*)ck2;
		uint32_t* p = (uint32_t*) pixels;
		for (unsigned i = 0; i < w * h; i++, p++)
			if (*p == srckey)
				*p = dstkey;
	}
}

static void ReadGrayAlphaData(
	png_struct* png_ptr, png_info* info_ptr,
	png_uint_32 w, png_uint_32 h,
	uint32_t* pixels
) {
	png_set_strip_16(png_ptr);
	png_set_gray_to_rgb(png_ptr);
	png_read_update_info(png_ptr, info_ptr);

	for (png_uint_32 y = 0; y < h; y++) {
		png_bytep dst = (png_bytep) pixels + y * w * 4;
		png_read_row(png_ptr, dst, NULL);
	}
}

static void ReadRGBData(
	png_struct* png_ptr, png_info* info_ptr,
	png_uint_32 w, png_uint_32 h,
	uint32_t* pixels
) {
	png_set_strip_16(png_ptr);
	png_set_filler(png_ptr, 0xFF, PNG_FILLER_AFTER);
	png_read_update_info(png_ptr, info_ptr);

	for (png_uint_32 y = 0; y < h; y++) {
		png_bytep dst = (png_bytep) pixels + y * w * 4;
		png_read_row(png_ptr, dst, NULL);
	}
}

static void ReadRGBAData(
	png_struct* png_ptr, png_info* info_ptr,
	png_uint_32 w, png_uint_32 h,
	uint32_t* pixels
) {
	png_set_strip_16(png_ptr);
	png_read_update_info(png_ptr, info_ptr);

	for (png_uint_32 y = 0; y < h; y++) {
		png_bytep dst = (png_bytep) pixels + y * w * 4;
		png_read_row(png_ptr, dst, NULL);
	}
}

static void write_data(png_structp out_ptr, png_bytep data, png_size_t len) {
	reinterpret_cast<Filesystem_Stream::OutputStream*>(png_get_io_ptr(out_ptr))->write(reinterpret_cast<char const*>(data), len);
}
static void flush_stream(png_structp out_ptr) {
	reinterpret_cast<Filesystem_Stream::OutputStream*>(png_get_io_ptr(out_ptr))->flush();
}

bool ImagePNG::Write(std::ostream& os, uint32_t width, uint32_t height, uint32_t* data) {
	png_structp write = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
	if (!write) {
		Output::Warning("Bitmap::WritePNG: error in png_create_write");
		return false;
	}

	png_infop info = png_create_info_struct(write);
	if (!info) {
		png_destroy_write_struct(&write, &info);
		Output::Warning("ImagePNG::WritePNG: error in png_create_info_struct");
		return false;
	}

	png_bytep* ptrs = new png_bytep[height];
	for (size_t i = 0; i < height; ++i) {
		ptrs[i] = reinterpret_cast<png_bytep>(&data[width*i]);
	}

	if (setjmp(png_jmpbuf(write))) {
		png_destroy_write_struct(&write, &info);
		delete [] ptrs;
		Output::Warning("ImagePNG::WritePNG: error writing PNG file");
		return false;
	}

	png_set_write_fn(write, &os, &write_data, &flush_stream);

	png_set_IHDR(write, info, width, height, 8,
				 PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE,
				 PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
	png_write_info(write, info);
	png_write_image(write, ptrs);
	png_write_end(write, NULL);

	png_destroy_write_struct(&write, &info);
	delete [] ptrs;

	return true;
}


/*end of file .\image_png.cpp*/

/*start of file .\image_xyz.cpp*/

/* ... license chunk ... */

// Headers
#include <cstdlib>
#include <cstring>
#include <istream>
#include <zlib.h>
#include <vector>
#include "output.h"
#include "image_xyz.h"

bool ImageXYZ::Read(const uint8_t* data, unsigned len, bool transparent, ImageOut& output) {
	output.pixels = nullptr;

	if (len < 8) {
		Output::Warning("Not a valid XYZ file.");
		return false;
	}

	uint16_t w = data[4] + (data[5] << 8);
	uint16_t h = data[6] + (data[7] << 8);
	uLongf src_size = len - 8;
	Bytef* src_buffer = (Bytef*)&data[8];
	uLongf dst_size = 768 + (w * h);
	std::vector<Bytef> dst_buffer(dst_size);

	int status = uncompress(&dst_buffer.front(), &dst_size, src_buffer, src_size);
	if (status != Z_OK) {
		Output::Warning("Error decompressing XYZ file.");
		return false;
	}
	const uint8_t (*palette)[3] = (const uint8_t(*)[3]) &dst_buffer.front();

	output.pixels = malloc(w * h * 4);
	if (!output.pixels) {
		Output::Warning("Error allocating XYZ pixel buffer.");
		return false;
	}

	uint8_t* dst = (uint8_t*) output.pixels;
	const uint8_t* src = (const uint8_t*) &dst_buffer[768];
	for (int y = 0; y < h; y++) {
		for (int x = 0; x < w; x++) {
			uint8_t pix = *src++;
			const uint8_t* color = palette[pix];
			*dst++ = color[0];
			*dst++ = color[1];
			*dst++ = color[2];
			*dst++ = (transparent && pix == 0) ? 0 : 255;
		}
	}

	output.width = w;
	output.height = h;
	output.bpp = 8;

	return true;
}

bool ImageXYZ::Read(Filesystem_Stream::InputStream& stream, bool transparent, ImageOut& output) {
	std::vector<uint8_t> buffer = Utils::ReadStream(stream);
	return Read(&buffer.front(), (unsigned) buffer.size(), transparent, output);
}


/*end of file .\image_xyz.cpp*/

/*start of file .\input.cpp*/

/* ... license chunk ... */

// Headers
#include "input.h"
#include "game_config.h"
#include "input_buttons.h"
#include "input_source.h"
#include "output.h"
#include "player.h"
#include "system.h"
#include "baseui.h"

#include <algorithm>
#include <array>
#include <fstream>
#include <utility>
#include <cassert>

namespace Input {
	/**
	 * Start repeat time (in frames) a key has
	 * to be maintained pressed before being
	 * repeated for fist time.
	 */
	constexpr int start_repeat_time = 23;

	/**
	 * Repeat time (in frames) a key has to be
	 * maintained pressed after the start repeat time
	 * has passed for being repeated again.
	 */
	constexpr int repeat_time = 4;

	std::array<int, BUTTON_COUNT> press_time;
	std::bitset<BUTTON_COUNT> triggered, repeated, released;
	Input::KeyStatus raw_triggered, raw_pressed, raw_released;
	int dir4;
	int dir8;
	std::unique_ptr<Source> source;

	bool wait_input = false;
}

bool Input::IsWaitingInput() { return wait_input; }
void Input::WaitInput(bool v) { wait_input = v; }

void Input::Init(
	Game_ConfigInput cfg,
	const std::string& replay_from_path,
	const std::string& record_to_path
) {
	std::fill(press_time.begin(), press_time.end(), 0);
	triggered.reset();
	repeated.reset();
	released.reset();
	raw_triggered.reset();
	raw_pressed.reset();
	raw_released.reset();

	DirectionMappingArray directions = {
		{ Direction::DOWN, DOWN },
		{ Direction::LEFT, LEFT },
		{ Direction::RIGHT, RIGHT },
		{ Direction::UP, UP }
	};

	cfg.Hide();
	Input::GetSupportedConfig(cfg);

	source = Source::Create(cfg, std::move(directions), replay_from_path);
	source->InitRecording(record_to_path);

	ResetMask();
}

static void UpdateButton(int i, bool pressed) {
	using namespace Input;

	if (pressed) {
		released[i] = false;
		press_time[i] += 1;
	} else {
		released[i] = press_time[i] > 0;
		press_time[i] = 0;
	}

	if (press_time[i] > 0) {
		triggered[i] = press_time[i] == 1;
		repeated[i] = press_time[i] == 1 || (press_time[i] >= start_repeat_time && press_time[i] % repeat_time == 0);
	} else {
		triggered[i] = false;
		repeated[i] = false;
	}
}

void Input::Update() {
	wait_input = false; // clear each frame

	source->Update();
	auto& pressed_buttons = source->GetPressedButtons();

	// Check button states
	for (unsigned i = 0; i < BUTTON_COUNT; ++i) {
		bool pressed = pressed_buttons[i];
		UpdateButton(i, pressed);
	}

	auto& directions = source->GetDirectionMappings();

	// Press time for directional buttons, the less they have been pressed, the higher their priority will be
	int dirpress[Direction::NUM_DIRECTIONS] = {};

	// Get max pressed time for each directional button
	for (auto& dm: directions) {
		if (dirpress[dm.first] < press_time[dm.second]) {
			dirpress[dm.first] = press_time[dm.second];
		};
	}

	// Calculate diagonal directions pressed time by dir4 combinations
	dirpress[Direction::DOWNLEFT] += (dirpress[Direction::DOWN] > 0 && dirpress[Direction::LEFT] > 0) ? dirpress[Direction::DOWN] + dirpress[Direction::LEFT] : 0;
	dirpress[Direction::DOWNRIGHT] += (dirpress[Direction::DOWN] > 0 && dirpress[Direction::RIGHT] > 0) ? dirpress[Direction::DOWN] + dirpress[Direction::RIGHT] : 0;
	dirpress[Direction::UPLEFT] += (dirpress[Direction::UP] > 0 && dirpress[Direction::LEFT] > 0) ? dirpress[Direction::UP] + dirpress[Direction::LEFT] : 0;
	dirpress[Direction::UPRIGHT] += (dirpress[Direction::UP] > 0 && dirpress[Direction::RIGHT] > 0) ? dirpress[Direction::UP] + dirpress[Direction::RIGHT] : 0;

	dir4 = Direction::NONE;
	dir8 = Direction::NONE;

	// Check if no opposed keys are being pressed at the same time
	if (!(dirpress[Direction::DOWN] > 0 && dirpress[Direction::UP] > 0) && !(dirpress[Direction::LEFT] > 0 && dirpress[Direction::RIGHT] > 0)) {

		// Get dir4 by the with lowest press time (besides 0 frames)
		int min_press_time = 0;
		for (int i = 2; i <= 8; i += 2) {
			if (dirpress[i] > 0) {
				if (min_press_time == 0 || dirpress[i] < min_press_time) {
					dir4 = i;
					min_press_time = dirpress[i];
				}
			}
		}

		// Dir8 will be at least equal to Dir4
		dir8 = dir4;

		// Check diagonal directions (There is a priority order)
		if		(dirpress[Direction::UPRIGHT] > 0)	dir8 = Direction::UPRIGHT;
		else if (dirpress[Direction::UPLEFT] > 0)	dir8 = Direction::UPLEFT;
		else if (dirpress[Direction::DOWNRIGHT] > 0)	dir8 = Direction::DOWNRIGHT;
		else if (dirpress[Direction::DOWNLEFT] > 0)	dir8 = Direction::DOWNLEFT;
	}

	// Determine pressed & released keys from raw keystate
	const auto& raw_pressed_now = source->GetPressedKeys();
	for (unsigned i = 0; i < Input::Keys::KEYS_COUNT; ++i) {
		raw_triggered[i] = raw_pressed_now[i] && !raw_pressed[i];
		raw_released[i] = !raw_pressed_now[i] && raw_pressed[i];
	}
	raw_pressed = raw_pressed_now;
}

void Input::UpdateSystem() {
	source->UpdateSystem();
	auto& pressed_buttons = source->GetPressedButtons();

	// Check button states
	for (unsigned i = 0; i < BUTTON_COUNT; ++i) {
		if (IsSystemButton(static_cast<InputButton>(i))) {
			bool pressed = pressed_buttons[i];
			UpdateButton(i, pressed);
		}
	}
}

void Input::ResetKeys() {
	triggered.reset();
	repeated.reset();
	released.reset();
	for (unsigned i = 0; i < BUTTON_COUNT; i++) {
		press_time[i] = 0;
	}
	dir4 = Direction::NONE;
	dir8 = Direction::NONE;

	// TODO: we want Input to be agnostic to where the button
	// presses are coming from, and if there's a UI at all.
	// Move this into the callers?
	if (DisplayUi) {
		DisplayUi->GetKeyStates().reset();
	}
}

void Input::ResetTriggerKeys() {
	triggered.reset();
}

void Input::ResetNonSystemKeys() {
	auto buttons = source->GetButtonMappings();
	auto& key_states = DisplayUi->GetKeyStates();

	for (auto& bm: buttons) {
		if (IsSystemButton(bm.first)) {
			continue;
		}

		triggered[bm.first] = false;
		repeated[bm.first] = false;
		released[bm.first] = false;
		press_time[bm.first] = 0;
		key_states[bm.second] = false;
	}

	dir4 = Direction::NONE;
	dir8 = Direction::NONE;
}

void Input::ResetDefaultMapping(Input::InputButton button) {
	auto def_mappings = GetDefaultButtonMappings();
	auto& mappings = Input::GetInputSource()->GetButtonMappings();

	mappings.RemoveAll(button);

	for (auto ki = def_mappings.LowerBound(button); ki != def_mappings.end() && ki->first == button;++ki) {
		mappings.Add(*ki);
	}
}

void Input::ResetAllMappings() {
	auto& mappings = Input::GetInputSource()->GetButtonMappings();
	mappings = GetDefaultButtonMappings();
}

bool Input::IsPressed(InputButton button) {
	assert(!IsSystemButton(button));
	WaitInput(true);
	return press_time[button] > 0;
}

bool Input::IsTriggered(InputButton button) {
	assert(!IsSystemButton(button));
	WaitInput(true);
	return triggered[button];
}

bool Input::IsRepeated(InputButton button) {
	assert(!IsSystemButton(button));
	WaitInput(true);
	return repeated[button];
}

bool Input::IsReleased(InputButton button) {
	assert(!IsSystemButton(button));
	WaitInput(false);
	return released[button];
}

bool Input::IsSystemPressed(InputButton button) {
	assert(IsSystemButton(button));
	return press_time[button] > 0;
}

bool Input::IsSystemTriggered(InputButton button) {
	assert(IsSystemButton(button));
	return triggered[button];
}

bool Input::IsSystemRepeated(InputButton button) {
	assert(IsSystemButton(button));
	return repeated[button];
}

bool Input::IsSystemReleased(InputButton button) {
	assert(IsSystemButton(button));
	return released[button];
}

bool Input::IsAnyPressed() {
	WaitInput(true);
	return std::find_if(press_time.begin(), press_time.end(),
						[](int t) {return t > 0;}) != press_time.end();
}

bool Input::IsAnyTriggered() {
	WaitInput(true);
	return triggered.any();
}

bool Input::IsAnyRepeated() {
	WaitInput(true);
	return repeated.any();
}

bool Input::IsAnyReleased() {
	WaitInput(false);
	return released.any();
}

std::vector<Input::InputButton> Input::GetAllPressed() {
	WaitInput(true);
	std::vector<InputButton> vector;
	for (unsigned i = 0; i < BUTTON_COUNT; i++) {
		if (press_time[i] > 0)
			vector.push_back((InputButton)i);
	}
	return vector;
}

std::vector<Input::InputButton> Input::GetAllTriggered() {
	WaitInput(true);
	std::vector<InputButton> vector;
	for (unsigned i = 0; i < BUTTON_COUNT; i++) {
		if (triggered[i])
			vector.push_back((InputButton)i);
	}
	return vector;
}

std::vector<Input::InputButton> Input::GetAllRepeated() {
	WaitInput(true);
	std::vector<InputButton> vector;
	for (unsigned i = 0; i < BUTTON_COUNT; i++) {
		if (repeated[i])
			vector.push_back((InputButton)i);
	}
	return vector;
}

std::vector<Input::InputButton> Input::GetAllReleased() {
	WaitInput(false);
	std::vector<InputButton> vector;
	for (unsigned i = 0; i < BUTTON_COUNT; i++) {
		if (released[i])
			vector.push_back((InputButton)i);
	}
	return vector;
}

bool Input::IsRawKeyPressed(Input::Keys::InputKey key) {
	return raw_pressed[key];
}

bool Input::IsRawKeyTriggered(Input::Keys::InputKey key) {
	return raw_triggered[key];
}

bool Input::IsRawKeyReleased(Input::Keys::InputKey key) {
	return raw_released[key];
}

const Input::KeyStatus& Input::GetAllRawPressed() {
	return raw_pressed;
}

const Input::KeyStatus& Input::GetAllRawTriggered() {
	return raw_triggered;
}

const Input::KeyStatus& Input::GetAllRawReleased() {
	return raw_released;
}

Point Input::GetMousePosition() {
	return source->GetMousePosition();
}

void Input::AddRecordingData(Input::RecordingData type, std::string_view data) {
	assert(source);
	source->AddRecordingData(type, data);
}

bool Input::IsRecording() {
	assert(source);
	return source->IsRecording();
}

Input::Source *Input::GetInputSource() {
	assert(source);
	return source.get();
}

Input::KeyStatus Input::GetMask() {
	assert(source);
	return source->GetMask();
}

void Input::SetMask(Input::KeyStatus new_mask) {
	auto& old_mask = source->GetMask();
	old_mask = new_mask;
}

void Input::ResetMask() {
	assert(source);
	SetMask(source->GetMask());
}

void Input::SimulateButtonPress(Input::InputButton button) {
	switch (button) {
		case Input::UP:
		case Input::DOWN:
		case Input::LEFT:
		case Input::RIGHT:
		{
			// Directional movement has its own input handling
			// These buttons need to be simulated on a lower level,
			// or else those movement actions will be overwritten
			auto& cfg = source->GetConfig();
			for (auto& bm : cfg.buttons) {
				if (bm.first == button) {
					source->SimulateKeyPress(bm.second);
					break;
				}
			}
			break;
		}
		default:
			break;
	}
	UpdateButton(button, true);
}


/*end of file .\input.cpp*/

/*start of file .\input_buttons_desktop.cpp*/

/* ... license chunk ... */

// FIXME: Move in platform/generic (?) and handle with CMake
#if !(defined(OPENDINGUX) || defined(PLAYER_NINTENDO) || defined(PLAYER_UI))

// Headers
#include "input_buttons.h"
#include "keys.h"
#include "game_config.h"

Input::ButtonMappingArray Input::GetDefaultButtonMappings() {
	return {
		{UP, Keys::UP},
		{UP, Keys::K},
		{UP, Keys::KP8},
		{UP, Keys::W},
		{DOWN, Keys::DOWN},
		{DOWN, Keys::J},
		{DOWN, Keys::KP2},
		{DOWN, Keys::S},
		{LEFT, Keys::LEFT},
		{LEFT, Keys::H},
		{LEFT, Keys::KP4},
		{LEFT, Keys::A},
		{RIGHT, Keys::RIGHT},
		{RIGHT, Keys::L},
		{RIGHT, Keys::KP6},
		{RIGHT, Keys::D},
		{DECISION, Keys::Z},
		{DECISION, Keys::SPACE},
		{DECISION, Keys::RETURN},
		{DECISION, Keys::SELECT},
		{CANCEL, Keys::AC_BACK},
		{CANCEL, Keys::X},
		{CANCEL, Keys::C},
		{CANCEL, Keys::V},
		{CANCEL, Keys::B},
		{CANCEL, Keys::N},
		{CANCEL, Keys::ESCAPE},
		{CANCEL, Keys::KP0},
		{SHIFT, Keys::LSHIFT},
		{SHIFT, Keys::RSHIFT},
		{N0, Keys::N0},
		{N0, Keys::KP0},
		{N1, Keys::N1},
		{N1, Keys::KP1},
		{N2, Keys::N2},
		{N2, Keys::KP2},
		{N3, Keys::N3},
		{N3, Keys::KP3},
		{N4, Keys::N4},
		{N4, Keys::KP4},
		{N5, Keys::N5},
		{N5, Keys::KP5},
		{N6, Keys::N6},
		{N6, Keys::KP6},
		{N7, Keys::N7},
		{N7, Keys::KP7},
		{N8, Keys::N8},
		{N8, Keys::KP8},
		{N9, Keys::N9},
		{N9, Keys::KP9},
		{PLUS, Keys::KP_ADD},
		{PLUS, Keys::RIGHT_BRACKET},
		{MINUS, Keys::KP_SUBTRACT},
		{MINUS, Keys::APOSTROPH},
		{MULTIPLY, Keys::KP_MULTIPLY},
		{MULTIPLY, Keys::LEFT_BRACKET},
		{DIVIDE, Keys::KP_DIVIDE},
		{DIVIDE, Keys::SEMICOLON},
		{PERIOD, Keys::KP_PERIOD},
		{PERIOD, Keys::PERIOD},
		{SETTINGS_MENU, Keys::F1},
		{DEBUG_MENU, Keys::F9},
		{DEBUG_THROUGH, Keys::LCTRL},
		{DEBUG_THROUGH, Keys::RCTRL},
		{DEBUG_SAVE, Keys::F11},
		{DEBUG_ABORT_EVENT, Keys::F10},
		{TAKE_SCREENSHOT, Keys::F7},
		{TOGGLE_FPS, Keys::F2},
		{SHOW_LOG, Keys::F3},
		{TOGGLE_FULLSCREEN, Keys::F4},
		{TOGGLE_ZOOM, Keys::F5},
		{PAGE_UP, Keys::PGUP},
		{PAGE_DOWN, Keys::PGDN},
		{RESET, Keys::F12},
		{FAST_FORWARD_A, Keys::F},
		{FAST_FORWARD_B, Keys::G},

#if defined(USE_MOUSE) && defined(SUPPORT_MOUSE)
		{MOUSE_LEFT, Keys::MOUSE_LEFT},
		{MOUSE_RIGHT, Keys::MOUSE_RIGHT},
		{MOUSE_MIDDLE, Keys::MOUSE_MIDDLE},
		{SCROLL_UP, Keys::MOUSE_SCROLLUP},
		{SCROLL_DOWN, Keys::MOUSE_SCROLLDOWN},
#endif

#if defined(USE_JOYSTICK) && defined(SUPPORT_JOYSTICK)
		{UP, Keys::JOY_DPAD_UP},
		{DOWN, Keys::JOY_DPAD_DOWN},
		{LEFT, Keys::JOY_DPAD_LEFT},
		{RIGHT, Keys::JOY_DPAD_RIGHT},
		{DECISION, Keys::JOY_A},
		{CANCEL, Keys::JOY_B},
		{CANCEL, Keys::JOY_X},
		{SHIFT, Keys::JOY_Y},
		{N0, Keys::JOY_LSTICK},
		{N5, Keys::JOY_RSTICK},
		{MULTIPLY, Keys::JOY_REAR_LEFT_1},
		{DIVIDE, Keys::JOY_REAR_LEFT_2},
		{PLUS, Keys::JOY_REAR_RIGHT_1},
		{MINUS, Keys::JOY_REAR_RIGHT_2},
		{DEBUG_ABORT_EVENT, Keys::JOY_SHOULDER_LEFT},
		{TOGGLE_FPS, Keys::JOY_SHOULDER_RIGHT},
		{SETTINGS_MENU, Keys::JOY_START},
		{RESET, Keys::JOY_BACK},

#if USE_SDL==1
		// Arbitrary: Remap this when porting to a embedded platform with SDL1
		// (or even better: Provide your own input_buttons.cpp file)
		{DECISION, Keys::JOY_OTHER_0},
		{CANCEL, Keys::JOY_OTHER_1},
		{SHIFT, Keys::JOY_OTHER_2},
		{TOGGLE_FPS, Keys::JOY_OTHER_3},
		{SETTINGS_MENU, Keys::JOY_OTHER_4},
		{RESET, Keys::JOY_OTHER_5},
#endif
#endif

#if defined(USE_JOYSTICK_AXIS)  && defined(SUPPORT_JOYSTICK_AXIS)
		{UP, Keys::JOY_LSTICK_UP},
		{DOWN, Keys::JOY_LSTICK_DOWN},
		{LEFT, Keys::JOY_LSTICK_LEFT},
		{RIGHT, Keys::JOY_LSTICK_RIGHT},
		{N1, Keys::JOY_RSTICK_DOWN_LEFT},
		{N2, Keys::JOY_RSTICK_DOWN},
		{N3, Keys::JOY_RSTICK_DOWN_RIGHT},
		{N4, Keys::JOY_RSTICK_LEFT},
		{N6, Keys::JOY_RSTICK_RIGHT},
		{N7, Keys::JOY_RSTICK_UP_LEFT},
		{N8, Keys::JOY_RSTICK_UP},
		{N9, Keys::JOY_RSTICK_UP_RIGHT},
		{FAST_FORWARD_A, Keys::JOY_RTRIGGER_SOFT},
		{FAST_FORWARD_B, Keys::JOY_RTRIGGER_FULL},
		{DEBUG_THROUGH, Keys::JOY_LTRIGGER_SOFT},
		{DEBUG_MENU, Keys::JOY_LTRIGGER_FULL},
#endif

#if defined(USE_TOUCH) && defined(SUPPORT_TOUCH)
		{MOUSE_LEFT, Keys::ONE_FINGER},
		{MOUSE_RIGHT, Keys::TWO_FINGERS},
		{MOUSE_MIDDLE, Keys::THREE_FINGERS},
#endif
	};
}

Input::KeyNamesArray Input::GetInputKeyNames() {
	return {};
}

void Input::GetSupportedConfig(Game_ConfigInput& cfg) {
#if defined(USE_JOYSTICK) && defined(SUPPORT_JOYSTICK)
	cfg.gamepad_swap_ab_and_xy.SetOptionVisible(true);
	cfg.gamepad_swap_analog.SetOptionVisible(true);
	cfg.gamepad_swap_dpad_with_buttons.SetOptionVisible(true);
#endif
}

#if USE_SDL==1
#include "platform/sdl/axis.h"
SdlAxis Input::GetSdlAxis() {
	return {
		0, 1, 2, 3, 4, 5, false, false
	};
}
#endif

#endif


/*end of file .\input_buttons_desktop.cpp*/

/*start of file .\input_source.cpp*/

/* ... license chunk ... */

#include <algorithm>
#include <cstring>
#include <cerrno>
#include <ctime>
#include <cmath>

#include "baseui.h"
#include "input_source.h"
#include "player.h"
#include "output.h"
#include "game_system.h"
#include "main_data.h"
#include "version.h"

using namespace std::chrono_literals;

std::unique_ptr<Input::Source> Input::Source::Create(
		const Game_ConfigInput& cfg,
		Input::DirectionMappingArray directions,
		const std::string& replay_from_path)
{
	if (!replay_from_path.empty()) {
		auto path = replay_from_path.c_str();

		auto log_src = std::make_unique<Input::LogSource>(path, cfg, std::move(directions));

		if (*log_src) {
			return log_src;
		}
		Output::Error("Failed to open file for input replaying: {}", path);
	}

	return std::make_unique<Input::UiSource>(cfg, std::move(directions));
}

void Input::UiSource::DoUpdate(bool system_only) {
	keystates = DisplayUi->GetKeyStates();

	pressed_buttons = {};

	UpdateGamepad();
	UpdateTouch();

	for (auto& bm: cfg.buttons) {
		if (keymask[bm.second]) {
			continue;
		}

		if (!system_only || Input::IsSystemButton(bm.first)) {
			pressed_buttons[bm.first] = pressed_buttons[bm.first] || keystates[bm.second] || keystates_virtual[bm.second];
		}
	}
	keystates_virtual = {};

	Record();

	mouse_pos = DisplayUi->GetMousePosition();
}

void Input::UiSource::Update() {
	DoUpdate(false);
}

void Input::UiSource::UpdateSystem() {
	DoUpdate(true);
}

Input::LogSource::LogSource(const char* log_path, const Game_ConfigInput& cfg, DirectionMappingArray directions)
	: Source(cfg, std::move(directions)),
	log_file(FileFinder::Root().OpenInputStream(log_path, std::ios::in))
{
	if (!log_file) {
		Output::Error("Error reading input logfile {}", log_path);
		return;
	}

	std::string header;
	Utils::ReadLine(log_file, header);
	if (StartsWith(header, "H EasyRPG")) {
		std::string ver;
		Utils::ReadLine(log_file, ver);
		if (StartsWith(ver, "V 2")) {
			version = 2;
		} else {
			Output::Error("Unsupported logfile version {}", ver);
		}
	} else {
		Output::Debug("Using legacy inputlog format");
	}
}

void Input::LogSource::Update() {
	if (version == 2) {
		if (!Main_Data::game_system) {
			return;
		}

		if (last_read_frame == -1) {
			pressed_buttons.reset();

			std::string line;
			while (Utils::ReadLine(log_file, line) && !StartsWith(line, "F ")) {
				// no-op
			}
			if (!line.empty()) {
				keys = Utils::Tokenize(line.substr(2), [](char32_t c) { return c == ','; });
				if (!keys.empty()) {
					last_read_frame = atoi(keys[0].c_str());
				}
			}
		}
		if (Main_Data::game_system->GetFrameCounter() == last_read_frame) {
			for (const auto& key : keys) {
				Input::InputButton btn;
				if (Input::kInputButtonNames.etag(key.c_str(), btn)) {
					pressed_buttons[(int)btn] = true;
				}
			}
			last_read_frame = -1;
		}
	} else {
		log_file >> pressed_buttons;
	}

	if (!log_file) {
		Player::exit_flag = true;
	}

	Record();
}


bool Input::Source::InitRecording(const std::string& record_to_path) {
	if (!record_to_path.empty()) {
		auto path = record_to_path.c_str();

		record_log = std::make_unique<Filesystem_Stream::OutputStream>(FileFinder::Root().OpenOutputStream(path, std::ios::out | std::ios::trunc));

		if (!record_log) {
			Output::Error("Failed to open file {} for input recording : {}", path, strerror(errno));
			return false;
		}

		*record_log << "H EasyRPG Player Recording\n";
		*record_log << "V 2 " << Version::STRING << "\n";

		std::time_t t = std::time(nullptr);
		// trigraph ?-escapes
		std::string date = R"(????-??-?? ??:??:??)";
		char timestr[100];
		if (std::strftime(timestr, sizeof(timestr), "%Y-%m-%d %H:%M:%S", std::localtime(&t))) {
			date = std::string(timestr);
		}

		*record_log << "D " << date << '\n';
	}
	return true;
}

void Input::Source::Record() {
	if (record_log) {
		const auto& buttons = GetPressedNonSystemButtons();
		if (buttons.any()) {
			if (!Main_Data::game_system) {
				return;
			}
			int cur_frame = Main_Data::game_system->GetFrameCounter();
			if (cur_frame == last_written_frame) {
				return;
			}
			last_written_frame = cur_frame;

			*record_log << "F " << cur_frame;

			for (size_t i = 0; i < buttons.size(); ++i) {
				if (!buttons[i]) {
					continue;
				}

				*record_log << ',' << Input::kInputButtonNames[i];
			}

			*record_log << '\n';
		}
	}
}

void Input::Source::UpdateGamepad() {
	// Configuration
	if (cfg.gamepad_swap_analog.Get()) {
		std::swap(analog_input.primary, analog_input.secondary);
	}

	auto bit_swap = [&](Input::Keys::InputKey first, Input::Keys::InputKey second) {
		// No std::swap support for std::bitset
		bool tmp = keystates[first];
		keystates[first] = keystates[second];
		keystates[second] = tmp;
	};

#if defined(USE_JOYSTICK) && defined(SUPPORT_JOYSTICK)
	if (cfg.gamepad_swap_dpad_with_buttons.Get()) {
		bit_swap(Input::Keys::JOY_DPAD_UP, Input::Keys::JOY_Y);
		bit_swap(Input::Keys::JOY_DPAD_DOWN, Input::Keys::JOY_A);
		bit_swap(Input::Keys::JOY_DPAD_LEFT, Input::Keys::JOY_X);
		bit_swap(Input::Keys::JOY_DPAD_RIGHT, Input::Keys::JOY_B);
	}

	if (cfg.gamepad_swap_ab_and_xy.Get()) {
		bit_swap(Input::Keys::JOY_A, Input::Keys::JOY_B);
		bit_swap(Input::Keys::JOY_X, Input::Keys::JOY_Y);
	}
#endif

#if defined(USE_JOYSTICK_AXIS) && defined(SUPPORT_JOYSTICK_AXIS)
	// Primary Analog Stick (For directions, does not support diagonals)
	keystates[Input::Keys::JOY_LSTICK_RIGHT] = analog_input.primary.x > JOYSTICK_STICK_SENSIBILITY;
	keystates[Input::Keys::JOY_LSTICK_LEFT] = analog_input.primary.x < -JOYSTICK_STICK_SENSIBILITY;
	keystates[Input::Keys::JOY_LSTICK_UP] = analog_input.primary.y < -JOYSTICK_STICK_SENSIBILITY;
	keystates[Input::Keys::JOY_LSTICK_DOWN] = analog_input.primary.y > JOYSTICK_STICK_SENSIBILITY;

	// Secondary Analog Stick (For other things, supports diagonals)
	if (analog_input.secondary.x > JOYSTICK_STICK_SENSIBILITY || analog_input.secondary.x < -JOYSTICK_STICK_SENSIBILITY ||
		analog_input.secondary.y > JOYSTICK_STICK_SENSIBILITY || analog_input.secondary.y < -JOYSTICK_STICK_SENSIBILITY) {

		auto angle = static_cast<int>(std::atan2(analog_input.secondary.y, analog_input.secondary.x) * 180.0f / M_PI);
		if (angle >= -22 && angle <= 22) {
			keystates[Input::Keys::JOY_RSTICK_RIGHT] = true;
		} else if (angle >= 23 && angle <= 67) {
			keystates[Input::Keys::JOY_RSTICK_DOWN_RIGHT] = true;
		} else if (angle >= 68 && angle <= 112) {
			keystates[Input::Keys::JOY_RSTICK_DOWN] = true;
		} else if (angle >= 113 && angle <= 157) {
			keystates[Input::Keys::JOY_RSTICK_DOWN_LEFT] = true;
		} else if (angle >= 158 || angle <= -158) {
			keystates[Input::Keys::JOY_RSTICK_LEFT] = true;
		} else if (angle >= -157 && angle <= -113) {
			keystates[Input::Keys::JOY_RSTICK_UP_LEFT] = true;
		} else if (angle >= -112 && angle <= -68) {
			keystates[Input::Keys::JOY_RSTICK_UP] = true;
		} else if (angle >= -67 && angle <= -23) {
			keystates[Input::Keys::JOY_RSTICK_UP_RIGHT] = true;
		}
	}

	// Trigger
	analog_input = DisplayUi->GetAnalogInput();
	keystates[Input::Keys::JOY_LTRIGGER_FULL] = (analog_input.trigger_left > AnalogInput::kMaxValue * 0.9);
	keystates[Input::Keys::JOY_LTRIGGER_SOFT] =
			(analog_input.trigger_left > JOYSTICK_TRIGGER_SENSIBILITY) &&
			!keystates[Input::Keys::JOY_LTRIGGER_FULL];
	keystates[Input::Keys::JOY_RTRIGGER_FULL] = (analog_input.trigger_right > AnalogInput::kMaxValue * 0.9);
	keystates[Input::Keys::JOY_RTRIGGER_SOFT] =
			(analog_input.trigger_right > JOYSTICK_TRIGGER_SENSIBILITY) &&
			!keystates[Input::Keys::JOY_RTRIGGER_FULL];
#endif
}

void Input::Source::UpdateTouch() {
#if !defined(_MSC_VER) || _MSC_VER >= 1930
#if defined(USE_TOUCH) && defined(SUPPORT_TOUCH)
	// process touch input
	// only the exact finger count is true, e.g. when "3 fingers" then "2" and "1" are false
	keystates[Input::Keys::ONE_FINGER] = false;
	keystates[Input::Keys::TWO_FINGERS] = false;
	keystates[Input::Keys::THREE_FINGERS] = false;
	keystates[Input::Keys::FOUR_FINGERS] = false;
	keystates[Input::Keys::FIVE_FINGERS] = false;

	auto& touch = DisplayUi->GetTouchInput();

	for (auto& finger: touch) {
		if (!finger.prev_frame_pressed && finger.pressed) {
			// Touch just started
			finger.prev_frame_pressed = true;
			finger.touch_begin = Game_Clock::now();
		}

		if (finger.prev_frame_pressed && !finger.pressed) {
			// Touch just ended
			finger.prev_frame_pressed = false;
			finger.touch_end = Game_Clock::now();
		}
	}

	// How many fingers pressed is evaluated after all fingers left the screen
	// While they are on screen it is handled like motion / mouse
	if (!std::any_of(touch.begin(), touch.end(), [](auto& finger) { return finger.pressed; })) {
		auto now = Game_Clock::now();
		// The time limits are arbitrary.

		// The fingers do not leave the touchpad at the exact same millisecond
		// To prevent wrong detections (e.g. one finger when two fingers left) wait, until one finger left for 50ms
		if (std::count_if(touch.begin(), touch.end(), [now](auto& finger) {
			return now - finger.touch_end >= 50ms;
		}) >= 1) {
			// Count every finger that recently left and wasn't a long press
			int fingers = std::count_if(touch.begin(), touch.end(), [now](auto& finger) {
				return now - finger.touch_end <= 200ms && finger.touch_end - finger.touch_begin <= 500ms;
			});

			if (fingers > 0) {
				keystates[Input::Keys::ONE_FINGER + fingers - 1] = true;
			}
		}
	}
#endif
#endif
}

void Input::Source::AddRecordingData(Input::RecordingData type, std::string_view data) {
	if (record_log) {
		*record_log << static_cast<char>(type) << " " << data << "\n";
	}
}

void Input::Source::SimulateKeyPress(Input::Keys::InputKey key) {
	keystates_virtual[key] = true;
}

void Input::LogSource::UpdateSystem() {
	// input log does not record actions outside of logical frames.
}

void Input::TouchInput::Down(int id, int x, int y) {
	this->id = id;
	this->position = { x, y };
	this->pressed = true;
}

void Input::TouchInput::Up() {
	id = -1;
	pressed = false;
}


/*end of file .\input_source.cpp*/

/*start of file .\instrumentation.cpp*/

/* ... license chunk ... */

#include "instrumentation.h"
#include "utils.h"

#ifdef PLAYER_INSTRUMENTATION_VTUNE
__itt_domain* Instrumentation::domain = nullptr;
#endif

void Instrumentation::Init(const char* name) {
#ifdef PLAYER_INSTRUMENTATION_VTUNE
	assert(!domain);
#ifdef _WIN32
	domain = __itt_domain_create(Utils::ToWideString(name).c_str());
#else
	domain = __itt_domain_create(name);
#endif
#else
	(void)name;
#endif
}


/*end of file .\instrumentation.cpp*/

/*start of file .\json_helper.cpp*/

/* ... license chunk ... */

#include "json_helper.h"

#ifdef HAVE_NLOHMANN_JSON

#include "output.h"
#include <nlohmann/json.hpp>
#include <sstream>
#include <unordered_map>
#include <charconv>
#include "string_view.h"

namespace {

	std::string GetValueAsString(const json& json_obj) {
		if (json_obj.is_null()) {
			return "null";
		}
		if (json_obj.is_string()) {
			return json_obj.get<std::string>();
		}
		if (json_obj.is_number_integer()) {
			return std::to_string(json_obj.get<int64_t>());
		}
		if (json_obj.is_number_float()) {
			return std::to_string(json_obj.get<double>());
		}
		if (json_obj.is_boolean()) {
			return json_obj.get<bool>() ? "true" : "false";
		}
		return json_obj.dump();
	}

} // namespace

namespace Json_Helper {

	std::optional<json> Parse(std::string_view json_data) {
		json json_obj = json::parse(json_data, nullptr, false);
		if (json_obj.is_discarded()) {
			return {};
		}
		return json_obj;
	}

	bool CheckJsonPointer(std::string_view json_path) {
		if (json_path.empty()) {
			Output::Warning("JSON: Empty json pointer at: {}", json_path);
			return false;
		}

		if (json_path.front() != '/') {
			Output::Warning("JSON: Json pointer must start with /: {}", json_path);
			return false;
		}

		return true;
	}

	std::string GetValue(json& json_obj, std::string_view json_path) {
		std::string path_str = std::string(json_path);
		json::json_pointer ptr(path_str);

		if (!json_obj.contains(ptr)) {
			return {};
		}

		const json& value = json_obj[ptr];
		auto val = GetValueAsString(value);
		return val;
	}


	std::string SetValue(json& json_obj, std::string_view json_path, std::string_view value) {
		std::string path_str = std::string(json_path);
		json::json_pointer ptr(path_str);

		json obj_value = json::parse(value, nullptr, false);
		if (obj_value.is_discarded()) {
			// If parsing fails, treat it as a string value
			json_obj[ptr] = std::string(value);
		}
		else {
			json_obj[ptr] = obj_value;
		}

		return json_obj.dump();
	}

	size_t GetLength(const json& json_obj, std::string_view json_path) {
		std::string path_str = std::string(json_path);
		json::json_pointer ptr(path_str);

		if (!json_obj.contains(ptr)) {
			return 0;
		}

		const json& value = json_obj[ptr];
		if (!value.is_array() && !value.is_object()) {
			return 0;
		}

		return value.size();
	}

	std::vector<std::string> GetKeys(const json& json_obj, std::string_view json_path) {
		std::string path_str = std::string(json_path);
		json::json_pointer ptr(path_str);
		if (!json_obj.contains(ptr)) {
			return {};
		}

		const json& value = json_obj[ptr];

		std::vector<std::string> keys;

		if (value.is_object()) {
			for (const auto& item : value.items()) {
				keys.push_back(item.key());
			}
		}
		else if (value.is_array()) {
			for (size_t i = 0; i < value.size(); ++i) {
				keys.push_back(std::to_string(i));
			}
		}
		return keys;
	}

	std::string GetType(const json& json_obj, std::string_view json_path) {
		std::string path_str = std::string(json_path);
		json::json_pointer ptr(path_str);
		if (!json_obj.contains(ptr)) {
			return {};
		}

		const json& value = json_obj[ptr];

		if (value.is_object()) return std::string("object");
		if (value.is_array()) return std::string("array");
		if (value.is_string()) return std::string("string");
		if (value.is_number()) return std::string("number");
		if (value.is_boolean()) return std::string("boolean");
		if (value.is_null()) return std::string("null");
		return std::string("unknown");
	}

	std::string GetPath(const json& json_obj, const json& search_value) {
		std::function<std::string(const json&, const json&, const std::string&)> find_path;

		find_path = [&find_path](const json& obj, const json& target, const std::string& current_path) -> std::string {
			if (obj == target) {
				return current_path;
			}

			if (obj.is_object()) {
				for (const auto& item : obj.items()) {
					auto path = find_path(item.value(), target, current_path + "/" + item.key());
					if (!path.empty()) return path;
				}
			}
			else if (obj.is_array()) {
				for (size_t i = 0; i < obj.size(); ++i) {
					auto path = find_path(obj[i], target, current_path + "/" + std::to_string(i));
					if (!path.empty()) return path;
				}
			}
			return {};
			};

		return find_path(json_obj, search_value, "");
	}

	std::string PrettyPrint(const json& json_obj, int indent) {
		return json_obj.dump(std::max(0, indent));
	}

	std::string RemoveValue(json& json_obj, std::string_view json_path) {
		std::string path_str = std::string(json_path);
		json::json_pointer ptr(path_str);

		if (!json_obj.contains(ptr)) {
			return {};
		}

		// Get parent path and key/index to remove
		auto parent_ptr = ptr.parent_pointer();

		json& parent = json_obj[parent_ptr];
		json_path.remove_prefix(parent_ptr.to_string().size() + 1);

		if (parent.is_object()) {
			parent.erase(std::string(json_path));
		}
		else if (parent.is_array()) {
			// Check if key is a valid positive number
			unsigned index;
			auto ec = std::from_chars(json_path.data(), json_path.data() + json_path.size(), index).ec;
			if (ec == std::errc()) {
				if (index < parent.size()) {
					parent.erase(index);
				}
			} else {
				Output::Warning("JSON: Invalid array index at: {}", json_path);
				return {};
			}
		}

		return json_obj.dump();
	}

	std::string PushValue(json& json_obj, std::string_view json_path, std::string_view value) {
		std::string path_str = std::string(json_path);
		json::json_pointer ptr(path_str);

		if (!json_obj.contains(ptr)) {
			return {};
		}

		json& array = json_obj[ptr];
		if (!array.is_array()) {
			Output::Warning("JSON: Path does not point to an array: {}", json_path);
			return {};
		}

		json obj_value = json::parse(value, nullptr, false);
		if (obj_value.is_discarded()) {
			// If parsing fails, treat it as a string value
			array.push_back(std::string(value));
		}
		else {
			array.push_back(obj_value);
		}

		return json_obj.dump();
	}

	std::tuple<std::string, std::string> PopValue(json& json_obj, std::string_view json_path) {
		std::string path_str = std::string(json_path);
		json::json_pointer ptr(path_str);

		if (!json_obj.contains(ptr)) {
			return {};
		}

		json& array = json_obj[ptr];
		if (!array.is_array() || array.empty()) {
			Output::Warning("JSON: Path does not point to a non-empty array: {}", json_path);
			return {};
		}

		json popped = array.back();
		array.erase(array.size() - 1);

		return {json_obj.dump(), GetValueAsString(popped)};
	}

	bool Contains(const json& json_obj, std::string_view json_path) {
		std::string path_str = std::string(json_path);
		json::json_pointer ptr(path_str);

		return json_obj.contains(ptr);
	}

} // namespace Json_Helper

#endif // HAVE_NLOHMANN_JSON


/*end of file .\json_helper.cpp*/

/*start of file .\lcf_data.cpp*/

/*
 * This file is part of liblcf. Copyright (c) 2020 liblcf authors.
 * https://github.com/EasyRPG/liblcf - https://easyrpg.org
 *
 * liblcf is Free/Libre Open Source Software, released under the MIT License.
 * For the full copyright and license information, please view the COPYING
 * file that was distributed with this source code.
 */

#include "lcf/rpg/database.h"
#include "lcf/data.h"

namespace lcf {

namespace Data {
	rpg::Database data;

	std::vector<rpg::Actor>& actors = data.actors;
	std::vector<rpg::Skill>& skills = data.skills;
	std::vector<rpg::Item>& items = data.items;
	std::vector<rpg::Enemy>& enemies = data.enemies;
	std::vector<rpg::Troop>& troops = data.troops;
	std::vector<rpg::Terrain>& terrains = data.terrains;
	std::vector<rpg::Attribute>& attributes = data.attributes;
	std::vector<rpg::State>& states = data.states;
	std::vector<rpg::Animation>& animations = data.animations;
	std::vector<rpg::Chipset>& chipsets = data.chipsets;
	std::vector<rpg::CommonEvent>& commonevents = data.commonevents;
	rpg::BattleCommands& battlecommands = data.battlecommands;
	std::vector<rpg::Class>& classes = data.classes;
	std::vector<rpg::BattlerAnimation>& battleranimations = data.battleranimations;
	rpg::Terms& terms = data.terms;
	rpg::System& system = data.system;
	std::vector<rpg::Switch>& switches = data.switches;
	std::vector<rpg::Variable>& variables = data.variables;
	std::vector<rpg::StringVariable>& maniac_string_variables = data.maniac_string_variables;

	rpg::TreeMap treemap;
}

void Data::Clear() {
	actors.clear();
	skills.clear();
	items.clear();
	enemies.clear();
	troops.clear();
	terrains.clear();
	attributes.clear();
	states.clear();
	animations.clear();
	chipsets.clear();
	commonevents.clear();
	battlecommands = rpg::BattleCommands();
	classes.clear();
	battleranimations.clear();
	terms = rpg::Terms();
	system = rpg::System();
	switches.clear();
	variables.clear();
	maniac_string_variables.clear();
	treemap.active_node = 0;
	treemap.maps.clear();
	treemap.tree_order.clear();
}

} //namespace lcf


/*end of file .\lcf_data.cpp*/

/*start of file .\main_data.cpp*/

/* ... license chunk ... */

// Headers
#include <cstdlib>
#include "main_data.h"
#include "filefinder_rtp.h"
#include "game_destiny.h"
#include "game_system.h"
#include "game_actors.h"
#include "game_party.h"
#include "game_enemyparty.h"
#include "game_dynrpg.h"
#include "game_ineluki.h"
#include "game_player.h"
#include "game_screen.h"
#include "game_pictures.h"
#include "game_map.h"
#include "game_variables.h"
#include "game_strings.h"
#include "game_switches.h"
#include "game_targets.h"
#include "game_quit.h"
#include "game_windows.h"
#include "system.h"

#ifndef _WIN32
#  include <unistd.h>
#endif
#if defined(USE_SDL) && defined(__ANDROID__)
#  include <jni.h>
#  include <SDL_system.h>
#elif defined(__APPLE__) && TARGET_OS_OSX
#  include <sys/syslimits.h>
#  include "platform/macos/macos_utils.h"
#endif

// Global variables.
std::string project_path;

namespace Main_Data {
	// Dynamic Game lcf::Data
	std::unique_ptr<Game_System> game_system;
	std::unique_ptr<Game_Switches> game_switches;
	std::unique_ptr<Game_Variables> game_variables;
	std::unique_ptr<Game_Strings> game_strings;
	std::unique_ptr<Game_Screen> game_screen;
	std::unique_ptr<Game_Pictures> game_pictures;
	std::unique_ptr<Game_Windows> game_windows;
	std::unique_ptr<Game_Actors> game_actors;
	std::unique_ptr<Game_Player> game_player;
	std::unique_ptr<Game_Party> game_party;
	std::unique_ptr<Game_EnemyParty> game_enemyparty;
	std::unique_ptr<Game_Targets> game_targets;
	std::unique_ptr<Game_Quit> game_quit;
	std::unique_ptr<Game_DynRpg> game_dynrpg;
	std::unique_ptr<Game_Ineluki> game_ineluki;
	std::unique_ptr<Game_Destiny> game_destiny;
	std::unique_ptr<Game_Switches> game_switches_global;
	std::unique_ptr<Game_Variables> game_variables_global;

	std::unique_ptr<FileFinder_RTP> filefinder_rtp;
}

void Main_Data::Init() {
	if (project_path.empty()) {
		// First use environment variables
		project_path =
			getenv("RPG_TEST_GAME_PATH") ? getenv("RPG_TEST_GAME_PATH") :
			getenv("RPG_GAME_PATH") ? getenv("RPG_GAME_PATH") :
			"";

		if (project_path.empty()) {
			// Set to current directory
			project_path = "";

#if defined(PLAYER_AMIGA)
			// Working directory not correctly handled
			char working_dir[256];
			getcwd(working_dir, 255);
			project_path = std::string(working_dir);
#elif defined(__APPLE__) && TARGET_OS_OSX
			// Apple Finder does not set the working directory
			// It points to HOME instead. When it is HOME change it to
			// the application directory instead

			char* home = getenv("HOME");
			char current_dir[PATH_MAX] = { 0 };
			getcwd(current_dir, sizeof(current_dir));
			if (strcmp(current_dir, "/") == 0 || strcmp(current_dir, home) == 0) {
				project_path = MacOSUtils::GetBundleDir();
			}
#endif
		}
	}
}

void Main_Data::Cleanup() {
	Game_Map::Quit();

	game_switches.reset();
	game_screen.reset();
	game_pictures.reset();
	game_windows.reset();
	game_player.reset();
	game_party.reset();
	game_enemyparty.reset();
	game_actors.reset();
	game_targets.reset();
	game_quit.reset();
	game_system.reset();
	game_dynrpg.reset();
	game_ineluki.reset();
	game_destiny.reset();
	game_switches_global.reset();
	game_variables_global.reset();
}

const std::string& Main_Data::GetDefaultProjectPath() {
	return project_path;
}


/*end of file .\main_data.cpp*/

/*start of file .\maniac_patch.cpp*/

/* ... license chunk ... */

#include "maniac_patch.h"

#include "filesystem_stream.h"
#include "input.h"
#include "game_actors.h"
#include "game_interpreter_control_variables.h"
#include "game_map.h"
#include "game_interpreter.h"
#include "game_party.h"
#include "game_switches.h"
#include "game_variables.h"
#include "main_data.h"
#include "output.h"
#include "player.h"

#include <lcf/reader_lcf.h>
#include <lcf/reader_util.h>
#include <lcf/writer_lcf.h>
#include <vector>

/*
The following operations are unsupported:

All array functions (Array, Range and Subscript):
They could be implemented but are not very useful

All Inplace functions:
These functions are disabled when EasyRpg Extensions are active.
Inplace assigns to variables while the ControlVariables event command is executed.
This violates how the command is supposed to work because more variables than the target variables can be set.
*/

namespace {
	enum class Op {
		Null = 0,
		U8,
		U16,
		S32,
		UX8,
		UX16,
		SX32,
		Var = 8,
		Switch,
		VarIndirect = 13,
		SwitchIndirect,
		Array = 19,
		Negate = 24,
		Not,
		Flip,
		AssignInplace = 34,
		AddInplace,
		SubInplace,
		MulInplace,
		DivInplace,
		ModInplace,
		BitOrInplace,
		BitAndInplace,
		BitXorInplace,
		BitShiftLeftInplace,
		BitShiftRightInplace,
		Add = 48,
		Sub,
		Mul,
		Div,
		Mod,
		BitOr,
		BitAnd,
		BitXor,
		BitShiftLeft,
		BitShiftRight,
		Equal,
		GreaterEqual,
		LessEqual,
		Greater,
		Less,
		NotEqual,
		Or,
		And,
		Range,
		Subscript,
		Ternary = 72,
		Function = 78
	};

	enum class Fn {
		Rand = 0,
		Item,
		Event,
		Actor,
		Party,
		Enemy,
		Misc,
		Pow,
		Sqrt,
		Sin,
		Cos,
		Atan2,
		Min,
		Max,
		Abs,
		Clamp,
		Muldiv,
		Divmul,
		Between
	};

	bool global_save_opened = false;
}

struct ProcessAssignmentRet {
	Op op = Op::Null;
	int id = 0;

	int fetch() const {
		switch (op) {
		case Op::Var:
			return Main_Data::game_variables->Get(id);
		case Op::Switch:
			return Main_Data::game_switches->Get(id);
		case Op::VarIndirect: {
			return Main_Data::game_variables->GetIndirect(id);
		}
		case Op::SwitchIndirect: {
			int var = Main_Data::game_variables->GetIndirect(id);
			return Main_Data::game_switches->Get(var);
		}
		default:
			Output::Warning("Maniac: Expression assignment {} is not a lvalue", static_cast<int>(op));
			return 0;
		}
	}

	int assign(int value) const {
		if (Player::HasEasyRpgExtensions()) {
			Output::Warning("Maniac: Inplace assignments are not allowed in expressions when running in EasyRpg Mode");
			return fetch();
		}

		switch (op) {
		case Op::Var:
			Game_Map::SetNeedRefreshForVarChange(id);
			return Main_Data::game_variables->Set(id, value);
		case Op::Switch:
			Game_Map::SetNeedRefreshForSwitchChange(id);
			return Main_Data::game_switches->Set(id, value > 0);
		case Op::VarIndirect: {
			int var = Main_Data::game_variables->GetIndirect(id);
			Game_Map::SetNeedRefreshForVarChange(var);
			return Main_Data::game_variables->Set(var, value);
		}
		case Op::SwitchIndirect: {
			int var = Main_Data::game_variables->GetIndirect(id);
			Game_Map::SetNeedRefreshForSwitchChange(var);
			return Main_Data::game_switches->Set(var, value > 0);
		}
		default:
			Output::Warning("Maniac: Expression assignment {} is not a lvalue", static_cast<int>(op));
			return 0;
		}
	}
};

ProcessAssignmentRet ProcessAssignment(std::vector<int32_t>::iterator& it, std::vector<int32_t>::iterator end, const Game_BaseInterpreterContext& ip);

int Process(std::vector<int32_t>::iterator& it, std::vector<int32_t>::iterator end, const Game_BaseInterpreterContext& ip) {
	int value = 0;
	int imm = 0;
	int imm2 = 0;
	int imm3 = 0;

	if (it == end) {
		return 0;
	}

	auto op = static_cast<Op>(*it);
	++it;

	// When entering the switch it is on the first argument
	switch (op) {
		case Op::Null:
			it++;
			return 0;
		case Op::U8:
		case Op::UX8:
			value = *it++;
			return value;
		case Op::U16:
		case Op::UX16:
			imm = *it++;
			if (it == end) {
				return 0;
			}
			imm2 = *it++;
			value = (imm2 << 8) + imm;
			return value;
		case Op::S32:
		case Op::SX32:
			imm = *it++;
			if (it == end) {
				return 0;
			}
			imm2 = *it++;
			if (it == end) {
				return 0;
			}
			imm3 = *it++;
			if (it == end) {
				return 0;
			}
			value = *it++;
			value = (value << 24) + (imm3 << 16) + (imm2 << 8) + imm;
			return value;
		case Op::Var:
			imm = Process(it, end, ip);
			return Main_Data::game_variables->Get(imm);
		case Op::Switch:
			imm = Process(it, end, ip);
			return Main_Data::game_switches->GetInt(imm);
		case Op::VarIndirect:
			imm = Process(it, end, ip);
			return Main_Data::game_variables->GetIndirect(imm);
		case Op::SwitchIndirect:
			imm = Process(it, end, ip);
			return Main_Data::game_switches->GetInt(Main_Data::game_variables->Get(imm));
		case Op::Negate:
			imm = Process(it, end, ip);
			return -imm;
		case Op::Not:
			imm = Process(it, end, ip);
			return !imm ? 0 : 1;
		case Op::Flip:
			imm = Process(it, end, ip);
			return ~imm;
		case Op::AssignInplace: {
			auto ret = ProcessAssignment(it, end, ip);
			imm2 = Process(it, end, ip);
			return ret.assign(imm2);
		}
		case Op::AddInplace: {
			auto ret = ProcessAssignment(it, end, ip);
			imm2 = Process(it, end, ip);
			return ret.assign(static_cast<int32_t>(Utils::Clamp<int64_t>(static_cast<int64_t>(ret.fetch()) + imm2, std::numeric_limits<int32_t>::min(), std::numeric_limits<int32_t>::max())));
		}
		case Op::SubInplace: {
			auto ret = ProcessAssignment(it, end, ip);
			imm2 = Process(it, end, ip);
			return ret.assign(static_cast<int32_t>(Utils::Clamp<int64_t>(static_cast<int64_t>(ret.fetch()) - imm2, std::numeric_limits<int32_t>::min(), std::numeric_limits<int32_t>::max())));
		}
		case Op::MulInplace: {
			auto ret = ProcessAssignment(it, end, ip);
			imm2 = Process(it, end, ip);
			return ret.assign(static_cast<int32_t>(Utils::Clamp<int64_t>(static_cast<int64_t>(ret.fetch()) * imm2, std::numeric_limits<int32_t>::min(), std::numeric_limits<int32_t>::max())));
		}
		case Op::DivInplace: {
			auto ret = ProcessAssignment(it, end, ip);
			imm2 = Process(it, end, ip);
			if (imm2 == 0) {
				return ret.fetch();
			}
			return ret.assign(ret.fetch() / imm2);
		}
		case Op::ModInplace: {
			auto ret = ProcessAssignment(it, end, ip);
			imm2 = Process(it, end, ip);
			if (imm2 == 0) {
				return ret.fetch();
			}
			return ret.assign(ret.fetch() % imm2);
		}
		case Op::BitOrInplace: {
			auto ret = ProcessAssignment(it, end, ip);
			imm2 = Process(it, end, ip);
			return ret.assign(ret.fetch() | imm2);
		}
		case Op::BitAndInplace: {
			auto ret = ProcessAssignment(it, end, ip);
			imm2 = Process(it, end, ip);
			return ret.assign(ret.fetch() & imm2);
		}
		case Op::BitXorInplace: {
			auto ret = ProcessAssignment(it, end, ip);
			imm2 = Process(it, end, ip);
			return ret.assign(ret.fetch() ^ imm2);
		}
		case Op::BitShiftLeftInplace: {
			auto ret = ProcessAssignment(it, end, ip);
			imm2 = Process(it, end, ip);
			return ret.assign(ret.fetch() << imm2);
		}
		case Op::BitShiftRightInplace: {
			auto ret = ProcessAssignment(it, end, ip);
			imm2 = Process(it, end, ip);
			return ret.assign(ret.fetch() >> imm2);
		}
		case Op::Add:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return static_cast<int32_t>(Utils::Clamp<int64_t>(static_cast<int64_t>(imm) + imm2, std::numeric_limits<int32_t>::min(), std::numeric_limits<int32_t>::max()));
		case Op::Sub:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return static_cast<int32_t>(Utils::Clamp<int64_t>(static_cast<int64_t>(imm) - imm2, std::numeric_limits<int32_t>::min(), std::numeric_limits<int32_t>::max()));
		case Op::Mul:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return static_cast<int32_t>(Utils::Clamp<int64_t>(static_cast<int64_t>(imm) * imm2, std::numeric_limits<int32_t>::min(), std::numeric_limits<int32_t>::max()));
		case Op::Div:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			if (imm2 == 0) {
				return imm;
			}
			return imm / imm2;
		case Op::Mod:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			if (imm2 == 0) {
				return imm;
			}
			return imm % imm2;
		case Op::BitOr:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return imm | imm2;
		case Op::BitAnd:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return imm & imm2;
		case Op::BitXor:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return imm ^ imm2;
		case Op::BitShiftLeft:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return imm << imm2;
		case Op::BitShiftRight:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return imm >> imm2;
		case Op::Equal:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return imm == imm2 ? 1 : 0;
		case Op::GreaterEqual:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return imm >= imm2 ? 1 : 0;
		case Op::LessEqual:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return imm <= imm2 ? 1 : 0;
		case Op::Greater:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return imm > imm2 ? 1 : 0;
		case Op::Less:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return imm < imm2 ? 1 : 0;
		case Op::NotEqual:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return imm != imm2 ? 1 : 0;
		case Op::Or:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return !!imm || !!imm2 ? 1 : 0;
		case Op::And:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			return !!imm && !!imm2 ? 1 : 0;
		case Op::Ternary:
			imm = Process(it, end, ip);
			imm2 = Process(it, end, ip);
			imm3 = Process(it, end, ip);
			return imm != 0 ? imm2 : imm3;
		case Op::Function:
			imm = *it++; // function
			imm2 = *it++; // arguments

			if ((imm2 & 0x80) != 0) {
				// Argument count is 4 bytes, that mode is not supported
				Output::Warning("Maniac: Expression func long args unsupported");
				return 0;
			}

			switch (static_cast<Fn>(imm)) {
				case Fn::Rand:
					if (imm2 != 2) {
						Output::Warning("Maniac: Expression rnd args {} != 2", imm2);
						return 0;
					}
					imm3 = Process(it, end, ip);
					return ControlVariables::Random(Process(it, end, ip), imm3);
				case Fn::Item:
					if (imm2 != 2) {
						Output::Warning("Maniac: Expression item args {} != 2", imm2);
						return 0;
					}
					imm3 = Process(it, end, ip);
					return ControlVariables::Item(Process(it, end, ip), imm3);
				case Fn::Event:
					if (imm2 != 2) {
						Output::Warning("Maniac: Expression event args {} != 2", imm2);
						return 0;
					}
					imm3 = Process(it, end, ip);
					return ControlVariables::Event(Process(it, end, ip), imm3, ip);
				case Fn::Actor:
					if (imm2 != 2) {
						Output::Warning("Maniac: Expression actor args {} != 2", imm2);
						return 0;
					}
					imm3 = Process(it, end, ip);
					return ControlVariables::Actor(Process(it, end, ip), imm3);
				case Fn::Party:
					if (imm2 != 2) {
						Output::Warning("Maniac: Expression member args {} != 2", imm2);
						return 0;
					}
					imm3 = Process(it, end, ip);
					return ControlVariables::Party(Process(it, end, ip), imm3);
				case Fn::Enemy:
					if (imm2 != 2) {
						Output::Warning("Maniac: Expression enemy args {} != 2", imm2);
						return 0;
					}
					imm3 = Process(it, end, ip);
					return ControlVariables::Enemy(Process(it, end, ip), imm3);
					break;
				case Fn::Misc:
					if (imm2 != 1) {
						Output::Warning("Maniac: Expression misc args {} != 1", imm2);
						return 0;
					}
					return ControlVariables::Other(Process(it, end, ip));
				case Fn::Pow:
					if (imm2 != 2) {
						Output::Warning("Maniac: Expression pow args {} != 2", imm2);
						return 0;
					}
					return ControlVariables::Pow(Process(it, end, ip), Process(it, end, ip));
				case Fn::Sqrt:
					if (imm2 != 2) {
						Output::Warning("Maniac: Expression sqrt args {} != 2", imm2);
						return 0;
					}
					return ControlVariables::Sqrt(Process(it, end, ip), Process(it, end, ip));
				case Fn::Sin:
					if (imm2 != 3) {
						Output::Warning("Maniac: Expression sin args {} != 3", imm2);
						return 0;
					}
					return ControlVariables::Sin(Process(it, end, ip), Process(it, end, ip), Process(it, end, ip));
				case Fn::Cos:
					if (imm2 != 3) {
						Output::Warning("Maniac: Expression cos args {} != 3", imm2);
						return 0;
					}
					return ControlVariables::Cos(Process(it, end, ip), Process(it, end, ip), Process(it, end, ip));
				case Fn::Atan2:
					if (imm2 != 3) {
						Output::Warning("Maniac: Expression atan2 args {} != 3", imm2);
						return 0;
					}
					return ControlVariables::Atan2(Process(it, end, ip), Process(it, end, ip), Process(it, end, ip));
				case Fn::Min:
					if (imm2 != 2) {
						Output::Warning("Maniac: Expression min args {} != 2", imm2);
						return 0;
					}
					return ControlVariables::Min(Process(it, end, ip), Process(it, end, ip));
				case Fn::Max:
					if (imm2 != 2) {
						Output::Warning("Maniac: Expression max args {} != 2", imm2);
						return 0;
					}
					return ControlVariables::Max(Process(it, end, ip), Process(it, end, ip));
				case Fn::Abs:
					if (imm2 != 1) {
						Output::Warning("Maniac: Expression abs args {} != 1", imm2);
						return 0;
					}
					return ControlVariables::Abs(Process(it, end, ip));
				case Fn::Clamp:
					if (imm2 != 3) {
						Output::Warning("Maniac: Expression clamp args {} != 3", imm2);
						return 0;
					}
					return ControlVariables::Clamp(Process(it, end, ip), Process(it, end, ip), Process(it, end, ip));
				case Fn::Muldiv:
					if (imm2 != 3) {
						Output::Warning("Maniac: Expression muldiv args {} != 3", imm2);
						return 0;
					}
					return ControlVariables::Muldiv(Process(it, end, ip), Process(it, end, ip), Process(it, end, ip));
				case Fn::Divmul:
					if (imm2 != 3) {
						Output::Warning("Maniac: Expression divmul args {} != 3", imm2);
						return 0;
					}
					return ControlVariables::Divmul(Process(it, end, ip), Process(it, end, ip), Process(it, end, ip));
				case Fn::Between:
					if (imm2 != 3) {
						Output::Warning("Maniac: Expression between args {} != 3", imm2);
						return 0;
					}
					return ControlVariables::Between(Process(it, end, ip), Process(it, end, ip), Process(it, end, ip));
				default:
					Output::Warning("Maniac: Expression Unknown Func {}", imm);
					for (int i = 0; i < imm2; ++i) {
						Process(it, end, ip);
					}
					return 0;
			}
		default:
			Output::Warning("Maniac: Expression contains unsupported operation {}", static_cast<int>(op));
			return 0;
	}
}

ProcessAssignmentRet ProcessAssignment(std::vector<int32_t>::iterator& it, std::vector<int32_t>::iterator end, const Game_BaseInterpreterContext& ip) {
	// Like process but it remembers the type (Variable or Switch) without evaluating it to allow assignments
	int imm = 0;

	if (it == end) {
		return {Op::Null, 0};
	}

	auto op = static_cast<Op>(*it);
	++it;

	// When entering the switch it is on the first argument
	switch (op) {
		case Op::Var:
		case Op::Switch:
		case Op::VarIndirect:
		case Op::SwitchIndirect:
			imm = Process(it, end, ip);
			return {op, imm};
		default:
			--it; // back on the op as op is fetched again by Process
			imm = Process(it, end, ip);
			return {op, imm};
	}
}

int32_t ManiacPatch::ParseExpression(Span<const int32_t> op_codes, const Game_BaseInterpreterContext& interpreter) {
	std::vector<int32_t> ops;
	for (auto &o: op_codes) {
		auto uo = static_cast<uint32_t>(o);
		ops.push_back(static_cast<int32_t>(uo & 0x000000FF));
		ops.push_back(static_cast<int32_t>((uo & 0x0000FF00) >> 8));
		ops.push_back(static_cast<int32_t>((uo & 0x00FF0000) >> 16));
		ops.push_back(static_cast<int32_t>((uo & 0xFF000000) >> 24));
	}
	auto beg = ops.begin();
	return Process(beg, ops.end(), interpreter);
}

std::vector<int32_t> ManiacPatch::ParseExpressions(Span<const int32_t> op_codes, const Game_BaseInterpreterContext& interpreter) {
	std::vector<int32_t> ops;
	for (auto& o : op_codes) {
		auto uo = static_cast<uint32_t>(o);
		ops.push_back(static_cast<int32_t>(uo & 0x000000FF));
		ops.push_back(static_cast<int32_t>((uo & 0x0000FF00) >> 8));
		ops.push_back(static_cast<int32_t>((uo & 0x00FF0000) >> 16));
		ops.push_back(static_cast<int32_t>((uo & 0xFF000000) >> 24));
	}

	if (ops.empty()) {
		return {};
	}

	auto it = ops.begin();

	std::vector<int32_t> results;

	while (true) {
		results.push_back(Process(it, ops.end(), interpreter));

		if (it == ops.end() || static_cast<Op>(*it) == Op::Null) {
			break;
		}
	}

	return results;
}

std::array<bool, 50> ManiacPatch::GetKeyRange() {
	std::array<Input::Keys::InputKey, 50> keys = {
		Input::Keys::A,
		Input::Keys::B,
		Input::Keys::C,
		Input::Keys::D,
		Input::Keys::E,
		Input::Keys::F,
		Input::Keys::G,
		Input::Keys::H,
		Input::Keys::I,
		Input::Keys::J,
		Input::Keys::K,
		Input::Keys::L,
		Input::Keys::M,
		Input::Keys::N,
		Input::Keys::O,
		Input::Keys::P,
		Input::Keys::Q,
		Input::Keys::R,
		Input::Keys::S,
		Input::Keys::T,
		Input::Keys::U,
		Input::Keys::V,
		Input::Keys::W,
		Input::Keys::X,
		Input::Keys::Y,
		Input::Keys::Z,
		Input::Keys::N0,
		Input::Keys::N1,
		Input::Keys::N2,
		Input::Keys::N3,
		Input::Keys::N4,
		Input::Keys::N5,
		Input::Keys::N6,
		Input::Keys::N7,
		Input::Keys::N8,
		Input::Keys::N9,
		Input::Keys::LEFT,
		Input::Keys::UP,
		Input::Keys::RIGHT,
		Input::Keys::DOWN,
		Input::Keys::RETURN,
		Input::Keys::SHIFT,
		Input::Keys::CTRL,
		Input::Keys::ALT,
		Input::Keys::SPACE,
#if defined(USE_MOUSE) && defined(SUPPORT_MOUSE)
		Input::Keys::MOUSE_LEFT,
		Input::Keys::MOUSE_RIGHT,
		Input::Keys::MOUSE_MIDDLE,
		Input::Keys::MOUSE_SCROLLUP,
		Input::Keys::MOUSE_SCROLLDOWN
#else
		Input::Keys::NONE,
		Input::Keys::NONE,
		Input::Keys::NONE,
		Input::Keys::NONE,
		Input::Keys::NONE
#endif
	};

	std::array<bool, 50> pressed = {};

	for (size_t i = 0; i < pressed.size(); ++i) {
		pressed[i] = Input::IsRawKeyPressed(keys[i]);
	}

	if (!pressed[41]) {
		pressed[41] = Input::IsRawKeyPressed(Input::Keys::LSHIFT) || Input::IsRawKeyPressed(Input::Keys::RSHIFT);
	}
	if (!pressed[42]) {
		pressed[42] = Input::IsRawKeyPressed(Input::Keys::LCTRL) || Input::IsRawKeyPressed(Input::Keys::RCTRL);
	}
	if (!pressed[43]) {
		pressed[43] = Input::IsRawKeyPressed(Input::Keys::LALT) || Input::IsRawKeyPressed(Input::Keys::RALT);
	}

	return pressed;
}

bool ManiacPatch::CheckString(std::string_view str_l, std::string_view str_r, int op, bool ignore_case) {
	auto check = [op](const auto& l, const auto& r) {
		switch (op) {
			case 0: // eq
				return l == r;
			case 2: // contains (l contains r)
				return l.find(r) != std::string::npos;
			case 1: // neq
				return l != r;
			case 3: // notContains (l does not contain r)
				return l.find(r) == std::string::npos;
			default:
				return false;
		}
	};

	if (ignore_case) {
		std::string str_l_lower = Utils::LowerCase(str_l);
		std::string str_r_lower = Utils::LowerCase(str_r);
		return check(str_l_lower, str_r_lower);
	}

	return check(str_l, str_r);
}

std::string_view ManiacPatch::GetLcfName(int data_type, int id, bool is_dynamic) {
	auto get_name = [&id](std::string_view type, const auto& vec) -> std::string_view {
		auto* data = lcf::ReaderUtil::GetElement(vec, id);
		if (!data) {
			Output::Warning("Unable to read {} name: {}", type, id);
			return {};
		}
		return data->name;
	};

	switch (data_type)
	{
	case 0:  //.actor[a].name
		if (is_dynamic) {
			auto actor = Main_Data::game_actors->GetActor(id);
			if (actor != nullptr) {
				return actor->GetName();
			}
		}
		else {
			return get_name("Actor", lcf::Data::actors);
		}
		break;
	case 1:	 return get_name("Skill", lcf::Data::skills);   //.skill[a].name
	case 2:	 return get_name("Item", lcf::Data::items);   //.item[a].name
	case 3:	 return get_name("Enemy", lcf::Data::enemies);   //.enemy[a].name
	case 4:	 return get_name("Troop", lcf::Data::troops);   //.troop[a].name
	case 5:	 return get_name("Terrain", lcf::Data::terrains);   //.terrain[a].name
	case 6:	 return get_name("Attribute", lcf::Data::attributes);   //.element[a].name
	case 7:	 return get_name("State", lcf::Data::states);   //.state[a].name
	case 8:	 return get_name("Animation", lcf::Data::animations);   //.anim[a].name
	case 9:	 return get_name("Chipset", lcf::Data::chipsets);   //.tileset[a].name
	case 10: return Main_Data::game_switches->GetName(id);   //.s[a].name
	case 11: return Main_Data::game_variables->GetName(id);   //.v[a].name
	case 12: return {};  // FIXME: .t[a].name -- not sure how to get this for now
	case 13: //.cev[a].name
	{
		// assuming the vector of common events here is ordered by common event ID
		if (static_cast<int>(Game_Map::GetCommonEvents().size()) >= id) {
			return Game_Map::GetCommonEvents()[id - 1].GetName();
		}
		break;
	}
	case 14: return get_name("Class", lcf::Data::classes);   //.class[a].name
	case 15: return get_name("BattlerAnimation", lcf::Data::battleranimations);   //.anim2[a].name
	case 16: return Game_Map::GetMapName(id);   //.map[a].name
	case 17:   //.mev[a].name
	{
		auto map = Game_Map::GetEvent(id);
		if (map != nullptr) {
			return map->GetName();
		}
		break;
	}
	case 18: //.member[a].name, index starts from 0
	{
		auto actor = Main_Data::game_party->GetActor(id);
		if (actor != nullptr) {
			if (is_dynamic) {
				return actor->GetName();
			}
			else {
				id = actor->GetId();
				return get_name("Actor", lcf::Data::actors);
			}
		}
		break;
	}
	}

	Output::Warning("GetLcfName: Unsupported data_type {} {}", data_type, id);
	return {};
}

std::string_view ManiacPatch::GetLcfDescription(int data_type, int id, bool is_dynamic) {
	auto get_desc = [id](std::string_view type, const auto& vec) -> std::string_view {
		auto* data = lcf::ReaderUtil::GetElement(vec, id);
		if (!data) {
			Output::Warning("Unable to read {} description: {}", type, id);
			return {};
		}
		if constexpr (std::is_same_v<typename std::decay_t<decltype(vec)>::value_type, lcf::rpg::Actor>) {
			return data->title;
		} else {
			return data->description;
		}
	};

	switch (data_type)
	{
	case 0:  //.actor[a].desc
		if (is_dynamic) {
			auto actor = Main_Data::game_actors->GetActor(id);
			if (actor != nullptr) {
				return actor->GetTitle();
			}
		}
		else {
			return get_desc("Actor", lcf::Data::actors);
		}
		break;
	case 1: return get_desc("Skill", lcf::Data::skills); //.skill[a].desc
	case 2: return get_desc("Item", lcf::Data::items); //.item[a].desc
	case 18: //.member[a].desc
	{
		auto actor = Main_Data::game_party->GetActor(id);
		if (actor != nullptr) {
			if (is_dynamic) {
				return actor->GetTitle();
			}
			else {
				id = actor->GetId();
				return get_desc("Actor", lcf::Data::actors);
			}
		}
		break;
	}
	}

	Output::Warning("GetLcfDescription: Unsupported data_type {} {}", data_type, id);
	return {};
}

bool ManiacPatch::GlobalSave::Load() {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	if (global_save_opened) {
		return true;
	}

	// Even consider it opened when the file is missing
	// It will be created on Save
	global_save_opened = true;

	auto lgs_in = FileFinder::Save().OpenFile("Save.lgs");
	if (!lgs_in) {
		return false;
	}

	return Load(lgs_in);
}

bool ManiacPatch::GlobalSave::Load(Filesystem_Stream::InputStream& lgs_in) {
	if (!lgs_in) {
		return false;
	}

	lcf::LcfReader reader(lgs_in);
	std::string header;
	reader.ReadString(header, reader.ReadInt());
	if (header.length() != 13 || header != "LcfGlobalSave") {
		Output::Debug("This is not a valid global save.");
		return false;
	}

	lcf::LcfReader::Chunk chunk;

	while (!reader.Eof()) {
		chunk.ID = reader.ReadInt();
		chunk.length = reader.ReadInt();
		switch (chunk.ID) {
			case 1: {
				Game_Switches::Switches_t switches;
				reader.Read(switches, chunk.length);
				Main_Data::game_switches_global->SetData(std::move(switches));
				break;
			}
			case 2: {
				Game_Variables::Variables_t variables;
				reader.Read(variables, chunk.length);
				Main_Data::game_variables_global->SetData(std::move(variables));
				break;
			}
			default:
				reader.Skip(chunk, "CommandManiacControlGlobalSave");
		}
	}

	return true;
}

bool ManiacPatch::GlobalSave::Save(bool close_global_save) {
	if (!Player::IsPatchManiac()) {
		return true;
	}

	if (!global_save_opened) {
		return true;
	}

	auto savelgs_name = FileFinder::Save().FindFile("Save.lgs");
	if (savelgs_name.empty()) {
		savelgs_name = "Save.lgs";
	}

	auto lgs_out = FileFinder::Save().OpenOutputStream(savelgs_name);
	if (!Save(lgs_out)) {
		Output::Warning("Maniac ControlGlobalSave: Saving failed");
		return false;
	}

	global_save_opened = !close_global_save;

	AsyncHandler::SaveFilesystem();
	return true;
}

bool ManiacPatch::GlobalSave::Save(Filesystem_Stream::OutputStream& lgs_out) {
	if (!lgs_out) {
		return false;
	}

	lcf::LcfWriter writer(lgs_out, lcf::EngineVersion::e2k3);
	writer.WriteInt(13);
	const std::string header = "LcfGlobalSave";
	writer.Write(header);
	writer.WriteInt(1);
	writer.WriteInt(Main_Data::game_switches_global->GetSize());
	writer.Write(Main_Data::game_switches_global->GetData());
	writer.WriteInt(2);
	writer.WriteInt(Main_Data::game_variables_global->GetSize() * sizeof(int32_t));
	writer.Write(Main_Data::game_variables_global->GetData());
	return true;
}

void ManiacPatch::GlobalSave::Close() {
	global_save_opened = false;
}


/*end of file .\maniac_patch.cpp*/

/*start of file .\message_overlay.cpp*/

/* ... license chunk ... */

#include <sstream>

#include "message_overlay.h"
#include "player.h"
#include "bitmap.h"
#include "game_message.h"
#include "drawable_mgr.h"
#include "baseui.h"

MessageOverlay::MessageOverlay() : Drawable(Priority_Overlay, Drawable::Flags::Global)
{
	// Graphics::RegisterDrawable is in the Update function
}

void MessageOverlay::Draw(Bitmap& dst) {
	if (!IsAnyMessageVisible() && !show_all) {
		// Don't render overlay when no message visible
		return;
	}

	dst.Blit(ox, oy, *bitmap, bitmap->GetRect(), 255);

	if (!dirty) return;

	bitmap->Clear();

	int i = 0;

	for (auto& message : messages) {
		if (!message.hidden || show_all) {
			bitmap->Blit(0, i * text_height, *black, black->GetRect(), 128);

			std::string text = message.text;
			if (message.repeat_count > 0) {
				text += " [" + std::to_string(message.repeat_count + 1) + "x]";
			}

			Text::Draw(*bitmap, 2, i * text_height, *Font::DefaultBitmapFont(), message.color, text);
			++i;
		}
	}

	dirty = false;
}

void MessageOverlay::AddMessage(const std::string& message, Color color) {
	if (message.empty()) {
		return;
	}

	if (message == last_message) {
		// The message matches the previous message -> increase counter
		messages.back().repeat_count++;
		messages.back().hidden = false;
		// Keep the old message (with a new counter) on the screen
		counter = 0;

		dirty = true;
		return;
	}

	last_message = message;

	Game_Message::WordWrap(
			message,
			Player::screen_width - 6, // hardcoded to screen width because the bitmap is not initialized early enough
			[&](std::string_view line) {
				messages.emplace_back(std::string(line), color);
			}, *Font::DefaultBitmapFont()
	);

	while (messages.size() > (unsigned)message_max) {
		messages.pop_front();
	}

	dirty = true;
}

void MessageOverlay::Update() {
	if (!DisplayUi) {
		return;
	}

	if (!bitmap) {
		// Initialisation is delayed because the display is not ready on startup
		OnResolutionChange();
	}

	if (IsAnyMessageVisible()) {
		++counter;
		if (counter > 150) {
			counter = 0;
			for (auto& message : messages) {
				if (!message.hidden) {
					message.hidden = true;
					break;
				}
			}
			dirty = true;
		}
	}
}

void MessageOverlay::SetShowAll(bool show_all) {
	this->show_all = show_all;
	dirty = true;
}

void MessageOverlay::OnResolutionChange() {
	if (!bitmap) {
		DrawableMgr::Register(this);
	}

	black = Bitmap::Create(Player::screen_width, text_height, Color(0, 0, 0, 255));
	bitmap = Bitmap::Create(Player::screen_width, text_height * message_max, true);
}

bool MessageOverlay::IsAnyMessageVisible() const {
	return std::any_of(messages.cbegin(), messages.cend(), [](const MessageOverlayItem& m) { return !m.hidden; });
}

MessageOverlayItem::MessageOverlayItem(const std::string& text, Color color) :
	text(text), color(color)
{
	// no-op
}


/*end of file .\message_overlay.cpp*/

/*start of file .\meta.cpp*/

/* ... license chunk ... */

#include <iostream>

// Headers
#include <fstream>
#include <iomanip>
#include <memory>
#include <sstream>
#include <lcf/data.h>
#include "filefinder.h"
#include <lcf/lmt/reader.h>
#include <lcf/lsd/reader.h>
#include "main_data.h"
#include "meta.h"
#include "output.h"
#include "player.h"
#include "translation.h"
#include <lcf/reader_util.h>


// Constants used for identifying fields in the easyrpg.ini file.
#define MTINI_NAME "Name"
#define MTINI_IMPORT_SAVE_PIVOT_MAP "ImportSavePivotMap"
#define MTINI_IMPORT_SAVE_PARENT "ImportSaveParent"
#define MTINI_EASY_RPG_SECTION "EasyRPG"
#define MTINI_FILE_FORMAT_VERSION "FileFormatVersion"
#define MTINI_FILEXT_LDB_ALIAS "LdbFileAlias"
#define MTINI_FILEXT_LMT_ALIAS "LmtFileAlias"
#define MTINI_FILEXT_LMU_ALIAS "LmuFileAlias"

// Extended vocab key/value pairs
#define MTINI_EXVOCAB_IMPORT_SAVE_HELP_KEY "Vocab_ImportSaveHelp"
#define MTINI_EXVOCAB_IMPORT_SAVE_HELP_VALUE "Import Existing Save (Multi-Games Only)"
#define MTINI_EXVOCAB_IMPORT_SAVE_TITLE_KEY "Vocab_ImportSave"
#define MTINI_EXVOCAB_IMPORT_SAVE_TITLE_VALUE "Import Save"
#define MTINI_EXVOCAB_TRANSLATE_TITLE_KEY "Vocab_Translate"
#define MTINI_EXVOCAB_TRANSLATE_TITLE_VALUE "Language"


// Helper: Get the CRC32 of a given file as a hex string
std::string crc32file(std::string file_name) {
	if (!file_name.empty()) {
		auto in = FileFinder::Game().OpenInputStream(file_name);
		if (in) {
			auto crc = Utils::CRC32(in);
			std::stringstream res;
			res <<std::hex << std::setfill('0') <<std::setw(8) <<crc;
			return res.str();
		}
	}
	return "";
}


Meta::Meta(std::string_view meta_file) {
	auto is = FileFinder::Game().OpenInputStream(meta_file);
	if (!is) {
		return;
	}

	ini = std::make_unique<lcf::INIReader>(is);

	// Cache per-game lookups
	if (!Empty()) {
		auto version = ini->GetString(MTINI_EASY_RPG_SECTION, MTINI_FILE_FORMAT_VERSION, "");
		if (version == "1") {
			IdentifyCanonName(TREEMAP_NAME, DATABASE_NAME);
		} else {
			Output::Warning("Metadata error in {}, format property {}:{} is missing or invalid: '{}'", meta_file, MTINI_EASY_RPG_SECTION, MTINI_FILE_FORMAT_VERSION, version);
			ini.reset();
		}
	}
}

void Meta::ReInitForNonStandardExtensions(std::string_view file1, std::string_view file2) {
	if (!Empty()) {
		if (canon_ini_lookup.empty()) {
			IdentifyCanonName(file1, file2);
		}
		if (canon_ini_lookup.empty()) {
			IdentifyCanonName(file2, file1);
		}
	}
}


int Meta::GetPivotMap() const {
	if (!Empty()) {
		return ini->GetInteger(canon_ini_lookup, MTINI_IMPORT_SAVE_PIVOT_MAP, 0);
	}

	return 0;
}

std::string Meta::GetParentGame() const {
	if (!Empty()) {
		return std::string(ini->GetString(canon_ini_lookup, MTINI_IMPORT_SAVE_PARENT, ""));
	}

	return "";
}

std::vector<std::string> Meta::GetImportChildPaths(const FilesystemView& parent_fs) const {
	std::vector<std::string> res;

	if (!Empty()) {
		const auto* entries = parent_fs.ListDirectory();
		if (entries) {
			for (const auto &item: *entries) {
				if (item.second.type != DirectoryTree::FileType::Directory) {
					continue;
				}
				res.push_back(item.second.name);
			}
		}
	}

	return res;
}

std::vector<Meta::FileItem> Meta::SearchImportPaths(const FilesystemView& parent_fs, std::string_view child_path) const {
	if (!Empty()) {
		int pivotMapId = GetPivotMap();
		auto parent = GetParentGame();
		return BuildImportCandidateList(parent_fs, child_path, parent, pivotMapId);
	}

	return std::vector<Meta::FileItem>();
}


std::vector<Meta::FileItem> Meta::BuildImportCandidateList(const FilesystemView& parent_fs, std::string_view child_path, std::string_view parent_game_name, int pivot_map_id) const {
	// Scan each folder, looking for an ini file
	// For now, this only works with "standard" folder layouts, since we need Game files + Save files
	std::vector<Meta::FileItem> res;

	// Try to read the game name. Note that we assume the games all have the same encoding (and use Player::encoding)
	bool is_match = false;

	// NOTE: FindFile doesn't work outside the root of the FileSystemView, so we use Exists() and pass a relative path.
	//       This will likely only work on Native filesystems; the Exists(".") attempts to sanity check this.
	auto child_tree = parent_fs.Subtree(child_path);
	if (child_tree.Exists(".")) {
		// Try to match the parent game name.
		std::string lmtPath = child_tree.GetSubPath() + "/" + TREEMAP_NAME;
		std::string crcLMT = crc32file(lmtPath);
		std::string crcLDB = "*";

		if (parent_game_name.find(crcLMT)==0) {
			if (parent_game_name == crcLMT + "/" + crcLDB) {
				is_match = true;
			} else {
				std::string ldbPath = child_tree.GetSubPath() + "/" + DATABASE_NAME;
				crcLDB = crc32file(ldbPath);
				if (parent_game_name == crcLMT + "/" + crcLDB) {
					is_match = true;
				}
			}
		}
	}

	if (is_match) {
		// Scan over every possible save file and see if any match.
		for (int saveId = 0; saveId < 15; saveId++) {
			std::stringstream ss;
			ss << "Save" << (saveId <= 8 ? "0" : "") << (saveId + 1) << ".lsd";

			// Check for an existing, non-corrupt file with the right mapID
			// Note that corruptness is checked later (in window_savefile.cpp)
			if (child_tree.Exists(ss.str())) {
				auto filePath= child_tree.GetSubPath() + "/" + ss.str();
				std::unique_ptr<lcf::rpg::Save> savegame = lcf::LSD_Reader::Load(filePath, Player::encoding);
				if (savegame != nullptr) {
					if (savegame->party_location.map_id == pivot_map_id || pivot_map_id==0) {
						FileItem item;
						item.full_path = filePath;
						item.short_path = FileFinder::MakeCanonical(child_path, 1);
						item.file_id = saveId + 1;
						res.push_back(item);
					}
				}
			}
		}
	}
	return res;
}

std::string Meta::GetLdbAlias() const {
	if (!Empty()) {
		return std::string(ini->GetString(canon_ini_lookup, MTINI_FILEXT_LDB_ALIAS, ""));
	}
	return "";
}

std::string Meta::GetLmtAlias() const {
	if (!Empty()) {
		return std::string(ini->GetString(canon_ini_lookup, MTINI_FILEXT_LMT_ALIAS, ""));
	}
	return "";
}

std::string Meta::GetLmuAlias() const {
	if (!Empty()) {
		return std::string(ini->GetString(canon_ini_lookup, MTINI_FILEXT_LMU_ALIAS, ""));
	}
	return "";
}


bool Meta::IsImportEnabled() const {
	return !GetParentGame().empty();
}


std::string Meta::GetExVocabImportSaveHelpText() const {
	return GetExVocab(MTINI_EXVOCAB_IMPORT_SAVE_HELP_KEY, MTINI_EXVOCAB_IMPORT_SAVE_HELP_VALUE);
}

std::string Meta::GetExVocabImportSaveTitleText() const {
	return GetExVocab(MTINI_EXVOCAB_IMPORT_SAVE_TITLE_KEY, MTINI_EXVOCAB_IMPORT_SAVE_TITLE_VALUE);
}

std::string Meta::GetExVocabTranslateTitleText() const {
	std::string term;

	if (Tr::HasActiveTranslation()) {
		term = Player::translation.GetCurrentLanguage().lang_term;
	} else {
		term = Player::translation.GetDefaultLanguage().lang_term;
	}

	if (!term.empty()) {
		return term;
	}

	return GetExVocab(MTINI_EXVOCAB_TRANSLATE_TITLE_KEY, MTINI_EXVOCAB_TRANSLATE_TITLE_VALUE);
}

std::string Meta::GetExVocab(std::string_view term, std::string_view def_value) const {
	if (!Empty()) {
		return std::string(ini->GetString(canon_ini_lookup, term, def_value));
	}

	return ToString(def_value);
}

void Meta::IdentifyCanonName(std::string_view lmtFile, std::string_view ldbFile) {
	// Calculate the lookup based on the LMT/LDB hashes, preferring to use LMT only if possible.
	// This requires a mandatory field, for which we will use "Name".
	if (!Empty()) {
		std::string lmtPath = FileFinder::Game().FindFile(ToString(lmtFile));
		std::string crcLMT = crc32file(lmtPath);
		std::string crcLDB = "*";
		Output::Debug("CRC32 of 'LMT' file ('{}') is {}", lmtFile, crcLMT);
		if (ini->HasValue(crcLMT + "/" + crcLDB , MTINI_NAME)) {
			canon_ini_lookup = crcLMT + "/" + crcLDB;
		} else {
			std::string ldbPath = FileFinder::Game().FindFile(ToString(ldbFile));
			crcLDB = crc32file(ldbPath);
			if (ini->HasValue(crcLMT + "/" + crcLDB , MTINI_NAME)) {
				canon_ini_lookup = crcLMT + "/" + crcLDB;
			}
			Output::Debug("CRC32 of 'LDB' file ('{}') file is {}", ldbFile, crcLDB);
		}
	}
}

bool Meta::Empty() const {
	return ini == nullptr || ini->ParseError() == -1;
}


/*end of file .\meta.cpp*/

/*start of file .\midisequencer.cpp*/

/*
Copyright (c) 2003-2006 yuno
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
3. Neither the name of copyright holders nor the names of its contributors
   may be used to endorse or promote products derived from this software
   without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS''
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "system.h"

#include "midisequencer.h"
#include "output.h"

#include <cassert>
#include <algorithm>

using namespace std::chrono_literals;

namespace midisequencer{
    static uint_least32_t read_variable_value(void* fp, int(*fgetc)(void*), uint_least32_t* track_length, const char* errtext)
    {
        int ret = 0;
        int d;
        do{
            --*track_length;
            d = fgetc(fp);
            if(d == EOF){
                Output::Warning("Midi sequencer: {}", errtext);
            }
            ret <<= 7;
            ret |= (d & 0x7F);
        }while(d & 0x80);
        return ret;
    }

    inline bool operator<(const midi_message& a, const midi_message& b)
    {
        return a.time < b.time;
    }

    sequencer::sequencer():
        position(messages.begin())
    {
        loop_position = position;
    }
    void sequencer::clear()
    {
        messages.clear();
        long_messages.clear();
        position = messages.begin();
    }
    void sequencer::rewind()
    {
        position = messages.begin();
    }

    std::vector<midi_message>::iterator sequencer::rewind_to_loop()
    {
        position = loop_position;
        if (position != messages.begin()) {
            position--;
        }
        return loop_position;
    }

    bool sequencer::is_at_end()
    {
        return position == messages.end();
    }
    bool sequencer::load(void* fp, int(*fgetc)(void*))
    {
        bool result = false;
        clear();
        int b0 = fgetc(fp);
        int b1 = fgetc(fp);
        int b2 = fgetc(fp);
        int b3 = fgetc(fp);
        if(b0 == 0x4D && b1 == 0x54 && b2 == 0x68 && b3 == 0x64){
            load_smf(fp, fgetc);
            result = true;
        }else{
            Output::Warning("Midi sequencer: unsupported format");
        }
        if(!result){
            clear();
        }
        position = messages.begin();
        return result;
    }
    static int fpfgetc(void* fp)
    {
        return getc(static_cast<std::FILE*>(fp));
    }
    static bool is_loop_start(uint_least32_t msg) {
        // If the message matches the de facto standard MIDI loop instruction:
        // Which is a Control Change on any channel with Value 111
        uint8_t event_type = (msg & 0x0000F0) >> 4;
        uint8_t value1 = (msg & 0x00FF00) >> 8;
        return event_type == 0b1011 && value1 == 111;
    }
    bool sequencer::load(std::FILE* fp)
    {
        return load(fp, fpfgetc);
    }
    int sequencer::get_num_ports()const
    {
        int ret = 0;
        for(const auto& message: messages){
            if(ret < message.port){
                ret = message.port;
            }
        }
        return ret + 1;
    }
    std::chrono::microseconds sequencer::get_total_time()const
    {
        if(messages.empty()){
            return 0us;
        }else{
            return messages.back().time;
        }
    }
    std::string sequencer::get_title()const
    {
        for(const auto& message: messages){
            if(message.track == 0 && (message.message & 0xFF) == 0xFF){
                assert((message.message >> 8) < long_messages.size());
                const std::string& s = long_messages[message.message >> 8];
                if(s.size() > 1 && s[0] == 0x03){
                    return s.substr(1);
                }
            }
        }
        return std::string();
    }
    std::string sequencer::get_copyright()const
    {
        for(const auto& message: messages){
            if(message.track == 0 && (message.message & 0xFF) == 0xFF){
                assert((message.message >> 8) < long_messages.size());
                const std::string& s = long_messages[message.message >> 8];
                if(s.size() > 1 && s[0] == 0x02){
                    return s.substr(1);
                }
            }
        }
        return std::string();
    }
    std::string sequencer::get_song()const
    {
        std::string ret;
        for(const auto& message: messages){
            if(message.track == 0 && (message.message & 0xFF) == 0xFF){
                assert((message.message >> 8) < long_messages.size());
                const std::string& s = long_messages[message.message >> 8];
                assert(s.size() >= 1);
                if(s[0] == 0x05){
                    ret += s.substr(1);
                }
            }
        }
        return ret;
    }
    void sequencer::play(std::chrono::microseconds time, output* out)
    {
        if(position != messages.begin() && (position - 1)->time >= time){
            position = messages.begin();
        }
        if(position == messages.begin() && position != messages.end() && position->time < time){
            out->reset();
        }

        while(position != messages.end() && position->time < time){
            uint_least32_t message = position->message;
            int port = position->port;
            ++position;

            switch(message & 0xFF){
            case 0xF0:
                {
                    assert((message >> 8) < long_messages.size());
                    const std::string& s = long_messages[static_cast<int>(message >> 8)];
                    out->sysex_message(port, s.data(), s.size());
                }
                break;
            case 0xFF:
                {
                    assert((message >> 8) < long_messages.size());
                    const std::string& s = long_messages[static_cast<int>(message >> 8)];
                    assert(s.size() >= 1);
                    out->meta_event(static_cast<unsigned char>(s[0]), s.data() + 1, s.size() - 1);
                }
                break;
            default:
                out->midi_message(port, message);
                break;
            }
        }
    }

    void sequencer::set_time(std::chrono::microseconds time, output* out)
    {
        if(position != messages.begin() && (position - 1)->time >= time){
            position = messages.begin();
        }
        if(position == messages.begin() && position != messages.end() && position->time < time){
            out->reset();
        }

        if(position->time > time)
            position = messages.begin();

        while(position != messages.end() && position->time < time){
            uint_least32_t message = position->message;
            int port = position->port;
            ++position;

            switch(message & 0xFF){
                case 0xF0:
                {
                    assert((message >> 8) < long_messages.size());
                    const std::string& s = long_messages[static_cast<int>(message >> 8)];
                    out->sysex_message(port, s.data(), s.size());
                }
                    break;
                case 0xFF:
                {
                    assert((message >> 8) < long_messages.size());
                    const std::string& s = long_messages[static_cast<int>(message >> 8)];
                    assert(s.size() >= 1);
                    out->meta_event(static_cast<unsigned char>(s[0]), s.data() + 1, s.size() - 1);
                }
                    break;
                default:

                    if((message & 0xF0) == 0x80 || (message & 0xF0) == 0x90)
                    {
                        out->meta_event(META_EVENT_ALL_NOTE_OFF, NULL, 0);
                        break;
                    }

                    out->midi_message(port, message);
                    break;
            }
        }
    }

    std::chrono::microseconds sequencer::get_start_skipping_silence() {
        std::vector<midi_message> m;

        for (auto& msg: messages) {
            // If we find Loop Start before the first NoteOn, just start there
            if (is_loop_start(msg.message)) {
                std::chrono::microseconds time = msg.time;
                // RPG_RT always rewinds "a little"
                // This amount is based on the tempo, and this 2100000 divisor
                // I determined experimentally.
                time = std::max(0us, std::chrono::microseconds(static_cast<int>(time.count() - (msg.tempo / 2.1f))));
                return time;
            } else if ((msg.message & 0xFF) == 0xF0) {
                // SysEx message. RPG_RT doesn't skip silence if there's a SysEx
                // message in the beginning, so neither should we...
                return 0us;
            } else if ((msg.message & 0xF0) == 0x90) {
                // NoteOn -- found the first note!
                std::chrono::microseconds time = msg.time;
                // RPG_RT always rewinds "a little"
                // This amount is based on the tempo, and this 2100000 divisor
                // I determined experimentally.
                time = std::max(0us, std::chrono::microseconds(static_cast<int>(time.count() - (msg.tempo / 2.1f))));
                return time;
            }
        }
        return 0us;
    }

    void sequencer::load_smf(void* fp, int(*fgetc)(void*))
    {
        if(fgetc(fp) != 0
        || fgetc(fp) != 0
        || fgetc(fp) != 0
        || fgetc(fp) != 6
        || fgetc(fp) != 0){
            Output::Warning("Midi sequencer: invalid file header");
        }
        int format = fgetc(fp);
        if(format != 0 && format != 1){
            Output::Warning("Midi sequencer: unsupported format type");
        }
        int t0 = fgetc(fp);
        int t1 = fgetc(fp);
        unsigned num_tracks = (t0 << 8) | t1;
        int d0 = fgetc(fp);
        int d1 = fgetc(fp);
        division = (d0 << 8) | d1;
        for(unsigned track = 0; track < num_tracks; ++track){
            if(fgetc(fp) != 0x4D || fgetc(fp) != 0x54 || fgetc(fp) != 0x72 || fgetc(fp) != 0x6B){
                Output::Warning("Midi sequencer: invalid track header");
            }
            int l0 = fgetc(fp);
            int l1 = fgetc(fp);
            int l2 = fgetc(fp);
            int l3 = fgetc(fp);
            uint_least32_t track_length = (static_cast<uint_least32_t>(l0) << 24)
                                        | (static_cast<uint_least32_t>(l1) << 16)
                                        | (l2 << 8)
                                        | l3;
            int running_status = 0;
            double time_offset = 0;
            uint_least32_t time = 0;
            midi_message msg;
            msg.port = 0;
            msg.track = track;
            for(;;){
                if(track_length < 4){
                    Output::Warning("Midi sequencer: unexpected EOF (track_length)");
                }
                uint_least32_t delta = read_variable_value(fp, fgetc, &track_length, "unexpected EOF (deltatime)");
                time += delta;
                if(division & 0x8000){
                    int fps = ~(division >> 8) + 1;
                    int frames = division & 0xFF;
                    msg.time = std::chrono::microseconds(static_cast<int>(time / (frames * fps) + time_offset));
                }else{
                    msg.time = std::chrono::microseconds(time);
                }
                int param = fgetc(fp);
                --track_length;
                switch(param){
                case 0xF0:
                    {
                        int n = read_variable_value(fp, fgetc, &track_length, "unexpected EOF (sysex length)");
                        std::string s(n + 1, '\0');
                        s[0] = static_cast<char>(0xF0);
                        for(int i = 1; i <= n; ++i){
                            s[i] = static_cast<char>(fgetc(fp));
                        }
                        if(s[n] != '\xF7'){
                            Output::Debug("Midi sequencer: missing sysex terminator");
                            s += static_cast<char>(0xF7);
                        }
                        track_length -= n;
                        msg.message = 0xF0 | (long_messages.size() << 8);
                        messages.push_back(msg);
                        long_messages.push_back(s);
                    }
                    break;
                case 0xF7:
                    /* unsupported */
                    /*
                    {
                        int n = read_variable_value(fp, fgetc, &track_length, "unexpected EOF (sysex-F7 length)");
                        std::string s(n, '\0');
                        for(int i = 0; i < n; ++i){
                            s[i] = fgetc(fp);
                        }
                        track_length -= n;
                        msg.message = 0xF0 | (long_messages.size() << 8);
                        messages.push_back(msg);
                        long_messages.push_back(s);
                    }
                    */
                    break;
                case 0xFF:
                    {
                        int type = fgetc(fp);
                        --track_length;
                        int n = read_variable_value(fp, fgetc, &track_length, "unexpected EOF (metaevent)");
                        std::string s(n + 1, '\0');
                        s[0] = static_cast<char>(type);
                        for(int i = 1; i <= n; ++i){
                            s[i] = static_cast<char>(fgetc(fp));
                        }
                        track_length -= n;
                        msg.message = 0xFF | (long_messages.size() << 8);
                        messages.push_back(msg);
                        long_messages.push_back(s);
                        switch(type){
                        case 0x21:
                            if(n == 1){
                                msg.port = static_cast<unsigned char>(s[1]);
                            }
                            break;
                        case 0x2F:
                            goto next_track;
                        case 0x54:
                            if(n != 5){
                                Output::Warning("Midi sequencer: invalid SMTPE offset metaevent length");
                            }
                            if(msg.time == 0us && (division & 0x8000)){
                                int hour = static_cast<unsigned char>(s[1]);
                                int min = static_cast<unsigned char>(s[2]);
                                int sec = static_cast<unsigned char>(s[3]);
                                int frame = static_cast<unsigned char>(s[4]);
                                int subframe = static_cast<unsigned char>(s[5]);
                                double fps;
                                switch(hour >> 5){
                                default: // line added by nextvolume (2015-02-25)
                                case 0:
                                    fps = 24;
                                    break;
                                case 1:
                                    fps = 25;
                                    break;
                                case 2:
                                    fps = 29.97;
                                    break;
                                case 3:
                                    fps = 30;
                                    break;
                                }
                                time = 0;
                                time_offset = (hour & 0x1F) * 3600 + min * 60 + sec + (frame + subframe / 100.0) * fps;
                            }
                            break;
                        }
                    }
                    break;
                default:
                    if(param & 0x80){
                        running_status = param;
                        param = fgetc(fp);
                        --track_length;
                    }
                    switch(running_status & 0xF0){
                    case 0xC0:
                    case 0xD0:
                        msg.message = running_status | (param << 8);
                        break;
                    case 0x80:
                    case 0x90:
                    case 0xA0:
                    case 0xB0:
                    case 0xE0:
                        msg.message = running_status | (param << 8) | (fgetc(fp) << 16);
                        --track_length;
                        break;
                    default:
                        Output::Warning("Midi sequencer: invalid midi message");
                    }
                    messages.push_back(msg);
                    break;
                }
            }
        next_track:
            while(track_length > 0){
                if(fgetc(fp) == EOF){
                    Output::Warning("Midi sequencer: unexpected EOF (tailer padding)");
                }
                --track_length;
            }
        }
        std::stable_sort(messages.begin(), messages.end());
        loop_position = messages.begin();
        if(!(division & 0x8000)){
            uint_least32_t tempo = 500000;
            std::chrono::microseconds time_offset = 0us;
            std::chrono::microseconds base = 0us;
            for(auto i = messages.begin(); i != messages.end(); ++i){
                std::chrono::microseconds org_time = i->time;
                i->time = std::chrono::microseconds(static_cast<int>(static_cast<double>((i->time.count() - base.count())) * tempo / division + time_offset.count()));
                if((i->message & 0xFF) == 0xFF){
                    assert((i->message >> 8) < long_messages.size());
                    const std::string& s = long_messages[i->message >> 8];
                    if(s.size() == 4 && s[0] == 0x51){
                        tempo = (static_cast<uint_least32_t>(static_cast<unsigned char>(s[1])) << 16)
                              | (static_cast<unsigned char>(s[2]) << 8)
                              | static_cast<unsigned char>(s[3]);
                        base = org_time;
                        time_offset = i->time;
                    }
                }
                i->tempo = tempo;
                if (is_loop_start(i->message)) {
                    // Loop backwards through the messages to find the first message with the same
                    // timestamp as the loop message
                    for (auto j = i; j != messages.begin() && j->time >= i->time; j--) {
                        loop_position = j;
                    }
                }
            }
        }
    }

    uint32_t sequencer::get_division() const {
        return division;
    }
}


/*end of file .\midisequencer.cpp*/

/*start of file .\midisynth.cpp*/

/*
Copyright (c) 2003-2006 yuno
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
3. Neither the name of copyright holders nor the names of its contributors
   may be used to endorse or promote products derived from this software
   without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS''
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "system.h"

#ifdef WANT_FMMIDI

// MIDI software synthesizer.
#include "midisynth.h"

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstring>
#include <utility>

#ifdef __BORLANDC__
#include <fastmath.h>
namespace std{
    using ::_fm_sin;
    using ::_fm_cos;
    using ::_fm_log10;
}
#endif

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

namespace midisynth{
    // Channel constructor.
    channel::channel(note_factory* factory_, int bank):
        factory(factory_), default_bank(bank)
    {
        notes.reserve(16);
        reset_all_parameters();
    }
    // Channel destructor.
    channel::~channel()
    {
        all_sound_off_immediately();
    }
    // Synthesizes sound notes.
    int channel::synthesize(int_least32_t* out, std::size_t samples, float rate, int_least32_t master_volume, int master_balance)
    {
        double volume = mute ? 0.0 : std::pow(static_cast<double>(master_volume) * this->volume * expression / (16383.0 * 16383.0 * 16383.0), 2) * 16383.0;
        int num_notes = 0;
        std::vector<NOTE>::iterator i = notes.begin();
        while(i != notes.end()){
            class note* note = i->note;
            int_least32_t panpot = note->get_panpot();
            if(this->panpot <= 8192){
                panpot = panpot * this->panpot / 8192;
            }else{
                panpot = panpot * (16384 - this->panpot) / 8192 + (this->panpot - 8192) * 2;
            }
            if(master_balance <= 8192){
                panpot = panpot * master_balance / 8192;
            }else{
                panpot = panpot * (16384 - master_balance) / 8192 + (master_balance - 8192) * 2;
            }
            int_least32_t left = static_cast<int_least32_t>(volume * std::cos(std::max<int_least32_t>(0, panpot - 1) * (M_PI / 2 / 16382)));
            int_least32_t right = static_cast<int_least32_t>(volume * std::sin(std::max<int_least32_t>(0, panpot - 1) * (M_PI / 2 / 16382)));
            bool ret = note->synthesize(out, samples, rate, left, right);
            if(ret){
                ++i;
            }else{
                i = notes.erase(i);
                delete note;
            }
            ++num_notes;
        }
        return num_notes;
    }
    // Returns all parameters to the initial state.
    void channel::reset_all_parameters()
    {
        program = default_bank * 128;
        bank = default_bank;
        panpot = 8192;
        volume = 12800;
        fine_tuning = 8192;
        coarse_tuning = 8192;
        tremolo_frequency = 3;
        vibrato_frequency = 3;
        master_frequency_multiplier = 1;
        mono = false;
        mute = false;
        system_mode = system_mode_default;
        reset_all_controller();
    }
    // Returns all controllers to the initial state.
    void channel::reset_all_controller()
    {
        expression = 16383;
        pressure = 0;
        channel_pressure(0);
        pitch_bend = 8192;
        pitch_bend_sensitivity = 256;
        frequency_multiplier = 0.0f;
        update_frequency_multiplier();
        modulation_depth = 0;
        modulation_depth_range = 64;
        update_modulation();
        damper = 0;
        set_damper(0);
        set_sostenute(0);
        freeze = 0;
        set_freeze(0);
        RPN = 0x3FFF;
        NRPN = 0x3FFF;
    }
    // Turns off all notes.
    void channel::all_note_off()
    {
        for(std::vector<NOTE>::iterator i = notes.begin(); i != notes.end(); ++i){
            if(i->status == NOTE::NOTEON){
                i->status = NOTE::NOTEOFF;
                i->note->note_off(64);
            }
        }
    }
    // Turns off all sounds.
    void channel::all_sound_off()
    {
        for(std::vector<NOTE>::iterator i = notes.begin(); i != notes.end(); ++i){
            if(i->status != NOTE::SOUNDOFF){
                i->status = NOTE::SOUNDOFF;
                i->note->sound_off();
            }
        }
    }
    // Mutes immediately.
    void channel::all_sound_off_immediately()
    {
        for(std::vector<NOTE>::iterator i = notes.begin(); i != notes.end(); ++i){
            delete i->note;
        }
        notes.clear();
    }
    // Note on. Sound output.
    void channel::note_on(int note, int velocity)
    {
        assert(note >= 0 && note < NUM_NOTES);
        assert(velocity >= 0 && velocity <= 127);

        note_off(note, 64);
        if(velocity){
            if(mono){
                all_sound_off();
            }
            class note* p = factory->note_on(program, note, velocity, frequency_multiplier);
            if(p){
                int assign = p->get_assign();
                if(assign){
                    for(std::vector<NOTE>::iterator i = notes.begin(); i != notes.end(); ++i){
                        if(i->note->get_assign() == assign){
                            i->note->sound_off();
                        }
                    }
                }
                if(freeze){
                    p->set_freeze(freeze);
                }
                if(damper){
                    p->set_damper(damper);
                }
                if(modulation_depth){
                    float depth = static_cast<double>(modulation_depth) * modulation_depth_range / (16383.0 * 128.0);
                    p->set_vibrato(depth, vibrato_frequency);
                }
                if(pressure){
                    p->set_tremolo(pressure, tremolo_frequency);
                }
                notes.push_back(NOTE(p, note));
            }
        }
    }
    // Note off. Sound gets into the release step.
    void channel::note_off(int note, int velocity)
    {
        assert(note >= 0 && note < NUM_NOTES);
        assert(velocity >= 0 && velocity <= 127);
        for(std::vector<NOTE>::iterator i = notes.begin(); i != notes.end(); ++i){
            if(i->key == note && i->status == NOTE::NOTEON){
                i->status = NOTE::NOTEOFF;
                i->note->note_off(velocity);
            }
        }
    }
    // Polyphonic key pressure.
    void channel::polyphonic_key_pressure(int note, int value)
    {
        assert(note >= 0 && note < NUM_NOTES);
        assert(value >= 0 && value <= 127);
        for(std::vector<NOTE>::iterator i = notes.begin(); i != notes.end(); ++i){
            if(i->key == note && i->status == NOTE::NOTEON){
                i->note->set_tremolo(value, tremolo_frequency);
            }
        }
    }
    // Channel Pressure.
    void channel::channel_pressure(int value)
    {
        assert(value >= 0 && value <= 127);
        if(pressure != value){
            pressure = value;
            for(std::vector<NOTE>::iterator i = notes.begin(); i != notes.end(); ++i){
                if(i->status == NOTE::NOTEON){
                    i->note->set_tremolo(value, tremolo_frequency);
                }
            }
        }
    }
    // Control Change.
    void channel::control_change(int control, int value)
    {
        assert(value >= 0 && value <= 0x7F);
        switch(control){
        case 0x00:
            bank_select((bank & 0x7F) | (value << 7));
            break;
        case 0x01:
            set_modulation_depth((modulation_depth & 0x7F) | (value << 7));
            break;
        case 0x06:
            set_registered_parameter((get_registered_parameter() & 0x7F) | (value << 7));
            break;
        case 0x07:
            volume = (volume & 0x7F) | (value << 7);
            break;
        case 0x0A:
            panpot = (panpot & 0x7F) | (value << 7);
            break;
        case 0x0B:
            expression = (expression & 0x7F) | (value << 7);
            break;
        case 0x20:
            bank_select((bank & 0x7F) | (value << 7));
            break;
        case 0x21:
            set_modulation_depth((modulation_depth & ~0x7F) | value);
            break;
        case 0x26:
            set_registered_parameter((get_registered_parameter() & ~0x7F) | value);
            break;
        case 0x27:
            volume = (volume & ~0x7F) | value;
            break;
        case 0x2A:
            panpot = (panpot & ~0x7F) | value;
            break;
        case 0x2B:
            expression = (expression & ~0x7F) | value;
            break;
        case 0x40:
            set_damper(value);
            break;
        case 0x42:
            set_sostenute(value);
            break;
        case 0x45:
            set_freeze(value);
            break;
        case 0x60:
            set_registered_parameter(std::min(0x3FFF, get_registered_parameter() + 1));
            break;
        case 0x61:
            set_registered_parameter(std::max(0, get_registered_parameter() - 1));
            break;
        case 0x62:
            set_NRPN((NRPN & ~0x7F) | value);
            break;
        case 0x63:
            set_NRPN((NRPN & 0x7F) | (value << 7));
            break;
        case 0x64:
            set_RPN((RPN & ~0x7F) | value);
            break;
        case 0x65:
            set_RPN((RPN & 0x7F) | (value << 7));
            break;
        case 0x78:
            all_sound_off();
            break;
        case 0x79:
            reset_all_controller();
            break;
        case 0x7B:
        case 0x7C:
        case 0x7D:
            all_note_off();
            break;
        case 0x7E:
            mono_mode_on();
            break;
        case 0x7F:
            poly_mode_on();
            break;
        }
    }
    // Bank select.
    void channel::bank_select(int value)
    {
        switch(system_mode){
        case system_mode_gm:
            break;
        case system_mode_gs:
            if(((bank & 0x3F80) == 0x3C00) == ((value & 0x3F80) == 0x3C00)){
                set_bank(value);
            }
            break;
        case system_mode_xg:
            if(default_bank == 0x3C00){
                set_bank(0x3C00 | (value & 0x7F));
            }else if((value & 0x3F80) == 0x3F80){
                set_bank(0x3C00 | (value & 0x7F));
            }else{
                set_bank(value);
            }
            break;
        default:
            if(default_bank == 0x3C00){
                set_bank(0x3C00 | (value & 0x7F));
            }else{
                set_bank(value);
            }
            break;
        }
    }
    // Damper effect.
    void channel::set_damper(int value)
    {
        if(damper != value){
            damper = value;
            for(std::vector<NOTE>::iterator i = notes.begin(); i != notes.end(); ++i){
                i->note->set_damper(value);
            }
        }
    }
    // Sostenuto effect.
    void channel::set_sostenute(int value)
    {
        sostenute = value;
        for(std::vector<NOTE>::iterator i = notes.begin(); i != notes.end(); ++i){
            i->note->set_sostenute(value);
        }
    }
    // Freeze effect.
    void channel::set_freeze(int value)
    {
        if(freeze != value){
            freeze = value;
            for(std::vector<NOTE>::iterator i = notes.begin(); i != notes.end(); ++i){
                i->note->set_freeze(value);
            }
        }
    }
    // Gets RPN.
    int channel::get_registered_parameter()
    {
        switch(RPN){
        case 0x0000:
            return pitch_bend_sensitivity;
        case 0x0001:
            return fine_tuning;
        case 0x0002:
            return coarse_tuning;
        case 0x0005:
            return modulation_depth_range;
        default:
            return 0;
        }
    }
    // Sets RPN.
    void channel::set_registered_parameter(int value)
    {
        switch(RPN){
        case 0x0000:
            set_pitch_bend_sensitivity(value);
            break;
        case 0x0001:
            set_fine_tuning(value);
            break;
        case 0x0002:
            set_coarse_tuning(value);
            break;
        case 0x0005:
            set_modulation_depth_range(value);
            break;
        default:
            break;
        }
    }
    // Recalculates and updates the frequency multiplier.
    void channel::update_frequency_multiplier()
    {
        float value = master_frequency_multiplier
                    * std::pow(2, (coarse_tuning - 8192) / (128.0 * 100.0 * 12.0)
                                + (fine_tuning - 8192) / (8192.0 * 100.0 * 12.0)
                                + static_cast<double>(pitch_bend - 8192) * pitch_bend_sensitivity / (8192.0 * 128.0 * 12.0));
        if(frequency_multiplier != value){
            frequency_multiplier = value;
            for(std::vector<NOTE>::iterator i = notes.begin(); i != notes.end(); ++i){
                i->note->set_frequency_multiplier(value);
            }
        }
    }
    // Updates the modulation depth effect.
    void channel::update_modulation()
    {
        float depth = static_cast<double>(modulation_depth) * modulation_depth_range / (16383.0 * 128.0);
        for(std::vector<NOTE>::iterator i = notes.begin(); i != notes.end(); ++i){
            i->note->set_vibrato(depth, vibrato_frequency);
        }
    }

    // Synthesizer constructor.
    synthesizer::synthesizer(note_factory* factory)
    {
        for(int i = 0; i < 16; ++i){
            channels[i].reset(new channel(factory, i == 9 ? 0x3C00 : 0x3C80));
        }
        reset_all_parameters();
    }
    // Gets channel.
    channel* synthesizer::get_channel(int ch)
    {
        assert(ch >= 0 && ch < NUM_CHANNELS);
        return channels[ch].get();
    }
    // Sound synthesis. Returns the number of notes.
    int synthesizer::synthesize(int_least16_t* output, std::size_t samples, float rate)
    {
        std::size_t n = samples * 2;
        std::vector<int_least32_t> buf(n);
        int num_notes = synthesize_mixing(&buf[0], samples, rate);
        if(num_notes){
            for(std::size_t i = 0; i < n; ++i){
                int_least32_t x = buf[i];
                if(x < -32767){
                    output[i] = -32767;
                }else if(x > 32767){
                    output[i] = 32767;
                }else{
                    output[i] = static_cast<int_least16_t>(x);
                }
            }
        }else{
            std::memset(output, 0, sizeof(int_least16_t) * n);
        }
        return num_notes;
    }
    int synthesizer::synthesize_mixing(int_least32_t* output, std::size_t samples, float rate)
    {
        if(active_sensing == 0){
            all_sound_off();
            active_sensing = -1;
        }else if(active_sensing > 0){
            active_sensing = std::max(0.0f, active_sensing - samples / rate);
        }
        int_least32_t volume = static_cast<int_least32_t>(main_volume) * master_volume / 16384;
        int num_notes = 0;
        for(int i = 0; i < NUM_CHANNELS; ++i){
            num_notes += channels[i]->synthesize(output, samples, rate, volume, master_balance);
        }
        return num_notes;
    }
    // Resets the synthesizer completely.
    void synthesizer::reset()
    {
        all_sound_off_immediately();
        reset_all_parameters();
    }
    // Returns all parameters to the initial state.
    void synthesizer::reset_all_parameters()
    {
        active_sensing = -1;
        main_volume = 8192;
        master_volume = 16383;
        master_balance = 8192;
        master_fine_tuning = 8192;
        master_coarse_tuning = 8192;
        master_frequency_multiplier = 1;
        system_mode = system_mode_default;
        for(int i = 0; i < NUM_CHANNELS; ++i){
            channels[i]->reset_all_parameters();
        }
    }
    // Returns all controllers to the initial state.
    void synthesizer::reset_all_controller()
    {
        for(int i = 0; i < NUM_CHANNELS; ++i){
            channels[i]->reset_all_controller();
        }
    }
    // All notes off. Turns off all notes.
    void synthesizer::all_note_off()
    {
        for(int i = 0; i < NUM_CHANNELS; ++i){
            channels[i]->all_note_off();
        }
    }
    // All sounds off. Turns off all sounds.
    void synthesizer::all_sound_off()
    {
        for(int i = 0; i < NUM_CHANNELS; ++i){
            channels[i]->all_sound_off();
        }
    }
    // Instant silence.
    void synthesizer::all_sound_off_immediately()
    {
        for(int i = 0; i < NUM_CHANNELS; ++i){
            channels[i]->all_sound_off_immediately();
        }
    }
    // Sets and execututes system exclusive messages.
    void synthesizer::sysex_message(const void* pvdata, std::size_t size)
    {
        const unsigned char* data = reinterpret_cast<const unsigned char*>(pvdata);
        if(size == 6 && std::memcmp(data, "\xF0\x7E\x7F\x09\x01\xF7", 6) == 0){
            /* GM system on */
            set_system_mode(system_mode_gm);
        }else if(size == 6 && std::memcmp(data, "\xF0\x7E\x7F\x09\x02\xF7", 6) == 0){
            /* GM system off */
            set_system_mode(system_mode_gm2);
        }else if(size == 6 && std::memcmp(data, "\xF0\x7E\x7F\x09\x03\xF7", 6) == 0){
            /* GM2 system on */
            set_system_mode(system_mode_gm2);
        }else if(size == 11 && std::memcmp(data, "\xF0\x41", 2) == 0 && std::memcmp(data + 3, "\x42\x12\x40\x00\x7F\x00\x41\xF7", 8) == 0){
            /* GS reset */
            set_system_mode(system_mode_gs);
        }else if(size == 9 && std::memcmp(data, "\xF0\x43", 2) == 0 && (data[2] & 0xF0) == 0x10 && std::memcmp(data + 3, "\x4C\x00\x00\x7E\x00\xF7", 6) == 0){
            /* XG system on */
            set_system_mode(system_mode_xg);
        }else if(size == 8 && std::memcmp(data, "\xF0\x7F\x7F\x04\x01", 5) == 0 && data[7] == 0xF7){
            /* master volume */
            set_master_volume((data[5] & 0x7F) | ((data[6] & 0x7F) << 7));
        }else if(size == 8 && std::memcmp(data, "\xF0\x7F\x7F\x04\x02", 5) == 0 && data[7] == 0xF7){
            /* master balance */
            set_master_balance((data[5] & 0x7F) | ((data[6] & 0x7F) << 7));
        }else if(size == 8 && std::memcmp(data, "\xF0\x7F\x7F\x04\x03", 5) == 0 && data[7] == 0xF7){
            /* master fine tuning */
            set_master_fine_tuning((data[5] & 0x7F) | ((data[6] & 0x7F) << 7));
        }else if(size == 8 && std::memcmp(data, "\xF0\x7F\x7F\x04\x04", 5) == 0 && data[7] == 0xF7){
            /* master coarse tuning */
            set_master_coarse_tuning((data[5] & 0x7F) | ((data[6] & 0x7F) << 7));
        }else if(size == 11 && std::memcmp(data, "\xF0\x41", 2) == 0 && (data[2] & 0xF0) == 0x10 && std::memcmp(data + 3, "\x42\x12\x40", 3) == 0 && (data[6] & 0xF0) == 0x10 && data[7] == 0x15 && data[10] == 0xF7){
            /* use for rhythm part */
            int channel = data[6] & 0x0F;
            int map = data[8];
            if(map == 0){
                channels[channel]->set_bank(0x3C80);
            }else{
                channels[channel]->set_bank(0x3C00);
            }
            channels[channel]->program_change(0);
        }
    }
    // Sets and executes MIDI events.
    void synthesizer::midi_event(int event, int param1, int param2)
    {
        if(event == 0xFE)
            active_sensing = 0.33f;
        else if (event == 0xFF) {
            all_sound_off();
            reset_all_parameters();
        }else{
            switch(event & 0xF0){
            case 0x80:
                note_off(event & 0x0F, param1 & 0x7F, param2 & 0x7F);
                break;
            case 0x90:
                note_on(event & 0x0F, param1 & 0x7F, param2 & 0x7F);
                break;
            case 0xA0:
                polyphonic_key_pressure(event & 0x0F, param1 & 0x7F, param2 & 0x7F);
                break;
            case 0xB0:
                control_change(event & 0x0F, param1 & 0x7F, param2 & 0x7F);
                break;
            case 0xC0:
                program_change(event & 0x0F, param1 & 0x7F);
                break;
            case 0xD0:
                channel_pressure(event & 0x0F, param1 & 0x7F);
                break;
            case 0xE0:
                pitch_bend_change(event & 0x0F, ((param2 & 0x7F) << 7) | (param1 & 0x7F));
                break;
            default:
                break;
            }
        }
    }
    // Changes the system mode.
    void synthesizer::set_system_mode(system_mode_t mode)
    {
        all_sound_off();
        reset_all_parameters();
        system_mode = mode;
        for(int i = 0; i < NUM_CHANNELS; ++i){
            channels[i]->set_system_mode(mode);
        }
    }
    // Recalculates and updates the master frequency multiploer (tuning).
    void synthesizer::update_master_frequency_multiplier()
    {
        float value = std::pow(2, (master_coarse_tuning - 8192) / (128.0 * 100.0 * 12.0)
                                + (master_fine_tuning - 8192) / (8192.0 * 100.0 * 12.0));
        if(master_frequency_multiplier != value){
            master_frequency_multiplier = value;
            for(int i = 0; i < NUM_CHANNELS; ++i){
                channels[i]->set_master_frequency_multiplier(value);
            }
        }
    }

    // Sine table. For sine wave generators.
    namespace{
        class sine_table{
        public:
            enum{ DIVISION = 4096 };
            sine_table();
            int_least16_t get(int n)const{ return data[n]; }
        private:
            int_least16_t data[DIVISION];
        }sine_table;

        sine_table::sine_table()
        {
            for(int i = 0; i < DIVISION; ++i){
                data[i] = static_cast<int_least16_t>(32767 * std::sin(i * 2 * M_PI / DIVISION));
            }
        }
    }
    // Sine table. Sine wave generator.
    inline sine_wave_generator::sine_wave_generator():
        position(0), step(0)
    {
    }
    inline sine_wave_generator::sine_wave_generator(float cycle):
        position(0)
    {
        set_cycle(cycle);
    }
    // changes the period of the sine wave.
    void sine_wave_generator::set_cycle(float cycle)
    {
        if(cycle){
            step = static_cast<uint_least32_t>(sine_table::DIVISION * 32768.0 / cycle);
        }else{
            step = 0;
        }
    }
    // Adds modulation.
    void sine_wave_generator::add_modulation(int_least32_t x)
    {
        position += static_cast<int_least32_t>(static_cast<int_least64_t>(step) * x >> 16);
    }
    // Gets the next sample.
    inline int sine_wave_generator::get_next()
    {
        return sine_table.get((position += step) / 32768 % sine_table::DIVISION);
    }
    // Gets the next sample (with frequency modulation).
    inline int sine_wave_generator::get_next(int_least32_t modulation)
    {
        uint_least32_t m = modulation * sine_table::DIVISION / 65536;
        uint_least32_t p = ((position += step) / 32768 + m) % sine_table::DIVISION;
        return sine_table.get(p);
    }

    // Logarithmic conversion table. Use in the subsequent decay of the envelope generator.
    namespace{
        #define LOG10_32767 4.5154366811416989472479934140484
        #define LOGTABLE_SIZE 4096
        #define LOGTABLE_FACTOR (LOGTABLE_SIZE / LOG10_32767)
        class log_table{
        public:
            log_table();
            uint_least16_t get(int x)const{ return x >= LOGTABLE_SIZE ? data[LOGTABLE_SIZE - 1] : data[x]; }
        private:
            uint_least16_t data[LOGTABLE_SIZE];
        }log_table;
        log_table::log_table()
        {
            for(int i = 0; i < LOGTABLE_SIZE; ++i){
                data[i] = static_cast<uint_least16_t>(std::pow(10, static_cast<double>(i) / LOGTABLE_FACTOR));
            }
        }
    }

    // Envelope table. Calculates and processes AR, DR, SR and RR rates.
    namespace{
        struct envelope_table{
            envelope_table();
            uint_least32_t TL[128];
            uint_least32_t SL[16][128];
            double AR[64][128];
            double RR[64][128];
        }const envelope_table;

        envelope_table::envelope_table()
        {
            for(int t = 0; t < 128; ++t){
                double fTL = 32767 * std::pow(10, t * -0.75 / 10);
                TL[t] = static_cast<uint_least32_t>(fTL);
                if(TL[t] == 0){
                    TL[t] = 1;
                }
                for(int s = 0; s < 16; ++s){
                    double x = fTL * std::pow(10, s * -3.0 / 10);
                    if(x <= 1){
                        SL[s][t] = 0;
                    }else{
                        SL[s][t] = static_cast<uint_least32_t>(65536 * LOGTABLE_FACTOR * std::log10(x));
                    }
                }
            }
            for(int x = 0; x < 64; ++x){
                double attack_time = 15.3262 * std::pow(10, x * -0.75 / 10);
                double release_time = 211.84 * std::pow(10, x * -0.75 / 10);
                for(int t = 0; t < 128; ++t){
                    AR[x][t] = TL[t] / attack_time;
                    RR[x][t] = 65536 * LOGTABLE_FACTOR * 48.0 / 10 * TL[t] / 32767 / release_time;
                }
            }
        }
    }

    // Envelope generator constructor.
    envelope_generator::envelope_generator(int AR_, int DR_, int SR_, int RR_, int SL, int TL_):
        state(ATTACK), AR(AR_), DR(DR_), SR(SR_), RR(RR_), TL(TL_),
        current(0), rate(1), hold(0), freeze(0)
    {
        if(AR >= 63) AR = 63;
        if(DR >= 63) DR = 63;
        if(SR >= 63) SR = 63;
        if(RR >= 63) RR = 63;
        assert(AR >= 0);
        assert(DR >= 0);
        assert(SR >= 0);
        assert(RR >= 0);
        assert(SL >= 0 && SL <= 15);
        assert(TL >= 0 && TL <= 127);

        fTL = envelope_table.TL[TL];
        fSS = fSL = envelope_table.SL[SL][TL];
        fAR = 0;
        fDR = 0;
        fSR = 0;
        fRR = 0;
        fOR = 0;
        fDRR = 0;
        fDSS = 0;
    }
    // Set the playback rate.
    inline void envelope_generator::set_rate(float rate)
    {
        this->rate = rate ? rate : 1;
        update_parameters();
    }
    // Sets the hold (damper and sostenuto).
    void envelope_generator::set_hold(float hold)
    {
        if(this->hold > hold || state <= SASTAIN || current >= fSL){
            this->hold = hold;
            update_parameters();
        }
    }
    // Sets the freeze.
    void envelope_generator::set_freeze(float freeze)
    {
        if(this->freeze > freeze || state <= SASTAIN || current >= fSL){
            this->freeze = freeze;
            update_parameters();
        }
    }
    // Updates ADSR parameters.
    void envelope_generator::update_parameters()
    {
        double fAR = envelope_table.AR[AR][TL] / rate;
        double fDR = envelope_table.RR[DR][TL] / rate;
        double fSR = envelope_table.RR[SR][TL] / rate;
        double fRR = envelope_table.RR[RR][TL] / rate;

        if(fRR < 1){
            fRR = 1;
        }
        if(hold > 0){
            fRR = fSR * hold + fRR * (1 - hold);
        }
        if(freeze > 0){
            fDR *= (1 - freeze);
            fSR *= (1 - freeze);
            fRR *= (1 - freeze);
        }
        if(fAR < 1){
            fAR = 1;
        }
        this->fAR = static_cast<uint_least32_t>(fAR);
        this->fDR = static_cast<uint_least32_t>(fDR);
        this->fSR = static_cast<uint_least32_t>(fSR);
        this->fRR = static_cast<uint_least32_t>(fRR);
        this->fOR = static_cast<uint_least32_t>(envelope_table.RR[63][0] / rate);
        this->fSS = std::max(this->fDR, fSL);
        this->fDRR = std::max(this->fDR, this->fRR);
        this->fDSS = std::max(this->fDRR, this->fSS);
    }
    // Key-off. Gets into release step.
    void envelope_generator::key_off()
    {
        switch(state){
        case ATTACK:
            state = ATTACK_RELEASE;
            break;
        case DECAY:
            state = DECAY_RELEASE;
            break;
        case SASTAIN:
            state = RELEASE;
            break;
        default:
            break;
        }
    }
    // Sound off. Enters rapidly in mute mode.
    void envelope_generator::sound_off()
    {
        switch(state){
        case ATTACK:
        case ATTACK_RELEASE:
            if(current){
                current = static_cast<uint_least32_t>(65536 * LOGTABLE_FACTOR * std::log10(static_cast<double>(current)));
            }
            break;
        default:
            break;
        }
        state = SOUNDOFF;
    }
    // Level moving from release to sound off.
    // Because releasing a long note forever is a CPU power waste it must be cut where appropiate.
    // Attenuation is a logarithm, so infinite time is needed for the volume to become true in a zero.
    // In fact it gets muted when lesser than 1 as it is rounded to an integer actually.
    // A higher value may sound not natural but improves performance
    #define SOUNDOFF_LEVEL 1024
    // Gets the next sample.
    int envelope_generator::get_next()
    {
        uint_least32_t current = this->current;
        switch(state){
        case ATTACK:
            if(current < fTL){
                return this->current = current + fAR;
            }
            this->current = static_cast<uint_least32_t>(65536 * LOGTABLE_FACTOR * std::log10(static_cast<double>(fTL)));
            state = DECAY;
            return fTL;
        case DECAY:
            if(current > fSS){
                this->current = current -= fDR;
                return log_table.get(current / 65536);
            }
            this->current = current = fSL;
            state = SASTAIN;
            return log_table.get(current / 65536);
        case SASTAIN:
            if(current > fSR){
                this->current = current -= fSR;
                int n = log_table.get(current / 65536);
                if(n > 1){
                    return n;
                }
            }
            state = FINISHED;
            return 0;
        case ATTACK_RELEASE:
            if(current < fTL){
                return this->current = current + fAR;
            }
            this->current = static_cast<uint_least32_t>(65536 * LOGTABLE_FACTOR * std::log10(static_cast<double>(fTL)));
            state = DECAY_RELEASE;
            return fTL;
        case DECAY_RELEASE:
            if(current > fDSS){
                this->current = current -= fDRR;
                return log_table.get(current / 65536);
            }
            this->current = current = fSL;
            state = RELEASE;
            return log_table.get(current / 65536);
        case RELEASE:
            if(current > fRR){
                this->current = current -= fRR;
                int n = log_table.get(current / 65536);
                if(n > SOUNDOFF_LEVEL){
                    return n;
                }
                state = SOUNDOFF;
                return n;
            }
            state = FINISHED;
            return 0;
        case SOUNDOFF:
            if(current > fOR){
                this->current = current -= fOR;
                int n = log_table.get(current / 65536);
                if(n > 1){
                    return n;
                }
            }
            state = FINISHED;
            return 0;
        default:
            return 0;
        }
    }

    namespace{
        // Key scaling table
        const int keyscale_table[4][128] = {
            {
                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2,
                 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
            }, {
                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
                 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4,
                 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
                 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
            }, {
                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2,
                 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5,
                 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8,
                 8, 8, 8, 8, 8, 9, 9, 9,10,10,10,10,10,10,10,10,
                10,11,11,11,12,12,12,12,12,12,12,12,12,13,13,13,
                14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15
            }, {
                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                 0, 0, 0, 1, 1, 2, 2, 3, 4, 4, 4, 4, 4, 4, 4, 5,
                 5, 6, 6, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9,10,10,11,
                12,12,12,12,12,12,12,13,13,14,14,15,16,16,16,16,
                16,16,16,17,17,18,18,19,20,20,20,20,20,20,20,21,
                21,22,22,23,24,24,24,24,24,24,24,25,25,26,26,27,
                28,28,28,28,28,28,28,29,29,30,30,31,31,31,31,31,
                31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31
            }
        };
        // Detune table
        const float detune_table[4][128] = {
            { 0 },
            {
                0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
                0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
                0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
                0.053, 0.053, 0.053, 0.053, 0.053, 0.053, 0.053, 0.053,
                0.053, 0.053, 0.053, 0.053, 0.053, 0.053, 0.053, 0.053,
                0.053, 0.053, 0.053, 0.053, 0.053, 0.053, 0.053, 0.053,
                0.106, 0.106, 0.106, 0.106, 0.106, 0.106, 0.106, 0.106,
                0.106, 0.106, 0.106, 0.106, 0.106, 0.106, 0.106, 0.106,
                0.106, 0.106, 0.106, 0.159, 0.159, 0.159, 0.159, 0.159,
                0.212, 0.212, 0.212, 0.212, 0.212, 0.212, 0.212, 0.212,
                0.212, 0.212, 0.212, 0.264, 0.264, 0.264, 0.264, 0.264,
                0.264, 0.264, 0.264, 0.317, 0.317, 0.317, 0.317, 0.370,
                0.423, 0.423, 0.423, 0.423, 0.423, 0.423, 0.423, 0.423,
                0.423, 0.423, 0.423, 0.423, 0.423, 0.423, 0.423, 0.423,
                0.423, 0.423, 0.423, 0.423, 0.423, 0.423, 0.423, 0.423,
                0.423, 0.423, 0.423, 0.423, 0.423, 0.423, 0.423, 0.423
            }, {
                0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
                0.000, 0.000, 0.000, 0.000, 0.000, 0.053, 0.053, 0.053,
                0.053, 0.053, 0.053, 0.053, 0.053, 0.053, 0.053, 0.053,
                0.106, 0.106, 0.106, 0.106, 0.106, 0.106, 0.106, 0.106,
                0.106, 0.106, 0.106, 0.106, 0.106, 0.106, 0.106, 0.106,
                0.106, 0.106, 0.106, 0.106 ,0.106, 0.159, 0.159, 0.159,
                0.212, 0.212, 0.212, 0.212, 0.212, 0.212, 0.212 ,0.212,
                0.212, 0.212, 0.212, 0.264, 0.264, 0.264, 0.264, 0.264,
                0.264, 0.264, 0.264, 0.317, 0.317, 0.317, 0.317, 0.370,
                0.423, 0.423, 0.423, 0.423, 0.423, 0.423, 0.423, 0.423,
                0.423, 0.476, 0.476, 0.529, 0.582, 0.582, 0.582, 0.582,
                0.582, 0.582 ,0.582, 0.635, 0.635, 0.688, 0.688, 0.741,
                0.846, 0.846, 0.846, 0.846, 0.846, 0.846, 0.846 ,0.846,
                0.846, 0.846, 0.846, 0.846, 0.846, 0.846, 0.846, 0.846,
                0.846, 0.846, 0.846, 0.846, 0.846, 0.846, 0.846, 0.846
            }, {
                0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
                0.000, 0.000, 0.000, 0.000, 0.000, 0.106, 0.106, 0.106,
                0.106, 0.106, 0.106, 0.106, 0.106, 0.106, 0.106, 0.106,
                0.106, 0.106, 0.106, 0.106, 0.106, 0.106, 0.106, 0.159,
                0.159, 0.159, 0.159, 0.159, 0.212, 0.212, 0.212, 0.212,
                0.212, 0.212, 0.212, 0.212, 0.212, 0.212, 0.212, 0.264,
                0.264, 0.264, 0.264, 0.264, 0.264, 0.264, 0.264, 0.317,
                0.317, 0.317, 0.317, 0.370, 0.423, 0.423, 0.423, 0.423,
                0.423, 0.423, 0.423, 0.423, 0.423, 0.476, 0.476, 0.529,
                0.582, 0.582, 0.582, 0.582, 0.582, 0.582, 0.582, 0.635,
                0.635, 0.688, 0.688, 0.741, 0.846, 0.846, 0.846, 0.846,
                0.846, 0.846, 0.846, 0.899, 0.899, 1.005, 1.005, 1.058,
                1.164, 1.164, 1.164, 1.164, 1.164, 1.164, 1.164, 1.164,
                1.164, 1.164, 1.164, 1.164, 1.164, 1.164, 1.164, 1.164,
                1.164, 1.164, 1.164, 1.164, 1.164, 1.164, 1.164, 1.164,
                1.164, 1.164, 1.164, 1.164, 1.164, 1.164, 1.164, 1.164
            }
        };
        // LFO table
        const uint_least32_t ams_table[4] = {
            0,
            static_cast<uint_least32_t>(128 - 128 * std::pow(10, -1.44 / 10)),
            static_cast<uint_least32_t>(128 - 128 * std::pow(10, -5.9 / 10)),
            static_cast<uint_least32_t>(128 - 128 * std::pow(10, -11.8 / 10))
        };
    }

    // FM operator constructor.
    fm_operator::fm_operator(int AR, int DR, int SR, int RR, int SL, int TL, int KS, int ML_, int DT_, int AMS_, int key):
        eg(AR * 2 + keyscale_table[KS][key],
           DR * 2 + keyscale_table[KS][key],
           SR * 2 + keyscale_table[KS][key],
           RR * 4 + keyscale_table[KS][key] + 2,
           SL,
           TL)
    {
        assert(AR >= 0 && AR <= 31);
        assert(DR >= 0 && DR <= 31);
        assert(SR >= 0 && SR <= 31);
        assert(RR >= 0 && RR <= 15);
        assert(SL >= 0);
        assert(TL >= 0);
        assert(KS >= 0 && KS <= 3);
        assert(ML_ >= 0 && ML_ <= 15);
        assert(DT_ >= 0 && DT_ <= 7);
        assert(AMS_ >= 0 && AMS_ <= 3);
        assert(key >= 0 && key <= 127);

        if(DT_ >= 4){
            DT = -detune_table[DT_ - 4][key];
        }else{
            DT = detune_table[DT_][key];
        }
        if(ML_ == 0){
            ML = 0.5;
        }else{
            ML = ML_;
        }

        ams_factor = ams_table[AMS_] / 2;
        ams_bias = 32768 - ams_factor * 256;
    }
    // Sets playback frequency rate.
    void fm_operator::set_freq_rate(float freq, float rate)
    {
        freq += DT;
        freq *= ML;
        swg.set_cycle(rate / freq);
        eg.set_rate(rate);
    }
    // Gets the next sample.
    inline int fm_operator::get_next()
    {
        return static_cast<int_least32_t>(swg.get_next()) * eg.get_next() >> 15;
    }
    inline int fm_operator::get_next(int modulate)
    {
        return static_cast<int_least32_t>(swg.get_next(modulate)) * eg.get_next() >> 15;
    }
    inline int fm_operator::get_next(int ams, int modulate)
    {
        return (static_cast<int_least32_t>(swg.get_next(modulate)) * eg.get_next() >> 15) * (ams * ams_factor + ams_bias) >> 15;
    }

    // Vibrato table.
    namespace{
        class vibrato_table{
        public:
            enum{ DIVISION = 16384 };
            vibrato_table();
            int_least32_t get(int x)const{ return data[x + DIVISION / 2]; }
        private:
            int_least32_t data[DIVISION];
        }vibrato_table;

        vibrato_table::vibrato_table()
        {
            for(int i = 0; i < DIVISION; ++i){
                double x = (static_cast<double>(i) / DIVISION - 0.5) * 256.0 / 12.0;
                data[i] = static_cast<int_least32_t>((std::pow(2, x) - 1) * 65536.0);
            }
        }
    }

    // FM sound generator constructor.
    fm_sound_generator::fm_sound_generator(const FMPARAMETER& params, int note, float frequency_multiplier):
        op1(params.op1.AR, params.op1.DR, params.op1.SR, params.op1.RR, params.op1.SL, params.op1.TL, params.op1.KS, params.op1.ML, params.op1.DT, params.op1.AMS, note),
        op2(params.op2.AR, params.op2.DR, params.op2.SR, params.op2.RR, params.op2.SL, params.op2.TL, params.op2.KS, params.op2.ML, params.op2.DT, params.op2.AMS, note),
        op3(params.op3.AR, params.op3.DR, params.op3.SR, params.op3.RR, params.op3.SL, params.op3.TL, params.op3.KS, params.op3.ML, params.op3.DT, params.op3.AMS, note),
        op4(params.op4.AR, params.op4.DR, params.op4.SR, params.op4.RR, params.op4.SL, params.op4.TL, params.op4.KS, params.op4.ML, params.op4.DT, params.op4.AMS, note),
        ALG(params.ALG),
        freq(440 * std::pow(2.0, (note - 69) / 12.0)),
        freq_mul(frequency_multiplier),
        tremolo_depth(0),
        tremolo_freq(1),
        vibrato_depth(0),
        vibrato_freq(1),
        rate(0),
        feedback(0),
        damper(0),
        sostenute(0)
    {
        assert(ALG >= 0 && ALG <= 7);
        assert(params.LFO >= 0 && params.LFO <= 7);
        assert(params.FB >= 0 && params.FB <= 7);

        static const int feedbacks[8] = {
            31, 6, 5, 4, 3, 2, 1, 0
        };
        FB = feedbacks[params.FB];

        static const float ams_table[8] = {
            3.98, 5.56, 6.02, 6.37, 6.88, 9.63, 48.1, 72.2
        };
        ams_freq = ams_table[params.LFO];
        ams_enable = (params.op1.AMS + params.op2.AMS + params.op3.AMS + params.op4.AMS != 0);
    }
    // Sets playback rate.
    void fm_sound_generator::set_rate(float rate)
    {
        if(this->rate != rate){
            this->rate = rate;
            ams_lfo.set_cycle(rate / ams_freq);
            vibrato_lfo.set_cycle(rate / vibrato_freq);
            tremolo_lfo.set_cycle(rate / tremolo_freq);
            float f = freq * freq_mul;
            op1.set_freq_rate(f, rate);
            op2.set_freq_rate(f, rate);
            op3.set_freq_rate(f, rate);
            op4.set_freq_rate(f, rate);
        }
    }
    // Sets frequency multiplier.
    void fm_sound_generator::set_frequency_multiplier(float value)
    {
        freq_mul = value;
        float f = freq * freq_mul;
        op1.set_freq_rate(f, rate);
        op2.set_freq_rate(f, rate);
        op3.set_freq_rate(f, rate);
        op4.set_freq_rate(f, rate);
    }
    // Sets damper effect.
    void fm_sound_generator::set_damper(int damper)
    {
        this->damper = damper;
        float value = 1.0 - (1.0 - damper / 127.0) * (1.0 - sostenute / 127.0);
        op1.set_hold(value);
        op2.set_hold(value);
        op3.set_hold(value);
        op4.set_hold(value);
    }
    // Sets sostenuto effect.
    void fm_sound_generator::set_sostenute(int sostenute)
    {
        this->sostenute = sostenute;
        float value = 1.0 - (1.0 - damper / 127.0) * (1.0 - sostenute / 127.0);
        op1.set_hold(value);
        op2.set_hold(value);
        op3.set_hold(value);
        op4.set_hold(value);
    }
    // Sets freeze efect.
    void fm_sound_generator::set_freeze(int freeze)
    {
        float value = freeze / 127.0;
        op1.set_freeze(value);
        op2.set_freeze(value);
        op3.set_freeze(value);
        op4.set_freeze(value);
    }
    // Sets tremolo effect.
    void fm_sound_generator::set_tremolo(int depth, float frequency)
    {
        tremolo_depth = depth;
        tremolo_freq = frequency;
        tremolo_lfo.set_cycle(rate / frequency);
    }
    // Sets vibrato effect.
    void fm_sound_generator::set_vibrato(float depth, float frequency)
    {
        vibrato_depth = static_cast<int>(depth * (vibrato_table::DIVISION / 256.0));
        vibrato_freq = frequency;
        vibrato_lfo.set_cycle(rate / frequency);
    }
    // Key-off.
    void fm_sound_generator::key_off()
    {
        op1.key_off();
        op2.key_off();
        op3.key_off();
        op4.key_off();
    }
    // Sound off.
    void fm_sound_generator::sound_off()
    {
        op1.sound_off();
        op2.sound_off();
        op3.sound_off();
        op4.sound_off();
    }
    // Returns whether or not the sound generation has been completed.
    bool fm_sound_generator::is_finished()const
    {
        switch(ALG){
        case 0:
        case 1:
        case 2:
        case 3:
            return op4.is_finished();
        case 4:
            return op2.is_finished() && op4.is_finished();
        case 5:
        case 6:
            return op2.is_finished() && op3.is_finished() && op4.is_finished();
        case 7:
            return op1.is_finished() && op2.is_finished() && op3.is_finished() && op4.is_finished();
        default:
            assert(!"fm_sound_generator: invalid algorithm number");
            return true;
        }
    }
    // Gets the next sample.
    int fm_sound_generator::get_next()
    {
        if(vibrato_depth){
            int x = static_cast<int_least32_t>(vibrato_lfo.get_next()) * vibrato_depth >> 15;
            int_least32_t modulation = vibrato_table.get(x);
            op1.add_modulation(modulation);
            op2.add_modulation(modulation);
            op3.add_modulation(modulation);
            op4.add_modulation(modulation);
        }
        int feedback = (this->feedback << 1) >> FB;
        int ret;
        if(ams_enable){
            int ams = ams_lfo.get_next() >> 7;
            switch(ALG){
            case 0:
                ret = op4(ams, op3(ams, op2(ams, this->feedback = op1(ams, feedback))));
                break;
            case 1:
                ret = op4(ams, op3(ams, op2(ams, 0) + (this->feedback = op1(ams, feedback))));
                break;
            case 2:
                ret = op4(ams, op3(ams, op2(ams, 0)) + (this->feedback = op1(ams, feedback)));
                break;
            case 3:
                ret = op4(ams, op3(ams, 0) + op2(ams, this->feedback = op1(ams, feedback)));
                break;
            case 4:
                ret = op4(ams, op3(ams, 0)) + op2(ams, this->feedback = op1(ams, feedback));
                break;
            case 5:
                this->feedback = feedback = op1(ams, feedback);
                ret = op4(ams, feedback) + op3(ams, feedback) + op2(ams, feedback);
                break;
            case 6:
                ret = op4(ams, 0) + op3(ams, 0) + op2(ams, this->feedback = op1(ams, feedback));
                break;
            case 7:
                ret = op4(ams, 0) + op3(ams, 0) + op2(ams, 0) + (this->feedback = op1(ams, feedback));
                break;
            default:
                assert(!"fm_sound_generator: invalid algorithm number");
                return 0;
            }
        }else{
            switch(ALG){
            case 0:
                ret = op4(op3(op2(this->feedback = op1(feedback))));
                break;
            case 1:
                ret = op4(op3(op2() + (this->feedback = op1(feedback))));
                break;
            case 2:
                ret = op4(op3(op2()) + (this->feedback = op1(feedback)));
                break;
            case 3:
                ret = op4(op3() + op2(this->feedback = op1(feedback)));
                break;
            case 4:
                ret = op4(op3()) + op2(this->feedback = op1(feedback));
                break;
            case 5:
                this->feedback = feedback = op1(feedback);
                ret = op4(feedback) + op3(feedback) + op2(feedback);
                break;
            case 6:
                ret = op4() + op3() + op2(this->feedback = op1(feedback));
                break;
            case 7:
                ret = op4() + op3() + op2() + (this->feedback = op1(feedback));
                break;
            default:
                assert(!"fm_sound_generator: invalid algorithm number");
                return 0;
            }
        }
        if(tremolo_depth){
            int_least32_t x = 4096 - (((static_cast<int_least32_t>(tremolo_lfo.get_next()) + 32768) * tremolo_depth) >> 11);
            ret = ret * x >> 12;
        }
        return ret;
    }

    // FM notes constructor.
    fm_note::fm_note(const FMPARAMETER& params, int note, int velocity_, int panpot, int assign, float frequency_multiplier):
        midisynth::note(assign, panpot),
        fm(params, note, frequency_multiplier),
        velocity(velocity_)
    {
        assert(velocity >= 1 && velocity <= 127);
        ++velocity;
    }
    // Waveform output.
    bool fm_note::synthesize(int_least32_t* buf, std::size_t samples, float rate, int_least32_t left, int_least32_t right)
    {
        left = (left * velocity) >> 7;
        right = (right * velocity) >> 7;
        fm.set_rate(rate);
        for(std::size_t i = 0; i < samples; ++i){
            int_least32_t sample = fm.get_next();
            buf[i * 2 + 0] += (sample * left) >> 14;
            buf[i * 2 + 1] += (sample * right) >> 14;
        }
        return !fm.is_finished();
    }
    // Note off.
    void fm_note::note_off(int)
    {
        fm.key_off();
    }
    // Sound off.
    void fm_note::sound_off()
    {
        fm.sound_off();
    }
    // Sets frequency multiplier.
    void fm_note::set_frequency_multiplier(float value)
    {
        fm.set_frequency_multiplier(value);
    }
    // Sets tremolo effect.
    void fm_note::set_tremolo(int depth, float freq)
    {
        fm.set_tremolo(depth, freq);
    }
    // Sets vibrato effect.
    void fm_note::set_vibrato(float depth, float freq)
    {
        fm.set_vibrato(depth, freq);
    }
    // Sets damper effect.
    void fm_note::set_damper(int value)
    {
        fm.set_damper(value);
    }
    // Sets sostenuto effect.
    void fm_note::set_sostenute(int value)
    {
        fm.set_sostenute(value);
    }
    // Sets freeze effect.
    void fm_note::set_freeze(int value)
    {
        fm.set_freeze(value);
    }

    // FM note factory initialization.
    fm_note_factory::fm_note_factory()
    {
        clear();
    }
    // Clear.
    void fm_note_factory::clear()
    {
        // Default tone (sine wave)
        static const struct FMPARAMETER param = {
            7, 0, 0,    // ALG FB LFO
            //AR DR SR RR SL  TL KS ML DT AMS
            { 31, 0, 0,15, 0,  0, 0, 0, 0, 0 },
            {  0, 0, 0,15, 0,127, 0, 0, 0, 0 },
            {  0, 0, 0,15, 0,127, 0, 0, 0, 0 },
            {  0, 0, 0,15, 0,127, 0, 0, 0, 0 }
        };
        drums.clear();
        programs.clear();
        programs[-1] = param;
    }
    // Sound parameters validation check
    namespace{
        bool is_valid_fmparameter(const FMPARAMETER& p)
        {
            return p.ALG >= 0 && p.ALG <= 7
                && p.FB >= 0 && p.FB <= 7
                && p.LFO >= 0 && p.LFO <= 7
                && p.op1.AR >= 0 && p.op1.AR <= 31
                && p.op1.DR >= 0 && p.op1.DR <= 31
                && p.op1.SR >= 0 && p.op1.SR <= 31
                && p.op1.RR >= 0 && p.op1.RR <= 15
                && p.op1.SL >= 0 && p.op1.SL <= 15
                && p.op1.TL >= 0 && p.op1.TL <= 127
                && p.op1.KS >= 0 && p.op1.KS <= 3
                && p.op1.ML >= 0 && p.op1.ML <= 15
                && p.op1.DT >= 0 && p.op1.DT <= 7
                && p.op1.AMS >= 0 && p.op1.AMS <= 3
                && p.op2.AR >= 0 && p.op2.AR <= 31
                && p.op2.DR >= 0 && p.op2.DR <= 31
                && p.op2.SR >= 0 && p.op2.SR <= 31
                && p.op2.RR >= 0 && p.op2.RR <= 15
                && p.op2.SL >= 0 && p.op2.SL <= 15
                && p.op2.TL >= 0 && p.op2.TL <= 127
                && p.op2.KS >= 0 && p.op2.KS <= 3
                && p.op2.ML >= 0 && p.op2.ML <= 15
                && p.op2.DT >= 0 && p.op2.DT <= 7
                && p.op2.AMS >= 0 && p.op2.AMS <= 3
                && p.op3.AR >= 0 && p.op3.AR <= 31
                && p.op3.DR >= 0 && p.op3.DR <= 31
                && p.op3.SR >= 0 && p.op3.SR <= 31
                && p.op3.RR >= 0 && p.op3.RR <= 15
                && p.op3.SL >= 0 && p.op3.SL <= 15
                && p.op3.TL >= 0 && p.op3.TL <= 127
                && p.op3.KS >= 0 && p.op3.KS <= 3
                && p.op3.ML >= 0 && p.op3.ML <= 15
                && p.op3.DT >= 0 && p.op3.DT <= 7
                && p.op3.AMS >= 0 && p.op3.AMS <= 3
                && p.op4.AR >= 0 && p.op4.AR <= 31
                && p.op4.DR >= 0 && p.op4.DR <= 31
                && p.op4.SR >= 0 && p.op4.SR <= 31
                && p.op4.RR >= 0 && p.op4.RR <= 15
                && p.op4.SL >= 0 && p.op4.SL <= 15
                && p.op4.TL >= 0 && p.op4.TL <= 127
                && p.op4.KS >= 0 && p.op4.KS <= 3
                && p.op4.ML >= 0 && p.op4.ML <= 15
                && p.op4.DT >= 0 && p.op4.DT <= 7
                && p.op4.AMS >= 0 && p.op4.AMS <= 3;
        }
        bool is_valid_drumparameter(const DRUMPARAMETER& p)
        {
            return is_valid_fmparameter(p)
                && p.key >= 0 && p.key <= 127
                && p.panpot >= 0 && p.panpot <= 16383;
        }
    }
    // Gets program parameters.
    void fm_note_factory::get_program(int program, FMPARAMETER& p)
    {
        if(programs.find(program) != programs.end()){
            p = programs[program];
        }else if(programs.find(program & 0x3FFF) != programs.end()){
            p = programs[program & 0x3FFF];
        }else if(programs.find(program & 0x7F) != programs.end()){
            p = programs[program & 0x7F];
        }else{
            p = programs[-1];
        }
    }
    // Sets program parameter.
    bool fm_note_factory::set_program(int number, const FMPARAMETER& p)
    {
        if(is_valid_fmparameter(p)){
            programs[number] = p;
            return true;
        }else{
            return false;
        }
    }
    // Sets drum program parameter.
    bool fm_note_factory::set_drum_program(int number, const DRUMPARAMETER& p)
    {
        if(is_valid_drumparameter(p)){
            drums[number] = p;
            return true;
        }else{
            return false;
        }
    }
    // Note on.
    note* fm_note_factory::note_on(int_least32_t program, int note, int velocity, float frequency_multiplier)
    {
        bool drum = (program >> 14) == 120;
        if(drum){
            int n = (program & 0x3FFF) * 128 + note;
            struct DRUMPARAMETER* p;
            if(drums.find(n) != drums.end()){
                p = &drums[n];
            }else if(drums.find(n & 0x3FFF) != drums.end()){
                p = &drums[n & 0x3FFF];
            }else if(drums.find(note) != drums.end()){
                p = &drums[note];
            }else if(drums.find(-1) != drums.end()){
                p = &drums[-1];
            }else{
                return NULL;
            }
            return new fm_note(*p, p->key, velocity, p->panpot, p->assign, 1);
        }else{
            struct FMPARAMETER* p;
            if(programs.find(program) != programs.end()){
                p = &programs[program];
            }else if(programs.find(program & 0x7F) != programs.end()){
                p = &programs[program & 0x7F];
            }else{
                p = &programs[-1];
            }
            return new fm_note(*p, note, velocity, 8192, 0, frequency_multiplier);
        }
    }
}

#endif


/*end of file .\midisynth.cpp*/

/*start of file .\output.cpp*/

/* ... license chunk ... */

// Headers
#include <cstdlib>
#include <cstdarg>
#include <ctime>
#include <cstdio>
#include <iostream>
#include <fstream>
#include <thread>
#include <chrono>
#include <fmt/color.h>
#include <fmt/ostream.h>
#ifdef EMSCRIPTEN
#  include "platform/emscripten/interface.h"
#endif

#include "output.h"
#include "graphics.h"
#include "filefinder.h"
#include "input.h"
#include "options.h"
#include "player.h"
#include "bitmap.h"
#include "message_overlay.h"
#include "font.h"
#include "baseui.h"

// fmt 7 has renamed the namespace
#if FMT_VERSION < 70000
#  define FMT_COLOR_TYPE fmt::internal::color_type
#else
#  define FMT_COLOR_TYPE fmt::detail::color_type
#endif

using namespace std::chrono_literals;

namespace {
	constexpr const char* const log_prefix[] = {
		"Error", "Warning", "Info", "Debug"
	};
	LogLevel log_level = LogLevel::Debug;

	std::ostream& output_time() {
		std::time_t t = std::time(nullptr);
		return Game_Config::GetLogFileOutput() << Utils::FormatDate(std::localtime(&t), "[%Y-%m-%d %H:%M:%S] ");
	}

	bool ignore_pause = false;
	bool colored_log = true;

	// pair of repeat count + message
	struct {
		int repeat = 0;
		std::string msg;
		LogLevel lvl = {};
	} last_message;

	void LogCallback(LogLevel lvl, std::string const& msg, LogCallbackUserData /* userdata */) {
		// terminal output
		std::string prefix = Output::LogLevelToString(lvl) + ":";

		// only support colors with a "recent" fmt 6
	#if FMT_VERSION >= 60000
		if (colored_log) {
			FMT_COLOR_TYPE log_color =
				(lvl == LogLevel::Error) ? fmt::terminal_color::red :
				(lvl == LogLevel::Warning) ? fmt::terminal_color::yellow :
				(lvl == LogLevel::Debug) ? fmt::terminal_color::white :
				fmt::terminal_color::bright_white;

	#  if FMT_VERSION < 90000
			// format using temporary strings
			fmt::print(std::cerr, "{} {}\n",
				fmt::format(fmt::fg(log_color) | fmt::emphasis::bold, prefix),
				fmt::format(fmt::fg(log_color), msg));
	#  else
			// fmt 9 has styled arguments
			fmt::print(std::cerr, "{} {}\n",
				fmt::styled(prefix, fmt::fg(log_color) | fmt::emphasis::bold),
				fmt::styled(msg, fmt::fg(log_color)));
	#  endif
			return;
		}
	#endif
		std::cerr << prefix << " " << msg << std::endl;
	}

	LogCallbackFn log_cb = LogCallback;
	LogCallbackUserData log_cb_udata = nullptr;
}

std::string Output::LogLevelToString(LogLevel lvl) {
	return log_prefix[static_cast<int>(lvl)];
}

LogLevel Output::GetLogLevel() {
	return log_level;
}

void Output::SetLogLevel(LogLevel lvl) {
	log_level = lvl;
}

void Output::SetTermColor(bool colored) {
	colored_log = colored;
}

void Output::IgnorePause(bool const val) {
	ignore_pause = val;
}

void Output::SetLogCallback(LogCallbackFn fn, LogCallbackUserData userdata) {
	if (!fn) {
		log_cb = LogCallback;
		log_cb_udata = nullptr;
	} else {
		log_cb = fn;
		log_cb_udata = userdata;
	}
}

static void WriteLog(LogLevel lvl, std::string const& msg, Color const& c = Color()) {
// skip writing log file
#ifndef EMSCRIPTEN
	std::string prefix = Output::LogLevelToString(lvl) + ": ";

	// Every new message is written once to the file.
	// When it is repeated increment a counter until a different message appears,
	// then write the buffered message with the counter.
	if (msg == last_message.msg) {
		last_message.repeat++;
	} else {
		if (last_message.repeat > 0) {
			output_time() << Output::LogLevelToString(last_message.lvl) << ": " << last_message.msg << " [" << last_message.repeat + 1 << "x]" << std::endl;
		}
		output_time() << prefix << msg << '\n';

		last_message.repeat = 0;
		last_message.msg = msg;
		last_message.lvl = lvl;
	}
#endif

	// output to custom logger or terminal
	log_cb(lvl, msg, log_cb_udata);

	// output to overlay
	if (lvl != LogLevel::Debug && lvl != LogLevel::Error) {
		Graphics::GetMessageOverlay().AddMessage(msg, c);
	}
}

static void HandleErrorOutput(const std::string& err) {
	// Drawing directly on the screen because message_overlay is not visible
	// when faded out
	BitmapRef surface = DisplayUi->GetDisplaySurface();
	surface->FillRect(surface->GetRect(), Color(255, 0, 0, 128));

	std::string error = err + "\nPress [ENTER] key to exit...";

	Text::Draw(*surface, 11, 11, *Font::DefaultBitmapFont(), Color(0, 0, 0, 255), error);
	Text::Draw(*surface, 10, 10, *Font::DefaultBitmapFont(), Color(255, 255, 255, 255), error);
	DisplayUi->UpdateDisplay();

	if (ignore_pause) { return; }

	Input::ResetKeys();
	while (!Input::IsAnyPressed()) {
#if !defined(USE_LIBRETRO)
		Game_Clock::SleepFor(1ms);
#endif
		if (!DisplayUi->ProcessEvents() || Player::exit_flag) {
			break;
		}

		Input::Update();
	}
}

void Output::Quit() {
	Game_Config::CloseLogFile();
}

bool Output::TakeScreenshot(bool is_auto_screenshot) {
#ifdef EMSCRIPTEN
	Emscripten_Interface::TakeScreenshot(is_auto_screenshot);
	return true;
#else
	auto fs = FileFinder::Save();
	auto p = GetNextScreenshotFileName(fs, is_auto_screenshot);
	return TakeScreenshot(p);
#endif
}

bool Output::TakeScreenshot(std::string_view file) {
	auto ret = FileFinder::Save().OpenOutputStream(file, std::ios_base::binary | std::ios_base::out | std::ios_base::trunc);

	if (ret) {
		Output::Debug("Saving Screenshot {}", file);
		return Output::TakeScreenshot(ret);
	}
	return false;
}

bool Output::TakeScreenshot(std::ostream& os) {
	int scale = Player::player_config.screenshot_scale.Get();
	if (scale > 1) {
		auto& disp = DisplayUi->GetDisplaySurface();
		auto scaled_disp = Bitmap::Create(disp->GetWidth() * scale, disp->GetHeight() * scale, false);
		scaled_disp->ZoomOpacityBlit(0, 0, 0, 0, *disp, disp->GetRect(), scale, scale, Opacity::Opaque());
		return scaled_disp->WritePNG(os);
	} else {
		return DisplayUi->GetDisplaySurface()->WritePNG(os);
	}
}

std::string Output::GetScreenshotName(bool is_auto_screenshot) {
	std::string prefix = is_auto_screenshot ? "auto" : "screenshot";

	if (Player::player_config.screenshot_timestamp.Get()) {
		std::time_t t = std::time(nullptr);
		std::tm* tm = std::localtime(&t);
		prefix += "_" + Utils::FormatDate(tm, Utils::DateFormat_YYYYMMDD_HHMMSS);
	}

	return prefix;
}

std::string Output::GetNextScreenshotFileName(FilesystemView fs, bool is_auto_screenshot) {
	std::string output_path;
	int index = 0;
	std::string name = GetScreenshotName(is_auto_screenshot);

	if (Player::player_config.screenshot_timestamp.Get()) {
		output_path = name + ".png";
		if (!fs.Exists(output_path)) {
			return output_path;
		}
		index++;
	}
	name += "_";

	do {
		output_path = name + std::to_string(index++) + ".png";
	} while (fs.Exists(output_path));
	return output_path;
}

void Output::ToggleLog() {
	static bool show_log = true;
	Graphics::GetMessageOverlay().SetShowAll(show_log);
	show_log = !show_log;
}

void Output::ErrorStr(std::string const& err) {
	WriteLog(LogLevel::Error, err);
	std::string error = "Error:\n" + err + "\n\nEasyRPG Player will close now.";

	static bool recursive_call = false;
	if (!recursive_call && DisplayUi) {
		recursive_call = true;
		// Try platform handler first, then global one
		if (!DisplayUi->HandleErrorOutput(error)) {
			HandleErrorOutput(error);
		}
		DisplayUi.reset();
	} else {
		// Fallback to Console if the display is not ready yet
		std::cout << error << std::endl;
#if defined (PLAYER_NINTENDO) || defined(__vita__)
		// stdin is non-blocking
		Game_Clock::SleepFor(5s);
#elif defined (EMSCRIPTEN)
		// Don't show JavaScript Window.prompt from stdin call
		std::cout << " Process finished.";
#else
		std::cout << " Press any key..." << std::endl;
		std::cin.get();
#endif
	}

	Player::exit_code = EXIT_FAILURE;

	// FIXME: No idea how to indicate error from core in libretro
	exit(Player::exit_code);
}

void Output::WarningStr(std::string const& warn) {
	if (log_level < LogLevel::Warning) {
		return;
	}
	WriteLog(LogLevel::Warning, warn, Color(255, 255, 0, 255));
}

void Output::InfoStr(std::string const& msg) {
	if (log_level < LogLevel::Info) {
		return;
	}
	WriteLog(LogLevel::Info, msg, Color(255, 255, 255, 255));
}

void Output::DebugStr(std::string const& msg) {
	if (log_level < LogLevel::Debug) {
		return;
	}
	WriteLog(LogLevel::Debug, msg, Color(128, 128, 128, 255));
}


/*end of file .\output.cpp*/

/*start of file .\pending_message.cpp*/

/* ... license chunk ... */

#include "pending_message.h"
#include "game_variables.h"
#include "game_strings.h"
#include "game_actors.h"
#include "game_message.h"
#include "game_switches.h"
#include <lcf/data.h>
#include "output.h"
#include "utils.h"
#include "player.h"
#include "main_data.h"
#include <cassert>
#include <cctype>
#include <algorithm>
#include <utility>

static void RemoveControlChars(std::string& s) {
	// RPG_RT ignores any control characters within messages.
	auto iter = std::remove_if(s.begin(), s.end(), [](const char c) { return Utils::IsControlCharacter(c); });
	s.erase(iter, s.end());
}

PendingMessage::PendingMessage(PendingMessage::CommandInserter cmd_fn) :
	command_inserter(std::move(cmd_fn)) {
	// no-op
};

int PendingMessage::PushLineImpl(std::string msg) {
	RemoveControlChars(msg);
	msg = ApplyTextInsertingCommands(std::move(msg), Player::escape_char, command_inserter);
	texts.push_back(std::move(msg));
	return texts.size();
}

int PendingMessage::PushLine(std::string msg) {
	assert(!HasChoices());
	assert(!HasNumberInput());
	return PushLineImpl(std::move(msg));
}

int PendingMessage::PushChoice(std::string msg, bool enabled) {
	assert(!HasNumberInput());
	if (!HasChoices()) {
		choice_start = NumLines();
	}
	choice_enabled[GetNumChoices()] = enabled;
	return PushLineImpl(std::move(msg));
}

int PendingMessage::PushNumInput(int variable_id, int num_digits) {
	assert(!HasChoices());
	assert(!HasNumberInput());
	num_input_variable = variable_id;
	num_input_digits = num_digits;
	return NumLines();
}

void PendingMessage::PushPageEnd() {
	assert(!HasChoices());
	assert(!HasNumberInput());
	if (texts.empty()) {
		texts.push_back("");
	}
	texts.back().push_back('\f');
}

void PendingMessage::SetWordWrapped(bool value) {
	assert(texts.empty());
	word_wrapped = value;
}

void PendingMessage::SetChoiceCancelType(int value) {
	choice_cancel_type = value;
}

void PendingMessage::SetChoiceResetColors(bool value) {
	choice_reset_color = value;
}

std::string PendingMessage::ApplyTextInsertingCommands(std::string input, uint32_t escape_char, const CommandInserter& cmd_fn) {
	if (input.empty()) {
		return input;
	}

	std::string output;

	const char* iter = input.data();
	const auto end = input.data() + input.size();

	const char* start_copy = iter;
	while (iter != end) {
		auto ret = Utils::UTF8Next(iter, end);
		if (ret.ch != escape_char) {
			iter = ret.next;
			continue;
		}

		// utf8 parsing failed
		if (ret.ch == 0) {
			break;
		}

		output.append(start_copy, iter - start_copy);
		start_copy = iter;

		iter = ret.next;
		if (iter == end) {
			break;
		}

		const auto ch = *iter;
		++iter;

		auto fn_res = cmd_fn(ch, &iter, end, escape_char);
		if (fn_res) {
			output.append(*fn_res);
			start_copy = iter;
		} 
	}

	if (start_copy == input.data()) {
		// Fast path - no substitutions occured, so just move the input into the return value.
		output = std::move(input);
	} else {
		output.append(start_copy, end - start_copy);
	}

	return output;
}

std::optional<std::string> PendingMessage::DefaultCommandInserter(char ch, const char** iter, const char* end, uint32_t escape_char) {
	if (ch == 'N' || ch == 'n') {
		auto parse_ret = Game_Message::ParseActor(*iter, end, escape_char, true);
		*iter = parse_ret.next;
		int value = parse_ret.value;

		const auto* actor = Main_Data::game_actors->GetActor(value);
		if (!actor) {
			Output::Warning("Invalid Actor Id {} in message text", value);
			return "";
		} else {
			return ToString(actor->GetName());
		}
	} else if (ch == 'V' || ch == 'v') {
		auto parse_ret = Game_Message::ParseVariable(*iter, end, escape_char, true);
		*iter = parse_ret.next;
		int value = parse_ret.value;

		int variable_value = Main_Data::game_variables->Get(value);
		return std::to_string(variable_value);
	}

	return std::nullopt;
}


/*end of file .\pending_message.cpp*/

/*start of file .\plane.cpp*/

/* ... license chunk ... */

// Headers
#include "plane.h"
#include "player.h"
#include "bitmap.h"
#include "main_data.h"
#include "game_map.h"
#include "drawable_mgr.h"
#include "game_screen.h"

Plane::Plane() : Drawable(0)
{
	DrawableMgr::Register(this);
}

void Plane::Draw(Bitmap& dst) {
	if (!bitmap) return;

	if (needs_refresh) {
		needs_refresh = false;

		if (!tone_bitmap ||
			bitmap->GetWidth() != tone_bitmap->GetWidth() ||
			bitmap->GetHeight() != tone_bitmap->GetHeight()) {
			tone_bitmap = Bitmap::Create(bitmap->GetWidth(), bitmap->GetHeight());
		}
		tone_bitmap->Clear();
		tone_bitmap->ToneBlit(0, 0, *bitmap, bitmap->GetRect(), tone_effect, Opacity::Opaque());
	}

	BitmapRef source = tone_effect == Tone() ? bitmap : tone_bitmap;

	Rect dst_rect = dst.GetRect();
	int src_x = -ox - GetRenderOx();
	int src_y = -oy - GetRenderOy();

	// Apply screen shaking
	const int shake_x = Main_Data::game_screen->GetShakeOffsetX();
	const int shake_y = Main_Data::game_screen->GetShakeOffsetY();
	if (Game_Map::LoopHorizontal()) {
		src_x += shake_x;
	} else {
		// The panorama occupies the same rectangle as the whole map.
		// Using coordinates where the top-left of the screen is the origin...
		// Minimal width is a 20 tile wide map by default, smaller maps are hacked
		int bg_x = -Game_Map::GetDisplayX() / TILE_SIZE + shake_x;
		int bg_width = std::max(Game_Map::GetTilesX() * TILE_SIZE, Player::screen_width);

		// Clip the panorama to the screen
		if (bg_x < 0) {
			bg_width += bg_x;
			bg_x = 0;
		}
		if (dst_rect.width < bg_x + bg_width) {
			bg_width = dst_rect.width - bg_x;
		}

		bool off_screen =
			bg_x >= dst_rect.width ||
			bg_x + bg_width <= 0;
		if (off_screen) {
			// This probably won't happen...
			return;
		}

		dst_rect.x = bg_x;
		dst_rect.width = bg_width;

		// Correct the offset if the top-left corner moved.
		src_x += shake_x + bg_x;
	}
	src_y += shake_y;

	dst.TiledBlit(src_x, src_y, source->GetRect(), *source, dst_rect, 255);
}



/*end of file .\plane.cpp*/

/*start of file .\platform.cpp*/

/* ... license chunk ... */

// Headers
#include "platform.h"
#include "filefinder.h"
#include "utils.h"
#include <cassert>
#include <utility>

#ifndef DT_UNKNOWN
#define DT_UNKNOWN 0
#endif
#ifndef DT_REG
#define DT_REG DT_UNKNOWN
#endif
#ifndef DT_DIR
#define DT_DIR DT_UNKNOWN
#endif

Platform::File::File(std::string name) :
#ifdef _WIN32
		filename(Utils::ToWideString(name.empty() ? "." : name))
#else
		filename(name.empty() ? "." : std::move(name))
#endif
{
	// no-op
}

bool Platform::File::Exists() const {
#ifdef _WIN32
	return ::GetFileAttributesW(filename.c_str()) != (DWORD)-1;
#elif defined(__vita__)
	struct SceIoStat sb;
	return (::sceIoGetstat(filename.c_str(), &sb) >= 0);
#else
	return ::access(filename.c_str(), F_OK) != -1;
#endif
}

bool Platform::File::IsFile(bool follow_symlinks) const {
	return GetType(follow_symlinks) == FileType::File;
}

bool Platform::File::IsDirectory(bool follow_symlinks) const {
	return GetType(follow_symlinks) == FileType::Directory;
}

Platform::FileType Platform::File::GetType(bool follow_symlinks) const {
#if defined(_WIN32)
	(void)follow_symlinks;
	int attribs = ::GetFileAttributesW(filename.c_str());

	if (attribs == INVALID_FILE_ATTRIBUTES) {
		return FileType::Unknown;
	} else if ((attribs & FILE_ATTRIBUTE_DIRECTORY) == 0) {
		return FileType::File;
	} else if ((attribs & (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT)) == FILE_ATTRIBUTE_DIRECTORY) {
		return FileType::Directory;
	}
	return FileType::Other;
#elif defined(__vita__)
	(void)follow_symlinks;
	struct SceIoStat sb = {};
	if (::sceIoGetstat(filename.c_str(), &sb) >= 0) {
		return SCE_S_ISREG(sb.st_mode) ? FileType::File :
			SCE_S_ISDIR(sb.st_mode) ? FileType::Directory :
			FileType::Other;
	}
	return FileType::Unknown;
#else
	struct stat sb = {};
#  if defined(PLAYER_NINTENDO)
	// no symlink support (FAT)
	(void)follow_symlinks;
	auto fn = ::stat;
#  else
	auto fn = follow_symlinks ? ::stat : ::lstat;
#  endif
	if (fn(filename.c_str(), &sb) == 0) {
		return S_ISREG(sb.st_mode) ? FileType::File :
			S_ISDIR(sb.st_mode) ? FileType::Directory :
			FileType::Other;
	}
	return FileType::Unknown;
#endif
}

int64_t Platform::File::GetSize() const {
#if defined(_WIN32)
	WIN32_FILE_ATTRIBUTE_DATA data;
	BOOL res = ::GetFileAttributesExW(filename.c_str(),
			GetFileExInfoStandard,
			&data);
	if (!res) {
		return -1;
	}

	return ((int64_t)data.nFileSizeHigh << 32) | (int64_t)data.nFileSizeLow;
#elif defined(__vita__)
	struct SceIoStat sb = {};
	int result = ::sceIoGetstat(filename.c_str(), &sb);
	return (result >= 0) ? (int64_t)sb.st_size : (int64_t)-1;
#else
	struct stat sb = {};
	int result = ::stat(filename.c_str(), &sb);
	return (result == 0) ? (int64_t)sb.st_size : (int64_t)-1;
#endif
}

bool Platform::File::MakeDirectory(bool follow_symlinks) const {
	if (IsDirectory(follow_symlinks)) {
		return true;
	}

#ifdef _WIN32
	std::string path = Utils::FromWideString(filename);
#else
	std::string path = filename;
#endif

	auto components = FileFinder::SplitPath(path);
	std::string cur_path;
	if (StartsWith(path, "/")) {
		cur_path += "/";
	}

	bool first = true;
	for (const auto& comp : components) {
		if (comp.empty() || comp == ".") {
			continue;
		}

		cur_path = FileFinder::MakePath(cur_path, comp);

		if (first) {
			// Do not check stuff that looks like drives, such as C:, ux0: or sd:
			// Some systems do not consider them directories
			first = false;
			if (comp.back() == ':') {
				continue;
			}
		}

#if defined(__WIIU__)
		if (cur_path == "fs:/vol" || cur_path == "/vol") {
			// /vol is part of the path but checking for existance fails
			continue;
		}
#endif

		File cf(cur_path);
		if (cf.IsDirectory(follow_symlinks)) {
			continue;
		} else if (cf.IsFile(follow_symlinks) || cf.Exists()) {
			return false;
		} else {
#ifdef _WIN32
			if (!CreateDirectoryW(Utils::ToWideString(cur_path).c_str(), nullptr)) {
				return false;
			}
#else
#  if defined(__vita__)
			int res = sceIoMkdir(cur_path.c_str(), 0777);
#  else
			int res = mkdir(cur_path.c_str(), 0777);
#  endif
			if (res < 0) {
				return false;
			}
#endif
		}
	}
	return true;
}

Platform::Directory::Directory(const std::string& name) {
#if defined(_WIN32)
	std::wstring wname = Utils::ToWideString((name.empty() ? "." : name) + "\\*");
	dir_handle = FindFirstFileW(wname.c_str(), &entry);
#elif defined(__vita__)
	dir_handle = ::sceIoDopen(name.empty() ? "." : name.c_str());
#else
	dir_handle = ::opendir(name.empty() ? "." : name.c_str());
#endif
}

Platform::Directory::~Directory() {
	Close();
}

bool Platform::Directory::Read() {
#if defined(__vita__)
	assert(dir_handle >= 0);

	valid_entry = ::sceIoDread(dir_handle, &entry) > 0;
#elif defined(_WIN32)
	assert(dir_handle != INVALID_HANDLE_VALUE);

	if (!first_entry) {
		valid_entry = FindNextFile(dir_handle, &entry) != 0;
	} else {
		valid_entry = true;
		first_entry = false;
	}
#else
	assert(dir_handle);

	entry = ::readdir(dir_handle);

	valid_entry = entry != nullptr;
#endif

	return valid_entry;
}

std::string Platform::Directory::GetEntryName() const {
	assert(valid_entry);

#if defined(__vita__)
	return entry.d_name;
#elif defined(_WIN32)
	return Utils::FromWideString(entry.cFileName);
#else
	return entry->d_name;
#endif
}

#if !defined(__vita__) && !defined(_WIN32)
[[maybe_unused]] static inline Platform::FileType GetEntryType(...) {
	return Platform::FileType::Unknown;
}

template <typename T, typename = decltype(std::declval<T>().d_type)>
static inline Platform::FileType GetEntryType(T* entry) {
	return entry->d_type == DT_REG ? Platform::FileType::File :
		   entry->d_type == DT_DIR ? Platform::FileType::Directory :
		   entry->d_type == DT_UNKNOWN ? Platform::FileType::Unknown : Platform::FileType::Other;
}
#endif

Platform::FileType Platform::Directory::GetEntryType() const {
	assert(valid_entry);

#if defined(__vita__)
	return SCE_S_ISREG(entry.d_stat.st_mode) ? FileType::File :
			SCE_S_ISDIR(entry.d_stat.st_mode) ? FileType::Directory : FileType::Other;
#elif defined(_WIN32)
	int attribs = entry.dwFileAttributes;
	if (attribs == INVALID_FILE_ATTRIBUTES) {
		return FileType::Unknown;
	} else if ((attribs & FILE_ATTRIBUTE_DIRECTORY) == 0) {
		return FileType::File;
	} else if ((attribs & (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT)) == FILE_ATTRIBUTE_DIRECTORY) {
		return FileType::Directory;
	}
	return FileType::Other;
#else
	return ::GetEntryType(entry);
#endif
}

void Platform::Directory::Close() {
	if (*this) {
#if defined(_WIN32)
		FindClose(dir_handle);
		dir_handle = nullptr;
#elif defined(__vita__)
		::sceIoDclose(dir_handle);
		dir_handle = -1;
#else
		::closedir(dir_handle);
		dir_handle = nullptr;
#endif
	}

	valid_entry = false;
}


/*end of file .\platform.cpp*/

/*start of file .\player.cpp*/

/* ... license chunk ... */

// Headers
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <memory>

#ifdef _WIN32
#  include "platform/windows/utils.h"
#  include <windows.h>
#elif defined(EMSCRIPTEN)
#  include <emscripten.h>
#endif

#include "async_handler.h"
#include "audio.h"
#include "cache.h"
#include "rand.h"
#include "cmdline_parser.h"
#include "game_dynrpg.h"
#include "filefinder.h"
#include "filefinder_rtp.h"
#include "fileext_guesser.h"
#include "filesystem_hook.h"
#include "game_actors.h"
#include "game_battle.h"
#include "game_destiny.h"
#include "game_map.h"
#include "game_enemyparty.h"
#include "game_ineluki.h"
#include "game_party.h"
#include "game_player.h"
#include "game_switches.h"
#include "game_screen.h"
#include "game_pictures.h"
#include "game_system.h"
#include "game_variables.h"
#include "game_strings.h"
#include "game_targets.h"
#include "game_windows.h"
#include "graphics.h"
#include <lcf/inireader.h>
#include "input.h"
#include <lcf/ldb/reader.h>
#include <lcf/lmt/reader.h>
#include <lcf/lsd/reader.h>
#include "main_data.h"
#include "output.h"
#include "player.h"
#include <lcf/reader_lcf.h>
#include <lcf/reader_util.h>
#include "scene_battle.h"
#include "scene_logo.h"
#include "scene_map.h"
#include "utils.h"
#include "version.h"
#include "game_quit.h"
#include "scene_settings.h"
#include "scene_title.h"
#include "instrumentation.h"
#include "transition.h"
#include <lcf/scope_guard.h>
#include <lcf/log_handler.h>
#include "baseui.h"
#include "game_clock.h"
#include "message_overlay.h"
#include "audio_midi.h"
#include "maniac_patch.h"

#if defined(__ANDROID__) && !defined(USE_LIBRETRO)
#include "platform/android/android.h"
#endif

#ifndef EMSCRIPTEN
// This is not used on Emscripten.
#include "exe_reader.h"
#endif

using namespace std::chrono_literals;

namespace Player {
	int screen_width = SCREEN_TARGET_WIDTH;
	int screen_height = SCREEN_TARGET_HEIGHT;
	int menu_offset_x = (screen_width - MENU_WIDTH) / 2;
	int menu_offset_y = (screen_height - MENU_HEIGHT) / 2;
	int message_box_offset_x = (screen_width - MENU_WIDTH) / 2;
	bool has_custom_resolution = false;
	int exit_code = EXIT_SUCCESS;
	bool exit_flag = false;
	bool reset_flag = false;
	bool debug_flag;
	bool hide_title_flag;
	int load_game_id;
	int party_x_position;
	int party_y_position;
	std::vector<int> party_members;
	int start_map_id;
	bool no_rtp_flag;
	std::string rtp_path;
	bool no_audio_flag;
	bool is_easyrpg_project;
	std::string encoding;
	std::string escape_symbol;
	uint32_t escape_char;
	std::string game_title;
	std::string game_title_original;
	bool shared_game_and_save_directory = false;
	std::shared_ptr<Meta> meta;
	FileExtGuesser::RPG2KFileExtRemap fileext_map;
	std::string startup_language;
	Translation translation;
	int frames;
	std::string replay_input_path;
	std::string record_input_path;
	std::string command_line;
	int rng_seed = -1;
	Game_ConfigPlayer player_config;
	Game_ConfigGame game_config;
#ifdef EMSCRIPTEN
	std::string emscripten_game_name;
#endif
	Game_Clock::time_point last_auto_screenshot;
}

namespace {
	std::vector<std::string> arguments;

	// Overwritten by --encoding
	std::string forced_encoding;

	FileRequestBinding system_request_id;
	FileRequestBinding save_request_id;
	FileRequestBinding map_request_id;
}

void Player::Init(std::vector<std::string> args) {
	lcf::LogHandler::SetHandler([](lcf::LogHandler::Level level, std::string_view message, lcf::LogHandler::UserData) {
		Output::Debug("lcf ({}): {}", lcf::LogHandler::kLevelTags.tag(level), message);
	});

	frames = 0;

	// Must be called before the first call to Output
	Graphics::Init();

#ifdef _WIN32
	SetConsoleOutputCP(65001);
#endif

	// First parse command line arguments
	arguments = args;
	auto cfg = ParseCommandLine();

	// Display a nice version string
	auto header = GetFullVersionString() + " started";
	Output::Debug("{}", header);
	for (auto& c : header)
		c = '=';
	Output::Debug("{}", header);

#if defined(_WIN32)
	WindowsUtils::InitMiniDumpWriter();
#endif

	Output::Debug("CLI: {}", command_line);

	Game_Clock::logClockInfo();
	if (rng_seed < 0) {
		Rand::SeedRandomNumberGenerator(time(NULL));
	} else {
		Rand::SeedRandomNumberGenerator(rng_seed);
	}

	Main_Data::Init();

	DisplayUi.reset();

	if(! DisplayUi) {
		DisplayUi = BaseUi::CreateUi(Player::screen_width, Player::screen_height, cfg);
	}

	Input::Init(cfg.input, replay_input_path, record_input_path);
	Input::AddRecordingData(Input::RecordingData::CommandLine, command_line);

	player_config = std::move(cfg.player);

	last_auto_screenshot = Game_Clock::now();
}

void Player::Run() {
	Instrumentation::Init("EasyRPG-Player");

	Scene::Push(std::make_shared<Scene_Logo>());
	Graphics::UpdateSceneCallback();

	reset_flag = false;

	Game_Clock::ResetFrame(Game_Clock::now());

	// Main loop
#if defined(USE_LIBRETRO) || defined(EMSCRIPTEN)
	// emscripten implemented in main.cpp
	// libretro invokes the MainLoop through a retro_run-callback
#else
	while (Transition::instance().IsActive() || (Scene::instance && Scene::instance->type != Scene::Null)) {
		MainLoop();
	}
#endif
}

void Player::MainLoop() {
	Instrumentation::FrameScope iframe;

	const auto frame_time = Game_Clock::now();
	Game_Clock::OnNextFrame(frame_time);

	Player::UpdateInput();

	if (!DisplayUi->ProcessEvents()) {
		Scene::PopUntil(Scene::Null);
		Player::Exit();
		return;
	}

	int num_updates = 0;
	while (Game_Clock::NextGameTimeStep()) {
		if (num_updates > 0) {
			Player::UpdateInput();

			if (!DisplayUi->ProcessEvents()) {
				Scene::PopUntil(Scene::Null);
				Player::Exit();
				return;
			}
		}

		Scene::old_instances.clear();
		Scene::instance->MainFunction();

		Graphics::GetMessageOverlay().Update();

		++num_updates;
	}
	if (num_updates == 0) {
		// If no logical frames ran, we need to update the system keys only.
		Input::UpdateSystem();
	}

	Player::Draw();

	Scene::old_instances.clear();

	if (!Transition::instance().IsActive() && Scene::instance->type == Scene::Null) {
		Exit();
		return;
	}

	if (Player::player_config.automatic_screenshots.Get() && FileFinder::Game()) {
		auto diff = std::chrono::duration_cast<std::chrono::seconds>(Game_Clock::now() - last_auto_screenshot);
		if (diff.count() >= Player::player_config.automatic_screenshots_interval.Get()) {
			last_auto_screenshot = Game_Clock::now();
			Output::TakeScreenshot(true);
		}
	}

	auto frame_limit = DisplayUi->GetFrameLimit();
	if (frame_limit == Game_Clock::duration()) {
		return;
	}

	// Still time after graphic update? Yield until it's time for next one.
	auto now = Game_Clock::now();
	auto next = frame_time + frame_limit;
	if (Game_Clock::now() < next) {
		iframe.End();
		Game_Clock::SleepFor(next - now);
	}
}

void Player::Pause() {
	Audio().BGM_Pause();
}

void Player::Resume() {
	Input::ResetKeys();
	Audio().BGM_Resume();
	Game_Clock::ResetFrame(Game_Clock::now());
}

void Player::UpdateInput() {
	// Input Logic:
	if (Input::IsSystemTriggered(Input::TOGGLE_FPS)) {
		DisplayUi->ToggleShowFps();
	}
	if (Input::IsSystemTriggered(Input::TAKE_SCREENSHOT)) {
		Output::TakeScreenshot();
	}
	if (Input::IsSystemTriggered(Input::SHOW_LOG)) {
		Output::ToggleLog();
	}
	if (Input::IsSystemTriggered(Input::TOGGLE_ZOOM)) {
		DisplayUi->ToggleZoom();
	}
	float speed = 1.0;
	if (Input::IsSystemPressed(Input::FAST_FORWARD_A)) {
		speed = Input::GetInputSource()->GetConfig().speed_modifier_a.Get();
	}
	if (Input::IsSystemPressed(Input::FAST_FORWARD_B)) {
		speed = Input::GetInputSource()->GetConfig().speed_modifier_b.Get();
	}
	Game_Clock::SetGameSpeedFactor(speed);

	if (Main_Data::game_quit) {
		reset_flag |= Main_Data::game_quit->ShouldQuit();
	}
}

void Player::Update(bool update_scene) {
	std::shared_ptr<Scene> old_instance = Scene::instance;

	if (exit_flag) {
		Scene::PopUntil(Scene::Null);
	} else if (reset_flag && !Scene::IsAsyncPending()) {
		reset_flag = false;
		if (Scene::ReturnToTitleScene()) {
			// Fade out music and stop sound effects before returning
			Main_Data::game_system->BgmFade(800);
			Audio().SE_Stop();
			// Do not update this scene until it's properly set up in the next main loop
			update_scene = false;
		}
	}

	if (update_scene) {
		IncFrame();
	}

	Audio().Update();
	Input::Update();

	// Game events can query full screen status and change their behavior, so this needs to
	// be a game key and not a system key.
	if (Input::IsTriggered(Input::TOGGLE_FULLSCREEN)) {
		DisplayUi->ToggleFullscreen();
	}

	if (Main_Data::game_quit) {
		Main_Data::game_quit->Update();
	}

	auto& transition = Transition::instance();

	if (transition.IsActive()) {
		transition.Update();
	} else {
		// If we aren't waiting on a transition, but we are waiting for scene delay.
		Scene::instance->UpdateDelayFrames();
	}

	if (update_scene) {
		if (Main_Data::game_ineluki) {
			Main_Data::game_ineluki->Update();
		}

		Scene::instance->Update();
	}

#if defined(__ANDROID__) && !defined(USE_LIBRETRO)
	EpAndroid::invoke();
#endif
}

void Player::Draw() {
	Graphics::Update();
	Graphics::Draw(*DisplayUi->GetDisplaySurface());
	DisplayUi->UpdateDisplay();
}

void Player::IncFrame() {
	++frames;
	if (Main_Data::game_system) {
		Main_Data::game_system->IncFrameCounter();
	}
}

int Player::GetFrames() {
	return frames;
}

void Player::Exit() {
	if (player_config.settings_autosave.Get()) {
		Scene_Settings::SaveConfig(true);
	}

	Graphics::UpdateSceneCallback();
#ifdef EMSCRIPTEN
	BitmapRef surface = DisplayUi->GetDisplaySurface();
	std::string message = "It's now safe to turn off\n      your browser.";
	DisplayUi->CleanDisplay();
	Text::Draw(*surface, 84, DisplayUi->GetHeight() / 2 - 16, *Font::DefaultBitmapFont(), Color(221, 123, 64, 255), message);
	DisplayUi->UpdateDisplay();

	auto ret = FileFinder::Root().OpenOutputStream("/tmp/message.png", std::ios_base::binary | std::ios_base::out | std::ios_base::trunc);
	if (ret) Output::TakeScreenshot(ret);
#endif
	Player::ResetGameObjects();
	Font::Dispose();
	Graphics::Quit();
	Output::Quit();
	FileFinder::Quit();
	DisplayUi.reset();
}

Game_Config Player::ParseCommandLine() {
	debug_flag = false;
	hide_title_flag = false;
	exit_flag = false;
	reset_flag = false;
	load_game_id = -1;
	party_x_position = -1;
	party_y_position = -1;
	start_map_id = -1;
	no_rtp_flag = false;
	no_audio_flag = false;
	is_easyrpg_project = false;
	Game_Battle::battle_test.enabled = false;

	std::stringstream ss;
	for (size_t i = 1; i < arguments.size(); ++i) {
		ss << arguments[i] << " ";
	}
	command_line = ss.str();

	CmdlineParser cp(arguments);
	auto cfg = Game_Config::Create(cp);

	bool battletest_handled = false;

	cp.Rewind();
	if (!cp.Done()) {
		// BattleTest argument handling in a RPG_RT compatible way is very ugly because the arguments do not follow
		// directly. Try to parse it and afterwards rewind the parser to parse the rest.
		CmdlineArg arg;
		long li_value = 0;

		// Legacy BattleTest handling: When BattleTest is argument 1, then the values are:
		// - arg4: troop_id
		// - arg5-7: formation, condition, terrain_id (2k3 only)
		// - arg2-3 are unrelated ("ShowTitle Window")
		if (cp.ParseNext(arg, 6, {"battletest"})) {
			Game_Battle::battle_test.enabled = true;
			Game_Battle::battle_test.troop_id = 0;

			// Starting from 3 to reach arg4 from arg1
			if (arg.NumValues() >= 3) {
				if (arg.ParseValue(2, li_value)) {
					Game_Battle::battle_test.troop_id = li_value;
				}
			}

			if (arg.NumValues() >= 6) {
				if (arg.ParseValue(3, li_value)) {
					Game_Battle::battle_test.formation = static_cast<lcf::rpg::System::BattleFormation>(li_value);
				}
				if (arg.ParseValue(4, li_value)) {
					Game_Battle::battle_test.condition = static_cast<lcf::rpg::System::BattleCondition>(li_value);
				}
				if (arg.ParseValue(5, li_value)) {
					Game_Battle::battle_test.terrain_id = static_cast<lcf::rpg::System::BattleFormation>(li_value);
				}
			}

			battletest_handled = true;
		}
	}

	cp.Rewind();
	while (!cp.Done()) {
		CmdlineArg arg;
		long li_value = 0;
		if (cp.ParseNext(arg, 0, "window")) {
			// Legacy RPG_RT argument - window
			cfg.video.fullscreen.Set(false);
			continue;
		}
		if (cp.ParseNext(arg, 0, {"testplay", "--test-play"})) {
			// Legacy RPG_RT argument - testplay
			debug_flag = true;
			continue;
		}
		if (cp.ParseNext(arg, 0, {"hidetitle", "--hide-title"})) {
			// Legacy RPG_RT argument - hidetitle
			hide_title_flag = true;
			continue;
		}
		if(!battletest_handled && cp.ParseNext(arg, 4, {"battletest", "--battle-test"})) {
			// Legacy RPG_RT argument - battletest
			Game_Battle::battle_test.enabled = true;
			Game_Battle::battle_test.troop_id = 0;

			if (arg.NumValues() > 0) {
				if (arg.ParseValue(0, li_value)) {
					Game_Battle::battle_test.troop_id = li_value;
				}
			}

			if (arg.NumValues() >= 4) {
				// 2k3 passes formation, condition and terrain_id as args 5-7
				if (arg.ParseValue(1, li_value)) {
					Game_Battle::battle_test.formation = static_cast<lcf::rpg::System::BattleFormation>(li_value);
				} else {
					// When the argument is not a number, args5-7 were likely not specified and are something different
					// Rewind to prevent losing other args
					cp.RewindBy(3);
					continue;
				}

				if (arg.ParseValue(2, li_value)) {
					Game_Battle::battle_test.condition = static_cast<lcf::rpg::System::BattleCondition>(li_value);
				}
				if (arg.ParseValue(3, li_value)) {
					Game_Battle::battle_test.terrain_id = static_cast<lcf::rpg::System::BattleFormation>(li_value);
				}
			} else if (arg.NumValues() >= 2) {
				// Only troop-id was provided: Rewind to prevent losing other args
				cp.RewindBy(arg.NumValues() - 1);
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--project-path") && arg.NumValues() > 0) {
			if (arg.NumValues() > 0) {
				auto gamefs = FileFinder::Root().Create(FileFinder::MakeCanonical(arg.Value(0), 0));
				if (!gamefs) {
					Output::Error("Invalid --project-path {}", arg.Value(0));
				}
				FileFinder::SetGameFilesystem(gamefs);
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--save-path")) {
			if (arg.NumValues() > 0) {
				auto savefs = FileFinder::Root().Create(FileFinder::MakeCanonical(arg.Value(0), 0));
				if (!savefs) {
					Output::Error("Invalid --save-path {}", arg.Value(0));
				}
				FileFinder::SetSaveFilesystem(savefs);
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--load-game-id")) {
			if (arg.ParseValue(0, li_value)) {
				load_game_id = li_value;
			}
			continue;
		}
		/*else if (*it == "--load-game") {
			// load game by filename
		}
		else if (*it == "--database") {
			// overwrite database file
		}
		else if (*it == "--map-tree") {
			// overwrite map tree file
		}
		else if (*it == "--start-map") {
			// overwrite start map by filename
		}*/
		if (cp.ParseNext(arg, 1, "--seed")) {
			if (arg.ParseValue(0, li_value) && li_value > 0) {
				rng_seed = li_value;
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--start-map-id")) {
			if (arg.ParseValue(0, li_value)) {
				start_map_id = li_value;
			}
			continue;
		}
		if (cp.ParseNext(arg, 2, "--start-position")) {
			if (arg.ParseValue(0, li_value)) {
				party_x_position = li_value;
			}
			if (arg.ParseValue(1, li_value)) {
				party_y_position = li_value;
			}
			continue;
		}
		if (cp.ParseNext(arg, 4, "--start-party")) {
			for (int i = 0; i < arg.NumValues(); ++i) {
				if (arg.ParseValue(i, li_value)) {
					party_members.push_back(li_value);
				}
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--record-input")) {
			if (arg.NumValues() > 0) {
				record_input_path = arg.Value(0);
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--replay-input")) {
			if (arg.NumValues() > 0) {
				replay_input_path = arg.Value(0);
			}
			continue;
		}
		if (cp.ParseNext(arg, 1, "--encoding")) {
			if (arg.NumValues() > 0) {
				forced_encoding = arg.Value(0);
			}
			continue;
		}
		if (cp.ParseNext(arg, 0, {"--no-audio", "--disable-audio"})) {
			no_audio_flag = true;
			continue;
		}
		if (cp.ParseNext(arg, 0, {"--no-rtp", "--disable-rtp"})) {
			no_rtp_flag = true;
			continue;
		}
		if (cp.ParseNext(arg, 1, "--rtp-path")) {
			if (arg.NumValues() > 0) {
				rtp_path = arg.Value(0);
			}
			continue;
		}
		if (cp.ParseNext(arg, 0, "--no-log-color")) {
			Output::SetTermColor(false);
			continue;
		}
		if (cp.ParseNext(arg, 1, "--language")) {
			if (arg.NumValues() > 0) {
				startup_language = arg.Value(0);
				if (startup_language == "default") {
					startup_language.clear();
				}
			}
			continue;
		}
		if (cp.ParseNext(arg, 0, "--version", 'v')) {
			std::cout << GetFullVersionString() << std::endl;
			exit(0);
			break;
		}
		if (cp.ParseNext(arg, 0, {"--help", "/?"}, 'h')) {
			PrintUsage();
			exit(0);
			break;
		}
#ifdef EMSCRIPTEN
		if (cp.ParseNext(arg, 1, "--game")) {
			if (arg.NumValues() > 0) {
				emscripten_game_name = arg.Value(0);
			}
			continue;
		}
#endif
		cp.SkipNext();
	}

	return cfg;
}

void Player::CreateGameObjects() {
	// Parse game specific settings
	CmdlineParser cp(arguments);
	game_config = Game_ConfigGame();
	game_config.Initialize(cp);

	// Reinit MIDI
	MidiDecoder::Reset();

	// Load the meta information file.
	// Note: This should eventually be split across multiple folders as described in Issue #1210
	std::string meta_file = FileFinder::Game().FindFile(META_NAME);
	meta.reset(new Meta(meta_file));

	// Guess non-standard extensions (for the DB) before loading the encoding
	GuessNonStandardExtensions();

	GetEncoding();
	escape_symbol = lcf::ReaderUtil::Recode("\\", encoding);
	if (escape_symbol.empty()) {
		Output::Error("Invalid encoding: {}.", encoding);
	}
	escape_char = Utils::DecodeUTF32(Player::escape_symbol).front();

	// Special handling for games with altered files
	FileFinder::SetGameFilesystem(HookFilesystem::Detect(FileFinder::Game()));

	// Check for translation-related directories and load language names.
	translation.InitTranslations();

	std::string game_path = FileFinder::GetFullFilesystemPath(FileFinder::Game());
	std::string save_path = FileFinder::GetFullFilesystemPath(FileFinder::Save());
	shared_game_and_save_directory = (game_path == save_path);

	if (shared_game_and_save_directory) {
		Output::DebugStr("Game and Save Directory:");
		FileFinder::DumpFilesystem(FileFinder::Game());
	} else {
		Output::Debug("Game Directory:");
		FileFinder::DumpFilesystem(FileFinder::Game());
		Output::Debug("SaveDirectory:", save_path);
		FileFinder::DumpFilesystem(FileFinder::Save());
	}

	LoadDatabase();

	bool no_rtp_warning_flag = false;
	Player::has_custom_resolution = false;
	{ // Scope lifetime of variables for ini parsing
		std::string ini_file = FileFinder::Game().FindFile(INI_NAME);

		auto ini_stream = FileFinder::Game().OpenInputStream(ini_file, std::ios_base::in);
		if (ini_stream) {
			lcf::INIReader ini(ini_stream);
			if (ini.ParseError() != -1) {
				auto title = ini.Get("RPG_RT", "GameTitle", GAME_TITLE);
				game_title = lcf::ReaderUtil::Recode(title, encoding);
				no_rtp_warning_flag = ini.Get("RPG_RT", "FullPackageFlag", "0") == "1" ? true : no_rtp_flag;
				if (ini.HasValue("RPG_RT", "WinW") || ini.HasValue("RPG_RT", "WinH")) {
					Player::screen_width = ini.GetInteger("RPG_RT", "WinW", SCREEN_TARGET_WIDTH);
					Player::screen_height = ini.GetInteger("RPG_RT", "WinH", SCREEN_TARGET_HEIGHT);
					Player::has_custom_resolution = true;
				}
			}
		}
	}

	UpdateTitle(game_title);

	if (no_rtp_warning_flag) {
		Output::Debug("Game does not need RTP (FullPackageFlag=1)");
	}

	// ExFont parsing
	Cache::exfont_custom.clear();
	// Check for bundled ExFont
	auto exfont_stream = FileFinder::OpenImage("Font", "ExFont");
	if (!exfont_stream) {
		// Backwards compatible with older Player versions
		exfont_stream = FileFinder::OpenImage(".", "ExFont");
	}

	int& engine = game_config.engine;

#ifndef EMSCRIPTEN
	// Attempt reading ExFont and version information from RPG_RT.exe (not supported on Emscripten)
	std::unique_ptr<EXEReader> exe_reader;
	auto exeis = FileFinder::Game().OpenFile(EXE_NAME);

	if (exeis) {
		exe_reader.reset(new EXEReader(std::move(exeis)));
		Cache::exfont_custom = exe_reader->GetExFont();

		if (engine == EngineNone) {
			auto version_info = exe_reader->GetFileInfo();
			version_info.Print();
			bool is_patch_maniac;
			engine = version_info.GetEngineType(is_patch_maniac);
			if (!game_config.patch_override) {
				game_config.patch_maniac.Set(is_patch_maniac);
			}
		}

		if (engine == EngineNone) {
			Output::Debug("Unable to detect version from exe");
		}
	} else {
		Output::Debug("Cannot find RPG_RT");
	}
#endif

	if (exfont_stream) {
		Output::Debug("Using custom ExFont: {}", FileFinder::GetPathInsideGamePath(exfont_stream.GetName()));
		Cache::exfont_custom = Utils::ReadStream(exfont_stream);
	}

	if (engine == EngineNone) {
		if (lcf::Data::system.ldb_id == 2003) {
			engine = EngineRpg2k3;
			if (!FileFinder::Game().FindFile("ultimate_rt_eb.dll").empty()) {
				engine |= EngineEnglish | EngineMajorUpdated;
			}
		} else {
			engine = EngineRpg2k;
			if (lcf::Data::data.version >= 1) {
				engine |= EngineEnglish | EngineMajorUpdated;
			}
		}
		if (!(engine & EngineMajorUpdated)) {
			if (FileFinder::IsMajorUpdatedTree()) {
				engine |= EngineMajorUpdated;
			}
		}
	}

	Output::Debug("Engine configured as: 2k={} 2k3={} MajorUpdated={} Eng={}", Player::IsRPG2k(), Player::IsRPG2k3(), Player::IsMajorUpdatedVersion(), Player::IsEnglish());

	Main_Data::filefinder_rtp = std::make_unique<FileFinder_RTP>(no_rtp_flag, no_rtp_warning_flag, rtp_path);

	if (!game_config.patch_override) {
		if (!FileFinder::Game().FindFile("harmony.dll").empty()) {
			game_config.patch_key_patch.Set(true);
		}

		if (!FileFinder::Game().FindFile("dynloader.dll").empty()) {
			game_config.patch_dynrpg.Set(true);
			Output::Debug("This game uses DynRPG. Depending on the plugins used it will not run properly.");
		}

		if (!FileFinder::Game().FindFile("accord.dll").empty()) {
			game_config.patch_maniac.Set(true);
		}

		if (!FileFinder::Game().FindFile(DESTINY_DLL).empty()) {
			game_config.patch_destiny.Set(true);
		}
	}

	game_config.PrintActivePatches();

	ResetGameObjects();

	LoadFonts();

	if (Player::IsPatchKeyPatch()) {
		Main_Data::game_ineluki->ExecuteScriptList(FileFinder::Game().FindFile("autorun.script"));
	}

	if (Player::IsPatchDestiny()) {
		Main_Data::game_destiny->Load();
	}
}

void Player::UpdateTitle(std::string new_game_title) {
	if (!game_title.empty() && game_title != new_game_title) {
		if (game_title_original == new_game_title) {
			game_title_original = "";
		} else {
			game_title_original = game_title;
		}
		game_title = new_game_title;
	}

	std::stringstream title;
	if (!game_title.empty()) {
		Output::Debug("Loading game {}", game_title);
		title << new_game_title << " - ";
		Input::AddRecordingData(Input::RecordingData::GameTitle, game_title);
	} else {
		Output::Debug("Could not read game title.");
	}
	title << GAME_TITLE;
	DisplayUi->SetTitle(title.str());
}

bool Player::ChangeResolution(int width, int height) {
	if (!DisplayUi->ChangeDisplaySurfaceResolution(width, height)) {
		Output::Warning("Resolution change to {}x{} failed", width, height);
		return false;
	}

	Player::screen_width = width;
	Player::screen_height = height;
	Player::menu_offset_x = std::max<int>((Player::screen_width - MENU_WIDTH) / 2, 0);
	Player::menu_offset_y = std::max<int>((Player::screen_height - MENU_HEIGHT) / 2, 0);
	Player::message_box_offset_x = std::max<int>((Player::screen_width - MENU_WIDTH) / 2, 0);

	Graphics::GetMessageOverlay().OnResolutionChange();

	if (Main_Data::game_quit) {
		Main_Data::game_quit->OnResolutionChange();
	}

	Output::Debug("Resolution changed to {}x{}", width, height);
	return true;
}

void Player::RestoreBaseResolution() {
	if (Player::screen_width == SCREEN_TARGET_WIDTH && Player::screen_height == SCREEN_TARGET_HEIGHT) {
		return;
	}

	if (!Player::ChangeResolution(SCREEN_TARGET_WIDTH, SCREEN_TARGET_HEIGHT)) {
		// Considering that this is the base resolution this should never fail
		Output::Error("Failed restoring base resolution");
	}
}

void Player::ResetGameObjects() {
	// The init order is important
	ManiacPatch::GlobalSave::Save(true);

	Main_Data::Cleanup();

	Main_Data::game_switches = std::make_unique<Game_Switches>();
	Main_Data::game_switches->SetLowerLimit(lcf::Data::switches.size());

	auto min_var = lcf::Data::system.easyrpg_variable_min_value;
	if (min_var == 0) {
		if ((Player::game_config.patch_maniac.Get() & 1) == 1) {
			min_var = std::numeric_limits<Game_Variables::Var_t>::min();
		} else {
			min_var = Player::IsRPG2k3() ? Game_Variables::min_2k3 : Game_Variables::min_2k;
		}
	}
	auto max_var = lcf::Data::system.easyrpg_variable_max_value;
	if (max_var == 0) {
		if ((Player::game_config.patch_maniac.Get() & 1) == 1) {
			max_var = std::numeric_limits<Game_Variables::Var_t>::max();
		} else {
			max_var = Player::IsRPG2k3() ? Game_Variables::max_2k3 : Game_Variables::max_2k;
		}
	}
	Main_Data::game_variables = std::make_unique<Game_Variables>(min_var, max_var);
	Main_Data::game_variables->SetLowerLimit(lcf::Data::variables.size());

	Main_Data::game_strings = std::make_unique<Game_Strings>();

	// Prevent a crash when Game_Map wants to reset the screen content
	// because Setup() modified pictures array
	Main_Data::game_screen = std::make_unique<Game_Screen>();
	Main_Data::game_pictures = std::make_unique<Game_Pictures>();
	Main_Data::game_windows = std::make_unique<Game_Windows>();

	Main_Data::game_actors = std::make_unique<Game_Actors>();

	Game_Map::Init();

	Main_Data::game_system = std::make_unique<Game_System>();
	Main_Data::game_targets = std::make_unique<Game_Targets>();
	Main_Data::game_enemyparty = std::make_unique<Game_EnemyParty>();
	Main_Data::game_party = std::make_unique<Game_Party>();
	Main_Data::game_player = std::make_unique<Game_Player>();
	Main_Data::game_quit = std::make_unique<Game_Quit>();
	Main_Data::game_switches_global = std::make_unique<Game_Switches>();
	Main_Data::game_variables_global = std::make_unique<Game_Variables>(min_var, max_var);
	Main_Data::game_dynrpg = std::make_unique<Game_DynRpg>();
	Main_Data::game_ineluki = std::make_unique<Game_Ineluki>();
	Main_Data::game_destiny = std::make_unique<Game_Destiny>();

	Game_Clock::ResetFrame(Game_Clock::now());

	Main_Data::game_system->ReloadSystemGraphic();

	Input::ResetMask();
}

static bool DefaultLmuStartFileExists(const FilesystemView& fs) {
	// Compute map_id based on command line.
	int map_id = Player::start_map_id == -1 ? lcf::Data::treemap.start.party_map_id : Player::start_map_id;
	std::string mapName = Game_Map::ConstructMapName(map_id, false);

	// Now see if the file exists.
	return !fs.FindFile(mapName).empty();
}

void Player::GuessNonStandardExtensions() {
	// Check all conditions, but check the remap last (since it is potentially slower).
	FileExtGuesser::RPG2KNonStandardFilenameGuesser rpg2kRemap;
	if (!FileFinder::IsRPG2kProject(FileFinder::Game()) &&
		!FileFinder::IsEasyRpgProject(FileFinder::Game())) {

		rpg2kRemap = FileExtGuesser::GetRPG2kProjectWithRenames(FileFinder::Game());
		if (rpg2kRemap.Empty()) {
			// Unlikely to happen because of the game browser only launches valid games
			Output::Error("{}\n\n{}\n\n{}\n\n{}","No valid game was found.",
				"EasyRPG must be run from a game folder containing\nRPG_RT.ldb and RPG_RT.lmt.",
				"This engine only supports RPG Maker 2000 and 2003\ngames.",
				"RPG Maker XP, VX, VX Ace and MV are NOT supported.");
		}
	}

	// At this point we haven't yet determined if this is an easyrpg project or not.
	// There are several ways to handle this, but we just put 'is_easyrpg_project' in the header
	// and calculate it here.
	// Try loading EasyRPG project files first, then fallback to normal RPG Maker
	std::string edb = FileFinder::Game().FindFile(DATABASE_NAME_EASYRPG);
	std::string emt = FileFinder::Game().FindFile(TREEMAP_NAME_EASYRPG);
	is_easyrpg_project = !edb.empty() && !emt.empty();

	// Non-standard extensions only apply to non-EasyRPG projects
	if (!is_easyrpg_project && !rpg2kRemap.Empty()) {
		fileext_map = rpg2kRemap.guessExtensions(*meta);
	} else {
		fileext_map = FileExtGuesser::RPG2KFileExtRemap();
	}
}

void Player::LoadDatabase() {
	// Load lcf::Database
	lcf::Data::Clear();

	if (is_easyrpg_project) {
		std::string edb = FileFinder::Game().FindFile(DATABASE_NAME_EASYRPG);
		auto edb_stream = FileFinder::Game().OpenInputStream(edb, std::ios_base::in);
		if (!edb_stream) {
			Output::Error("Error loading {}", DATABASE_NAME_EASYRPG);
			return;
		}

		auto db = lcf::LDB_Reader::LoadXml(edb_stream);
		if (!db) {
			Output::ErrorStr(lcf::LcfReader::GetError());
			return;
		} else {
			lcf::Data::data = std::move(*db);
		}

		std::string emt = FileFinder::Game().FindFile(TREEMAP_NAME_EASYRPG);
		auto emt_stream = FileFinder::Game().OpenInputStream(emt, std::ios_base::in);
		if (!emt_stream) {
			Output::Error("Error loading {}", TREEMAP_NAME_EASYRPG);
			return;
		}

		auto treemap = lcf::LMT_Reader::LoadXml(emt_stream);
		if (!treemap) {
			Output::ErrorStr(lcf::LcfReader::GetError());
		} else {
			lcf::Data::treemap = std::move(*treemap);
		}
	} else {
		// Retrieve the appropriately-renamed files.
		std::string ldb_name = fileext_map.MakeFilename(RPG_RT_PREFIX, SUFFIX_LDB);
		std::string ldb = FileFinder::Game().FindFile(ldb_name);
		std::string lmt_name = fileext_map.MakeFilename(RPG_RT_PREFIX, SUFFIX_LMT);
		std::string lmt = FileFinder::Game().FindFile(lmt_name);

		auto ldb_stream = FileFinder::Game().OpenInputStream(ldb);
		if (!ldb_stream) {
			Output::Error("Error loading {}", ldb_name);
			return;
		}

		auto db = lcf::LDB_Reader::Load(ldb_stream, encoding);
		if (!db) {
			Output::ErrorStr(lcf::LcfReader::GetError());
			return;
		} else {
			lcf::Data::data = std::move(*db);
		}

		auto lmt_stream = FileFinder::Game().OpenInputStream(lmt);
		if (!lmt_stream) {
			Output::Error("Error loading {}", lmt_name);
			return;
		}

		auto treemap = lcf::LMT_Reader::Load(lmt_stream, encoding);
		if (!treemap) {
			Output::ErrorStr(lcf::LcfReader::GetError());
			return;
		} else {
			lcf::Data::treemap = std::move(*treemap);
		}

		if (Input::IsRecording()) {
			ldb_stream.clear();
			ldb_stream.seekg(0, std::ios::beg);
			lmt_stream.clear();
			lmt_stream.seekg(0, std::ios::beg);
			Input::AddRecordingData(Input::RecordingData::Hash,
									fmt::format("ldb {:#08x}", Utils::CRC32(ldb_stream)));
			Input::AddRecordingData(Input::RecordingData::Hash,
						   fmt::format("lmt {:#08x}", Utils::CRC32(lmt_stream)));
		}

		// Override map extension, if needed.
		if (!DefaultLmuStartFileExists(FileFinder::Game())) {
			FileExtGuesser::GuessAndAddLmuExtension(FileFinder::Game(), *meta, fileext_map);
		}
	}
}

void Player::LoadFonts() {
	Font::ResetDefault();

#ifdef HAVE_FREETYPE
	// Look for bundled fonts
	auto gothic = FileFinder::OpenFont("Font");
	if (gothic) {
		auto ft = Font::CreateFtFont(std::move(gothic), 12, false, false);
		player_config.font1.SetLocked(ft != nullptr);
		if (ft) {
			Font::SetDefault(ft, false);
		}
	}

	auto mincho = FileFinder::OpenFont("Font2");
	if (mincho) {
		auto ft = Font::CreateFtFont(std::move(mincho), 12, false, false);
		player_config.font2.SetLocked(ft != nullptr);
		if (ft) {
			Font::SetDefault(ft, true);
		}
	}
#endif
}

static void OnMapSaveFileReady(FileRequestResult*, lcf::rpg::Save save) {
	auto map = Game_Map::LoadMapFile(Main_Data::game_player->GetMapId());
	Game_Map::SetupFromSave(
			std::move(map),
			std::move(save.map_info),
			std::move(save.boat_location),
			std::move(save.ship_location),
			std::move(save.airship_location),
			std::move(save.foreground_event_execstate),
			std::move(save.panorama),
			std::move(save.common_events));
}

void Player::LoadSavegame(const std::string& save_name, int save_id) {
	Output::Debug("Loading Save {}", save_name);

	bool load_on_map = Scene::instance->type == Scene::Map;

	if (!load_on_map) {
		Main_Data::game_system->BgmFade(800);
		// We erase the screen now before loading the saved game. This prevents an issue where
		// if the save game has a different system graphic, the load screen would change before
		// transitioning out.
		Transition::instance().InitErase(Transition::TransitionFadeOut, Scene::instance.get(), 6);
	}

	auto title_scene = Scene::Find(Scene::Title);
	if (title_scene) {
		static_cast<Scene_Title*>(title_scene.get())->OnGameStart();
	}

	auto save_stream = FileFinder::Save().OpenInputStream(save_name);
	if (!save_stream) {
		Output::Error("Error loading {}", save_name);
		return;
	}

	std::unique_ptr<lcf::rpg::Save> save = lcf::LSD_Reader::Load(save_stream, encoding);

	if (!save.get()) {
		Output::ErrorStr(lcf::LcfReader::GetError());
		return;
	}

	std::stringstream verstr;
	int ver = save->easyrpg_data.version;
	if (ver == 0) {
		verstr << "RPG_RT or EasyRPG Player Pre-0.6.0";
	} else if (ver >= 10000) {
		verstr << "Unknown Engine";
	} else {
		verstr << "EasyRPG Player ";
		char verbuf[64];
		snprintf(verbuf, std::size(verbuf), "%d.%d.%d", ver / 1000 % 10, ver / 100 % 10, ver / 10 % 10);
		verstr << verbuf;
		if (ver % 10 > 0) {
			verstr << "." << ver % 10;
		}
	}

	Output::Debug("Savegame version {} ({})", ver, verstr.str());

	if (ver > PLAYER_SAVEGAME_VERSION) {
		Output::Warning("This savegame was created with {} which is newer than the current version of EasyRPG Player ({})",
			verstr.str(), Version::STRING);
	}

	// Compatibility hacks for old EasyRPG Player saves.
	if (save->easyrpg_data.version == 0) {
		// Old savegames accidentally wrote animation_type as continuous for all events.
		save->party_location.animation_type = Game_Character::AnimType::AnimType_non_continuous;
		save->boat_location.animation_type = Game_Character::AnimType::AnimType_non_continuous;
		save->ship_location.animation_type = Game_Character::AnimType::AnimType_non_continuous;
		save->airship_location.animation_type = Game_Character::AnimType::AnimType_non_continuous;
	}

	if (!load_on_map) {
		Scene::PopUntil(Scene::Title);
	}

	Main_Data::game_switches->SetLowerLimit(lcf::Data::switches.size());
	Main_Data::game_switches->SetData(std::move(save->system.switches));
	Main_Data::game_variables->SetLowerLimit(lcf::Data::variables.size());
	Main_Data::game_variables->SetData(std::move(save->system.variables));
	Main_Data::game_strings->SetData(std::move(save->system.maniac_strings));
	Main_Data::game_system->SetupFromSave(std::move(save->system));
	Main_Data::game_actors->SetSaveData(std::move(save->actors));
	Main_Data::game_party->SetupFromSave(std::move(save->inventory));
	Main_Data::game_screen->SetSaveData(std::move(save->screen));
	Main_Data::game_pictures->SetSaveData(std::move(save->pictures));
	Main_Data::game_targets->SetSaveData(std::move(save->targets));
	Main_Data::game_player->SetSaveData(save->party_location);
	Main_Data::game_windows->SetSaveData(std::move(save->easyrpg_data.windows));

	int map_id = Main_Data::game_player->GetMapId();

	FileRequestAsync* map = Game_Map::RequestMap(map_id);
	save_request_id = map->Bind(
		[save=std::move(*save), load_on_map, save_id](auto* request) {
			Game_Map::Dispose();

			OnMapSaveFileReady(request, std::move(save));

			if (load_on_map) {
				// Increment frame counter for consistency with a normal savegame load
				IncFrame();
				static_cast<Scene_Map*>(Scene::instance.get())->StartFromSave(save_id);
			}
		}
	);

	Main_Data::game_system->ReloadSystemGraphic();

	map->Start();
	// load_on_map is handled in the async callback
	if (!load_on_map) {
		Scene::Push(std::make_shared<Scene_Map>(save_id));
	}
}

static void OnMapFileReady(FileRequestResult*) {
	int map_id = Player::start_map_id == -1 ?
		lcf::Data::treemap.start.party_map_id : Player::start_map_id;
	int x_pos = Player::party_x_position == -1 ?
		lcf::Data::treemap.start.party_x : Player::party_x_position;
	int y_pos = Player::party_y_position == -1 ?
		lcf::Data::treemap.start.party_y : Player::party_y_position;
	if (Player::party_members.size() > 0) {
		Main_Data::game_party->Clear();
		for (auto& member: Player::party_members) {
			Main_Data::game_party->AddActor(member);
		}
	}

	Main_Data::game_player->MoveTo(map_id, x_pos, y_pos);
}

void Player::SetupNewGame() {
	Main_Data::game_system->BgmFade(800, true);
	Main_Data::game_system->ResetFrameCounter();
	auto title = Scene::Find(Scene::Title);
	if (title) {
		static_cast<Scene_Title*>(title.get())->OnGameStart();
	}

	Main_Data::game_system->SetAtbMode(static_cast<Game_System::AtbMode>(lcf::Data::battlecommands.easyrpg_default_atb_mode));

	Main_Data::game_party->SetupNewGame();
	SetupPlayerSpawn();
	Scene::Push(std::make_shared<Scene_Map>(0));
}

void Player::SetupPlayerSpawn() {
	int map_id = Player::start_map_id == -1 ?
		lcf::Data::treemap.start.party_map_id : Player::start_map_id;

	FileRequestAsync* request = Game_Map::RequestMap(map_id);
	map_request_id = request->Bind(&OnMapFileReady);
	request->Start();
}

void Player::SetupBattleTest() {
	BattleArgs args;
	args.troop_id = Game_Battle::battle_test.troop_id;
	args.first_strike = false;
	args.allow_escape = true;
	args.background = ToString(lcf::Data::system.battletest_background);
	args.terrain_id = 1; //Not used in 2k, for 2k3 only used to determine grid layout if formation == terrain.

	if (Player::IsRPG2k3()) {
		args.formation = Game_Battle::battle_test.formation;
		args.condition = Game_Battle::battle_test.condition;

		if (args.formation == lcf::rpg::System::BattleFormation_terrain) {
			args.terrain_id = Game_Battle::battle_test.terrain_id;
		}

		Output::Debug("BattleTest Mode 2k3 troop=({}) background=({}) formation=({}) condition=({}) terrain=({})",
				args.troop_id, args.background, static_cast<int>(args.formation), static_cast<int>(args.condition), args.terrain_id);
	} else {
		Output::Debug("BattleTest Mode 2k troop=({}) background=({})", args.troop_id, args.background);
	}

	auto* troop = lcf::ReaderUtil::GetElement(lcf::Data::troops, args.troop_id);
	if (troop == nullptr) {
		Output::Error("BattleTest: Invalid Monster Party ID {}", args.troop_id);
	}

	if (Game_Battle::battle_test.enabled) {
		Main_Data::game_party->SetupBattleTest();
	}

	Scene::Push(Scene_Battle::Create(std::move(args)), true);
}

std::string Player::GetEncoding() {
	encoding = forced_encoding;

	// command line > ini > detection > current locale
	if (encoding.empty()) {
		std::string ini = FileFinder::Game().FindFile(INI_NAME);
		auto ini_stream = FileFinder::Game().OpenInputStream(ini);
		if (ini_stream) {
			encoding = lcf::ReaderUtil::GetEncoding(ini_stream);
		}
	}

	if (encoding.empty() || encoding == "auto") {
		encoding = "";

		std::string ldb = FileFinder::Game().FindFile(fileext_map.MakeFilename(RPG_RT_PREFIX, SUFFIX_LDB));
		auto ldb_stream = FileFinder::Game().OpenInputStream(ldb);
		if (ldb_stream) {
			auto db = lcf::LDB_Reader::Load(ldb_stream);
			if (db) {
				std::vector<std::string> encodings = lcf::ReaderUtil::DetectEncodings(*db);

#ifndef EMSCRIPTEN
				for (std::string &enc : encodings) {
					// Heuristic: Check title graphic, system graphic, cursor SE, title BGM
					// Pure ASCII is skipped as it provides no added value
					escape_symbol = lcf::ReaderUtil::Recode("\\", enc);
					if (escape_symbol.empty()) {
						// Bad encoding
						Output::Debug("Bad encoding: {}. Trying next.", enc);
						continue;
					}
					escape_char = Utils::DecodeUTF32(Player::escape_symbol).front();

					const auto& title_name = db->system.title_name;
					const auto& system_name = db->system.system_name;
					const auto& cursor_se = db->system.cursor_se.name;
					const auto& title_music = db->system.title_music.name;
					int check_max = 0;
					int check_okay = 0;

					if (db->system.show_title && !Utils::StringIsAscii(title_name)) {
						++check_max;
						check_okay += FileFinder::FindImage("Title", lcf::ReaderUtil::Recode(title_name, enc)).empty() ? 0 : 1;
					}

					if (!Utils::StringIsAscii(system_name)) {
						++check_max;
						check_okay += FileFinder::FindImage("System", lcf::ReaderUtil::Recode(system_name, enc)).empty() ? 0 : 1;
					}

					if (!Utils::StringIsAscii(cursor_se)) {
						++check_max;
						check_okay += FileFinder::FindSound(lcf::ReaderUtil::Recode(cursor_se, enc)).empty() ? 0 : 1;
					}

					if (db->system.show_title && !Utils::StringIsAscii(title_music)) {
						++check_max;
						check_okay += FileFinder::FindMusic(lcf::ReaderUtil::Recode(title_music, enc)).empty() ? 0 : 1;
					}

					if (check_max == check_okay) {
						// Looks like a good encoding
						encoding = enc;
						break;
					} else {
						Output::Debug("Detected encoding: {}. Files not found ({}/{}). Trying next.", enc, check_okay, check_max);
					}
				}
#endif
				if (!encodings.empty() && encoding.empty()) {
					// No encoding found that matches the files, maybe RTP missing.
					// Use the first one instead
					encoding = encodings.front();
				}
			}
		}

		escape_symbol = "";
		escape_char = 0;

		if (!encoding.empty()) {
			Output::Debug("Detected encoding: {}", encoding);
		} else {
			Output::Debug("Encoding not detected");
			encoding = lcf::ReaderUtil::GetLocaleEncoding();
		}
	}

	return encoding;
}

std::string Player::GetFullVersionString() {
	return std::string(GAME_TITLE) + " " + Version::GetVersionString();
}

void Player::PrintUsage() {
	std::cout <<
R"(EasyRPG Player - An open source interpreter for RPG Maker 2000/2003 games.

Engine options:
 --autobattle-algo A  Which AutoBattle algorithm to use.
                      Options:
                       RPG_RT  - The default RPG_RT compatible algo, including
                                 RPG_RT bugs.
                       RPG_RT+ - The default RPG_RT compatible algo, with bug-
                                 fixes.
                       ATTACK  - Like RPG_RT+ but only physical attacks, no
                                 skills.
 -c, --config-path P  Set a custom configuration path. When not specified, the
                      configuration folder in the users home directory is used.
 --encoding N         Instead of autodetecting the encoding or using the one in
                      RPG_RT.ini, the encoding N is used.
 --enemyai-algo A     Which EnemyAI algorithm to use.
                      Options:
                       RPG_RT  - The default RPG_RT compatible algo, including
                                 RPG_RT bugs.
                       RPG_RT+ - The default RPG_RT compatible algo, with bug-
                                 fixes.
 --engine ENGINE      Disable auto detection of the simulated engine.
                      Options:
                       rpg2k      - RPG Maker 2000 (v1.00 - v1.10)
                       rpg2kv150  - RPG Maker 2000 (v1.50 - v1.51)
                       rpg2ke     - RPG Maker 2000 (English release, v1.61)
                       rpg2k3     - RPG Maker 2003 (v1.00 - v1.04)
                       rpg2k3v105 - RPG Maker 2003 (v1.05 - v1.09a)
                       rpg2k3e    - RPG Maker 2003 (English release, v1.12)
 --font1 FILE         Font to use for the first font. The system graphic of the
                      game determines whether font 1 or 2 is used.
 --font1-size PX      Size of font 1 in pixel. The default is 12.
 --font2 FILE         Font to use for the second font.
 --font2-size PX      Size of font 2 in pixel. The default is 12.
 --font-path PATH     The path in which the settings scene looks for fonts.
                      The default is config-path/Font.
 --language LANG      Load the game translation in language/LANG folder.
 --load-game-id N     Skip the title scene and load SaveN.lsd (N is padded to
                      two digits).
 --log-file FILE      Path to the logfile. The Player will write diagnostic
                      messages to this file.
 --new-game           Skip the title scene and start a new game directly.
 --no-log-color       Disable colors in terminal log.
 --no-rtp             Disable support for the Runtime Package (RTP).
 --patch-antilag-switch SWITCH
                      Disables event page refreshing when the switch SWITCH is
                      enabled.
 --patch-common-this  Enable usage of "This Event" in common events in any
                      version of the engine.
 --patch-direct-menu VAR
                      Directly access subscreens of the default menu by setting
                      VAR.
 --patch-encounter-alert VAR
                      Set troop id to variable VAR and skip random battles.
 --patch-dynrpg       Enable support of DynRPG patch by Cherry (very limited).
 --patch-easyrpg      Enable EasyRPG extensions.
 --patch-key-patch    Enable Key Patch by Ineluki.
 --patch-maniac [N]   Enable Maniac Patch by BingShan. Values for N:
                       - 1: Enable the patch (default)
                       - 2: Enable the patch but do not adjust variable ranges
                            to 32 bit.
 --patch-pic-unlock   Picture movement is not interrupted by messages in any
                      version of the engine.
 --patch-rpg2k3-cmds  Support all RPG Maker 2003 event commands in any version
                      of the engine.
 --no-patch           Disable all engine patches. To disable a single patch,
                      prefix any of the patch options with --no-
 --project-path PATH  Instead of using the working directory, the game in PATH
                      is used.
 --record-input FILE  Record all button inputs to FILE.
 --replay-input FILE  Replays button presses from an input log generated by
                      --record-input.
 --rtp-path PATH      Add PATH to the RTP directory list and use this one with
                      highest precedence.
 --save-path PATH     Instead of storing save files in the game directory,
                      store them in PATH. When using the game browser all games
                      will share the same save directory!
 --seed N             Seeds the random number generator with N.

Providing any patch option disables the patch autodetection of the engine.

Video options:
 --fps-limit          In combination with --no-vsync sets a custom frames per
                      second limit. The default is 60 FPS. Use --no-fps-limit
                      to run with unlimited frames per second.
 --fullscreen         Start in fullscreen mode.
 --game-resolution R  Force a different game resolution. This is experimental
                      and can cause glitches or break games!
                      Options:
                       original   - 320x240 (4:3). Recommended
                       widescreen - 416x240 (16:9)
                       ultrawide  - 560x240 (21:9)
 --pause-focus-lost   Pause the game when the window has no focus.
                      Disable with --no-pause-focus-lost.
 --scaling S          How the video output is scaled.
                      Options:
                       nearest  - Scale to screen size. Fast, but causes scaling
                                  artifacts.
                       integer  - Scales to a multiple of the game resolution.
                       bilinear - Like nearest, but applies a bilinear filter to
                                  avoid artifacts.
 --show-fps           Enable display of the frames per second counter.
                      When in windowed mode it is shown inside the window.
                      When in fullscreen mode it is shown in the titlebar.
                      Use --fps-render-window to always show the counter inside
                      the window.
                      Disable with --no-show-fps.
 --stretch            Ignore the aspect ratio and stretch video output to the
                      entire width of the screen.
                      Disable with --no-stretch.
 --vsync              Enables vertical sync if supported on this platform.
                      Disable with --no-vsync.
 --window             Start in windowed mode.

Audio options:
 --no-audio           Disable audio (in case you prefer your own music).
 --music-volume V     Set volume of background music to V (0-100).
 --sound-volume V     Set volume of sound effects to V (0-100).
 --soundfont FILE     Soundfont in sf2 format to use when playing MIDI files.
 --soundfont-path P   The path in which the settings scene looks for soundfonts.
                      The default is config-path/Soundfont.

Debug options:
 --battle-test N...   Start a battle test.
                      This option supports two modes:
                      Providing a single N sets the monster party.
                      Providing four N sets: monster party, formation,
                      condition and terrain ID.
 --hide-title         Hide the title background image and center the command
                      menu.
 --start-map-id N     Overwrite the map used for new games and use MapN.lmu
                      instead (N is padded to four digits).
                      Incompatible with --load-game-id.
 --start-party A B... Overwrite the starting party members with the actors with
                      IDs A, B, C...
                      Incompatible with --load-game-id.
 --start-position X Y Overwrite the party start position and move the party to
                      position (X, Y).
                      Incompatible with --load-game-id.
 --test-play          Enable TestPlay (Debug) mode.

Other options:
 -v, --version        Display program version and exit.
 -h, --help           Display this help and exit.

For compatibility with the legacy RPG Maker runtime the following arguments
are supported:
 BattleTest N         Same as --battle-test.
                      The argument list starts at the 4th argument.
 HideTitle            Same as --hide-title.
 TestPlay             Same as --test-play.
 Window               Same as --window.

Game related parameters (e.g. new-game and load-game-id) do not work correctly
when the startup directory does not contain a valid game (and the game browser
loads)

Alex, EV0001 and the EasyRPG authors wish you a lot of fun!)" << std::endl;
}

bool Player::IsCP932() {
	if (Tr::HasActiveTranslation() && !Tr::GetCurrentLanguageCode().empty()) {
		return Tr::GetCurrentLanguageCode() == "ja_JP";
	}

	return (encoding == "ibm-943_P15A-2003" || encoding == "932");
}

bool Player::IsCP949() {
	if (Tr::HasActiveTranslation() && !Tr::GetCurrentLanguageCode().empty()) {
		return Tr::GetCurrentLanguageCode() == "ko_KR";
	}

	return (encoding == "windows-949-2000" || encoding == "windows-949" || encoding == "949");
}

bool Player::IsBig5() {
	if (Tr::HasActiveTranslation() && !Tr::GetCurrentLanguageCode().empty()) {
		return Tr::GetCurrentLanguageCode() == "zh_TW";
	}

	return (encoding == "Big5" || encoding == "windows-950" || encoding == "950");
}

bool Player::IsCP936() {
	if (Tr::HasActiveTranslation() && !Tr::GetCurrentLanguageCode().empty()) {
		return Tr::GetCurrentLanguageCode() == "zh_CN";
	}

	return (encoding == "windows-936-2000" || encoding == "windows-936" || encoding == "936");
}

bool Player::IsCJK() {
	return (IsCP932() || IsCP949() || IsBig5() || IsCP936());
}

bool Player::IsCP1251() {
	if (Tr::HasActiveTranslation() && !Tr::GetCurrentLanguageCode().empty()) {
		return Tr::GetCurrentLanguageCode() == "ru_RU";
	}

	return (encoding == "ibm-5347_P100-1998" || encoding == "windows-1251" || encoding == "1251");
}

int Player::EngineVersion() {
	if (IsRPG2k3()) return 2003;
	if (IsRPG2k()) return 2000;
	return 0;
}

std::string Player::GetEngineVersion() {
	if (EngineVersion() > 0) return std::to_string(EngineVersion());
	return std::string();
}


/*end of file .\player.cpp*/

/*start of file .\rand.cpp*/

/* ... license chunk ... */

// Headers
#include "rand.h"
#include "utils.h"
#include "output.h"
#include "compiler.h"
#include <cassert>
#include <cstdint>
#include <cinttypes>
#include <algorithm>
#include <random>

namespace {
Rand::RNG rng;

/** Gets a random number uniformly distributed in [0, U32_MAX] */
uint32_t GetRandomU32() { return rng(); }

int32_t rng_lock_value = 0;
bool rng_locked= false;
}

/** Generate a random number in the range [0,max] */
static uint32_t GetRandomUnsigned(uint32_t max)
{
	if (max == 0xffffffffull) return GetRandomU32();

	// Rejection sampling:
	// 1. Divide the range of uint32 into blocks of max+1
	//    numbers each, with rem numbers left over.
	// 2. Generate a random u32. If it belongs to a block,
	//    mod it into the range [0,max] and accept it.
	// 3. If it fell into the range of rem leftover numbers,
	//    reject it and go back to step 2.
	uint32_t m = max + 1;
	uint32_t rem = -m % m; // = 2^32 mod m
	while (true) {
		uint32_t n = GetRandomU32();
		if (n >= rem)
			return n % m;
	}
}

int32_t Rand::GetRandomNumber(int32_t from, int32_t to) {
	assert(from <= to);
	if (rng_locked) {
		return Utils::Clamp(rng_lock_value, from, to);
	}
	// Don't use uniform_int_distribution--the algorithm used isn't
	// portable between stdlibs.
	// We do from + (rand int in [0, to-from]). The miracle of two's
	// complement let's us do this all in unsigned and then just cast
	// back.
	uint32_t ufrom = uint32_t(from);
	uint32_t uto = uint32_t(to);
	uint32_t urange = uto - ufrom;
	uint32_t ures = ufrom + GetRandomUnsigned(urange);
	return int32_t(ures);
}

Rand::RNG& Rand::GetRNG() {
	return rng;
}

bool Rand::ChanceOf(int32_t n, int32_t m) {
	assert(n >= 0 && m > 0);
	return GetRandomNumber(1, m) <= n;
}

bool Rand::PercentChance(float rate) {
	constexpr auto scale = 0x1000000;
	return GetRandomNumber(0, scale-1) < int32_t(rate * scale);
}

bool Rand::PercentChance(int rate) {
	return GetRandomNumber(0, 99) < rate;
}

void Rand::SeedRandomNumberGenerator(int32_t seed) {
	rng.seed(seed);
	Output::Debug("Seeded the RNG with {}.", seed);
}

void Rand::LockRandom(int32_t value) {
	rng_locked = true;
	rng_lock_value = value;
}

void Rand::UnlockRandom() {
	rng_locked = false;
}

std::pair<bool,int32_t> Rand::GetRandomLocked() {
	return { rng_locked, rng_lock_value };
}

Rand::LockGuard::LockGuard(int32_t lock_value, bool locked) {
	auto p = GetRandomLocked();
	_prev_locked = p.first;
	_prev_lock_value = p.second;
	_active = true;

	if (locked) {
		LockRandom(lock_value);
	} else {
		UnlockRandom();
	}
}

void Rand::LockGuard::Release() noexcept {
	if (Enabled()) {
		if (_prev_locked) {
			LockRandom(_prev_lock_value);
		} else {
			UnlockRandom();
		}
		Dismiss();
	}
}


/*end of file .\rand.cpp*/

/*start of file .\rect.cpp*/

/* ... license chunk ... */

// Headers
#include "rect.h"

void Rect::Adjust(int max_width, int max_height) {
	if (x < 0) {
		width += x;
		x = 0;
	}
	if (y < 0) {
		height += y;
		y = 0;
	}
	if (x < max_width && y < max_height) {
		if (max_width < x + width) width = max_width - x;
		if (max_height < y + height) height = max_height - y;
	}
}

void Rect::Adjust(const Rect& rect) {
	if (x < rect.x) {
		width += x - rect.x;
		x = rect.x;
	}

	if (y < rect.y) {
		height += y - rect.y;
		y = rect.y;
	}

	if (rect.x + rect.width < x + width)
		width = rect.x + rect.width - x;

	if (rect.y + rect.height < y + height)
		height = rect.y + rect.height - y;
}

bool Rect::IsEmpty() const {
	return width <= 0 || height <= 0;
}

bool Rect::IsOutOfBounds(int max_width, int max_height) const {
	if (width <= 0 || height <= 0) return true;
	if (x >= max_width || y >= max_height) return true;
	if (x + width <= 0 || y + height <= 0) return true;
	return false;
}

bool Rect::IsOutOfBounds(const Rect &src_rect) const {
	if (width <= 0 || height <= 0) return true;
	if (x >= src_rect.x + src_rect.width || y >= src_rect.y + src_rect.height) return true;
	if (x + width <= src_rect.x || y + height <= src_rect.y) return true;
	return false;
}

Rect Rect::GetSubRect(const Rect src_rect) const {
	Rect rect = src_rect;

	rect.x += x;
	rect.y += y;

	if (rect.x < x) {
		rect.width -= x - rect.x;
		rect.x = x;
	}

	if (rect.y < y) {
		rect.height -= y - rect.y;
		rect.y = y;
	}

	if (rect.x + rect.width > x + width) {
		rect.width = x + width - rect.x;
	}

	if (rect.y + rect.height > y + height) {
		rect.height = y + height - rect.y;
	}

	return rect;
}

bool Rect::AdjustRectangles(Rect& src, Rect& dst, const Rect& ref) {
	if (src.x < ref.x) {
		int dx = ref.x - src.x;
		src.x += dx;
		dst.x += dx;
		src.width -= dx;
	}

	if (src.y < ref.y) {
		int dy = ref.y - src.y;
		src.y += dy;
		dst.y += dy;
		src.height -= dy;
	}

	if (src.x + src.width > ref.x + ref.width) {
		int dx = (src.x + src.width) - (ref.x + ref.width);
		src.width -= dx;
	}

	if (src.y + src.height > ref.y + ref.height) {
		int dy = (src.y + src.height) - (ref.y + ref.height);
		src.height -= dy;
	}

	dst.width = src.width;
	dst.height = src.height;

	return src.width > 0 && src.height > 0;
}



/*end of file .\rect.cpp*/

/*start of file .\registry.cpp*/

/* ... license chunk ... */

#ifdef _WIN32
#  include <windows.h>
#endif

#if defined(_WIN32) && !defined(_ARM_)

// Headers
#include <string>
#include "registry.h"
#include "utils.h"

/**
 * Adds Manifest depending on architecture.
 */
#ifdef _MSC_VER
	#if defined _M_IX86
	#pragma comment(linker, "/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
	#elif defined _M_X64
	#pragma comment(linker, "/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
	#else
	#pragma comment(linker, "/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
	#endif
#endif

std::string Registry::ReadStrValue(HKEY hkey, std::string_view key, std::string_view val, REGVIEW view) {
	char value[1024];
	DWORD size = 1024;
	DWORD type = REG_SZ;
	HKEY key_handle;
	REGSAM desired_access = KEY_QUERY_VALUE;

	switch (view) {
		case KEY32:
			desired_access |= KEY_WOW64_32KEY;
			break;
		case KEY64:
			desired_access |= KEY_WOW64_64KEY;
			break;
		case NATIVE:
		default:
			break;
	}

	std::wstring wkey = Utils::ToWideString(ToString(key));

	if (RegOpenKeyEx(hkey, wkey.c_str(), NULL, desired_access, &key_handle)) {
		return "";
	}

	std::wstring wval = Utils::ToWideString(ToString(val));

	if (RegQueryValueEx(key_handle, wval.c_str(), NULL, &type, (LPBYTE)&value, &size)) {
		return "";
	}
	RegCloseKey(key_handle);

	std::string string_value = "";
	for (unsigned int i = 0; i < size; i++) {
		if (value[i] != '\0' ) {
			string_value += value[i];
		}
	}
	return string_value;
}

int Registry::ReadBinValue(HKEY hkey, std::string_view key, std::string_view val, unsigned char* bin, REGVIEW view) {
	DWORD size = 1024;
	DWORD type = REG_BINARY;
	HKEY key_handle;
	REGSAM desired_access = KEY_QUERY_VALUE;

	switch (view) {
		case KEY32:
			desired_access |= KEY_WOW64_32KEY;
			break;
		case KEY64:
			desired_access |= KEY_WOW64_64KEY;
			break;
		case NATIVE:
		default:
			break;
	}

	std::wstring wkey = Utils::ToWideString(ToString(key));

	if (RegOpenKeyEx(hkey, wkey.c_str(), NULL, desired_access, &key_handle)) {
		return 0;
	}

	std::wstring wval = Utils::ToWideString(ToString(val));

	if (RegQueryValueEx(key_handle, wval.c_str(), NULL, &type, bin, &size)) {
		return 0;
	}
	RegCloseKey(key_handle);

	return size;
}

#endif


/*end of file .\registry.cpp*/

/*start of file .\registry_wine.cpp*/

/* ... license chunk ... */

#include "system.h"

#ifdef USE_WINE_REGISTRY

#include <cstdlib>
#include <fstream>
#include "registry.h"
#include "filefinder.h"
#include "output.h"
#include "utils.h"

/*
Wine registry file example:

[Software\\Wow6432Node\\ASCII\\RPG2000] 1554665942 9542200
#time=1d4ed798dfc6938
"FullScreenFlag"="0"
"RuntimePackagePath"="C:\\Program Files (x86)\\ASCII\\RPG2000\\RTP"
 */

std::string Registry::ReadStrValue(HKEY hkey, std::string_view key, std::string_view val, REGVIEW view) {
	std::string prefix =
			getenv("WINEPREFIX")? getenv("WINEPREFIX"):
			getenv("HOME")? std::string(getenv("HOME")).append("/.wine"):
			std::string();

	std::string registry_file;
	std::string string_value;
	std::string formatted_key = ToString(key);

	// Replaces key backslashes with double backslashes
	size_t pos = 0;
	while ((pos = formatted_key.find('\\', pos)) != std::string::npos) {
		formatted_key.replace(pos, 1, R"(\\)");
		pos += 2;
	}

	// Puts value between quotes and add =
	std::string formatted_val = "\"" + ToString(val) + "\""  + "=";

	if (prefix.empty() || !FileFinder::Root().Exists(prefix)) {
		Output::Debug("wine prefix not found: \"{}\"", prefix.c_str());
		return std::string("");
	}

	switch (hkey) {
		case HKEY_LOCAL_MACHINE:
			registry_file = prefix + "/system.reg";
			break;
		case HKEY_CURRENT_USER:
			registry_file = prefix + "/user.reg";
			break;
	}

	bool is_wine64 = FileFinder::Root().Exists(prefix + "/drive_c/windows/syswow64");
	bool use_redirect = (view == KEY32 && is_wine64);

	/* On 64bit Windows 32bit keys are redirected in some cases, see:
	 * https://msdn.microsoft.com/en-us/library/aa384253(v=vs.85).aspx
	 * We only support redirecting "Software" in HKLM.
	 */
	if (hkey == HKEY_LOCAL_MACHINE &&
		use_redirect && (formatted_key.rfind(R"(Software\\)", 0) == 0)) {
		pos = formatted_key.find(R"(\\)", 0);
		formatted_key.insert(pos, R"(\\Wow6432Node)");
	}

	// Custom, simple INI parser because liblcf ini is not efficient enough
	// (lcf ini stores all keys/values but we only need one)
	std::string formatted_key_search = "[" + Utils::LowerCaseInPlace(formatted_key) + "]";
	Utils::LowerCaseInPlace(formatted_val);
	std::string path;
	std::ifstream registry(registry_file);
	if (!registry) {
		return path;
	}

	bool in_section = false;
	std::string line;
	line.reserve(1024);
	do {
		std::getline(registry, line);
		if (!in_section) {
			if (line.empty() || line[0] != '[') {
				continue;
			} else if (StartsWith(Utils::LowerCaseInPlace(line), formatted_key_search)) {
				// Found the section
				in_section = true;
			}
		} else {
			if (!line.empty() && line[0] == '[') {
				// value not found
				break;
			}

			if (StartsWith(Utils::LowerCase(line), formatted_val)) {
				// value found
				string_value = line.substr(formatted_val.length());
				break;
			}
		}
	} while (!registry.eof());

	if (!string_value.empty()) {
		// Removes begin and end quotes but keeps all other inner just in case
		if (!string_value.empty()) {
			string_value.erase(0, 1);
		}
		if (!string_value.empty()) {
			string_value.erase(string_value.size() - 1, 1);
		}

		if (string_value.size() < 3
				|| !std::isupper(*string_value.begin())
				|| std::string(string_value.begin() + 1, string_value.begin() + 3) != R"(:\)") {
			return string_value;
		}

		// Replaces double backslashes with single backslashes
		pos = 0;
		while ((pos = string_value.find(R"(\\)", pos)) != std::string::npos) {
			string_value.replace(pos, 2, "/");
			pos += 1;
		}

		const char drive = std::tolower(*string_value.begin());

		if (drive == 'z') {
			path.assign(string_value.begin() + 2, string_value.end());
		} else {
			path.assign(prefix.append("/drive_"))
					.append(&drive, 1).append(string_value.begin() + 2, string_value.end());
		}
	}

	return path;
}

int Registry::ReadBinValue(HKEY, std::string_view, std::string_view, unsigned char*, REGVIEW) {
	return 0; // not really used yet
}

#endif


/*end of file .\registry_wine.cpp*/

/*start of file .\rtp.cpp*/

/* ... license chunk ... */

#include <algorithm>
#include <array>
#include <cassert>
#include <cstring>
#include "rtp.h"

static std::pair<int, int> get_table_idx(const char* const lookup_table[16], const int lookup_table_idx[16], std::string_view category) {
	int i;

	for (i = 0; lookup_table[i] != nullptr; ++i) {
		if (std::string_view(lookup_table[i]) == category) {
			return {lookup_table_idx[i], lookup_table_idx[i+1]};
		}
	}

	// Points at nullptr (final row) in the rtp table
	return {lookup_table_idx[i], lookup_table_idx[i]};
}

template <typename T>
static void detect_helper(const FilesystemView& fs, std::vector<struct RTP::RtpHitInfo>& hit_list,
		T rtp_table, int num_rtps, int offset, const std::pair<int, int>& range, Span<std::string_view> ext_list, int miss_limit) {
	std::string ret;
	for (int j = 1; j <= num_rtps; ++j) {
		int cur_miss = 0;
		for (int i = range.first; i < range.second; ++i) {
			const char* category = rtp_table[i][0];
			const char* name = rtp_table[i][j];
			if (name != nullptr) {
				// TODO: Filefinder refactor should provide FindImage etc. for non-project trees
				DirectoryTree::Args args = { FileFinder::MakePath(category, name), ext_list, 1, false };
				ret = fs.FindFile(args);
				if (!ret.empty()) {
					hit_list[offset + j - 1].hits++;
				} else {
					++cur_miss;
					if (cur_miss > miss_limit) {
						break;
					}
				}
			}
		}
	}
}

std::vector<RTP::RtpHitInfo> RTP::Detect(const FilesystemView& fs, int version, int miss_limit) {
	std::vector<struct RTP::RtpHitInfo> hit_list = {{
		{RTP::Type::RPG2000_OfficialJapanese, kTypes[0], 2000, 0, 465, fs},
		{RTP::Type::RPG2000_OfficialEnglish, kTypes[1], 2000, 0, 465, fs},
		{RTP::Type::RPG2000_DonMiguelEnglish, kTypes[2], 2000, 0, 500, fs},
		{RTP::Type::RPG2000_DonMiguelAddon, kTypes[3], 2000, 0, 503, fs},
		{RTP::Type::RPG2003_OfficialJapanese, kTypes[4], 2003, 0, 675, fs},
		{RTP::Type::RPG2003_OfficialEnglish, kTypes[5], 2003, 0, 675, fs},
		{RTP::Type::RPG2003_RpgAdvocateEnglish, kTypes[6], 2003, 0, 675, fs},
		{RTP::Type::RPG2003_VladRussian, kTypes[7], 2003, 0, 350, fs},
		{RTP::Type::RPG2003_RpgUniverseSpanishPortuguese, kTypes[8], 2003, 0, 600, fs},
		{RTP::Type::RPG2003_Korean, kTypes[9], 2003, 0, 675, fs},
		{RTP::Type::RPG2003_OfficialTraditionalChinese, kTypes[10], 2003, 0, 676, fs}
	}};

	auto SOUND_TYPES = Utils::MakeSvVector(".wav", ".mp3");
	auto MUSIC_TYPES = Utils::MakeSvVector(".wav", ".mid");
	auto MOVIE_TYPES = Utils::MakeSvVector(".avi");
	auto IMAGE_TYPES = Utils::MakeSvVector(".png");

	auto ext_for_cat = [=](const char* category) {
		if (!strcmp("sound", category)) {
			return SOUND_TYPES;
		} else if (!strcmp("music", category)) {
			return MUSIC_TYPES;
		} else if (!strcmp("movie", category)) {
			return MOVIE_TYPES;
		} else {
			return IMAGE_TYPES;
		}
	};

	if (version == 2000 || version == 0) {
		for (int i = 0; rtp_table_2k_categories[i] != nullptr; ++i) {
			const char* category = rtp_table_2k_categories[i];
			std::pair<int, int> range = {rtp_table_2k_categories_idx[i], rtp_table_2k_categories_idx[i+1]};
			auto ext_list = ext_for_cat(category);
			detect_helper(fs, hit_list, rtp_table_2k, num_2k_rtps, 0, range, ext_list, miss_limit);
		}
	}
	if (version == 2003 || version == 0) {
		for (int i = 0; rtp_table_2k3_categories[i] != nullptr; ++i) {
			const char* category = rtp_table_2k3_categories[i];
			std::pair<int, int> range = {rtp_table_2k3_categories_idx[i], rtp_table_2k3_categories_idx[i+1]};
			auto ext_list = ext_for_cat(category);
			detect_helper(fs, hit_list, rtp_table_2k3, num_2k3_rtps, num_2k_rtps, range, ext_list, miss_limit);
		}
	}

	// remove RTPs with zero hits
	for (auto it = hit_list.begin(); it != hit_list.end(); ) {
		if (it->hits == 0) {
			it = hit_list.erase(it);
		} else {
			++it;
		}
	}

	// sort by hit rate (best to worse)
	std::sort(hit_list.begin(), hit_list.end(), [](const struct RTP::RtpHitInfo& a, const struct RTP::RtpHitInfo& b) {
		return (float)a.hits / a.max > (float)b.hits / b.max;
	});

	return hit_list;
}

template <typename T>
static std::vector<RTP::Type> lookup_any_to_rtp_helper(T rtp_table, const std::pair<int, int>& range,
		std::string_view src_name, int num_rtps, int offset) {
	std::vector<RTP::Type> type_hits;

	for (int i = range.first; i < range.second; ++i) {
		for (int j = 1; j <= num_rtps; ++j) {
			const char* name = rtp_table[i][j];
			if (name != nullptr && src_name == std::string_view(name)) {
				type_hits.push_back((RTP::Type)(j - 1 + offset));
			}
		}
	}

	return type_hits;
}

std::vector<RTP::Type> RTP::LookupAnyToRtp(std::string_view src_category, std::string_view src_name, int version) {
	if (version == 2000) {
		auto tbl_idx = get_table_idx(rtp_table_2k_categories, rtp_table_2k_categories_idx, src_category);
		return lookup_any_to_rtp_helper(rtp_table_2k, tbl_idx, src_name, num_2k_rtps, 0);
	} else {
		auto tbl_idx = get_table_idx(rtp_table_2k3_categories, rtp_table_2k3_categories_idx, src_category);
		return lookup_any_to_rtp_helper(rtp_table_2k3, tbl_idx, src_name, num_2k3_rtps, num_2k_rtps);
	}
}

template <typename T>
static std::string lookup_rtp_to_rtp_helper(T rtp_table, const std::pair<int, int>& range,
		std::string_view src_name, int src_index, int dst_index, bool* is_rtp_asset) {

	for (int i = range.first; i < range.second; ++i) {
		const char* name = rtp_table[i][src_index + 1];
		if (name != nullptr && src_name == std::string_view(name)) {
			const char* dst_name = rtp_table[i][dst_index + 1];

			if (is_rtp_asset) {
				*is_rtp_asset = true;
			}

			return dst_name == nullptr ? "" : dst_name;
		}
	}

	if (is_rtp_asset) {
		*is_rtp_asset = false;
	}

	return "";
}

std::string RTP::LookupRtpToRtp(std::string_view src_category, std::string_view src_name, RTP::Type src_rtp,
		RTP::Type target_rtp, bool* is_rtp_asset) {
	// ensure both 2k or 2k3
	assert(((int)src_rtp < num_2k_rtps && (int)target_rtp < num_2k_rtps) ||
		((int)src_rtp >= num_2k_rtps && (int)target_rtp >= num_2k_rtps));

	if (src_rtp == target_rtp) {
		// Design limitation: When game_rtp == installed rtp can't tell if it is a rtp asset, this needs a table scan
		if (is_rtp_asset) {
			*is_rtp_asset = false;
		}
		return ToString(src_name);
	}

	if ((int)src_rtp < num_2k_rtps) {
		auto tbl_idx = get_table_idx(rtp_table_2k_categories, rtp_table_2k_categories_idx, src_category);
		return lookup_rtp_to_rtp_helper(rtp_table_2k, tbl_idx, src_name, (int)src_rtp, (int)target_rtp, is_rtp_asset);
	} else {
		auto tbl_idx = get_table_idx(rtp_table_2k3_categories, rtp_table_2k3_categories_idx, src_category);
		return lookup_rtp_to_rtp_helper(rtp_table_2k3, tbl_idx, src_name, (int)src_rtp - num_2k_rtps, (int)target_rtp - num_2k_rtps, is_rtp_asset);
	}
}


/*end of file .\rtp.cpp*/

/*start of file .\rtp_table.cpp*/

/* ... license chunk ... */

#include "rtp.h"

namespace RTP {
/*
RPG 2000 RTP Table
- Official Japanese
- Official English
- Don Miguel English Translation
- Don Miguel RTP Addon

RPG 2003 RTP Table
- Official Japanese
- Official English
- RPG Advocate English Translation
- Vlad Russian Translation
- RPG Universe Spanish/Portuguese Translation
- Korean Translation
- Official Traditional Chinese
*/

const char* const rtp_table_2k[][5] = {
	{"backdrop", "ダンジョン1", "dungeon1", "cave1", nullptr},
	{"backdrop", "ダンジョン2", "dungeon2", "lavacave2", nullptr},
	{"backdrop", "ダンジョン3", "dungeon3", "icecave3", nullptr},
	{"backdrop", "ダンジョン4", "dungeon4", "cave4", nullptr},
	{"backdrop", "ダンジョン5", "dungeon5", "brickcave5", nullptr},
	{"backdrop", "宇宙", "space", "galaxy", nullptr},
	{"backdrop", "山道", "mountainpath", "canyon", nullptr},
	{"backdrop", "岩場", "rockyarea", "snowcanyon", nullptr},
	{"backdrop", "廃墟", "ruins", "wasteruins", nullptr},
	{"backdrop", "森1", "forest1", "forest1", nullptr},
	{"backdrop", "森2", "forest2", "forest2", nullptr},
	{"backdrop", "橋", "bridge", "bridge", nullptr},
	{"backdrop", "毒沼", "poisonswamp", "swamp", nullptr},
	{"backdrop", "海", "sea", "sea", nullptr},
	{"backdrop", "玉座", "throne", "castle", nullptr},
	{"backdrop", "異空間", "strangespace", "lightspeed", nullptr},
	{"backdrop", "砂浜", "sandybeach", "seabeach", nullptr},
	{"backdrop", "砂漠", "desert", "desert", nullptr},
	{"backdrop", "神殿", "shrine", "greece", nullptr},
	{"backdrop", "空", "sky", "sky", nullptr},
	{"backdrop", "船上", "shipdeck", "ship", nullptr},
	{"backdrop", "草原", "grassland", "grass", nullptr},
	{"backdrop", "荒地", "wasteland", "wasteland", nullptr},
	{"backdrop", "街中", "downtown", "town", nullptr},
	{"backdrop", "雪原", "snowfield", "snow", nullptr},
	{"backdrop", nullptr, nullptr, nullptr, "cave9"},
	{"backdrop", nullptr, nullptr, nullptr, "dark3"},
	{"backdrop", nullptr, nullptr, nullptr, "desert5"},
	{"backdrop", nullptr, nullptr, nullptr, "dungeon1"},
	{"backdrop", nullptr, nullptr, nullptr, "dungeon2"},
	{"backdrop", nullptr, nullptr, nullptr, "falls2"},
	{"backdrop", nullptr, nullptr, nullptr, "forest4"},
	{"backdrop", nullptr, nullptr, nullptr, "future1"},
	{"backdrop", nullptr, nullptr, nullptr, "future3"},
	{"backdrop", nullptr, nullptr, nullptr, "mtn4"},
	{"backdrop", nullptr, nullptr, nullptr, "nbridge"},
	{"backdrop", nullptr, nullptr, nullptr, "plainsg"},
	{"backdrop", nullptr, nullptr, nullptr, "ship1"},
	{"backdrop", nullptr, nullptr, nullptr, "underw1"},
	{"battle", "その他", "other", "etc", nullptr},
	{"battle", "バリア", "barrier", "barrier", nullptr},
	{"battle", "ブレス", "breath", "poison", nullptr},
	{"battle", "上昇", "buff", "up", nullptr},
	{"battle", "下降", "debuff", "down", nullptr},
	{"battle", "冷気", "ice", "cold", nullptr},
	{"battle", "剣1", "sword1", "sword1", nullptr},
	{"battle", "剣2", "sword2", "sword2", nullptr},
	{"battle", "吸収", "bite", "absorption", nullptr},
	{"battle", "回復", "recovery", "sun", nullptr},
	{"battle", "大地", "earth", "earth", nullptr},
	{"battle", "打撃", "blow", "hit", nullptr},
	{"battle", "斧", "axe", "axe", nullptr},
	{"battle", "暗黒", "dark", "dark", nullptr},
	{"battle", "槍", "spear", "spear", nullptr},
	{"battle", "水", "water", "water", nullptr},
	{"battle", "治療", "treatment", "sphere", nullptr},
	{"battle", "炎1", "fire1", "fire1", nullptr},
	{"battle", "炎2", "fire2", "fire2", nullptr},
	{"battle", "爆発", "explosion", "explosion", nullptr},
	{"battle", "爪", "claw", "fang", nullptr},
	{"battle", "矢", "arrow", "arrow", nullptr},
	{"battle", "神聖", "holy", "holy", nullptr},
	{"battle", "蘇生", "ressurection", "ray", nullptr},
	{"battle", "雷", "thunder", "zip", nullptr},
	{"battle", "鞭", "whip", "whip", nullptr},
	{"battle", "風", "wind", "wind", nullptr},
	{"battle", "麻痺", "paralysis", "paralysis", nullptr},
	{"battle", nullptr, nullptr, nullptr, "enemyhp"},
	{"battle", nullptr, nullptr, nullptr, "qande"},
	{"charset", "オブジェクト1", "object1", "object1", nullptr},
	{"charset", "オブジェクト2", "object2", "object2", nullptr},
	{"charset", "モンスター1", "monster1", "monster1", nullptr},
	{"charset", "モンスター2", "monster2", "monster2", nullptr},
	{"charset", "一般1", "people1", "people1", nullptr},
	{"charset", "一般2", "people2", "people7", nullptr},
	{"charset", "一般3", "people3", "people3", nullptr},
	{"charset", "一般4", "people4", "people4", nullptr},
	{"charset", "一般5", "people5", "people5", nullptr},
	{"charset", "主人公1", "actor1", "chara1", nullptr},
	{"charset", "主人公2", "actor2", "chara2", nullptr},
	{"charset", "主人公3", "actor3", "chara3", nullptr},
	{"charset", "主人公4", "actor4", "chara4", nullptr},
	{"charset", "乗り物", "vehicles", "vehicle", nullptr},
	{"charset", "動物", "animal", "animal", nullptr},
	{"charset", nullptr, nullptr, "chubby1", nullptr},
	{"charset", nullptr, nullptr, "chubby2", nullptr},
	{"charset", nullptr, nullptr, "crown1", nullptr},
	{"charset", nullptr, nullptr, "crown2", nullptr},
	{"charset", nullptr, nullptr, "crown3", nullptr},
	{"charset", nullptr, nullptr, "crown4", nullptr},
	{"charset", nullptr, nullptr, "crown5", nullptr},
	{"charset", nullptr, nullptr, "crown6", nullptr},
	{"charset", nullptr, nullptr, "crown7", nullptr},
	{"charset", nullptr, nullptr, "future1", nullptr},
	{"charset", nullptr, nullptr, "future2", nullptr},
	{"charset", nullptr, nullptr, "future3", nullptr},
	{"charset", nullptr, nullptr, "men1", nullptr},
	{"charset", nullptr, nullptr, "women1", nullptr},
	{"charset", nullptr, nullptr, nullptr, "actraiser3.1"},
	{"charset", nullptr, nullptr, nullptr, "african"},
	{"charset", nullptr, nullptr, nullptr, "alex"},
	{"charset", nullptr, nullptr, nullptr, "alien3"},
	{"charset", nullptr, nullptr, nullptr, "alien4"},
	{"charset", nullptr, nullptr, nullptr, "angel"},
	{"charset", nullptr, nullptr, nullptr, "arquivo-x"},
	{"charset", nullptr, nullptr, nullptr, "bahamut_lagoon"},
	{"charset", nullptr, nullptr, nullptr, "bartender"},
	{"charset", nullptr, nullptr, nullptr, "bloodydoors"},
	{"charset", nullptr, nullptr, nullptr, "brats01"},
	{"charset", nullptr, nullptr, nullptr, "breathoffire4"},
	{"charset", nullptr, nullptr, nullptr, "brian"},
	{"charset", nullptr, nullptr, nullptr, "chara01"},
	{"charset", nullptr, nullptr, nullptr, "chara02"},
	{"charset", nullptr, nullptr, nullptr, "chara03"},
	{"charset", nullptr, nullptr, nullptr, "chara04"},
	{"charset", nullptr, nullptr, nullptr, "chara05"},
	{"charset", nullptr, nullptr, nullptr, "chara06"},
	{"charset", nullptr, nullptr, nullptr, "chara07"},
	{"charset", nullptr, nullptr, nullptr, "chara08"},
	{"charset", nullptr, nullptr, nullptr, "chara09"},
	{"charset", nullptr, nullptr, nullptr, "chara10"},
	{"charset", nullptr, nullptr, nullptr, "chara11"},
	{"charset", nullptr, nullptr, nullptr, "chara12"},
	{"charset", nullptr, nullptr, nullptr, "chara13"},
	{"charset", nullptr, nullptr, nullptr, "chara14"},
	{"charset", nullptr, nullptr, nullptr, "chara15"},
	{"charset", nullptr, nullptr, nullptr, "chara16"},
	{"charset", nullptr, nullptr, nullptr, "chara6gold"},
	{"charset", nullptr, nullptr, nullptr, "charaa1"},
	{"charset", nullptr, nullptr, nullptr, "charaa2"},
	{"charset", nullptr, nullptr, nullptr, "chara_c1"},
	{"charset", nullptr, nullptr, nullptr, "chara_c2"},
	{"charset", nullptr, nullptr, nullptr, "chara_h_9"},
	{"charset", nullptr, nullptr, nullptr, "chara_misc_1"},
	{"charset", nullptr, nullptr, nullptr, "chubby2b"},
	{"charset", nullptr, nullptr, nullptr, "crosshairandtargets"},
	{"charset", nullptr, nullptr, nullptr, "crystals"},
	{"charset", nullptr, nullptr, nullptr, "ctchar"},
	{"charset", nullptr, nullptr, nullptr, "ctportal"},
	{"charset", nullptr, nullptr, nullptr, "dbz_chara1"},
	{"charset", nullptr, nullptr, nullptr, "dbz_chara2"},
	{"charset", nullptr, nullptr, nullptr, "dbz_orig1"},
	{"charset", nullptr, nullptr, nullptr, "don_chara1"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_10"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_11"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_12"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_13"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_14"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_15"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_16"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_17"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_18"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_19"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_1"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_20"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_21"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_22"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_23"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_24"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_25"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_26"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_27"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_28"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_2"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_3"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_4"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_5"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_6"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_7"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_8"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_9"},
	{"charset", nullptr, nullptr, nullptr, "don_collection_mm"},
	{"charset", nullptr, nullptr, nullptr, "don_fish"},
	{"charset", nullptr, nullptr, nullptr, "don_pikachuu"},
	{"charset", nullptr, nullptr, nullptr, "don_pokeballz"},
	{"charset", nullptr, nullptr, nullptr, "don_xfiles"},
	{"charset", nullptr, nullptr, nullptr, "earthbound1"},
	{"charset", nullptr, nullptr, nullptr, "earthbound2"},
	{"charset", nullptr, nullptr, nullptr, "earthbound3"},
	{"charset", nullptr, nullptr, nullptr, "earthboundsheet"},
	{"charset", nullptr, nullptr, nullptr, "edit1"},
	{"charset", nullptr, nullptr, nullptr, "egyptian"},
	{"charset", nullptr, nullptr, nullptr, "eskimo"},
	{"charset", nullptr, nullptr, nullptr, "evil1"},
	{"charset", nullptr, nullptr, nullptr, "expression"},
	{"charset", nullptr, nullptr, nullptr, "ff3_soldiers"},
	{"charset", nullptr, nullptr, nullptr, "ff7_chara1"},
	{"charset", nullptr, nullptr, nullptr, "ff83"},
	{"charset", nullptr, nullptr, nullptr, "ff9chara"},
	{"charset", nullptr, nullptr, nullptr, "fft_archers"},
	{"charset", nullptr, nullptr, nullptr, "fft_thieves"},
	{"charset", nullptr, nullptr, nullptr, "flags_n_chests"},
	{"charset", nullptr, nullptr, nullptr, "free01"},
	{"charset", nullptr, nullptr, nullptr, "free02"},
	{"charset", nullptr, nullptr, nullptr, "free03"},
	{"charset", nullptr, nullptr, nullptr, "free04"},
	{"charset", nullptr, nullptr, nullptr, "future_soldiers1"},
	{"charset", nullptr, nullptr, nullptr, "fx_chara16"},
	{"charset", nullptr, nullptr, nullptr, "gohanssj1-2"},
	{"charset", nullptr, nullptr, nullptr, "goldendoors"},
	{"charset", nullptr, nullptr, nullptr, "greece"},
	{"charset", nullptr, nullptr, nullptr, "houshin5"},
	{"charset", nullptr, nullptr, nullptr, "illustset1"},
	{"charset", nullptr, nullptr, nullptr, "islander"},
	{"charset", nullptr, nullptr, nullptr, "items_1"},
	{"charset", nullptr, nullptr, nullptr, "items_2"},
	{"charset", nullptr, nullptr, nullptr, "items_3"},
	{"charset", nullptr, nullptr, nullptr, "link"},
	{"charset", nullptr, nullptr, nullptr, "linofull"},
	{"charset", nullptr, nullptr, nullptr, "mario"},
	{"charset", nullptr, nullptr, nullptr, "megaman1"},
	{"charset", nullptr, nullptr, nullptr, "minato_c"},
	{"charset", nullptr, nullptr, nullptr, "mk"},
	{"charset", nullptr, nullptr, nullptr, "mohawk"},
	{"charset", nullptr, nullptr, nullptr, "newaya"},
	{"charset", nullptr, nullptr, nullptr, "object3"},
	{"charset", nullptr, nullptr, nullptr, "object6"},
	{"charset", nullptr, nullptr, nullptr, "object9"},
	{"charset", nullptr, nullptr, nullptr, "objecta"},
	{"charset", nullptr, nullptr, nullptr, "objectb"},
	{"charset", nullptr, nullptr, nullptr, "objectc"},
	{"charset", nullptr, nullptr, nullptr, "objectd"},
	{"charset", nullptr, nullptr, nullptr, "objecte"},
	{"charset", nullptr, nullptr, nullptr, "objectf"},
	{"charset", nullptr, nullptr, nullptr, "objectg"},
	{"charset", nullptr, nullptr, nullptr, "objecth"},
	{"charset", nullptr, nullptr, nullptr, "objecti"},
	{"charset", nullptr, nullptr, nullptr, "objectj"},
	{"charset", nullptr, nullptr, nullptr, "objectk"},
	{"charset", nullptr, nullptr, nullptr, "objectl"},
	{"charset", nullptr, nullptr, nullptr, "objects3"},
	{"charset", nullptr, nullptr, nullptr, "omek"},
	{"charset", nullptr, nullptr, nullptr, "patrick"},
	{"charset", nullptr, nullptr, nullptr, "pirate"},
	{"charset", nullptr, nullptr, nullptr, "pose19"},
	{"charset", nullptr, nullptr, nullptr, "pose2"},
	{"charset", nullptr, nullptr, nullptr, "pose3"},
	{"charset", nullptr, nullptr, nullptr, "pose"},
	{"charset", nullptr, nullptr, nullptr, "poses_kirby_dolphin"},
	{"charset", nullptr, nullptr, nullptr, "pw_chara"},
	{"charset", nullptr, nullptr, nullptr, "robot"},
	{"charset", nullptr, nullptr, nullptr, "robots1"},
	{"charset", nullptr, nullptr, nullptr, "rolf'sarmy1"},
	{"charset", nullptr, nullptr, nullptr, "rolf'sarmy2"},
	{"charset", nullptr, nullptr, nullptr, "rs3_1"},
	{"charset", nullptr, nullptr, nullptr, "sailormoon1"},
	{"charset", nullptr, nullptr, nullptr, "savepoint"},
	{"charset", nullptr, nullptr, nullptr, "set_ggi1"},
	{"charset", nullptr, nullptr, nullptr, "set_hei1"},
	{"charset", nullptr, nullptr, nullptr, "set_ipa1"},
	{"charset", nullptr, nullptr, nullptr, "set_ipa2"},
	{"charset", nullptr, nullptr, nullptr, "set_ken1"},
	{"charset", nullptr, nullptr, nullptr, "set_mon1"},
	{"charset", nullptr, nullptr, nullptr, "simchara"},
	{"charset", nullptr, nullptr, nullptr, "simpsons"},
	{"charset", nullptr, nullptr, nullptr, "slime1"},
	{"charset", nullptr, nullptr, nullptr, "slime2"},
	{"charset", nullptr, nullptr, nullptr, "soldiers_brats"},
	{"charset", nullptr, nullptr, nullptr, "soldiers"},
	{"charset", nullptr, nullptr, nullptr, "sparkleitems_1"},
	{"charset", nullptr, nullptr, nullptr, "sparkleitems_2"},
	{"charset", nullptr, nullptr, nullptr, "sparkleitems_3"},
	{"charset", nullptr, nullptr, nullptr, "sparkleitems_4"},
	{"charset", nullptr, nullptr, nullptr, "ss4gku_futrbulma"},
	{"charset", nullptr, nullptr, nullptr, "staroc1"},
	{"charset", nullptr, nullptr, nullptr, "starwar1"},
	{"charset", nullptr, nullptr, nullptr, "starwar2"},
	{"charset", nullptr, nullptr, nullptr, "sv"},
	{"charset", nullptr, nullptr, nullptr, "tenchi"},
	{"charset", nullptr, nullptr, nullptr, "torch_1"},
	{"charset", nullptr, nullptr, nullptr, "torch"},
	{"charset", nullptr, nullptr, nullptr, "treasure"},
	{"charset", nullptr, nullptr, nullptr, "vegetable"},
	{"charset", nullptr, nullptr, nullptr, "vehicle3"},
	{"charset", nullptr, nullptr, nullptr, "window"},
	{"charset", nullptr, nullptr, nullptr, "wizard"},
	{"charset", nullptr, nullptr, nullptr, "x-files_lh"},
	{"charset", nullptr, nullptr, nullptr, "xfmainchars2"},
	{"charset", nullptr, nullptr, nullptr, "xfmainchars"},
	{"charset", nullptr, nullptr, nullptr, "xmas_chara1"},
	{"charset", nullptr, nullptr, nullptr, "x-men-movie"},
	{"charset", nullptr, nullptr, nullptr, "zlightup"},
	{"chipset", "ダンジョン", "dungeon", "dungeon", nullptr},
	{"chipset", "内装", "interior", "inner", nullptr},
	{"chipset", "基本", "world", "basis", nullptr},
	{"chipset", "外観", "exterior", "outline", nullptr},
	{"chipset", "船", "ship", "ship", nullptr},
	{"chipset", nullptr, nullptr, "chipset1", nullptr},
	{"chipset", nullptr, nullptr, "chipset2", nullptr},
	{"chipset", nullptr, nullptr, "chipset3", nullptr},
	{"chipset", nullptr, nullptr, nullptr, "2ktownset"},
	{"chipset", nullptr, nullptr, nullptr, "3d_castl"},
	{"chipset", nullptr, nullptr, nullptr, "3d_inner"},
	{"chipset", nullptr, nullptr, nullptr, "3d_town"},
	{"chipset", nullptr, nullptr, nullptr, "3d_town_"},
	{"chipset", nullptr, nullptr, nullptr, "airship1"},
	{"chipset", nullptr, nullptr, nullptr, "airship2"},
	{"chipset", nullptr, nullptr, nullptr, "airship4"},
	{"chipset", nullptr, nullptr, nullptr, "air_ship"},
	{"chipset", nullptr, nullptr, nullptr, "army"},
	{"chipset", nullptr, nullptr, nullptr, "bof22_b"},
	{"chipset", nullptr, nullptr, nullptr, "bof22"},
	{"chipset", nullptr, nullptr, nullptr, "bof2"},
	{"chipset", nullptr, nullptr, nullptr, "bof"},
	{"chipset", nullptr, nullptr, nullptr, "boxing_r"},
	{"chipset", nullptr, nullptr, nullptr, "casino"},
	{"chipset", nullptr, nullptr, nullptr, "castle_2_"},
	{"chipset", nullptr, nullptr, nullptr, "castle"},
	{"chipset", nullptr, nullptr, nullptr, "chipset10"},
	{"chipset", nullptr, nullptr, nullptr, "chipset11b"},
	{"chipset", nullptr, nullptr, nullptr, "chipset11"},
	{"chipset", nullptr, nullptr, nullptr, "chipset12"},
	{"chipset", nullptr, nullptr, nullptr, "chipset13b"},
	{"chipset", nullptr, nullptr, nullptr, "chipset13"},
	{"chipset", nullptr, nullptr, nullptr, "chipset14"},
	{"chipset", nullptr, nullptr, nullptr, "chipset15"},
	{"chipset", nullptr, nullptr, nullptr, "chipset17"},
	{"chipset", nullptr, nullptr, nullptr, "chipset18"},
	{"chipset", nullptr, nullptr, nullptr, "chipset19"},
	{"chipset", nullptr, nullptr, nullptr, "chipset1old"},
	{"chipset", nullptr, nullptr, nullptr, "chipset_1"},
	{"chipset", nullptr, nullptr, nullptr, "chipset20"},
	{"chipset", nullptr, nullptr, nullptr, "chipset2old"},
	{"chipset", nullptr, nullptr, nullptr, "chipset_2"},
	{"chipset", nullptr, nullptr, nullptr, "chipset_3"},
	{"chipset", nullptr, nullptr, nullptr, "chipset4"},
	{"chipset", nullptr, nullptr, nullptr, "chipset5b"},
	{"chipset", nullptr, nullptr, nullptr, "chipset5c"},
	{"chipset", nullptr, nullptr, nullptr, "chipset5"},
	{"chipset", nullptr, nullptr, nullptr, "chipset6b"},
	{"chipset", nullptr, nullptr, nullptr, "chipset6c"},
	{"chipset", nullptr, nullptr, nullptr, "chipset6"},
	{"chipset", nullptr, nullptr, nullptr, "chipset7"},
	{"chipset", nullptr, nullptr, nullptr, "chipset8"},
	{"chipset", nullptr, nullptr, nullptr, "chipset9"},
	{"chipset", nullptr, nullptr, nullptr, "chronohouses"},
	{"chipset", nullptr, nullptr, nullptr, "darktown"},
	{"chipset", nullptr, nullptr, nullptr, "darkworld"},
	{"chipset", nullptr, nullptr, nullptr, "dumalchipset01"},
	{"chipset", nullptr, nullptr, nullptr, "dungeon2"},
	{"chipset", nullptr, nullptr, nullptr, "dw3"},
	{"chipset", nullptr, nullptr, nullptr, "earthboundchips_2"},
	{"chipset", nullptr, nullptr, nullptr, "earthboundchips"},
	{"chipset", nullptr, nullptr, nullptr, "ebchip_00"},
	{"chipset", nullptr, nullptr, nullptr, "ebinnerchips"},
	{"chipset", nullptr, nullptr, nullptr, "ff62"},
	{"chipset", nullptr, nullptr, nullptr, "ff6_airship"},
	{"chipset", nullptr, nullptr, nullptr, "ff6_inner"},
	{"chipset", nullptr, nullptr, nullptr, "ff6"},
	{"chipset", nullptr, nullptr, nullptr, "ff6_town"},
	{"chipset", nullptr, nullptr, nullptr, "forest"},
	{"chipset", nullptr, nullptr, nullptr, "forest_t"},
	{"chipset", nullptr, nullptr, nullptr, "future_i"},
	{"chipset", nullptr, nullptr, nullptr, "future_w"},
	{"chipset", nullptr, nullptr, nullptr, "golden1"},
	{"chipset", nullptr, nullptr, nullptr, "grey_cas"},
	{"chipset", nullptr, nullptr, nullptr, "hell"},
	{"chipset", nullptr, nullptr, nullptr, "house2"},
	{"chipset", nullptr, nullptr, nullptr, "house3"},
	{"chipset", nullptr, nullptr, nullptr, "house4"},
	{"chipset", nullptr, nullptr, nullptr, "house5"},
	{"chipset", nullptr, nullptr, nullptr, "house"},
	{"chipset", nullptr, nullptr, nullptr, "japanese_town"},
	{"chipset", nullptr, nullptr, nullptr, "lufia2_b"},
	{"chipset", nullptr, nullptr, nullptr, "lufia2_d"},
	{"chipset", nullptr, nullptr, nullptr, "lufia2_house"},
	{"chipset", nullptr, nullptr, nullptr, "lufia2"},
	{"chipset", nullptr, nullptr, nullptr, "lufia2_t"},
	{"chipset", nullptr, nullptr, nullptr, "map_town01"},
	{"chipset", nullptr, nullptr, nullptr, "minato1"},
	{"chipset", nullptr, nullptr, nullptr, "modern2"},
	{"chipset", nullptr, nullptr, nullptr, "modern3"},
	{"chipset", nullptr, nullptr, nullptr, "modern_b"},
	{"chipset", nullptr, nullptr, nullptr, "modern_c"},
	{"chipset", nullptr, nullptr, nullptr, "modern"},
	{"chipset", nullptr, nullptr, nullptr, "modern_world"},
	{"chipset", nullptr, nullptr, nullptr, "modified"},
	{"chipset", nullptr, nullptr, nullptr, "outcastle"},
	{"chipset", nullptr, nullptr, nullptr, "phantasystar"},
	{"chipset", nullptr, nullptr, nullptr, "pocket_m"},
	{"chipset", nullptr, nullptr, nullptr, "pokemontiles"},
	{"chipset", nullptr, nullptr, nullptr, "ps4"},
	{"chipset", nullptr, nullptr, nullptr, "robotrektown"},
	{"chipset", nullptr, nullptr, nullptr, "rs3"},
	{"chipset", nullptr, nullptr, nullptr, "school_chipset"},
	{"chipset", nullptr, nullptr, nullptr, "sd3_b"},
	{"chipset", nullptr, nullptr, nullptr, "sd3_c"},
	{"chipset", nullptr, nullptr, nullptr, "sd3_d"},
	{"chipset", nullptr, nullptr, nullptr, "sd3"},
	{"chipset", nullptr, nullptr, nullptr, "sompalace2"},
	{"chipset", nullptr, nullptr, nullptr, "sompalace"},
	{"chipset", nullptr, nullptr, nullptr, "som"},
	{"chipset", nullptr, nullptr, nullptr, "space"},
	{"chipset", nullptr, nullptr, nullptr, "suik2heroshouse"},
	{"chipset", nullptr, nullptr, nullptr, "suik2house"},
	{"chipset", nullptr, nullptr, nullptr, "suik2inside"},
	{"chipset", nullptr, nullptr, nullptr, "suik2kyaroinside"},
	{"chipset", nullptr, nullptr, nullptr, "suik2kyaro"},
	{"chipset", nullptr, nullptr, nullptr, "terranig"},
	{"chipset", nullptr, nullptr, nullptr, "topcity"},
	{"chipset", nullptr, nullptr, nullptr, "top-totus"},
	{"chipset", nullptr, nullptr, nullptr, "town_21"},
	{"chipset", nullptr, nullptr, nullptr, "town2"},
	{"chipset", nullptr, nullptr, nullptr, "town3"},
	{"chipset", nullptr, nullptr, nullptr, "town4"},
	{"chipset", nullptr, nullptr, nullptr, "townset_greg"},
	{"chipset", nullptr, nullptr, nullptr, "underground"},
	{"chipset", nullptr, nullptr, nullptr, "village3"},
	{"chipset", nullptr, nullptr, nullptr, "village"},
	{"chipset", nullptr, nullptr, nullptr, "white"},
	{"chipset", nullptr, nullptr, nullptr, "woods"},
	{"chipset", nullptr, nullptr, nullptr, "world2"},
	{"chipset", nullptr, nullptr, nullptr, "world"},
	{"chipset", nullptr, nullptr, nullptr, "xfileschipset1"},
	{"chipset", nullptr, nullptr, nullptr, "zelda3_b"},
	{"chipset", nullptr, nullptr, nullptr, "zelda3_d"},
	{"chipset", nullptr, nullptr, nullptr, "zelda3"},
	{"chipset", nullptr, nullptr, nullptr, "zeldadw"},
	{"faceset", "モンスター", "monster", "monsters", nullptr},
	{"faceset", "一般1", "people1", "people1", nullptr},
	{"faceset", "一般2", "people2", "people2", nullptr},
	{"faceset", "主人公1", "actor1", "chara1", nullptr},
	{"faceset", "主人公2", "actor2", "chara2", nullptr},
	{"faceset", nullptr, nullptr, "face1", nullptr},
	{"faceset", nullptr, nullptr, "face2", nullptr},
	{"faceset", nullptr, nullptr, "face3", nullptr},
	{"faceset", nullptr, nullptr, "face4", nullptr},
	{"faceset", nullptr, nullptr, nullptr, "anime3"},
	{"faceset", nullptr, nullptr, nullptr, "atelier_b"},
	{"faceset", nullptr, nullptr, nullptr, "atelier"},
	{"faceset", nullptr, nullptr, nullptr, "bof2"},
	{"faceset", nullptr, nullptr, nullptr, "bulma"},
	{"faceset", nullptr, nullptr, nullptr, "ccfaces1"},
	{"faceset", nullptr, nullptr, nullptr, "ccfaces2"},
	{"faceset", nullptr, nullptr, nullptr, "ccfaces3"},
	{"faceset", nullptr, nullptr, nullptr, "cc"},
	{"faceset", nullptr, nullptr, nullptr, "ch01_all"},
	{"faceset", nullptr, nullptr, nullptr, "chrono_face"},
	{"faceset", nullptr, nullptr, nullptr, "cool"},
	{"faceset", nullptr, nullptr, nullptr, "ct2"},
	{"faceset", nullptr, nullptr, nullptr, "dbz_b"},
	{"faceset", nullptr, nullptr, nullptr, "dbz_c"},
	{"faceset", nullptr, nullptr, nullptr, "dbz_face_1"},
	{"faceset", nullptr, nullptr, nullptr, "dbz_face1"},
	{"faceset", nullptr, nullptr, nullptr, "dbzface1"},
	{"faceset", nullptr, nullptr, nullptr, "dbz_face_2"},
	{"faceset", nullptr, nullptr, nullptr, "dbz_face_3"},
	{"faceset", nullptr, nullptr, nullptr, "dbz"},
	{"faceset", nullptr, nullptr, nullptr, "don_faces1"},
	{"faceset", nullptr, nullptr, nullptr, "don_faces2"},
	{"faceset", nullptr, nullptr, nullptr, "ebfacesx1"},
	{"faceset", nullptr, nullptr, nullptr, "expresion"},
	{"faceset", nullptr, nullptr, nullptr, "expression4"},
	{"faceset", nullptr, nullptr, nullptr, "expression5"},
	{"faceset", nullptr, nullptr, nullptr, "expression6"},
	{"faceset", nullptr, nullptr, nullptr, "expression7_b"},
	{"faceset", nullptr, nullptr, nullptr, "expression7"},
	{"faceset", nullptr, nullptr, nullptr, "expression"},
	{"faceset", nullptr, nullptr, nullptr, "face002"},
	{"faceset", nullptr, nullptr, nullptr, "face01"},
	{"faceset", nullptr, nullptr, nullptr, "face03"},
	{"faceset", nullptr, nullptr, nullptr, "ff4"},
	{"faceset", nullptr, nullptr, nullptr, "ff6_b"},
	{"faceset", nullptr, nullptr, nullptr, "ff7face"},
	{"faceset", nullptr, nullptr, nullptr, "ff7"},
	{"faceset", nullptr, nullptr, nullptr, "ff8_b"},
	{"faceset", nullptr, nullptr, nullptr, "ff8"},
	{"faceset", nullptr, nullptr, nullptr, "ff92"},
	{"faceset", nullptr, nullptr, nullptr, "ff9faceset"},
	{"faceset", nullptr, nullptr, nullptr, "ff9"},
	{"faceset", nullptr, nullptr, nullptr, "fire_emblem_b"},
	{"faceset", nullptr, nullptr, nullptr, "fire_emblem_c"},
	{"faceset", nullptr, nullptr, nullptr, "fire_emblem"},
	{"faceset", nullptr, nullptr, nullptr, "hourai"},
	{"faceset", nullptr, nullptr, nullptr, "image1"},
	{"faceset", nullptr, nullptr, nullptr, "item_b"},
	{"faceset", nullptr, nullptr, nullptr, "item_c"},
	{"faceset", nullptr, nullptr, nullptr, "item"},
	{"faceset", nullptr, nullptr, nullptr, "kof"},
	{"faceset", nullptr, nullptr, nullptr, "langrissa_b"},
	{"faceset", nullptr, nullptr, nullptr, "langrissa"},
	{"faceset", nullptr, nullptr, nullptr, "lodfaces"},
	{"faceset", nullptr, nullptr, nullptr, "lom_b"},
	{"faceset", nullptr, nullptr, nullptr, "lom_c"},
	{"faceset", nullptr, nullptr, nullptr, "lom"},
	{"faceset", nullptr, nullptr, nullptr, "marvel"},
	{"faceset", nullptr, nullptr, nullptr, "medieval2"},
	{"faceset", nullptr, nullptr, nullptr, "medieval"},
	{"faceset", nullptr, nullptr, nullptr, "megaman(face)"},
	{"faceset", nullptr, nullptr, nullptr, "mm2"},
	{"faceset", nullptr, nullptr, nullptr, "monster2"},
	{"faceset", nullptr, nullptr, nullptr, "piccoloface"},
	{"faceset", nullptr, nullptr, nullptr, "pokeface"},
	{"faceset", nullptr, nullptr, nullptr, "pokemon_2"},
	{"faceset", nullptr, nullptr, nullptr, "pokemon2"},
	{"faceset", nullptr, nullptr, nullptr, "ranmaface"},
	{"faceset", nullptr, nullptr, nullptr, "sailorfaces1"},
	{"faceset", nullptr, nullptr, nullptr, "sailor"},
	{"faceset", nullptr, nullptr, nullptr, "samurai_spirit4_b"},
	{"faceset", nullptr, nullptr, nullptr, "samurai_spirit4"},
	{"faceset", nullptr, nullptr, nullptr, "slayers_face_0"},
	{"faceset", nullptr, nullptr, nullptr, "slayers_face_1"},
	{"faceset", nullptr, nullptr, nullptr, "sonicface1"},
	{"faceset", nullptr, nullptr, nullptr, "sonicface2"},
	{"faceset", nullptr, nullptr, nullptr, "sonicface3"},
	{"faceset", nullptr, nullptr, nullptr, "srm95"},
	{"faceset", nullptr, nullptr, nullptr, "staroceanface"},
	{"faceset", nullptr, nullptr, nullptr, "star_wars_b"},
	{"faceset", nullptr, nullptr, nullptr, "star_wars"},
	{"faceset", nullptr, nullptr, nullptr, "suikoden_b"},
	{"faceset", nullptr, nullptr, nullptr, "suikoden_c"},
	{"faceset", nullptr, nullptr, nullptr, "suikoden"},
	{"faceset", nullptr, nullptr, nullptr, "teikyou_b"},
	{"faceset", nullptr, nullptr, nullptr, "teikyou"},
	{"faceset", nullptr, nullptr, nullptr, "top"},
	{"faceset", nullptr, nullptr, nullptr, "xenogears_b"},
	{"faceset", nullptr, nullptr, nullptr, "xenogears_c"},
	{"faceset", nullptr, nullptr, nullptr, "xenogears_d"},
	{"faceset", nullptr, nullptr, nullptr, "xenogears"},
	{"faceset", nullptr, nullptr, nullptr, "xeno"},
	{"faceset", nullptr, nullptr, nullptr, "zelda64"},
	{"gameover", "ゲームオーバー", "game over", "gameover", nullptr},
	{"monster", "ヴァンパイア", "vampire", "vampire", nullptr},
	{"monster", "オーク", "orc", "hog", nullptr},
	{"monster", "ガーゴイル", "gargoyle", "gargoyle", nullptr},
	{"monster", "キマイラ", "chimera", "chimera", nullptr},
	{"monster", "クラーケン", "kraken", "octopus", nullptr},
	{"monster", "グリフォン", "griffon", "griphon", nullptr},
	{"monster", "ケルベロス", "cerberus", "hellhound", nullptr},
	{"monster", "こうもり", "bat", "bat", nullptr},
	{"monster", "ゴースト", "ghost", "ghost", nullptr},
	{"monster", "ゴーレム", "golem", "golem", nullptr},
	{"monster", "コカトリス", "cockatorice", "rooster", nullptr},
	{"monster", "ゴブリン", "goblin", "troll", nullptr},
	{"monster", "コボルト", "kobold", "wolfman", nullptr},
	{"monster", "スケルトン", "skeleton", "skeleton", nullptr},
	{"monster", "スライム", "slime", "slime", nullptr},
	{"monster", "ゾンビ", "zombie", "zombie", nullptr},
	{"monster", "ダークエルフ", "dark elf", "darkelf", nullptr},
	{"monster", "デーモン", "demon", "flyingdemon", nullptr},
	{"monster", "ドラゴン", "dragona", "greendragon1", nullptr},
	{"monster", "ドラゴンナイト", "dragon knight", "dragonknight", nullptr},
	{"monster", "トルーパー", "knight", "darkrider", nullptr},
	{"monster", "トレント", "treant", "oak", nullptr},
	{"monster", "ハーピー", "harpy", "harpy", nullptr},
	{"monster", "ヒュドラ", "hydra", "hydra", nullptr},
	{"monster", "ブラックナイト", "black knight", "darkknight", nullptr},
	{"monster", "ホーネット", "hornet", "bee", nullptr},
	{"monster", "マーマン", "merman", "aquamen", nullptr},
	{"monster", "マミー", "mummy", "mummy", nullptr},
	{"monster", "ミノタウロス", "minotaur", "minotaur", nullptr},
	{"monster", "ミミック", "mimic", "ogrechest", nullptr},
	{"monster", "メデューサ", "medusa", "medusa", nullptr},
	{"monster", "リザードマン", "lizardman", "lizardmen", nullptr},
	{"monster", "リッチ", "lich", "darkspirit", nullptr},
	{"monster", "ワーウルフ", "werewolf", "wolf", nullptr},
	{"monster", "ワイバーン", "wyvern", "bluedragon", nullptr},
	{"monster", "一般人1", "people1", "boy1", nullptr},
	{"monster", "一般人2", "people2", "girl2", nullptr},
	{"monster", "一般人3", "people3", "boy3", nullptr},
	{"monster", "一般人4", "people4", "girl4", nullptr},
	{"monster", "一般人5", "people5", "man5", nullptr},
	{"monster", "一般人6", "people6", "girl6", nullptr},
	{"monster", "一般人7", "people7", "oldman7", nullptr},
	{"monster", "一般人8", "people8", "granny", nullptr},
	{"monster", "使い魔", "familiar", "imp", nullptr},
	{"monster", "兵士", "soldier", "warrior", nullptr},
	{"monster", "大グモ", "giant spider", "spider", nullptr},
	{"monster", "大サソリ", "giant scorpion", "redscorpion", nullptr},
	{"monster", "大蛇", "snake", "snake", nullptr},
	{"monster", "天使", "angel", "angel", nullptr},
	{"monster", "女王", "queen", "princess", nullptr},
	{"monster", "忍者", "ninja", "ninja", nullptr},
	{"monster", "怪魚", "monster fish", "fish", nullptr},
	{"monster", "戦士1", "warrior1", "hero1", nullptr},
	{"monster", "戦士2", "warrior2", "hero2", nullptr},
	{"monster", "武者", "warrior", "samurai", nullptr},
	{"monster", "死神", "reaper", "death", nullptr},
	{"monster", "海賊", "pirate", "gnome", nullptr},
	{"monster", "王", "king", "king", nullptr},
	{"monster", "盗賊", "thief", "thief", nullptr},
	{"monster", "鬼火", "wisp", "firescull", nullptr},
	{"monster", "魔王", "demon lord", "cloakdemon", nullptr},
	{"monster", "魔神", "demon god", "satan", nullptr},
	{"monster", "魔術師1", "magician1", "witch1", nullptr},
	{"monster", "魔術師2", "magician2", "witch2", nullptr},
	{"monster", "龍", "dragonb", "greendragon2", nullptr},
	{"monster", nullptr, nullptr, nullptr, "2souls"},
	{"monster", nullptr, nullptr, nullptr, "bloody_orb"},
	{"monster", nullptr, nullptr, nullptr, "damn_monkey"},
	{"monster", nullptr, nullptr, nullptr, "demon_king2"},
	{"monster", nullptr, nullptr, nullptr, "dlicker"},
	{"monster", nullptr, nullptr, nullptr, "dortylla"},
	{"monster", nullptr, nullptr, nullptr, "dragoon1"},
	{"monster", nullptr, nullptr, nullptr, "fire_fox"},
	{"monster", nullptr, nullptr, nullptr, "flaret"},
	{"monster", nullptr, nullptr, nullptr, "gekua"},
	{"monster", nullptr, nullptr, nullptr, "golem2"},
	{"monster", nullptr, nullptr, nullptr, "gugu"},
	{"monster", nullptr, nullptr, nullptr, "igogosha"},
	{"monster", nullptr, nullptr, nullptr, "kisser"},
	{"monster", nullptr, nullptr, nullptr, "ladyblue"},
	{"monster", nullptr, nullptr, nullptr, "leshi"},
	{"monster", nullptr, nullptr, nullptr, "mad_monkey"},
	{"monster", nullptr, nullptr, nullptr, "myss"},
	{"monster", nullptr, nullptr, nullptr, "napper"},
	{"monster", nullptr, nullptr, nullptr, "old_pirat"},
	{"monster", nullptr, nullptr, nullptr, "porker"},
	{"monster", nullptr, nullptr, nullptr, "pupsy"},
	{"monster", nullptr, nullptr, nullptr, "skeleton_magi"},
	{"monster", nullptr, nullptr, nullptr, "slime_death"},
	{"monster", nullptr, nullptr, nullptr, "torturle"},
	{"monster", nullptr, nullptr, nullptr, "zombie2"},
	{"movie", nullptr, nullptr, "babbit", nullptr},
	{"music", "jアイテム", "items", "item", nullptr},
	{"music", "jギャグ1", "gag1", "gag1", nullptr},
	{"music", "jギャグ2", "gag2", "gag2", nullptr},
	{"music", "jファンファーレ1", "fanfare1", "fanfare1", nullptr},
	{"music", "jファンファーレ2", "fanfare2", "fanfare2", nullptr},
	{"music", "jファンファーレ3", "fanfare3", "fanfare3", nullptr},
	{"music", "jファンファーレ4", "fanfare4", "fanfare4", nullptr},
	{"music", "jファンファーレ5", "fanfare5", "fanfare5", nullptr},
	{"music", "jファンファーレ6", "fanfare6", "fanfare6", nullptr},
	{"music", "j宿1", "inn1", "inn1", nullptr},
	{"music", "j宿2", "inn2", "inn2", nullptr},
	{"music", "j戦闘終了1", "battleend1", "battleend1", nullptr},
	{"music", "j戦闘終了2", "battleend2", "battleend2", nullptr},
	{"music", "j戦闘終了3", "battleend3", "battleend3", nullptr},
	{"music", "j戦闘終了4", "battleend4", "battleend4", nullptr},
	{"music", "j疑惑", "suspicion", "doubt", nullptr},
	{"music", "j謎", "mystery", "riddle", nullptr},
	{"music", "se地震", "earthquake", "seearthquake", nullptr},
	{"music", "se大雨", "rain2", "serain2", nullptr},
	{"music", "se時計", "clock", "seclock", nullptr},
	{"music", "se海", "sea", "sesea", nullptr},
	{"music", "se雨", "rain1", "serain", nullptr},
	{"music", "エンディング1", "ending1", "ending1", nullptr},
	{"music", "エンディング2", "ending2", "ending2", nullptr},
	{"music", "エンディング3", "ending3", "ending3", nullptr},
	{"music", "オープニング1", "opening1", "opening1", nullptr},
	{"music", "オープニング2", "opening2", "opening2", nullptr},
	{"music", "オープニング3", "opening3", "opening3", nullptr},
	{"music", "ゲームオーバー1", "gameover1", "gameover1", nullptr},
	{"music", "ゲームオーバー2", "gameover2", "gameover2", nullptr},
	{"music", "ゲームオーバー3", "gameover3", "gameover3", nullptr},
	{"music", "ゴーストタウン1", "ghosttown1", "gosttown1", nullptr},
	{"music", "ゴーストタウン2", "ghosttown2", "gosttown2", nullptr},
	{"music", "ダンジョン1", "dungeon1", "dungeon1", nullptr},
	{"music", "ダンジョン2", "dungeon2", "dungeon2", nullptr},
	{"music", "ダンジョン3", "dungeon3", "dungeon3", nullptr},
	{"music", "ダンジョン4", "dungeon4", "dungeon4", nullptr},
	{"music", "ダンジョン5", "dungeon5", "dungeon5", nullptr},
	{"music", "ピンチ", "crisis", "crisis", nullptr},
	{"music", "フィールド1", "field1", "field1", nullptr},
	{"music", "フィールド2", "field2", "field2", nullptr},
	{"music", "フィールド3", "field3", "field3", nullptr},
	{"music", "フィールド4", "field4", "field4", nullptr},
	{"music", "ボス1", "boss1", "boss1", nullptr},
	{"music", "ボス2", "boss2", "boss2", nullptr},
	{"music", "ボス3", "boss3", "boss3", nullptr},
	{"music", "ボス4", "boss4", "boss4", nullptr},
	{"music", "乗り物1", "vehicle1", "ride1", nullptr},
	{"music", "乗り物2", "vehicle2", "ride2", nullptr},
	{"music", "乗り物3", "vehicle3", "ride3", nullptr},
	{"music", "別れ1", "farewell1", "farewell1", nullptr},
	{"music", "別れ2", "farewell2", "farewell2", nullptr},
	{"music", "勇者1", "hero1", "hero1", nullptr},
	{"music", "勇者2", "hero2", "hero2", nullptr},
	{"music", "動物", "animal", "animal", nullptr},
	{"music", "勝利", "victory", "get", nullptr},
	{"music", "城1", "castle1", "castle1", nullptr},
	{"music", "城2", "castle2", "castle2", nullptr},
	{"music", "城3", "castle3", "castle3", nullptr},
	{"music", "塔1", "tower1", "tower1", nullptr},
	{"music", "塔2", "tower2", "tower2", nullptr},
	{"music", "塔3", "tower3", "tower3", nullptr},
	{"music", "妖精1", "fairy1", "fairy1", nullptr},
	{"music", "妖精2", "fairy2", "fairy2", nullptr},
	{"music", "安らぎ1", "peace1", "peace1", nullptr},
	{"music", "安らぎ2", "peace2", "peace2", nullptr},
	{"music", "安らぎ3", "peace3", "peace3", nullptr},
	{"music", "店1", "store1", "shop1", nullptr},
	{"music", "店2", "store2", "shop2", nullptr},
	{"music", "店3", "store3", "shop3", nullptr},
	{"music", "怒り", "anger", "anger", nullptr},
	{"music", "悲しみ", "sorrow", "sad", nullptr},
	{"music", "戦闘1", "battle1", "battle1", nullptr},
	{"music", "戦闘2", "battle2", "battle2", nullptr},
	{"music", "戦闘3", "battle3", "battle3", nullptr},
	{"music", "探索", "search", "search", nullptr},
	{"music", "敗北", "defeat", "lose", nullptr},
	{"music", "教会", "church", "church", nullptr},
	{"music", "明るい市場", "marketplace", "fiesta", nullptr},
	{"music", "村1", "village1", "village1", nullptr},
	{"music", "村2", "village2", "village2", nullptr},
	{"music", "村3", "village3", "village3", nullptr},
	{"music", "泥棒", "thief", "thief", nullptr},
	{"music", "活気", "energy", "energy", nullptr},
	{"music", "町1", "town1", "town1", nullptr},
	{"music", "町2", "town2", "town2", nullptr},
	{"music", "町3", "town3", "town3", nullptr},
	{"music", "神秘1", "mystery1", "mystery1", nullptr},
	{"music", "神秘2", "mystery2", "mystery2", nullptr},
	{"music", "神秘3", "mystery3", "mystery3", nullptr},
	{"music", "秘宝", "treasure", "treasure", nullptr},
	{"music", "船1", "ship1", "ship1", nullptr},
	{"music", "船2", "ship2", "ship2", nullptr},
	{"music", "船3", "ship3", "ship3", nullptr},
	{"music", "試練", "trial", "trial", nullptr},
	{"music", "闇市", "blackmarket", "dark", nullptr},
	{"music", "魔王", "devil", "devil", nullptr},
	{"music", nullptr, nullptr, "dungeon6", nullptr},
	{"music", nullptr, nullptr, "dungeon7", nullptr},
	{"music", nullptr, nullptr, "farewell3", nullptr},
	{"music", nullptr, nullptr, "farewell4", nullptr},
	{"music", nullptr, nullptr, "inn3", nullptr},
	{"music", nullptr, nullptr, "mystery4", nullptr},
	{"music", nullptr, nullptr, "night", nullptr},
	{"music", nullptr, nullptr, "pirate1", nullptr},
	{"music", nullptr, nullptr, "pirate2", nullptr},
	{"music", nullptr, nullptr, "pirate3", nullptr},
	{"music", nullptr, nullptr, "pirate4", nullptr},
	{"music", nullptr, nullptr, "ride4", nullptr},
	{"music", nullptr, nullptr, "shop4", nullptr},
	{"music", nullptr, nullptr, "snow", nullptr},
	{"music", nullptr, nullptr, nullptr, "casino"},
	{"music", nullptr, nullptr, nullptr, "castle4"},
	{"music", nullptr, nullptr, nullptr, "castle5"},
	{"music", nullptr, nullptr, nullptr, "done"},
	{"music", nullptr, nullptr, nullptr, "fairy3"},
	{"music", nullptr, nullptr, nullptr, "friends1"},
	{"music", nullptr, nullptr, nullptr, "meanwhile1"},
	{"music", nullptr, nullptr, nullptr, "meanwhile2"},
	{"music", nullptr, nullptr, nullptr, "morning1"},
	{"music", nullptr, nullptr, nullptr, "shop5"},
	{"music", nullptr, nullptr, nullptr, "sorrow"},
	{"music", nullptr, nullptr, nullptr, "spirit"},
	{"music", nullptr, nullptr, nullptr, "town4"},
	{"music", nullptr, nullptr, nullptr, "town5"},
	{"music", nullptr, nullptr, nullptr, "village4"},
	{"music", nullptr, nullptr, nullptr, "village5"},
	{"panorama", "夕焼け1", "sunset1", "dawn1", nullptr},
	{"panorama", "夕焼け2", "sunset2", "dawn2", nullptr},
	{"panorama", "夜明け1", "dawn1", "evening1", nullptr},
	{"panorama", "夜明け2", "dawn2", "evening2", nullptr},
	{"panorama", "夜空1", "night sky1", "night1", nullptr},
	{"panorama", "夜空2", "night sky2", "night2", nullptr},
	{"panorama", "宇宙", "cosmos1", "galaxy", nullptr},
	{"panorama", "惑星1", "planet1", "planet1", nullptr},
	{"panorama", "惑星2", "planet2", "planet2", nullptr},
	{"panorama", "惑星3", "planet3", "planet3", nullptr},
	{"panorama", "異空間", "dimension rift", "weird", nullptr},
	{"panorama", "空1", "sky1", "morning1", nullptr},
	{"panorama", "空2", "sky2", "morning2", nullptr},
	{"panorama", nullptr, nullptr, nullptr, "beach1"},
	{"picture", nullptr, nullptr, "cloud", nullptr},
	{"sound", "アイテム1", "item1", "item1", nullptr},
	{"sound", "アイテム2", "item2", "item2", nullptr},
	{"sound", "あたり1", "chime1", "success1", nullptr},
	{"sound", "あたり2", "chime2", "success2", nullptr},
	{"sound", "アップ", "buff", "up", nullptr},
	{"sound", "イヌ", "dog", "dog", nullptr},
	{"sound", "ウシ", "cow", "cow", nullptr},
	{"sound", "ウマ", "horse", "horse", nullptr},
	{"sound", "おたけび", "roar", "roar", nullptr},
	{"sound", "カーソル1", "cursor1", "cursor1", nullptr},
	{"sound", "カーソル2", "cursor2", "cursor2", nullptr},
	{"sound", "ガシャン", "glassshatter", "glass", nullptr},
	{"sound", "キャンセル1", "cancel1", "cansel1", nullptr},
	{"sound", "キャンセル2", "cancel2", "cansel2", nullptr},
	{"sound", "しびれ1", "paralyze1", "numbness1", nullptr},
	{"sound", "しびれ2", "paralyze2", "numbness2", nullptr},
	{"sound", "しびれ3", "paralyze3", "numbness3", nullptr},
	{"sound", "ジャンプ1", "jump1", "jump1", nullptr},
	{"sound", "ジャンプ2", "jump2", "jump2", nullptr},
	{"sound", "ショット1", "shot1", "shot1", nullptr},
	{"sound", "ショット2", "shot2", "shot2", nullptr},
	{"sound", "ショット3", "shot3", "shot3", nullptr},
	{"sound", "スイッチ1", "switch1", "switch1", nullptr},
	{"sound", "スイッチ2", "switch2", "switch2", nullptr},
	{"sound", "ダウン", "debuff", "down", nullptr},
	{"sound", "ダメージ1", "damage1", "damage1", nullptr},
	{"sound", "ダメージ2", "damage2", "damage2", nullptr},
	{"sound", "テレポート1", "teleport1", "teleport1", nullptr},
	{"sound", "テレポート2", "teleport2", "teleport2", nullptr},
	{"sound", "トラ", "tiger", "tiger", nullptr},
	{"sound", "にらみ", "glare", "power", nullptr},
	{"sound", "にわとり", "chicken", "chicken", nullptr},
	{"sound", "ネコ", "cat", "cat", nullptr},
	{"sound", "ノック", "knock", "knock", nullptr},
	{"sound", "はずれ1", "buzzer1", "failure1", nullptr},
	{"sound", "はずれ2", "buzzer2", "failure2", nullptr},
	{"sound", "バリア", "barrier", "barrier", nullptr},
	{"sound", "ひつじ", "sheep", "sheep", nullptr},
	{"sound", "ブザー1", "buzzer3", "buzzer1", nullptr},
	{"sound", "ブザー2", "buzzer4", "buzzer2", nullptr},
	{"sound", "フラッシュ1", "flash1", "flash1", nullptr},
	{"sound", "フラッシュ2", "flash2", "flash2", nullptr},
	{"sound", "フラッシュ3", "flash3", "flash3", nullptr},
	{"sound", "ブレス", "breath", "breast", nullptr},
	{"sound", "モンスター1", "monster1", "monster1", nullptr},
	{"sound", "モンスター2", "monster2", "monster2", nullptr},
	{"sound", "ライオン", "lion", "lion", nullptr},
	{"sound", "冷気1", "ice1", "cold1", nullptr},
	{"sound", "冷気2", "ice2", "cold2", nullptr},
	{"sound", "冷気3", "ice3", "cold3", nullptr},
	{"sound", "冷気4", "ice4", "cold4", nullptr},
	{"sound", "冷気5", "ice5", "cold5", nullptr},
	{"sound", "冷気6", "ice6", "cold6", nullptr},
	{"sound", "冷気7", "ice7", "cold7", nullptr},
	{"sound", "冷気8", "ice8", "cold8", nullptr},
	{"sound", "冷気9", "ice9", "cold9", nullptr},
	{"sound", "冷気10", "ice10", "cold10", nullptr},
	{"sound", "冷気11", "ice11", "cold11", nullptr},
	{"sound", "剣1", "sword1", "sword1", nullptr},
	{"sound", "剣2", "sword2", "sword2", nullptr},
	{"sound", "剣3", "sword3", "sword3", nullptr},
	{"sound", "吸収1", "absorb1", "absorption1", nullptr},
	{"sound", "吸収2", "absorb2", "absorption2", nullptr},
	{"sound", "噛む", "bite", "bite", nullptr},
	{"sound", "回復1", "recovery1", "recovery1", nullptr},
	{"sound", "回復2", "recovery2", "recovery2", nullptr},
	{"sound", "回復3", "recovery3", "recovery3", nullptr},
	{"sound", "回復4", "recovery4", "recovery4", nullptr},
	{"sound", "回復5", "recovery5", "recovery5", nullptr},
	{"sound", "回復6", "recovery6", "recovery6", nullptr},
	{"sound", "回復7", "recovery7", "recovery7", nullptr},
	{"sound", "回復8", "recovery8", "recovery8", nullptr},
	{"sound", "回避1", "evade1", "evasion1", nullptr},
	{"sound", "回避2", "evade2", "evasion2", nullptr},
	{"sound", "地震1", "earthquake1", "earthquake1", nullptr},
	{"sound", "地震2", "earthquake2", "earthquake2", nullptr},
	{"sound", "壁1", "barrier1", nullptr, nullptr},
	{"sound", "壁2", "barrier2", nullptr, nullptr},
	{"sound", "大地1", "earth1", "earth1", nullptr},
	{"sound", "大地2", "earth2", "earth2", nullptr},
	{"sound", "大地3", "earth3", "earth3", nullptr},
	{"sound", "大地4", "earth4", "earth4", nullptr},
	{"sound", "大地5", "earth5", "earth5", nullptr},
	{"sound", "大地6", "earth6", "earth6", nullptr},
	{"sound", "大地7", "earth7", "earth7", nullptr},
	{"sound", "大地8", "earth8", "earth8", nullptr},
	{"sound", "大地9", "earth9", "earth9", nullptr},
	{"sound", "大地10", "earth10", "earth10", nullptr},
	{"sound", "巻き付き", "ensnare", "refer book", nullptr},
	{"sound", "弓1", "bow1", "bow1", nullptr},
	{"sound", "弓2", "bow2", "bow2", nullptr},
	{"sound", "戦闘1", "combat1", "fight1", nullptr},
	{"sound", "戦闘2", "combat2", "fight2", nullptr},
	{"sound", "打撃1", "blow1", "blow1", nullptr},
	{"sound", "打撃2", "blow2", "blow2", nullptr},
	{"sound", "打撃3", "blow3", "blow3", nullptr},
	{"sound", "打撃4", "blow4", "blow4", nullptr},
	{"sound", "打撃5", "blow5", "blow5", nullptr},
	{"sound", "打撃6", "blow6", "blow6", nullptr},
	{"sound", "打撃7", "blow7", "blow7", nullptr},
	{"sound", "攻撃1", "attack1", "attack1", nullptr},
	{"sound", "攻撃2", "attack2", "attack2", nullptr},
	{"sound", "斬る1", "slash1", "kill1", nullptr},
	{"sound", "斬る2", "slash2", "kill2", nullptr},
	{"sound", "斬る3", "slash3", "kill3", nullptr},
	{"sound", "斬る4", "slash4", "kill4", nullptr},
	{"sound", "斬る5", "slash5", "kill5", nullptr},
	{"sound", "斬る6", "slash6", nullptr, nullptr},
	{"sound", "斬る7", "slash7", "kill7", nullptr},
	{"sound", "斬る8", "slash8", "kill8", nullptr},
	{"sound", "斬る9", "slash9", "kill9", nullptr},
	{"sound", "斬る10", "slash10", "kill10", nullptr},
	{"sound", "斬る11", "slash11", "kill11", nullptr},
	{"sound", "時計", "clock", "clock", nullptr},
	{"sound", "暗闇", "blind", "darkness", nullptr},
	{"sound", "暗黒1", "darkness1", "dark1", nullptr},
	{"sound", "暗黒2", "darkness2", "dark2", nullptr},
	{"sound", "暗黒3", "darkness3", "dark3", nullptr},
	{"sound", "暗黒4", "darkness4", "dark4", nullptr},
	{"sound", "暗黒5", "darkness5", "dark5", nullptr},
	{"sound", "暗黒6", "darkness6", "kill6", nullptr},
	{"sound", "歌", "song", "song", nullptr},
	{"sound", "毒", "poison", "poison", nullptr},
	{"sound", "水1", "water1", "water1", nullptr},
	{"sound", "水2", "water2", "water2", nullptr},
	{"sound", "水3", "water3", "water3", nullptr},
	{"sound", "水4", "water4", "water4", nullptr},
	{"sound", "水5", "water5", "water5", nullptr},
	{"sound", "水6", "water6", "water6", nullptr},
	{"sound", "決定1", "decision1", "decision1", nullptr},
	{"sound", "決定2", "decision2", "decision2", nullptr},
	{"sound", "沈黙", "silence", "silence", nullptr},
	{"sound", "海1", "sea1", "sea1", nullptr},
	{"sound", "海2", "sea2", "sea2", nullptr},
	{"sound", "消滅1", "collapse1", "annihilation1", nullptr},
	{"sound", "消滅2", "collapse2", "annihilation2", nullptr},
	{"sound", "混乱", "confusion", "chaos", nullptr},
	{"sound", "炎1", "fire1", "flame1", nullptr},
	{"sound", "炎2", "fire2", "flame2", nullptr},
	{"sound", "炎3", "fire3", "flame3", nullptr},
	{"sound", "炎4", "fire4", "flame4", nullptr},
	{"sound", "炎5", "fire5", "flame5", nullptr},
	{"sound", "炎6", "fire6", "flame6", nullptr},
	{"sound", "炎7", "fire7", "flame7", nullptr},
	{"sound", "炎8", "fire8", "flame8", nullptr},
	{"sound", "爆発1", "explosion1", "explosion1", nullptr},
	{"sound", "爆発2", "explosion2", "explosion2", nullptr},
	{"sound", "爆発3", "explosion3", "explosion3", nullptr},
	{"sound", "爆発4", "explosion4", "explosion4", nullptr},
	{"sound", "爆発5", "explosion5", "explosion5", nullptr},
	{"sound", "爆発6", "explosion6", "explosion6", nullptr},
	{"sound", "爆発7", "explosion7", "explosion7", nullptr},
	{"sound", "睡眠", "sleep", "sleep", nullptr},
	{"sound", "砂けむり", "sandstorm", "sand storm", nullptr},
	{"sound", "神聖1", "holy1", "holy1", nullptr},
	{"sound", "神聖2", "holy2", "holy2", nullptr},
	{"sound", "神聖3", "holy3", "holy3", nullptr},
	{"sound", "神聖4", "holy4", "holy4", nullptr},
	{"sound", "神聖5", "holy5", "holy5", nullptr},
	{"sound", "神聖6", "holy6", "holy6", nullptr},
	{"sound", "神聖7", "holy7", "holy7", nullptr},
	{"sound", "神聖8", "holy8", "holy8", nullptr},
	{"sound", "神聖9", "holy9", "holy9", nullptr},
	{"sound", "移動", "move", "movement", nullptr},
	{"sound", "花粉", "pollen", "pollen", nullptr},
	{"sound", "落ちる1", "fall1", "fall1", nullptr},
	{"sound", "落ちる2", "fall2", "fall2", nullptr},
	{"sound", "蘇生1", "raise1", "rebirth1", nullptr},
	{"sound", "蘇生2", "raise2", "rebirth2", nullptr},
	{"sound", "蘇生3", "raise3", "rebirth3", nullptr},
	{"sound", "逃走", "escape", "escape", nullptr},
	{"sound", "鍵", "key", "key", nullptr},
	{"sound", "鐘", "bell", "bell", nullptr},
	{"sound", "閉める1", "close1", "close1", nullptr},
	{"sound", "閉める2", "close2", "close2", nullptr},
	{"sound", "開ける1", "open1", "open1", nullptr},
	{"sound", "開ける2", "open2", "open2", nullptr},
	{"sound", "雨1", "rain1", "rain1", nullptr},
	{"sound", "雨2", "rain2", "rain2", nullptr},
	{"sound", "雷1", "thunder1", "thunder1", nullptr},
	{"sound", "雷2", "thunder2", "thunder2", nullptr},
	{"sound", "雷3", "thunder3", "thunder3", nullptr},
	{"sound", "雷4", "thunder4", "thunder4", nullptr},
	{"sound", "雷5", "thunder5", "thunder5", nullptr},
	{"sound", "雷6", "thunder6", "thunder6", nullptr},
	{"sound", "雷7", "thunder7", "thunder7", nullptr},
	{"sound", "雷8", "thunder8", "thunder8", nullptr},
	{"sound", "雷9", "thunder9", "thunder9", nullptr},
	{"sound", "雷10", "thunder10", "thunder10", nullptr},
	{"sound", "霧1", "fog1", "fog1", nullptr},
	{"sound", "霧2", "fog2", "fog2", nullptr},
	{"sound", "音波1", "wave1", "sonic1", nullptr},
	{"sound", "音波2", "wave2", "sonic2", nullptr},
	{"sound", "風1", "wind1", "wind1", nullptr},
	{"sound", "風2", "wind2", "wind2", nullptr},
	{"sound", "風3", "wind3", "wind3", nullptr},
	{"sound", "風4", "wind4", "wind4", nullptr},
	{"sound", "風5", "wind5", "wind5", nullptr},
	{"sound", "風6", "wind6", "wind6", nullptr},
	{"sound", "風7", "wind7", "wind7", nullptr},
	{"sound", "風8", "wind8", "wind8", nullptr},
	{"sound", "風9", "wind9", "wind9", nullptr},
	{"sound", "風10", "wind10", "wind10", nullptr},
	{"sound", "風11", "wind11", "wind11", nullptr},
	{"sound", "魔法1", "magic1", "wall1", nullptr},
	{"sound", "魔法2", "magic2", "wall2", nullptr},
	{"sound", nullptr, nullptr, nullptr, "anvil"},
	{"sound", nullptr, nullptr, nullptr, "camera"},
	{"sound", nullptr, nullptr, nullptr, "clap"},
	{"sound", nullptr, nullptr, nullptr, "comp"},
	{"sound", nullptr, nullptr, nullptr, "doorbell"},
	{"sound", nullptr, nullptr, nullptr, "drip"},
	{"sound", nullptr, nullptr, nullptr, "flush"},
	{"sound", nullptr, nullptr, nullptr, "glassbreak"},
	{"sound", nullptr, nullptr, nullptr, "gong"},
	{"sound", nullptr, nullptr, nullptr, "kiss"},
	{"sound", nullptr, nullptr, nullptr, "phone"},
	{"sound", nullptr, nullptr, nullptr, "pop"},
	{"sound", nullptr, nullptr, nullptr, "sneezing"},
	{"sound", nullptr, nullptr, nullptr, "snoring"},
	{"sound", nullptr, nullptr, nullptr, "ugh"},
	{"sound", nullptr, nullptr, nullptr, "whistle"},
	{"system", "システム", "system", "system", nullptr},
	{"system", nullptr, nullptr, "royal", nullptr},
	{"system", nullptr, nullptr, nullptr, "blue"},
	{"system", nullptr, nullptr, nullptr, "bof2sys"},
	{"system", nullptr, nullptr, nullptr, "bubbles"},
	{"system", nullptr, nullptr, nullptr, "don_system"},
	{"system", nullptr, nullptr, nullptr, "ff2"},
	{"system", nullptr, nullptr, nullptr, "ff3"},
	{"system", nullptr, nullptr, nullptr, "incomsys"},
	{"system", nullptr, nullptr, nullptr, "lightbluesystem"},
	{"system", nullptr, nullptr, nullptr, "lines"},
	{"system", nullptr, nullptr, nullptr, "lufia2"},
	{"system", nullptr, nullptr, nullptr, "mint"},
	{"system", nullptr, nullptr, nullptr, "ogre_battle"},
	{"system", nullptr, nullptr, nullptr, "purple"},
	{"system", nullptr, nullptr, nullptr, "red_future"},
	{"system", nullptr, nullptr, nullptr, "redmenu3"},
	{"system", nullptr, nullptr, nullptr, "sf2sys"},
	{"system", nullptr, nullptr, nullptr, "shoddy"},
	{"system", nullptr, nullptr, nullptr, "system01"},
	{"system", nullptr, nullptr, nullptr, "system02"},
	{"system", nullptr, nullptr, nullptr, "system03"},
	{"system", nullptr, nullptr, nullptr, "windows01"},
	{"system", nullptr, nullptr, nullptr, "windows02"},
	{"title", "タイトル1", "title1", "title1", nullptr},
	{"title", "タイトル2", "title2", "title2", nullptr},
	{"title", "タイトル3", "title3", "title3", nullptr},
	{"title", "タイトル4", "title4", "title4", nullptr},
	{nullptr, nullptr, nullptr, nullptr, nullptr}
};

const char* const rtp_table_2k_categories[15] = {
	"backdrop",
	"battle",
	"charset",
	"chipset",
	"faceset",
	"gameover",
	"monster",
	"movie",
	"music",
	"panorama",
	"picture",
	"sound",
	"system",
	"title",
	nullptr
};

const int rtp_table_2k_categories_idx[15] = {
	0,
	39,
	69,
	282,
	418,
	521,
	522,
	613,
	614,
	741,
	755,
	756,
	978,
	1002,
	1006
};

const char* const rtp_table_2k3[][8] = {
	{"backdrop", "お墓", "graveyard", "graveyard", "grave", "grave", "바닥", "墳場"},
	{"backdrop", "お寺", "temple1", "shrine", "temple", "temple", "절", "寺廟"},
	{"backdrop", "ダンジョン１", "dungeon1", "dungeon1", "cave", "donjohn1", "던젼１", "迷宮1"},
	{"backdrop", "ダンジョン２", "dungeon2", "dungeon2", "lavacave", "donjohnq", "던젼２", "迷宮2"},
	{"backdrop", "ダンジョン３", "dungeon3", "dungeon3", "icecave", "donjohnr", "던젼３", "迷宮3"},
	{"backdrop", "ダンジョン４", "dungeon4", "dungeon4", "stalagmites", "donjohns", "던젼４", "迷宮4"},
	{"backdrop", "ダンジョン５", "dungeon5", "dungeon5", "labyrinth", "donjohnt", "던젼５", "迷宮5"},
	{"backdrop", "ダンジョン６", "dungeon6", "dungeon6", "traininghall", "donjohnu", "던젼６", "迷宮6"},
	{"backdrop", "宇宙", "universe", "space", "space", "space", "우주", "宇宙"},
	{"backdrop", "山道", "mountain road", "mountain", "mountain", "mountainpath", "산길", "山路"},
	{"backdrop", "岩場", "rocky road", "rockbed", "rocks", "rocks", "바위", "岩壁"},
	{"backdrop", "廃墟", "ruins1", "wasteland", "ruins", "wasteland", "폐허", "廢墟"},
	{"backdrop", "旧市街", "old town", "ghost-town", "city", "oldurban", "구시가지", "老街"},
	{"backdrop", "森１", "forest1", "forest1", "forest1", "forestp", "숲１", "森林1"},
	{"backdrop", "森２", "forest2", "forest2", "forest2", "forestq", "숲２", "森林2"},
	{"backdrop", "橋", "bridge", "bridge", "bridge", "bridge", "다리", "橋"},
	{"backdrop", "毒沼", "swamp", "swamp", "swamp", "poisonswamp", "독연못", "毒沼"},
	{"backdrop", "洋館", "mansion", "building", "insidecastle", "westernstylebuilding", "양관(서양식집)", "洋館"},
	{"backdrop", "海", "sea", "ocean", "sea", "sea", "바다", "海"},
	{"backdrop", "玉座", "castle", "castle", "ballseat", "ballseat", "옥좌", "王位"},
	{"backdrop", "異空間", "space", "strange", "spacelight", "strangespacial", "이공간", "異次元空間"},
	{"backdrop", "砂浜", "beach", "beach", "beach", "sandybeach", "사구", "淺灘"},
	{"backdrop", "砂漠", "desert", "desert", "desert", "desert", "사막", "沙漠"},
	{"backdrop", "神殿", "temple2", "ruins1", "sanctuary", "sanctuary", "신전", "神殿"},
	{"backdrop", "空", "sky", "sky", "clouds", "empty", "하늘", "天空"},
	{"backdrop", "船上", "ship", "shipdeck", "ship", "onboat", "선상", "船上"},
	{"backdrop", "草原", "grassland", "plains", "grass", "grassyplain", "초원", "草原"},
	{"backdrop", "荒地", "wasteland", "barren", "roughforging", "roughforging", "황야", "荒地"},
	{"backdrop", "街中", "town", "town", "cityhouse", "city", "길가운데", "街道"},
	{"backdrop", "路上", "road", "road", "road", "road", "도로 위", "道路"},
	{"backdrop", "遺跡", "ruins2", "ruins2", "insidepyramid", "ruins", "유적", "遺跡"},
	{"backdrop", "銭湯", "bathhouse", "bath", "bathhouse", "bathhouse", "공중 목욕탕", "澡堂"},
	{"backdrop", "闘技場", "arena", "arena", "competitionplace", "competitionplace", "투기장", "競技場"},
	{"backdrop", "雪原", "snow field", "snowfield", "snow", "snowfield", "설원", "雪原"},
	{"battle", "2003その他1", "2003 other1", "misc1", "2003-other1", "2003addition1", "2003기타1", "2003其他1"},
	{"battle", "2003その他2", "2003 other2", "misc2", "2003-other2", "2003addition2", "2003기타2", "2003其他2"},
	{"battle", "2003バリア", "2003 barrier", "barrier1", "2003-barrier", "2003barrier", "2003베리어", "2003護罩"},
	{"battle", "2003ブレス", "2003 breath", "breath1", "2003-poison", "2003breath", "2003브레스", "2003氣息"},
	{"battle", "2003光柱", "2003 light pillar", "lightray", "2003-lines", "2003luminouspillar", "2003주위의 빛", "2003光柱"},
	{"battle", "2003冷気", "2003 cold", "ice1", "2003-cold", "2003coldair", "2003냉기", "2003冰"},
	{"battle", "2003剣", "2003 sword", "sword1", "2003-sword", "2003sword", "2003검", "2003劍"},
	{"battle", "2003吸収", "2003 absorb", "absorb1", "2003-absorption", "2003absorption", "2003흡수", "2003吸收"},
	{"battle", "2003回復", "2003 recovery", "healing1", "2003-sun", "2003recovery", "2003회복", "2003回復"},
	{"battle", "2003大地", "2003 earth", "earth1", "2003-earth", "2003ground", "2003대지", "2003大地"},
	{"battle", "2003弓", "2003 bow", "bow1", "2003-arrow", "2003bow", "2003화살", "2003弓"},
	{"battle", "2003打撃", "2003 blow", "strike", "2003-hit", "2003shock", "2003타격", "2003打擊"},
	{"battle", "2003斧", "2003 axe", "axe1", "2003-axe", "2003ax", "2003도끼", "2003斧"},
	{"battle", "2003暗黒", "2003 dark", "dark1", "2003-dark", "2003dark", "2003암흑", "2003暗黑"},
	{"battle", "2003槍", "2003 spear", "spear1", "2003-spear", "2003spear", "2003창", "2003槍"},
	{"battle", "2003水", "2003 water", "water1", "2003-water", "2003water", "2003물", "2003水"},
	{"battle", "2003治療", "2003 cure", "cure1", "2003-sphere", "2003remedy", "2003치료", "2003治療"},
	{"battle", "2003炎", "2003 fire", "fire1", "2003-fire", "2003flame", "2003화염", "2003炎"},
	{"battle", "2003爆発", "2003 explosion", "explode1", "2003-explosion", "2003explosive", "2003폭발", "2003爆發"},
	{"battle", "2003爪", "2003 claw", "claw1", "2003-claws", "2003nail", "2003손톱", "2003爪"},
	{"battle", "2003神聖", "2003 holy", "holy1", "2003-holy", "2003holy", "2003신성", "2003神聖"},
	{"battle", "2003蘇生", "2003 revive", "revive1", "2003-angel", "2003revival", "2003소생", "2003復活"},
	{"battle", "2003雷", "2003 thunder", "bolt1", "2003-zip", "2003thunder", "2003전격", "2003雷"},
	{"battle", "2003鞭", "2003 whip", "whip1", "2003-whip", "2003rod", "2003채찍", "2003鞭"},
	{"battle", "2003風", "2003 wind", "wind1", "2003-wind", "2003wind", "2003바람", "2003風"},
	{"battle", "2003麻痺", "2003 paralysis", "paralyze1", "2003-paralysis", "2003paralysis", "2003마비", "2003麻痺"},
	{"battle", "その他", "other", "misc3", nullptr, "addition", "기타", "其他"},
	{"battle", "バリア", "barrier", "barrier2", nullptr, "barrier", "배리어", "護罩"},
	{"battle", "ブレス", "breath", "breath2", nullptr, "breath", "호흡", "氣息"},
	{"battle", "上昇", "buff", "increase", nullptr, "rise", "상승", "上昇"},
	{"battle", "下降", "debuff", "decrease", nullptr, "drop", "하강", "下降"},
	{"battle", "冷気", "ice", "ice2", nullptr, "coldair", "냉기", "冰"},
	{"battle", "剣1", "sword1", "sword2", nullptr, "sword1", "검1", "劍1"},
	{"battle", "剣2", "sword2", "sword3", nullptr, "sword2", "검2", "劍2"},
	{"battle", "吸収", "bite", "absorb2", nullptr, "absorption", "흡수", "吸收"},
	{"battle", "回復", "recovery", "healing2", nullptr, "recovery", "회복", "回復"},
	{"battle", "大地", "earth", "earth2", nullptr, "ground", "대지", "大地"},
	{"battle", "打撃", "blow", "attack", nullptr, "shock", "타격", "打擊"},
	{"battle", "斧", "axe", "axe2", nullptr, "ax", "도끼", "斧"},
	{"battle", "暗黒", "dark", "dark2", nullptr, "dark", "암흑", "暗黑"},
	{"battle", "槍", "spear", "spear2", nullptr, "spear", "창", "槍"},
	{"battle", "水", "water", "water2", nullptr, "water", "물", "水"},
	{"battle", "治療", "treatment", "cure2", nullptr, "remedy", "치료", "治療"},
	{"battle", "炎1", "fire1", "fire2", nullptr, "flame1", "화염1", "炎1"},
	{"battle", "炎2", "fire2", "fire3", nullptr, "flame2", "화염2", "炎2"},
	{"battle", "爆発", "explosion", "explode2", nullptr, "explosive", "폭발", "爆發"},
	{"battle", "爪", "claw", "claw2", nullptr, "nail", "손톱", "爪"},
	{"battle", "矢", "arrow", "bow2", nullptr, "bow", "화살", "箭"},
	{"battle", "神聖", "holy", "holy2", nullptr, "holy", "신성", "神聖"},
	{"battle", "蘇生", "ressurection", "revive2", nullptr, "revivial", "소생", "復活"},
	{"battle", "雷", "thunder", "bolt2", nullptr, "thunder", "전격", "雷"},
	{"battle", "鞭", "whip", "whip2", nullptr, "rod", "채찍", "鞭"},
	{"battle", "風", "wind", "wind2", nullptr, "wind", "바람", "風"},
	{"battle", "麻痺", "paralysis", "paralyze2", nullptr, "paralysis", "마비", "麻痺"},
	{"battlecharset", "エルフ女a", "female elf a", "elf-f-1", "tuanaa", "elfwomana", "엘프女 a", "妖精女a"},
	{"battlecharset", "エルフ女b", "female elf b", "elf-f-2", "tuanab", "elfwomanb", "엘프女 b", "妖精女b"},
	{"battlecharset", "エルフ男a", "male elf a", "elf-m-1", "temmada", "elfmana", "엘프男 a", "妖精男a"},
	{"battlecharset", "エルフ男b", "male elf b", "elf-m-2", "temmadb", "elfmanb", "엘프男 b", "妖精男b"},
	{"battlecharset", "中華女a", "chinese woman a", "chinese-f-1", "chuzaa", "chinesewomana", "중화女a", "中華女a"},
	{"battlecharset", "中華女b", "chinese woman b", "chinese-f-2", "chuzab", "chinesewomanb", "중화女b", "中華女b"},
	{"battlecharset", "中華男a", "chinese man a", "chinese-m-1", "chinga", "chinesemana", "중화男a", "中華男a"},
	{"battlecharset", "中華男b", "chinese man b", "chinese-m-2", "chingb", "chinesemanb", "중화男b", "中華男b"},
	{"battlecharset", "侍a", "samurai a", "samurai1", "garrea", "samuraia", "사무라이a", "武士a"},
	{"battlecharset", "侍b", "samurai b", "samurai2", "garreb", "samuraib", "사무라이b", "武士b"},
	{"battlecharset", "僧侶女a", "female monk a", "priestess1", "kloria", "monkwomana", "승려女a", "僧侶女a"},
	{"battlecharset", "僧侶女b", "female monk b", "priestess2", "klorib", "monkwomanb", "승려女b", "僧侶女b"},
	{"battlecharset", "僧侶男a", "male monk a", "priest1", "siossa", "monkmana", "승려男a", "僧侶男a"},
	{"battlecharset", "僧侶男b", "male monk b", "priest2", "siossb", "monkmanb", "승려男b", "僧侶男b"},
	{"battlecharset", "勇者女a", "female hero a", "hero-f-1", "noddaa", "herowomana", "용자女a", "勇者女a"},
	{"battlecharset", "勇者女b", "female hero b", "hero-f-2", "noddab", "herowomanb", "용자女b", "勇者女b"},
	{"battlecharset", "勇者男a", "male hero a", "hero-m-1", "jemmona", "heromana", "용자男a", "勇者男a"},
	{"battlecharset", "勇者男b", "male hero b", "hero-m-2", "jemmonb", "heromanb", "용자男b", "勇者男b"},
	{"battlecharset", "女性１a", "woman1 a", "woman1-1", "cletoa", "womanépa", "여성１a", "女性1a"},
	{"battlecharset", "女性１b", "woman1 b", "woman1-2", "cletob", "womanépb", "여성１b", "女性1b"},
	{"battlecharset", "女性２a", "woman2 a", "woman2-1", "jikuaa", "womanéqa", "여성２a", "女性2a"},
	{"battlecharset", "女性２b", "woman2 b", "woman2-2", "jikuab", "womanéqb", "여성２b", "女性2b"},
	{"battlecharset", "女性３a", "woman3 a", "woman3-1", "irregiaa", "womanéra", "여성３a", "女性3a"},
	{"battlecharset", "女性３b", "woman3 b", "woman3-2", "irregiab", "womanérb", "여성３b", "女性3b"},
	{"battlecharset", "女性４a", "woman4 a", "woman4-1", "nysmaa", "womanésa", "여성４a", "女性4a"},
	{"battlecharset", "女性４b", "woman4 b", "woman4-2", "nysmab", "womanésb", "여성４b", "女性4b"},
	{"battlecharset", "女性５a", "woman5 a", "woman5-1", "beruaa", "womanéta", "여성５a", "女性5a"},
	{"battlecharset", "女性５b", "woman5 b", "woman5-2", "beruab", "womanétb", "여성５b", "女性5b"},
	{"battlecharset", "忍者女a", "female ninja a", "ninja-f-1", "ginnya", "ninjawomana", "닌자女a", "忍者女a"},
	{"battlecharset", "忍者女b", "female ninja b", "ninja-f-2", "ginnyb", "ninjawomanb", "닌자女b", "忍者女b"},
	{"battlecharset", "忍者男a", "male ninja a", "ninja-m-1", "xeoda", "ninjamana", "닌자男a", "忍者男a"},
	{"battlecharset", "忍者男b", "male ninja b", "ninja-m-2", "xeodb", "ninjamanb", "닌자男b", "忍者男b"},
	{"battlecharset", "戦士女a", "female warrior a", "soldier-f-1", "eljeaa", "soldierwomana", "전사女a", "戰士女a"},
	{"battlecharset", "戦士女b", "female warrior b", "soldier-f-2", "eljeab", "soldierwomanb", "전사女b", "戰士女b"},
	{"battlecharset", "戦士男a", "male warrior a", "soldier-m-1", "raglea", "soldiermana", "전사男a", "戰士男a"},
	{"battlecharset", "戦士男b", "male warrior b", "solider-m-2", "ragleb", "soldiermanb", "전사男b", "戰士男b"},
	{"battlecharset", "格闘家女a", "female fighter a", "monk-f-1", "phesaa", "grapplehousewomana", "격투가女a", "格鬥家女a"},
	{"battlecharset", "格闘家女b", "female fighter b", "monk-f-2", "phesab", "grapplehousewomanb", "격투가女b", "格鬥家女b"},
	{"battlecharset", "格闘家男a", "male fighter a", "monk-m-1", "rasnena", "grapplehousemana", "격투가男a", "格鬥家男a"},
	{"battlecharset", "格闘家男b", "male fighter b", "monk-m-2", "rasnenb", "grapplehousemanb", "격투가男b", "格鬥家男b"},
	{"battlecharset", "海賊女a", "female pirate a", "pirate-f-1", "rennaa", "piratewomana", "해적女a", "海賊女a"},
	{"battlecharset", "海賊女b", "female pirate b", "pirate-f-2", "rennab", "piratewomanb", "해적女b", "海賊女b"},
	{"battlecharset", "海賊男a", "male pirate a", "pirate-m-1", "goxana", "piratemana", "해적男a", "海賊男a"},
	{"battlecharset", "海賊男b", "male pirate b", "pirate-m-2", "goxanb", "pirateb", "해적男b", "海賊男b"},
	{"battlecharset", "男性１a", "man1 a", "man1-1", "jidada", "manépa", "남성１a", "男性1a"},
	{"battlecharset", "男性１b", "man1 b", "man1-2", "jidadb", "manépb", "남성１b", "男性1b"},
	{"battlecharset", "男性２a", "man2 a", "man2-1", "mjitta", "manéqa", "남성２a", "男性2a"},
	{"battlecharset", "男性２b", "man2 b", "man2-2", "mjittb", "manéqb", "남성２b", "男性2b"},
	{"battlecharset", "男性３a", "man3 a", "man3-1", "chuaza", "manéra", "남성３a", "男性3a"},
	{"battlecharset", "男性３b", "man3 b", "man3-2", "chuazb", "manérb", "남성３b", "男性3b"},
	{"battlecharset", "男性４a", "man4 a", "man4-1", "shella", "manésa", "남성４a", "男性4a"},
	{"battlecharset", "男性４b", "man4 b", "man4-2", "shellb", "manésb", "남성４b", "男性4b"},
	{"battlecharset", "男性５a", "man5 a", "man5-1", "frossa", "manéta", "남성５a", "男性5a"},
	{"battlecharset", "男性５b", "man5 b", "man5-2", "frossb", "manétb", "남성５b", "男性5b"},
	{"battlecharset", "盗賊女a", "female bandit a", "thief-f-1", "otipaa", "thiefwomana", "도적女a", "盜賊女a"},
	{"battlecharset", "盗賊女b", "female bandit b", "thief-f-2", "otipab", "thiefwomanb", "도적女b", "盜賊女b"},
	{"battlecharset", "盗賊男a", "male bandit a", "thief-m-1", "unnona", "thiefmana", "도적男a", "盜賊男a"},
	{"battlecharset", "盗賊男b", "male bandit b", "thief-m-2", "unnonb", "thiefmanb", "도적男b", "盜賊男b"},
	{"battlecharset", "鎧武者a", "armored warror a", "armor1", "joegoa", "armourwarriora", "갑옷무사a", "鎧甲武者a"},
	{"battlecharset", "鎧武者b", "armored warror b", "armor2", "joegob", "armourwarriorb", "갑옷무사b", "鎧甲武者b"},
	{"battlecharset", "魔術師女a", "female mage a", "mage-f-1", "ljitia", "magicteacherwomana", "마술사女a", "魔術師女a"},
	{"battlecharset", "魔術師女b", "female mage b", "mage-f-2", "ljitib", "magicteacherwomanb", "마술사女b", "魔術師女b"},
	{"battlecharset", "魔術師男a", "male mage a", "mage-m-1", "rivraa", "magicteachermana", "마술사男a", "魔術師男a"},
	{"battlecharset", "魔術師男b", "male mage b", "mage-m-2", "rivrab", "magicteachermanb", "마술사男b", "魔術師男b"},
	{"battleweapon", "武器", "weapon", "weapons", "standart", "weapon", "무기", "武器"},
	{"charset", "オブジェクト1", "object1", "object1", "objects1", "object1", "오브젝트1", "物件1"},
	{"charset", "オブジェクト2", "object2", "object2", "objects2", "object2", "오브젝트2", "物件2"},
	{"charset", "モンスター1", "monster1", "monster1", "monsters1", "monster1", "몬스터1", "怪物1"},
	{"charset", "モンスター2", "monster2", "monster2", "monsters2", "monster2", "몬스터2", "怪物2"},
	{"charset", "一般1", "people1", "char1", "people1", "general1", "일반1", "一般1"},
	{"charset", "一般2", "people2", "char2", "people2", "general2", "일반2", "一般2"},
	{"charset", "一般3", "people3", "char3", "people3", "general3", "일반3", "一般3"},
	{"charset", "一般4", "people4", "char4", "people4", "general4", "일반4", "一般4"},
	{"charset", "一般5", "people5", "char5", "people5", "general5", "일반5", "一般5"},
	{"charset", "主人公1", "actor1", "hero1", "chara1", "protagonist1", "주인공1", "主角1"},
	{"charset", "主人公2", "actor2", "hero2", "chara2", "protagonist2", "주인공2", "主角2"},
	{"charset", "主人公3", "actor3", "hero3", "chara3", "protagonist3", "주인공3", "主角3"},
	{"charset", "主人公4", "actor4", "hero4", "chara4", "protagonist4", "주인공4", "主角4"},
	{"charset", "乗り物", "vehicles", "vehicle", "vehicles", "vehicle", "탈것", "交通工具"},
	{"charset", "動物", "animal", "animal", "animals", "animal", "동물", "動物"},
	{"chipset", "ダンジョン", "dungeon", "dungeon", "internal1", "donjohn", "던젼", "迷宮"},
	{"chipset", "内装", "interior", "building", "internal2", "interior", "내부", "內部"},
	{"chipset", "基本", "world", "main", "world", "basic", "기본", "基本"},
	{"chipset", "外観", "exterior", "town", "village", "appearance", "외견", "外部"},
	{"chipset", "船", "ship", "ship", "ship", "boat", "배", "船"},
	{"faceset", "モンスター", "monster", "monster", "monsters", "monster", "몬스터", "怪物"},
	{"faceset", "一般1", "people1", "faces1", "people", "general1", "일반1", "一般1"},
	{"faceset", "一般2", "people2", "faces2", "peopleanimal", "general2", "일반2", "一般2"},
	{"faceset", "主人公1", "actor1", "hero1", "face1", "protagonist1", "주인공1", "主角1"},
	{"faceset", "主人公2", "actor2", "hero2", "face2", "protagonist2", "주인공2", "主角2"},
	{"gameover", "ゲームオーバー", "game over", "gameover", "gameover", "gameover", "게임오버", "遊戲結束"},
	{"gameover", nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, "遊戲結束2"},
	{"monster", "アーリマン", "ahriman", "ariman", "maliciousflower", "ahriman", "아리맨", "阿利曼"},
	{"monster", "アスラ", "asura", "asura", "weaponmaster", "multiarmdemon", "아수라", "阿蘇拉"},
	{"monster", "アナコンダ", "anaconda", "anaconda", "snake", "anaconda", "아나콘다", "巨蟒"},
	{"monster", "アリゲーター", "alligator", "alligator", "crocodile", "alligator", "엘리게이터", "短吻鱷"},
	{"monster", "アンデッドナイト", "undead knight", "u-knight", "deadpirate", "pimpskeleton", "언데드 나이트", "不死騎士"},
	{"monster", "イフリート", "ifreet", "efreet", "efrit", "ifrit", "이프리트", "伊弗利特"},
	{"monster", "インプ", "imp", "imp", "features", "littledemon", "임프", "小魔鬼"},
	{"monster", "ヴァンパイア", "vampire", "vampire", "vampire", "vampire", "뱀파이어", "吸血鬼"},
	{"monster", "ウロボロス", "ouroboros", "oroboros", "levitan", "dragon", "우로보로스", "吞尾蛇"},
	{"monster", "エルフ", "elf", "elf", "archer", "elf", "엘프", "妖精"},
	{"monster", "オーガ", "ogre", "ogre", "primitiveman", "auger", "오거", "食人魔"},
	{"monster", "オーク", "orc", "orc", "pigsoldier", "ork", "오크", "獸人戰士"},
	{"monster", "オーディン", "odin", "odin", "dangeroussoldier", "odin", "오딘", "奧丁"},
	{"monster", "オクトパス", "octopus", "octopus", "octopus", "octopus", "옥토퍼스", "八爪章魚"},
	{"monster", "ガーゴイル", "gargoyle", "gargoyle", "gargoyle", "gargoyle", "가고일", "石像獸"},
	{"monster", "カーバンクル", "carbuncle", "carbuncle", "rubyfox", "carbunkle", "카방클", "紅寶石"},
	{"monster", "カーミラ", "carmilla", "cojurer", "murdererwoman", "carmira", "카미라", "卡美拉"},
	{"monster", "カッパ", "kappa", "kappa", "morloc", "raincoat", "카트바", "河童"},
	{"monster", "カトブレパス", "catoblepas", "catoblepas", "curvebull", "demonhorsething", "카토부레바트", "卡托布里帕斯"},
	{"monster", "ガルーダ", "garuda", "garuda", "flyingwarrior", "garuda", "가루다", "揭路荼"},
	{"monster", "キメラ", "chimera", "chimera", "chimera", "chimera", "키메라", "吐火獸"},
	{"monster", "グール", "ghoul", "ghoul", "zombie", "ghoul", "구울", "食屍鬼"},
	{"monster", "クラーケン", "kraken", "kraken", "seabowl", "seamonster", "크라켄", "克拉坎"},
	{"monster", "クラブ", "crab", "cancer", "crab", "crab", "크랩", "巨蟹"},
	{"monster", "グリフォン", "griffon", "griffon", "griphon", "griffin", "그리폰", "葛里芬"},
	{"monster", "グレル", "grell", "grell", "robot", "jellyfish", "구렐", "毛面蟲"},
	{"monster", "クロウラー", "crawler", "crawler", "worm", "crowera", "쿠로우라", "爬蟲"},
	{"monster", "ゲイザー", "gazer", "deathgaze", "eye", "eyestalk", "게이져", "看守者"},
	{"monster", "ケツアルクアトル", "quetzalcoatl", "quezal", "flyingworm", "birdsnake", "케이시아르크 아토르", "羽蛇神"},
	{"monster", "ケットシー", "cait sith", "caitsith", "eremite", "ketsea", "캐트시", "貓靈"},
	{"monster", "ケルベロス", "cerberus", "cerberus", "cerberus", "cerebus", "켈베로스", "地獄犬"},
	{"monster", "ケンタウロス", "centaur", "centaur", "centaur", "centaur", "켄타우르스", "半人馬"},
	{"monster", "ゴーゴン", "gorgon", "gorgon", "infernalbull", "bull", "고곤", "戈耳戈"},
	{"monster", "ゴースト", "ghost", "ghost", "witchphantom", "ghost", "고스트", "鬼魂"},
	{"monster", "ゴーレム", "golem", "golem", "golem", "golem", "골렘", "高崙"},
	{"monster", "コカトリス", "cockatorice", "cockatrice", "rooster", "cockatrice", "코카트리스", "雞蛇獸"},
	{"monster", "ゴブリン", "goblin", "goblin", "littledemon", "imp", "고블린", "小妖精"},
	{"monster", "コボルト", "kobold", "kobold", "wolf", "kobold", "코볼트", "地精"},
	{"monster", "サイクロプス", "cyclops", "cyclops", "cyclops", "giant", "사이클롭스", "獨眼巨人"},
	{"monster", "サタナエル", "satan", "satan", "darkangel", "darkangel", "사타나엘", "撒旦尼爾"},
	{"monster", "サハギン", "sahagin", "sahagin", "triton", "merman", "사하킨", "半魚人撒哈奇"},
	{"monster", "サラマンダー", "salamander", "salamander", "burninglizard", "salamander", "사라멘더", "火蜥蜴"},
	{"monster", "シャーク", "shark", "shark", "shark", "shark", "샤크", "鯊魚"},
	{"monster", "ジャイアント", "giant", "giant", "cannibal", "giant-2", "자이언트", "巨人"},
	{"monster", "ジャック・オー・ランタン", "jack-o-lantern", "jack", "pumpkin", "jackolantern", "잭-오-랜턴", "燈籠怪"},
	{"monster", "シャドウ", "shadow", "shadow", "lostshadow", "shadow", "셰도우", "幻影"},
	{"monster", "シルフ", "sylph", "sylph", "fairy", "fairy", "실프", "風之精靈－絲芙"},
	{"monster", "スキュラ", "scylla", "scylla", "medusa", "gorgon", "스쿨라", "斯庫拉"},
	{"monster", "スケルトン", "skeleton", "skeleton", "skeleton", "skeleton", "스켈톤", "骷髏"},
	{"monster", "スコーピオン", "scorpion", "scorpion", "cancer", "scorpion", "스콜피온", "天蠍"},
	{"monster", "スネーク", "snake", "snake", "dangeroussnake", "snake", "스테이크", "蛇"},
	{"monster", "スピリッツ", "spirit", "spirit", "laughingspirit", "spirit", "스피릿츠", "靈魂"},
	{"monster", "スフィンクス", "sphinx", "sphinx", "sphynx", "sphinx", "스핑크스", "斯芬克司"},
	{"monster", "スペクター", "spectre", "specter", "magicskull", "lostsoul", "스펙터", "幽靈"},
	{"monster", "スライム", "slime", "slime", "slime", "slime", "슬라임", "史萊姆"},
	{"monster", "セイレーン", "siren", "siren", "flyingmermaid", "merangel", "세이렌", "賽倫女妖"},
	{"monster", "セラフィム", "seraphim", "seraph", "sephiroth", "angel", "세라핌", "撒拉弗"},
	{"monster", "センチピード", "centipede", "centipede", "multileg", "catterpillar", "센티피드", "百腳蜈蚣"},
	{"monster", "ソーサラー", "sorcerer", "sorcerer", "magician", "wizard", "소서러", "巫師"},
	{"monster", "ゾンビ", "zombie", "zombie", "poisonzombie", "zombie", "좀비", "殭屍"},
	{"monster", "ダークエルフ", "dark elf", "darkelf", "fencer", "darkelf", "다크 엘프", "黑暗妖精"},
	{"monster", "ダークナイト", "dark knight", "darkknight", "knight", "darkknight", "다크 나이트", "暗黑騎士"},
	{"monster", "タイタン", "titan", "titan", "titan", "titan", "타이탄", "泰坦巨人"},
	{"monster", "タランチュラ", "tarantula", "spider", "spider", "spider", "타란튤라", "狼蛛"},
	{"monster", "ティアマット", "tiamat", "tiamat", "many-domeddragon", "tiamat", "데어 매트", "塔亞瑪特邪龍"},
	{"monster", "デーモン", "demon", "demon", "horngoat", "daemon", "데몬", "惡魔"},
	{"monster", "トード", "toad", "toad", "toad", "frog", "토드", "蟾蜍"},
	{"monster", "ドラゴン", "dragon", "dragon", "bluedragon", "dragon-2", "드래곤", "龍"},
	{"monster", "ドラゴンナイト", "dragon knight", "dragonknight", "dragonwarrior", "dragonknight", "드래곤 나이트", "龍騎士"},
	{"monster", "トレント", "treant", "treant", "dendrid", "tree", "트렌트", "樹精"},
	{"monster", "トロール", "troll", "troll", "orc", "troll", "트롤", "山怪"},
	{"monster", "ネクロマンサー", "necromancer", "necromancer", "necromant", "necromancer", "네크로맨서", "死靈法師"},
	{"monster", "ネペンテス", "nepenthes", "nepenthe", "multirootflower", "killerplant", "네벤테스", "豬籠草怪"},
	{"monster", "バーサーカー", "berserker", "berserker", "barbarian", "barbarian", "버저커", "狂暴戰士"},
	{"monster", "ハーピー", "harpy", "harpy", "harpy", "harpy", "하피", "鳥人哈比"},
	{"monster", "バジリスク", "basilisk", "basilisk", "horned", "earwig", "바실리크스", "蛇怪"},
	{"monster", "バット", "bat", "bat", "bat", "bat", "배트", "蝙蝠"},
	{"monster", "バハムート", "bahamut", "bahamut", "dragon", "lizarddemon", "바하무트", "巴哈姆特"},
	{"monster", "パラサイト", "parasite", "parasite", "all-knowing", "parasite", "페러사이트", "寄生蟲"},
	{"monster", "ビッグフット", "big foot", "bigfoot", "yeti", "yeti", "빅풋", "大腳怪"},
	{"monster", "ヒュドラ", "hydra", "hydra", "many-domeduglycreature", "hydra", "히드라", "九頭蛇"},
	{"monster", "フェニックス", "phoenix", "phoenix", "phoenix", "phoenix", "피닉스", "鳳凰鳥"},
	{"monster", "フェンリル", "fenrir", "fenrir", "realwolf", "wolf", "펜릴", "大天狼"},
	{"monster", "ベヒーモス", "behemoth", "behemoth", "infernaldog", "behemoth", "배히모스", "巨獸"},
	{"monster", "ホーネット", "hornet", "hornet", "bee", "bea", "호넷", "大黃蜂"},
	{"monster", "マンティコア", "manticore", "manticore", "crossedbeast", "monster", "만티코어", "蒙特寇爾"},
	{"monster", "マンティス", "mantis", "mantis", "insect", "preyingmantis", "만티스", "螳螂怪"},
	{"monster", "マンモス", "mammoth", "mammoth", "mamont", "mammoth", "맘모스", "長毛象"},
	{"monster", "ミイラ男", "mummy", "mummy", "mummy", "mummy", "미이라 男", "木乃伊"},
	{"monster", "ミドガルズオルム", "midgardsormr", "midgard-serp", "creepingcreature", "monster-2", "미드갈즈 오르무", "米嘉巨蟒"},
	{"monster", "ミノタウロス", "minotaur", "minotaur", "minotaur", "minotaur", "미노타우르스", "邁諾陶"},
	{"monster", "ミミック", "mimic", "mimic", "ogrechest", "mimic", "미믹", "變形怪"},
	{"monster", "メデューサ", "medusa", "medusa", "hypermedusa", "medusa", "메두사", "梅杜莎"},
	{"monster", "ユニコーン", "unicorn", "unicorn", "unicorn", "unicorn", "유니콘", "獨角獸"},
	{"monster", "ラクシュミ", "lakshmi", "rakashimi", "prophet", "mystic", "라쿠슈미", "吉祥天"},
	{"monster", "ラミア", "lamia", "lamia", "mermaid", "gorgon-2", "라미아", "拉米亞"},
	{"monster", "リヴァイアサン", "leviathan", "leviathan", "levitanwithahorn", "leviathan", "리바이어던", "大海獸"},
	{"monster", "リザード", "lizard", "lizard", "monitorlizard", "lizard", "리자드", "蜥蜴"},
	{"monster", "リザードマン", "lizardman", "lizardman", "lizardsoldier", "lizardman", "리자드맨", "蜥蜴人"},
	{"monster", "リッチ", "lich", "lich", "powerfulnecromant", "lich", "리치", "妖巫"},
	{"monster", "リリス", "lilith", "lillith", "multihandswarrior", "lilith", "리리스", "莉莉斯"},
	{"monster", "レイス", "wraith", "wraith", "phantom", "spectre", "레이스", "死靈"},
	{"monster", "レモラ", "remora", "remora", "sharpfish", "flyingfish", "레모라", "怪魚雷莫拉"},
	{"monster", "ワーウルフ", "werewolf", "werewolf", "werwolf", "werewolf", "워울프", "狼人"},
	{"monster", "ワーム", "worm", "worm", "toothworm", "worm", "웜", "蟲"},
	{"monster", "ワイト", "wight", "wight", "seizedsoldier", "yto", "와이트", "屍妖"},
	{"monster", "ワイバーン", "wyvern", "wyvern", "browndragon", "yburning", "와이번", "飛龍"},
	{"monster", "九尾の狐", "kyuubi", "ninetail", "magicfox", "foxofninetails", "구미호", "九尾狐狸"},
	{"monster", "朱雀", "suzaku", "redsparrow", "vainbird", "redsparrow", "주작", "朱雀"},
	{"monster", "玄武", "genbu", "blackturtle", "turtlesnake", "monster-3", "현무", "玄武"},
	{"monster", "白虎", "byakko", "whitetiger", "polartiger", "whitetiger", "백호", "白虎"},
	{"monster", "馬", "horse", "nightmare", "darkhorse", "horse", "말", "馬"},
	{"monster", "鬼", "oni", "oni", "ogre", "ogre", "도깨비(鬼)", "惡鬼"},
	{"monster", "麒麟", "kirin", "ki-rin", "fairytalehorse", "giraffe", "기린", "麒麟"},
	{"monster", "龍", "ryuu", "bluedragon", "longdragon", "bluedragon", "청룡", "青龍"},
	{"music", "2003いやしの泉", "2003healing spring", "spring", "2003happiness", "2003spring", "2003회복의 샘", "2003治癒之泉"},
	{"music", "2003カジノ三昧", "2003casino indulgence", "casino", "2003research", "2003casino", "2003카지노", "2003賭場"},
	{"music", "2003コロシアム", "2003colosseum", "arena", "2003piracy", "2003colloseum", "2003콜로세움", "2003競技場"},
	{"music", "2003サイバーシティ", "2003cyber city", "bustling-city", "2003joyfulnews", "2003rhinobarcity", "2003사이버 시티", "2003異次元城市"},
	{"music", "2003スノータウン", "2003snow town", "snowtown", "2003lullaby", "2003snowtown", "2003스노우 타운", "2003下雪的城鎮"},
	{"music", "2003パニック", "2003panic", "panic", "2003warning", "2003panic", "2003패닉", "2003恐慌"},
	{"music", "2003マキシマム・バトル", "2003maximum battle", "fierce-battle", "2003pursuit", "2003maximumsbattle", "2003맥시멈·전투", "2003極限戰鬥"},
	{"music", "2003一獲千金の夢", "2003dream of striking it rich", "jackpot", "2003silentpleasure", "2003dream-catchlotsofmoney", "2003일획천금의 꿈", "2003一獲千金之夢"},
	{"music", "2003冒険者たち", "2003adventurers", "adventure", "2003farewell", "2003venturepeople", "2003여행자 서고", "2003冒險者們"},
	{"music", "2003勇者の凱旋", "2003hero's return", "triumph", "2003bigpalace", "2003triumphalreturn", "2003용사의 개선", "2003勇者的凱旋"},
	{"music", "2003古城", "2003ancient city", "ancient-castle", "2003glory", "2003oldcastle", "2003고성", "2003古城"},
	{"music", "2003地下迷宮", "2003subterranean maze", "labyrinth", "2003fast", "2003undergroundlabyrinth", "2003지하미궁", "2003地下迷宮"},
	{"music", "2003夢幻の森", "2003dream forest", "forest", "2003worldsound", "2003forestoffantasy", "2003몽환의 숲", "2003夢幻之森"},
	{"music", "2003夢見心地", "2003dreaminess", "moonlight", "2003serenity", "2003mooniness", "2003꿈을 꾸는 기분", "2003夢幻心境"},
	{"music", "2003大混戦", "2003free for all", "armyclash", "2003gangster", "2003largeconfoundcombat", "2003대혼전", "2003大混戰"},
	{"music", "2003大空への翼", "2003wings to the sky", "airborne", "2003fanfares", "2003wingtoskies", "2003대공의 날개", "2003空中的羽翼"},
	{"music", "2003大聖堂", "2003cathedral", "hallowed-halls", "2003grief", "2003largesaintlyhall", "2003대성당", "2003大聖堂"},
	{"music", "2003妖精の森", "2003fairy forest", "fairies", "2003workingmusic", "2003fairyforest", "2003요정의 숲", "2003妖精之森"},
	{"music", "2003孤独な旅立ち", "2003lonesome journey", "lonewolf", "2003memoirs", "2003lonelyjourney", "2003고독한 여행", "2003孤獨的旅行"},
	{"music", "2003小さな兵隊のマーチ", "2003little army's march", "march", "2003parade", "2003marchofsmallsoldiers", "2003작은 군대의 행진곡", "2003小軍隊進行曲"},
	{"music", "2003山あいの村", "2003village in the valley", "mtn-village", "2003eaststyle", "2003villageofravines", "2003산골짜기 마을", "2003山中部落"},
	{"music", "2003帝国～エンパイア", "2003empire", "empire", "2003andagainpleasure", "2003enpire", "2003제국", "2003帝國"},
	{"music", "2003幼少の記憶", "2003young memories", "memories", "2003fairytale", "2003memoryofinfancy", "2003유소의 기억", "2003年少記憶"},
	{"music", "2003忍び寄る闇", "2003creeping darkness", "foreboding", "2003threat", "2003approachingdarkness", "2003살며시 다가옴", "2003悄然黑夜"},
	{"music", "2003悠久の時の流れに", "2003in the eternal flow of time", "eternal", "2003calm", "2003theeternalflow", "2003유구의 흐름", "2003悠久時光的流轉"},
	{"music", "2003悲しみ", "2003sorrow", "sadness", "2003calm2", "2003sorrow", "2003슬퍼하고", "2003悲傷"},
	{"music", "2003戦いの幕開け", "2003beginning of a war", "intro", "2003dangerousfog", "2003fightopening", "2003싸움의 개막", "2003戰爭的序幕"},
	{"music", "2003教会", "2003church", "church1", "2003church", "2003church", "2003교회", "2003教會"},
	{"music", "2003日だまりの村", "2003sunnyvillage", "village4", "2003farmer", "2003villageball", "2003양지의 마을", "2003日光村落"},
	{"music", "2003暗黒の祭壇", "2003darkaltar", "evil-temple", "2003globalfrustration", "2003altarofdarkness", "2003암흑의 제단", "2003暗黑祭壇"},
	{"music", "2003未開の集落", "2003village of savages", "strangetown", "2003witchsong", "2003unexploredvillage", "2003미개한 취락", "2003未開化部落"},
	{"music", "2003極東の地", "2003far eastern land", "far-east", "2003flight", "2003fareasternarea", "2003극동의 땅", "2003極東之地"},
	{"music", "2003機械要塞", "2003machine fortress", "mecha-base", "2003sadend", "2003machinefortress", "2003기계 요새", "2003機械要塞"},
	{"music", "2003氷のラビリンス", "2003ice labyrinth", "icecave", "2003drops", "2003icelabyrinth", "2003얼음의 래비런스", "2003冰之迷宮"},
	{"music", "2003決戦の地", "2003final battleground", "showdown", "2003battlefield", "2003areaofdecisivebattles", "2003결전의 땅", "2003決戰之地"},
	{"music", "2003無人の館", "2003deserted mansion", "haunted", "2003silentcrying", "2003unmannedmansion", "2003무인 저택", "2003無人別館"},
	{"music", "2003王宮のパーティー", "2003palace party", "royal-ball", "2003dance", "2003courtparty", "2003왕궁의 파티", "2003皇宮盛會"},
	{"music", "2003異次元回廊", "2003otherworldly corridor", "dimension", "2003fastbattle", "2003strangedimensionalcorridor", "2003차원의 길", "2003異次元迴廊"},
	{"music", "2003祝福ワルツ", "2003waltz of blessings", "waltz", "2003waltz", "2003blessingwaltz", "2003축복 왈츠", "2003祝福的華爾滋"},
	{"music", "2003穏やかな風", "2003steady breeze", "interlude", "2003summer", "2003calmwind", "2003온화한 바람", "2003徐徐微風"},
	{"music", "2003緊迫", "2003tension", "tension", "2003terribledream", "2003tension", "2003긴박", "2003緊迫"},
	{"music", "2003繰り返される戦い", "2003repeated wars", "endless-fight", "2003fastbattle2", "2003thefightwhichisrepeated", "2003반복된 싸움", "2003反覆的戰鬥"},
	{"music", "2003街の賑わい", "2003city bustle", "town-square", "2003pleasure", "2003towncrowd", "2003거리의 북적임", "2003熱鬧街道"},
	{"music", "2003街の酒場", "2003tavern", "bar", "2003travel", "2003townbar", "2003거리의 술집", "2003街上的酒館"},
	{"music", "2003記憶の彼方に", "2003deep memory", "memories2", "2003morning", "2003onthefarsideofmemories", "2003기억의 저쪽에", "2003記憶中的彼方"},
	{"music", "2003遺跡探索", "2003exploring ruins", "ruins", "2003infiniteidea", "2003ruinssearch", "2003유적 탐색", "2003遺跡探索"},
	{"music", "2003邪神との戦い", "2003battle with an evil god", "godslayer", "2003chaos", "2003wickedgodfight", "2003사신과의 싸움", "2003與邪神一戰"},
	{"music", "2003静寂", "2003silence", "calm", "2003underwater", "2003calmness", "2003정적", "2003靜寂"},
	{"music", "j2003ホルン", "j2003horn", "horns", "2003win", "j2003horn", "j2003호른", "j2003號角"},
	{"music", "jアイテム", "jitem", "item", nullptr, "jitem", "j아이템", "j物品"},
	{"music", "jギャグ1", "jjoke 1", "mischief1", nullptr, "jgag1", "j개그1", "j鬧劇1"},
	{"music", "jギャグ2", "jjoke 2", "mischief2", nullptr, "jgag2", "j개그2", "j鬧劇2"},
	{"music", "jファンファーレ1", "jfanfare 1", "fanfare1", nullptr, "jfanfare1", "j팡파르1", "j吹奏樂1"},
	{"music", "jファンファーレ2", "jfanfare 2", "fanfare2", nullptr, "jfanfare2", "j팡파르2", "j吹奏樂2"},
	{"music", "jファンファーレ3", "jfanfare 3", "fanfare3", nullptr, "jfanfare3", "j팡파르3", "j吹奏樂3"},
	{"music", "jファンファーレ4", "jfanfare 4", "fanfare4", nullptr, "jfanfare4", "j팡파르4", "j吹奏樂4"},
	{"music", "jファンファーレ5", "jfanfare 5", "fanfare5", nullptr, "jfanfare5", "j팡파르5", "j吹奏樂5"},
	{"music", "jファンファーレ6", "jfanfare 6", "fanfare6", nullptr, "jfanfare6", "j팡파르6", "j吹奏樂6"},
	{"music", "j宿1", "jinn 1", "inn1", nullptr, "jinn1", "j숙소1", "j住宿1"},
	{"music", "j宿2", "jinn 2", "inn2", nullptr, "jinn2", "j숙소2", "j住宿2"},
	{"music", "j戦闘終了1", "jend of battle 1", "victory1", nullptr, "jaggressiveend1", "j전투종료1", "j戰鬥結束1"},
	{"music", "j戦闘終了2", "jend of battle 2", "victory2", nullptr, "jaggressiveend2", "j전투종료2", "j戰鬥結束2"},
	{"music", "j戦闘終了3", "jend of battle 3", "victory3", nullptr, "jaggressiveend3", "j전투종료3", "j戰鬥結束3"},
	{"music", "j戦闘終了4", "jend of battle 4", "victory4", nullptr, "jaggressiveend4", "j전투종료4", "j戰鬥結束4"},
	{"music", "j疑惑", "jdoubt", "surprise", nullptr, "jdoubt", "j의혹", "j疑惑"},
	{"music", "j謎", "jmystery", "riddle", nullptr, "jpuzzle", "j수수께기", "j謎"},
	{"music", "se2003アラーム", "se2003alarm", "se-alarm", "se2003ding", "se2003alarm", "se2003알람", "se2003警報"},
	{"music", "se2003ジャングル", "se2003jungle", "se-jungle", "se2003jungle", "se2003jungle", "se2003정글", "se2003叢林"},
	{"music", "se2003雑踏", "se2003bustle", "se-crowd", "se2003people", "se2003bustle", "se2003혼잡", "se2003雜沓"},
	{"music", "se2003風", "se2003wind", "se-gale", "se2003winter", "se2003wind", "se2003바람", "se2003風"},
	{"music", "se2003鳥", "se2003bird", "se-bird", "se2003birds", "se2003bird", "se2003새", "se2003鳥"},
	{"music", "se地震", "seearthquake", "se-quake", "seearthquake", "seearthquake", "se지진", "se地震"},
	{"music", "se大雨", "sedownpour", "se-torrent", "serain2", "seheavyrain", "se호우", "se大雨"},
	{"music", "se時計", "seclock", "se-clock", "seclock", "seclock", "se시계", "se鐘"},
	{"music", "se海", "sesea", "se-ocean", "sesea", "sesea", "se바다", "se海"},
	{"music", "se雨", "serain", "se-rain", "serain", "serainy", "se비", "se雨"},
	{"music", "エンディング1", "ending 1", "ending1", nullptr, nullptr, "끝1", "結束1"},
	{"music", "エンディング2", "ending 2", "ending2", nullptr, nullptr, "끝2", "結束2"},
	{"music", "エンディング3", "ending 3", "ending3", nullptr, nullptr, "끝3", "結束3"},
	{"music", "オープニング1", "opening 1", "opening1", nullptr, nullptr, "오프닝1", "開始1"},
	{"music", "オープニング2", "opening 2", "opening2", nullptr, nullptr, "오프닝2", "開始2"},
	{"music", "オープニング3", "opening 3", "opening3", nullptr, nullptr, "오프닝3", "開始3"},
	{"music", "ゲームオーバー1", "game over 1", "gameover1", nullptr, nullptr, "게임오버1", "遊戲結束1"},
	{"music", "ゲームオーバー2", "game over 2", "gameover2", nullptr, nullptr, "게임오버2", "遊戲結束2"},
	{"music", "ゲームオーバー3", "game over 3", "gameover3", nullptr, nullptr, "게임오버3", "遊戲結束3"},
	{"music", "ゴーストタウン1", "ghost town 1", "ghost-town1", nullptr, nullptr, "고스트 타운1", "鬼城1"},
	{"music", "ゴーストタウン2", "ghost town 2", "ghost-town2", nullptr, nullptr, "고스트 타운2", "鬼城2"},
	{"music", "ダンジョン1", "dungeon 1", "dungeon1", nullptr, nullptr, "지하감옥1", "迷宮1"},
	{"music", "ダンジョン2", "dungeon 2", "dungeon2", nullptr, nullptr, "지하감옥2", "迷宮2"},
	{"music", "ダンジョン3", "dungeon 3", "dungeon3", nullptr, nullptr, "지하감옥3", "迷宮3"},
	{"music", "ダンジョン4", "dungeon 4", "dungeon4", nullptr, nullptr, "지하감옥4", "迷宮4"},
	{"music", "ダンジョン5", "dungeon 5", "dungeon5", nullptr, nullptr, "지하감옥5", "迷宮5"},
	{"music", "ピンチ", "in a pinch", "tightspot", nullptr, nullptr, "핀치", "危機"},
	{"music", "フィールド1", "field 1", "field1", nullptr, nullptr, "필드1", "原野1"},
	{"music", "フィールド2", "field 2", "field2", nullptr, nullptr, "필드2", "原野2"},
	{"music", "フィールド3", "field 3", "field3", nullptr, nullptr, "필드3", "原野3"},
	{"music", "フィールド4", "field 4", "field4", nullptr, nullptr, "필드4", "原野4"},
	{"music", "ボス1", "boss 1", "boss1", nullptr, nullptr, "보스1", "boss1"},
	{"music", "ボス2", "boss 2", "boss2", nullptr, nullptr, "보스2", "boss2"},
	{"music", "ボス3", "boss 3", "boss3", nullptr, nullptr, "보스3", "boss3"},
	{"music", "ボス4", "boss 4", "boss4", nullptr, nullptr, "보스4", "boss4"},
	{"music", "乗り物1", "vehicle 1", "vehicle1", nullptr, nullptr, "차량1", "交通工具1"},
	{"music", "乗り物2", "vehicle 2", "vehicle2", nullptr, nullptr, "차량2", "交通工具2"},
	{"music", "乗り物3", "vehicle 3", "vehicle3", nullptr, nullptr, "차량3", "交通工具3"},
	{"music", "別れ1", "parting 1", "parting1", nullptr, nullptr, "이별1", "別離1"},
	{"music", "別れ2", "parting 2", "parting2", nullptr, nullptr, "이별2", "別離2"},
	{"music", "勇者1", "hero 1", "hero1", nullptr, nullptr, "용사1", "勇者1"},
	{"music", "勇者2", "hero 2", "hero2", nullptr, nullptr, "용사2", "勇者2"},
	{"music", "動物", "animal", "animal", nullptr, nullptr, "동물", "動物"},
	{"music", "勝利", "victory", "success", nullptr, nullptr, "승리", "勝利"},
	{"music", "城1", "castle 1", "castle1", nullptr, nullptr, "성1", "城1"},
	{"music", "城2", "castle 2", "castle2", nullptr, nullptr, "성2", "城2"},
	{"music", "城3", "castle 3", "castle3", nullptr, nullptr, "성3", "城3"},
	{"music", "塔1", "tower 1", "tower1", nullptr, nullptr, "탑1", "塔1"},
	{"music", "塔2", "tower 2", "tower2", nullptr, nullptr, "탑2", "塔2"},
	{"music", "塔3", "tower 3", "tower3", nullptr, nullptr, "탑3", "塔3"},
	{"music", "妖精1", "fairy 1", "fairy1", nullptr, nullptr, "요정1", "妖精1"},
	{"music", "妖精2", "fairy 2", "fairy2", nullptr, nullptr, "요정2", "妖精2"},
	{"music", "安らぎ1", "repose 1", "solace1", nullptr, nullptr, "편안해짐1", "安樂1"},
	{"music", "安らぎ2", "repose 2", "solace2", nullptr, nullptr, "편안해짐2", "安樂2"},
	{"music", "安らぎ3", "repose 3", "solace3", nullptr, nullptr, "편안해짐3", "安樂3"},
	{"music", "店1", "shop 1", "shop1", nullptr, nullptr, "점1", "店1"},
	{"music", "店2", "shop 2", "shop2", nullptr, nullptr, "점2", "店2"},
	{"music", "店3", "shop 3", "shop3", nullptr, nullptr, "점3", "店3"},
	{"music", "怒り", "wrath", "malice", nullptr, nullptr, "화내다", "怒"},
	{"music", "悲しみ", "sorrow", "sad", nullptr, nullptr, "슬퍼하다", "悲傷"},
	{"music", "戦闘1", "battle 1", "battle1", nullptr, nullptr, "전투1", "戰鬥1"},
	{"music", "戦闘2", "battle 2", "battle2", nullptr, nullptr, "전투2", "戰鬥2"},
	{"music", "戦闘3", "battle 3", "battle3", nullptr, nullptr, "전투3", "戰鬥3"},
	{"music", "探索", "exploration", "explore", nullptr, nullptr, "탐색", "探索"},
	{"music", "敗北", "defeat", "defeat", nullptr, nullptr, "패배", "敗北"},
	{"music", "教会", "church", "church2", nullptr, nullptr, "교회", "教會"},
	{"music", "明るい市場", "lively market", "bazaar", nullptr, nullptr, "밝은 시장", "明亮的市集"},
	{"music", "村1", "village 1", "village1", nullptr, nullptr, "촌1", "村1"},
	{"music", "村2", "village 2", "village2", nullptr, nullptr, "촌2", "村2"},
	{"music", "村3", "village 3", "village3", nullptr, nullptr, "촌3", "村3"},
	{"music", "泥棒", "thief", "thief", nullptr, nullptr, "도둑", "泥棒"},
	{"music", "活気", "liveliness", "strength", nullptr, nullptr, "활기", "朝氣"},
	{"music", "町1", "town 1", "town1", nullptr, nullptr, "밭두둑1", "街1"},
	{"music", "町2", "town 2", "town2", nullptr, nullptr, "밭두둑2", "街2"},
	{"music", "町3", "town 3", "town3", nullptr, nullptr, "밭두둑3", "街3"},
	{"music", "神秘1", "mystery 1", "mystery1", nullptr, nullptr, "신비1", "神秘1"},
	{"music", "神秘2", "mystery 2", "mystery2", nullptr, nullptr, "신비2", "神秘2"},
	{"music", "神秘3", "mystery 3", "mystery3", nullptr, nullptr, "신비3", "神秘3"},
	{"music", "秘宝", "secret treasure", "treasure", nullptr, nullptr, "바보", "神秘寶藏"},
	{"music", "船1", "ship 1", "boat1", nullptr, nullptr, "배1", "船1"},
	{"music", "船2", "ship 2", "boat2", nullptr, nullptr, "배2", "船2"},
	{"music", "船3", "ship 3", "boat3", nullptr, nullptr, "배3", "船3"},
	{"music", "試練", "trial", "ordeal", nullptr, nullptr, "시련", "試煉"},
	{"music", "闇市", "black market", "eviltown", nullptr, nullptr, "암시장", "黑市"},
	{"music", "魔王", "demon lord", "demonic", nullptr, nullptr, "마왕", "魔王"},
	{"panorama", "夕焼け1", "sunset1", "dusk1", "dawn1", "eveningglow1", "석양1", "夕陽1"},
	{"panorama", "夕焼け2", "sunset2", "dusk2", "dawn2", "eveningglow2", "석양2", "夕陽2"},
	{"panorama", "夜明け1", "dawn1", "dawn1", "evening1", "dawn1", "새벽1", "黎明1"},
	{"panorama", "夜明け2", "dawn2", "dawn2", "evening2", "dawn2", "새벽2", "黎明2"},
	{"panorama", "夜空1", "night sky1", "night1", "night1", "nightempty1", "밤하늘1", "夜空1"},
	{"panorama", "夜空2", "night sky2", "night2", "night2", "nightempty2", "밤하늘2", "夜空2"},
	{"panorama", "宇宙", "cosmos1", "space", "galaxy", "space", "우주", "宇宙"},
	{"panorama", "惑星1", "planet1", "planet1", "planet1", "planetary1", "혹성1", "惑星1"},
	{"panorama", "惑星2", "planet2", "planet2", "planet2", "planetary2", "혹성2", "惑星2"},
	{"panorama", "惑星3", "planet3", "planet3", "planet3", "planetary3", "혹성3", "惑星3"},
	{"panorama", "異空間", "dimension rift", "strange", "weird", "strangespacial", "이공간", "異次元空間"},
	{"panorama", "空1", "sky1", "sky1", "morning1", "empty1", "하늘1", "天空1"},
	{"panorama", "空2", "sky2", "sky2", "morning2", "empty2", "하늘2", "天空2"},
	{"sound", "アイテム1", "item1", "item1", nullptr, "item1", "아이템1", "物品1"},
	{"sound", "アイテム2", "item2", "item2", nullptr, "item2", "아이템2", "物品2"},
	{"sound", "あたり1", "chime1", "jingle1", nullptr, "around1", "즈음하고1", "碰撞1"},
	{"sound", "あたり2", "chime2", "jingle2", nullptr, "around2", "즈음하고2", "碰撞2"},
	{"sound", "アップ", "buff", "increase", nullptr, "upgrade", "업", "上昇"},
	{"sound", "イヌ", "dog", "dog", nullptr, "dog", "강아지", "狗"},
	{"sound", "ウシ", "cow", "cow", nullptr, "cow", "소", "牛"},
	{"sound", "ウマ", "horse", "horse", nullptr, "horse", "발판", "馬"},
	{"sound", "おたけび", "roar", "roar", nullptr, "roar", "우렁찬 외침", "吶喊"},
	{"sound", "カーソル1", "cursor1", "cursor1", nullptr, "cursor1", "커서1", "游標1"},
	{"sound", "カーソル2", "cursor2", "cursor2", nullptr, "cursor2", "커서2", "游標2"},
	{"sound", "ガシャン", "glassshatter", "shatter", nullptr, "glass", "가샨", "裂開"},
	{"sound", "キャンセル1", "cancel1", "cancel1", nullptr, "cancel1", "취소1", "取消1"},
	{"sound", "キャンセル2", "cancel2", "cancel2", nullptr, "cancel2", "취소2", "取消2"},
	{"sound", "しびれ1", "paralyze1", "paralyze1", nullptr, "paralyze1", "마비1", "麻痺1"},
	{"sound", "しびれ2", "paralyze2", "paralyze2", nullptr, "paralyze2", "마비2", "麻痺2"},
	{"sound", "しびれ3", "paralyze3", "paralyze3", nullptr, "paralyze3", "마비3", "麻痺3"},
	{"sound", "ジャンプ1", "jump1", "jump1", nullptr, "jump1", "점프1", "跳躍1"},
	{"sound", "ジャンプ2", "jump2", "jump2", nullptr, "jump2", "점프2", "跳躍2"},
	{"sound", "ショット1", "shot1", "shot1", nullptr, "laser1", "쇼트1", "發射1"},
	{"sound", "ショット2", "shot2", "shot2", nullptr, "laser2", "쇼트2", "發射2"},
	{"sound", "ショット3", "shot3", "shot3", nullptr, "laser3", "쇼트3", "發射3"},
	{"sound", "スイッチ1", "switch1", "switch1", nullptr, "switch1", "스위치1", "開關1"},
	{"sound", "スイッチ2", "switch2", "switch2", nullptr, "switch2", "스위치2", "開關2"},
	{"sound", "ダウン", "debuff", "decrease", nullptr, "downgrade", "다운", "下降"},
	{"sound", "ダメージ1", "damage1", "damage1", nullptr, "damege1", "데미지1", "傷害1"},
	{"sound", "ダメージ2", "damage2", "damage2", nullptr, "damege2", "데미지2", "傷害2"},
	{"sound", "テレポート1", "teleport1", "teleport1", nullptr, "teleport1", "텔레포트1", "傳送1"},
	{"sound", "テレポート2", "teleport2", "teleport2", nullptr, "teleport2", "텔레포트2", "傳送2"},
	{"sound", "トラ", "tiger", "tiger", nullptr, "tiger", "트럭", "虎"},
	{"sound", "にらみ", "glare", "gaze", nullptr, "glare", "노려봄", "凝視"},
	{"sound", "にわとり", "chicken", "chicken", nullptr, "chicken", "닭", "雞"},
	{"sound", "ネコ", "cat", "cat", nullptr, "cat", "고양이", "貓"},
	{"sound", "ノック", "knock", "knock", nullptr, "knock", "노크", "敲"},
	{"sound", "はずれ1", "buzzer1", "failure1", nullptr, "end1", "잘라내기1", "磨擦1"},
	{"sound", "はずれ2", "buzzer2", "failure2", nullptr, "end2", "잘라내기2", "磨擦2"},
	{"sound", "バリア", "barrier", "barrier", nullptr, "barrier", "배리어", "護罩"},
	{"sound", "ひつじ", "sheep", "sheep", nullptr, "sheep", "양", "羊"},
	{"sound", "ブザー1", "buzzer3", "buzzer1", nullptr, "buzzer1", "버저1", "汽笛1"},
	{"sound", "ブザー2", "buzzer4", "buzzer2", nullptr, "buzzer2", "버저2", "汽笛2"},
	{"sound", "フラッシュ1", "flash1", "flash1", nullptr, "flashlight1", "플래시1", "閃爍1"},
	{"sound", "フラッシュ2", "flash2", "flash2", nullptr, "flashlight2", "플래시2", "閃爍2"},
	{"sound", "フラッシュ3", "flash3", "flash3", nullptr, "flashlight3", "플래시3", "閃爍3"},
	{"sound", "ブレス", "breath", "breath", nullptr, "breath", "호흡", "氣息"},
	{"sound", "モンスター1", "monster1", "monster1", nullptr, "monster1", "몬스터1", "怪物1"},
	{"sound", "モンスター2", "monster2", "monster2", nullptr, "monster2", "몬스터2", "怪物2"},
	{"sound", "ライオン", "lion", "lion", nullptr, "lion", "사자", "獅"},
	{"sound", "冷気1", "ice1", "ice01", nullptr, "ice1", "냉기1", "冰1"},
	{"sound", "冷気2", "ice2", "ice04", nullptr, "ice2", "냉기2", "冰2"},
	{"sound", "冷気3", "ice3", "ice05", nullptr, "ice3", "냉기3", "冰3"},
	{"sound", "冷気4", "ice4", "ice06", nullptr, "ice4", "냉기4", "冰4"},
	{"sound", "冷気5", "ice5", "ice07", nullptr, "ice5", "냉기5", "冰5"},
	{"sound", "冷気6", "ice6", "ice08", nullptr, "ice6", "냉기6", "冰6"},
	{"sound", "冷気7", "ice7", "ice09", nullptr, "ice7", "냉기7", "冰7"},
	{"sound", "冷気8", "ice8", "ice10", nullptr, "ice8", "냉기8", "冰8"},
	{"sound", "冷気9", "ice9", "ice11", nullptr, "ice9", "냉기9", "冰9"},
	{"sound", "冷気10", "ice10", "ice02", nullptr, "ice10", "냉기10", "冰10"},
	{"sound", "冷気11", "ice11", "ice03", nullptr, "ice11", "냉기11", "冰11"},
	{"sound", "剣1", "sword1", "sword1", nullptr, "sword1", "검1", "劍1"},
	{"sound", "剣2", "sword2", "sword2", nullptr, "sword2", "검2", "劍2"},
	{"sound", "剣3", "sword3", "sword3", nullptr, "sword3", "검3", "劍3"},
	{"sound", "吸収1", "absorb1", "absorb1", nullptr, "absorption1", "흡수1", "吸收1"},
	{"sound", "吸収2", "absorb2", "absorb2", nullptr, "absorption2", "흡수2", "吸收2"},
	{"sound", "噛む", "bite", "bloodsuck", nullptr, "bite", "물다", "咬"},
	{"sound", "回復1", "recovery1", "heal1", nullptr, "recovery1", "회복1", "回復1"},
	{"sound", "回復2", "recovery2", "heal2", nullptr, "recovery2", "회복2", "回復2"},
	{"sound", "回復3", "recovery3", "heal3", nullptr, "recovery3", "회복3", "回復3"},
	{"sound", "回復4", "recovery4", "heal4", nullptr, "recovery4", "회복4", "回復4"},
	{"sound", "回復5", "recovery5", "heal5", nullptr, "recovery5", "회복5", "回復5"},
	{"sound", "回復6", "recovery6", "heal6", nullptr, "recovery6", "회복6", "回復6"},
	{"sound", "回復7", "recovery7", "heal7", nullptr, "recovery7", "회복7", "回復7"},
	{"sound", "回復8", "recovery8", "heal8", nullptr, "recovery8", "회복8", "回復8"},
	{"sound", "回避1", "evade1", "evade1", nullptr, "evasion1", "회피1", "迴避1"},
	{"sound", "回避2", "evade2", "evade2", nullptr, "evasion2", "회피2", "迴避2"},
	{"sound", "地震1", "earthquake1", "quake1", nullptr, "earthquake1", "지진1", "地震1"},
	{"sound", "地震2", "earthquake2", "quake2", nullptr, "earthquake2", "지진2", "地震2"},
	{"sound", "壁1", "barrier1", "bump1", nullptr, "wall1", "벽1", "壁1"},
	{"sound", "壁2", "barrier2", "bump2", nullptr, "wall2", "벽2", "壁2"},
	{"sound", "大地1", "earth1", "earth01", nullptr, "earth1", "대지1", "大地1"},
	{"sound", "大地2", "earth2", "earth02", nullptr, "earth2", "대지2", "大地2"},
	{"sound", "大地3", "earth3", "earth03", nullptr, "earth3", "대지3", "大地3"},
	{"sound", "大地4", "earth4", "earth04", nullptr, "earth4", "대지4", "大地4"},
	{"sound", "大地5", "earth5", "earth05", nullptr, "earth5", "대지5", "大地5"},
	{"sound", "大地6", "earth6", "earth06", nullptr, "earth6", "대지6", "大地6"},
	{"sound", "大地7", "earth7", "earth07", nullptr, "earth7", "대지7", "大地7"},
	{"sound", "大地8", "earth8", "earth08", nullptr, "earth8", "대지8", "大地8"},
	{"sound", "大地9", "earth9", "earth09", nullptr, "earth9", "대지9", "大地9"},
	{"sound", "大地10", "earth10", "earth10", nullptr, "earth10", "대지10", "大地10"},
	{"sound", "巻き付き", "ensnare", "ensnare", nullptr, "vortex", "달라붙기", "捲襲"},
	{"sound", "弓1", "bow1", "bow1", nullptr, "bow1", "활1", "弓1"},
	{"sound", "弓2", "bow2", "bow2", nullptr, "bow2", "활2", "弓2"},
	{"sound", "戦闘1", "combat1", "battle1", nullptr, "battle1", "전투1", "戰鬥1"},
	{"sound", "戦闘2", "combat2", "battle2", nullptr, "battle2", "전투2", "戰鬥2"},
	{"sound", "打撃1", "blow1", "punch1", nullptr, "blow1", "타격1", "打擊1"},
	{"sound", "打撃2", "blow2", "punch2", nullptr, "blow2", "타격2", "打擊2"},
	{"sound", "打撃3", "blow3", "punch3", nullptr, "blow3", "타격3", "打擊3"},
	{"sound", "打撃4", "blow4", "punch4", nullptr, "blow4", "타격4", "打擊4"},
	{"sound", "打撃5", "blow5", "punch5", nullptr, "blow5", "타격5", "打擊5"},
	{"sound", "打撃6", "blow6", "punch6", nullptr, "blow6", "타격6", "打擊6"},
	{"sound", "打撃7", "blow7", "punch7", nullptr, "blow7", "타격7", "打擊7"},
	{"sound", "攻撃1", "attack1", "attack1", nullptr, "attack1", "공격1", "攻擊1"},
	{"sound", "攻撃2", "attack2", "attack2", nullptr, "attack2", "공격2", "攻擊2"},
	{"sound", "斬る1", "slash1", "strike01", nullptr, "cut1", "벤다1", "斬1"},
	{"sound", "斬る10", "slash10", "strike10", nullptr, "cut10", "벤다10", "斬10"},
	{"sound", "斬る11", "slash11", "strike11", nullptr, "cut11", "벤다11", "斬11"},
	{"sound", "斬る2", "slash2", "strike02", nullptr, "cut2", "벤다2", "斬2"},
	{"sound", "斬る3", "slash3", "strike03", nullptr, "cut3", "벤다3", "斬3"},
	{"sound", "斬る4", "slash4", "strike04", nullptr, "cut4", "벤다4", "斬4"},
	{"sound", "斬る5", "slash5", "strike05", nullptr, "cut5", "벤다5", "斬5"},
	{"sound", "斬る6", "slash6", "strike06", nullptr, "cut6", "벤다6", "斬6"},
	{"sound", "斬る7", "slash7", "strike07", nullptr, "cut7", "벤다7", "斬7"},
	{"sound", "斬る8", "slash8", "strike08", nullptr, "cut8", "벤다8", "斬8"},
	{"sound", "斬る9", "slash9", "strike09", nullptr, "cut9", "벤다9", "斬9"},
	{"sound", "時計", "clock", "clock", nullptr, "clock", "시계", "時鐘"},
	{"sound", "暗闇", "blind", "night", nullptr, "darkness", "안보임", "黑暗"},
	{"sound", "暗黒1", "darkness1", "dark1", nullptr, "darkness1", "암흑1", "暗黑1"},
	{"sound", "暗黒2", "darkness2", "dark2", nullptr, "darkness2", "암흑2", "暗黑2"},
	{"sound", "暗黒3", "darkness3", "dark3", nullptr, "darkness3", "암흑3", "暗黑3"},
	{"sound", "暗黒4", "darkness4", "dark4", nullptr, "darkness4", "암흑4", "暗黑4"},
	{"sound", "暗黒5", "darkness5", "dark5", nullptr, "darkness5", "암흑5", "暗黑5"},
	{"sound", "暗黒6", "darkness6", "dark6", "dark6", "darkness6", "암흑6", "暗黑6"},
	{"sound", "歌", "song", "song", nullptr, "song", "노래", "歌"},
	{"sound", "毒", "poison", "poison", nullptr, "poison", "독", "毒"},
	{"sound", "水1", "water1", "water1", nullptr, "water1", "물1", "水1"},
	{"sound", "水2", "water2", "water2", nullptr, "water2", "물2", "水2"},
	{"sound", "水3", "water3", "water3", nullptr, "water3", "물3", "水3"},
	{"sound", "水4", "water4", "water4", nullptr, "water4", "물4", "水4"},
	{"sound", "水5", "water5", "water5", nullptr, "water5", "물5", "水5"},
	{"sound", "水6", "water6", "water6", nullptr, "water6", "물6", "水6"},
	{"sound", "決定1", "decision1", "choice1", nullptr, "decision1", "결정1", "決定1"},
	{"sound", "決定2", "decision2", "choice2", nullptr, "decision2", "결정2", "決定2"},
	{"sound", "沈黙", "silence", "silence", nullptr, "silence", "침묵", "沉默"},
	{"sound", "海1", "sea1", "sea1", nullptr, "sea1", "바다1", "海1"},
	{"sound", "海2", "sea2", "sea2", nullptr, "sea2", "바다2", "海2"},
	{"sound", "消滅1", "collapse1", "vanish1", nullptr, "disappearance1", "소멸1", "消滅1"},
	{"sound", "消滅2", "collapse2", "vanish2", nullptr, "disappearance2", "소멸2", "消滅2"},
	{"sound", "混乱", "confusion", "confuse", nullptr, "caos", "혼란", "混亂"},
	{"sound", "炎1", "fire1", "fire1", nullptr, "flame1", "화염1", "炎1"},
	{"sound", "炎2", "fire2", "fire2", nullptr, "flame2", "화염2", "炎2"},
	{"sound", "炎3", "fire3", "fire3", nullptr, "flame3", "화염3", "炎3"},
	{"sound", "炎4", "fire4", "fire4", nullptr, "flame4", "화염4", "炎4"},
	{"sound", "炎5", "fire5", "fire5", nullptr, "flame5", "화염5", "炎5"},
	{"sound", "炎6", "fire6", "fire6", nullptr, "flame6", "화염6", "炎6"},
	{"sound", "炎7", "fire7", "fire7", nullptr, "flame7", "화염7", "炎7"},
	{"sound", "炎8", "fire8", "fire8", nullptr, "flame8", "화염8", "炎8"},
	{"sound", "爆発1", "explosion1", "explode1", nullptr, "explosion1", "폭발1", "爆發1"},
	{"sound", "爆発2", "explosion2", "explode2", nullptr, "explosion2", "폭발2", "爆發2"},
	{"sound", "爆発3", "explosion3", "explode3", nullptr, "explosion3", "폭발3", "爆發3"},
	{"sound", "爆発4", "explosion4", "explode4", nullptr, "explosion4", "폭발4", "爆發4"},
	{"sound", "爆発5", "explosion5", "explode5", nullptr, "explosion5", "폭발5", "爆發5"},
	{"sound", "爆発6", "explosion6", "explode6", nullptr, "explosion6", "폭발6", "爆發6"},
	{"sound", "爆発7", "explosion7", "explode7", nullptr, "explosion7", "폭발7", "爆發7"},
	{"sound", "睡眠", "sleep", "sleep", nullptr, "sleep", "수면", "睡眠"},
	{"sound", "砂けむり", "sandstorm", "sandstorm", nullptr, "sandmind", "모래 연기", "沙塵暴"},
	{"sound", "神聖1", "holy1", "holy1", nullptr, "holy1", "신성1", "神聖1"},
	{"sound", "神聖2", "holy2", "holy2", nullptr, "holy2", "신성2", "神聖2"},
	{"sound", "神聖3", "holy3", "holy3", nullptr, "holy3", "신성3", "神聖3"},
	{"sound", "神聖4", "holy4", "holy4", nullptr, "holy4", "신성4", "神聖4"},
	{"sound", "神聖5", "holy5", "holy5", nullptr, "holy5", "신성5", "神聖5"},
	{"sound", "神聖6", "holy6", "holy6", nullptr, "holy6", "신성6", "神聖6"},
	{"sound", "神聖7", "holy7", "holy7", nullptr, "holy7", "신성7", "神聖7"},
	{"sound", "神聖8", "holy8", "holy8", nullptr, "holy8", "신성8", "神聖8"},
	{"sound", "神聖9", "holy9", "holy9", nullptr, "holy9", "신성9", "神聖9"},
	{"sound", "移動", "move", "footstep", nullptr, "run", "이동", "移動"},
	{"sound", "花粉", "pollen", "pollen", nullptr, "pollen", "꽃가루", "花粉"},
	{"sound", "落ちる1", "fall1", "fall1", nullptr, "fall1", "떨어진다1", "落下1"},
	{"sound", "落ちる2", "fall2", "fall2", nullptr, "fall2", "떨어진다2", "落下2"},
	{"sound", "蘇生1", "raise1", "revive1", nullptr, "revival1", "소생1", "復活1"},
	{"sound", "蘇生2", "raise2", "revive2", nullptr, "revival2", "소생2", "復活2"},
	{"sound", "蘇生3", "raise3", "revive3", nullptr, "revival3", "소생3", "復活3"},
	{"sound", "逃走", "escape", "flee", nullptr, "escape", "도주", "逃走"},
	{"sound", "鍵", "key", "key", nullptr, "key", "자물쇠", "鑰匙"},
	{"sound", "鐘", "bell", "gong", nullptr, "bell", "종", "鐘"},
	{"sound", "閉める1", "close1", "close1", nullptr, "close1", "닫는다1", "關閉1"},
	{"sound", "閉める2", "close2", "close2", nullptr, "close2", "닫는다2", "關閉2"},
	{"sound", "開ける1", "open1", "open1", nullptr, "open1", "열다1", "開啟1"},
	{"sound", "開ける2", "open2", "open2", nullptr, "open2", "열다2", "開啟2"},
	{"sound", "雨1", "rain1", "rain1", nullptr, "rain1", "비1", "雨1"},
	{"sound", "雨2", "rain2", "rain2", nullptr, "rain2", "비2", "雨2"},
	{"sound", "雷1", "thunder1", "bolt01", nullptr, "thunder1", "전격1", "雷1"},
	{"sound", "雷2", "thunder2", "bolt02", nullptr, "thunder2", "전격2", "雷2"},
	{"sound", "雷3", "thunder3", "bolt03", nullptr, "thunder3", "전격3", "雷3"},
	{"sound", "雷4", "thunder4", "bolt04", nullptr, "thunder4", "전격4", "雷4"},
	{"sound", "雷5", "thunder5", "bolt05", nullptr, "thunder5", "전격5", "雷5"},
	{"sound", "雷6", "thunder6", "bolt06", nullptr, "thunder6", "전격6", "雷6"},
	{"sound", "雷7", "thunder7", "bolt07", nullptr, "thunder7", "전격7", "雷7"},
	{"sound", "雷8", "thunder8", "bolt08", nullptr, "thunder8", "전격8", "雷8"},
	{"sound", "雷9", "thunder9", "bolt09", nullptr, "thunder9", "전격9", "雷9"},
	{"sound", "雷10", "thunder10", "bolt10", nullptr, "thunder10", "전격10", "雷10"},
	{"sound", "霧1", "fog1", "fog1", nullptr, "fog1", "안개1", "霧1"},
	{"sound", "霧2", "fog2", "fog2", nullptr, "fog2", "안개2", "霧2"},
	{"sound", "音波1", "wave1", "wave1", nullptr, "sound wave1", "음파1", "音波1"},
	{"sound", "音波2", "wave2", "wave2", nullptr, "sound wave2", "음파2", "音波2"},
	{"sound", "風1", "wind1", "wind01", nullptr, "wind1", "바람1", "風1"},
	{"sound", "風2", "wind2", "wind02", nullptr, "wind2", "바람2", "風2"},
	{"sound", "風3", "wind3", "wind03", nullptr, "wind3", "바람3", "風3"},
	{"sound", "風4", "wind4", "wind04", nullptr, "wind4", "바람4", "風4"},
	{"sound", "風5", "wind5", "wind05", nullptr, "wind5", "바람5", "風5"},
	{"sound", "風6", "wind6", "wind06", nullptr, "wind6", "바람6", "風6"},
	{"sound", "風7", "wind7", "wind07", nullptr, "wind7", "바람7", "風7"},
	{"sound", "風8", "wind8", "wind08", nullptr, "wind8", "바람8", "風8"},
	{"sound", "風9", "wind9", "wind09", nullptr, "wind9", "바람9", "風9"},
	{"sound", "風10", "wind10", "wind10", nullptr, "wind10", "바람10", "風10"},
	{"sound", "風11", "wind11", "wind11", nullptr, "wind11", "바람11", "風11"},
	{"sound", "魔法1", "magic1", "magic1", nullptr, "magic1", "마법1", "魔法1"},
	{"sound", "魔法2", "magic2", "magic2", nullptr, "magic2", "마법2", "魔法2"},
	{"system", "システム", "system", "system1", "system", "system", "시스템", "系統"},
	{"system", "システムa", "systema", "system2", "systema", "systema", "시스템a", "系統a"},
	{"system", "システムb", "systemb", "system3", "systemb", "systemb", "시스템b", "系統b"},
	{"system", "システムc", "systemc", "system4", "systemc", "systemc", "시스템c", "系統c"},
	{"system2", "システム２a", "system2a", "system2a", "system2a", "systeméqa", "시스템２a", "系統2a"},
	{"system2", "システム２b", "system2b", "system2b", "system2b", "systeméqb", "시스템２b", "系統2b"},
	{"system2", "システム２c", "system2c", "system2c", "system2c", "systeméqc", "시스템２c", "系統2c"},
	{"title", "タイトル1", "title1", "title1", "title1", "title1", "타이틀1", "標題1"},
	{"title", "タイトル2", "title2", "title2", "title2", "title2", "타이틀2", "標題2"},
	{"title", "タイトル3", "title3", "title3", "title3", "title3", "타이틀3", "標題3"},
	{"title", "タイトル4", "title4", "title4", "title4", "title4", "타이틀4", "標題4"},
	{nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr}
};

const char* const rtp_table_2k3_categories[16] = {
	"backdrop",
	"battle",
	"battlecharset",
	"battleweapon",
	"charset",
	"chipset",
	"faceset",
	"gameover",
	"monster",
	"music",
	"panorama",
	"sound",
	"system",
	"system2",
	"title",
	nullptr
};

const int rtp_table_2k3_categories_idx[16] = {
	0,
	34,
	88,
	152,
	153,
	168,
	173,
	178,
	180,
	295,
	446,
	459,
	665,
	669,
	672,
	676
};

}


/*end of file .\rtp_table.cpp*/

/*start of file .\scene.cpp*/

/* ... license chunk ... */

// Headers
#include <cassert>
#include "async_handler.h"
#include "scene.h"
#include "graphics.h"
#include "input.h"
#include "player.h"
#include "output.h"
#include "audio.h"
#include "filefinder.h"
#include "transition.h"
#include "game_actors.h"
#include "game_interpreter.h"
#include "game_system.h"
#include "main_data.h"
#include "scene_language.h"
#include "scene_settings.h"
#include "scene_title.h"
#include "game_map.h"

#ifndef NDEBUG
#define DEBUG_VALIDATE(x) Scene::DebugValidate(x)
#else
#define DEBUG_VALIDATE(x) do {} while(0)
#endif

std::shared_ptr<Scene> Scene::instance;
std::vector<std::shared_ptr<Scene> > Scene::old_instances;
std::vector<std::shared_ptr<Scene> > Scene::instances;
const char Scene::scene_names[SceneMax][12] =
{
	"Null",
	"Title",
	"Map",
	"Menu",
	"Item",
	"Skill",
	"Equip",
	"ActorTarget",
	"Status",
	"File",
	"Save",
	"Load",
	"End",
	"Battle",
	"Shop",
	"Name",
	"Gameover",
	"Debug",
	"Logo",
	"Order",
	"GameBrowser",
	"Teleport",
	"Settings",
	"Language"
};

enum PushPopOperation {
	ScenePushed = 1,
	ScenePopped
};

int Scene::push_pop_operation = 0;

lcf::rpg::SaveSystem::Scene Scene::rpgRtSceneFromSceneType(SceneType t) {
	switch (t) {
		case Null:
		case GameBrowser:
		case SceneMax:
		case Logo:
			break;
		case Title:
			return lcf::rpg::SaveSystem::Scene_title;
		case Map:
			return lcf::rpg::SaveSystem::Scene_map;
		case Menu:
		case Item:
		case Skill:
		case Equip:
		case ActorTarget:
		case Status:
		case Teleport:
		case Order:
		case End:
		case Settings:
		case LanguageMenu:
			return lcf::rpg::SaveSystem::Scene_menu;
		case File:
		case Save:
		case Load:
			return lcf::rpg::SaveSystem::Scene_file;
		case Battle:
			return lcf::rpg::SaveSystem::Scene_battle;
		case Shop:
			return lcf::rpg::SaveSystem::Scene_shop;
		case Name:
			return lcf::rpg::SaveSystem::Scene_name;
		case Gameover:
			return lcf::rpg::SaveSystem::Scene_game_over;
		case Debug:
			return lcf::rpg::SaveSystem::Scene_debug;
	}
	return lcf::rpg::SaveSystem::Scene(-1);
}

Scene::Scene() {
	type = Scene::Null;
}

void Scene::ScheduleTransitionIn(Scene::SceneType prev_scene_type) {
	if (!Transition::instance().IsErasedNotActive()) {
		// Scene could have manually triggered transition earlier
		return;
	}

	// If Start() or Continue() produced an async operation, defer TransitionIn() call until
	// after async completes
	if (async_continuation) {
		AsyncNext([this,fn=std::move(async_continuation),prev_scene_type]() {
					fn();
					ScheduleTransitionIn(prev_scene_type);
				});
	} else {
		AsyncNext([this,prev_scene_type]() { TransitionIn(prev_scene_type); });
	}
}

void Scene::MainFunction() {
	static bool init = false;

	if (IsAsyncPending()) {
		Player::Update(false);
		return;
	} else {
		// This is used to provide a hook for Scene_Map to finish
		// it's PreUpdate() and teleport logic after transition
		// or asynchronous file load.
		OnFinishAsync();
	}

	// The continuation could have caused a new async wait condition, or
	// it could have changed the scene.
	if (!IsAsyncPending() && Scene::instance.get() == this) {
		if (!init) {
			auto prev_scene = Graphics::UpdateSceneCallback();
			auto prev_scene_type = prev_scene ? prev_scene->type : Null;

			// Destroy the previous scene here, before any initialization logic / transition in occurs.
			prev_scene.reset();

			// Initialization after scene switch
			switch (push_pop_operation) {
				case ScenePushed:
					Start();
					initialized = true;
					break;
				case ScenePopped:
					if (!initialized) {
						Start();
						initialized = true;
					} else {
						Continue(prev_scene_type);
					}
					break;
				default:;
			}

			push_pop_operation = 0;

			ScheduleTransitionIn(prev_scene_type);

			init = true;
			return;
		} else {
			Player::Update();
		}
	}

	if (Scene::instance.get() != this) {
		// Shutdown after scene switch
		assert(Scene::instance == instances.back() &&
			"Don't set Scene::instance directly, use Push instead!");

		Graphics::Update();

		auto next_scene = instance ? instance->type : Null;

		// Scene could have manually triggered transition earlier
		if (!Transition::instance().IsActive()) {
			TransitionOut(next_scene);
		}

		init = false;
	}
}

void Scene::Start() {
}

void Scene::Continue(SceneType /* prev_scene */) {
}

void Scene::TransitionIn(SceneType) {
	Transition::instance().InitShow(Transition::TransitionFadeIn, this, 6);
}

void Scene::TransitionOut(SceneType) {
	Transition::instance().InitErase(Transition::TransitionFadeOut, this, 6);
}

void Scene::Suspend(SceneType /* next_scene */) {
}

void Scene::OnFinishAsync() {
	if (async_continuation) {
		// The continuation could set another continuation, so move this
		// one out of the way first before we call it.
		AsyncContinuation continuation;
		async_continuation.swap(continuation);

		continuation();
	}
}

bool Scene::IsAsyncPending() {
	return Transition::instance().IsActive() || AsyncHandler::IsImportantFilePending()
		|| (instance != nullptr && instance->HasDelayFrames());
}

void Scene::Update() {
	// Allow calling of settings scene everywhere except from Logo (Player is currently starting up)
	// and from Map (has own handling to prevent breakage)
	if (instance->type != Scene::Logo &&
		instance->type != Scene::Map &&
		Input::IsTriggered(Input::SETTINGS_MENU) &&
		!Scene::Find(Scene::Settings)) {
			Scene::Push(std::make_shared<Scene_Settings>());
	}

	vUpdate();
}

void Scene::Push(std::shared_ptr<Scene> const& new_scene, bool pop_stack_top) {
	if (pop_stack_top) {
		old_instances.push_back(instances.back());
		instances.pop_back();
	}

	instances.push_back(new_scene);
	instance = new_scene;

	push_pop_operation = ScenePushed;

	DEBUG_VALIDATE("Push");
}

std::shared_ptr<Scene> Scene::Peek() {
	if (instances.size() == 1)
		return nullptr;
	return instances[instances.size() - 2];
}

void Scene::Pop() {
	old_instances.push_back(instances.back());
	instances.pop_back();

	instance = instances.empty() ? nullptr : instances.back();

	push_pop_operation = ScenePopped;

	DEBUG_VALIDATE("Pop");
}

void Scene::PopUntil(SceneType type) {
	int count = 0;

	for (int i = (int)instances.size() - 1 ; i >= 0; --i) {
		if (instances[i]->type == type) {
			for (i = 0; i < count; ++i) {
				old_instances.push_back(instances.back());
				instances.pop_back();
			}
			instance = instances.back();
			push_pop_operation = ScenePopped;
			DEBUG_VALIDATE("PopUntil");
			return;
		}
		++count;
	}

	Output::Warning("The requested scene {} was not on the stack", scene_names[type]);
	DEBUG_VALIDATE("PopUntil");
}

std::shared_ptr<Scene> Scene::Find(SceneType type) {
	std::vector<std::shared_ptr<Scene> >::const_reverse_iterator it;
	for (it = instances.rbegin() ; it != instances.rend(); ++it) {
		if ((*it)->type == type) {
			return *it;
		}
	}

	return std::shared_ptr<Scene>();
}

void Scene::DrawBackground(Bitmap& dst) {
	dst.Fill(Main_Data::game_system->GetBackgroundColor());
}

bool Scene::CheckSceneExit(AsyncOp aop) {
	if (aop.GetType() == AsyncOp::eExitGame) {
		if (Scene::Find(Scene::GameBrowser)) {
			Scene::PopUntil(Scene::GameBrowser);
		} else {
			Player::exit_flag = true;
		}
		return true;
	}

	if (aop.GetType() == AsyncOp::eToTitle) {
		Scene::ReturnToTitleScene();
		return true;
	}

	return false;
}



inline void Scene::DebugValidate(const char* caller) {
	if (instances.size() <= 1) {
		// Scene of size 1 happens before graphics stack is up. Which can
		// cause the following logs to crash.
		return;
	}
	std::bitset<SceneMax> present;
	for (auto& scene: instances) {
		if (present[scene->type]) {
			Output::Debug("Scene Stack after {}:", caller);
			for (auto& s: instances) {
				auto fmt =  (s == scene) ? "--> {} <--" : "  {}";
				Output::Debug(fmt, scene_names[s->type]);
			}
			Output::Error("Multiple scenes of type={} in the Scene instances stack!", scene_names[scene->type]);
		}
		present[scene->type] = true;
	}
	if (instances[0]->type != Null) {
		Output::Error("Scene.instances[0] is of type={} in the Scene instances stack!", scene_names[instances[0]->type]);
	}
}

void Scene::PushTitleScene(bool pop_stack_top) {
	auto title_scene = Scene::Find(Scene::Title);
	if (title_scene) {
		return;
	}

	if (!Player::startup_language.empty()) {
		Player::translation.SelectLanguage(Player::startup_language);
	} else if (Player::translation.HasTranslations()) {
		if (Player::player_config.lang_select_on_start.Get() == ConfigEnum::StartupLangSelect::Always
			|| (!FileFinder::HasSavegame() && Player::player_config.lang_select_on_start.Get() == ConfigEnum::StartupLangSelect::FirstStartup)) {
			Scene::Push(std::make_shared<Scene_Language>(), pop_stack_top);
			return;
		}
	}

	Scene::Push(std::make_shared<Scene_Title>(), pop_stack_top);
}

bool Scene::ReturnToTitleScene() {
	if (Scene::instance && Scene::instance->type == Scene::Title) {
		return false;
	}

	auto title_scene = Scene::Find(Scene::Title);
	if (!title_scene) {
		return false;
	}

	title_scene->SetDelayFrames(Scene::kReturnTitleDelayFrames);
	Scene::PopUntil(Scene::Title);
	return true;
}

void Scene::TransferDrawablesFrom(Scene& prev_scene) {
	drawable_list.TakeFrom(prev_scene.GetDrawableList(),
			[this](auto* draw) { return draw->IsGlobal() || (uses_shared_drawables && draw->IsShared()); });

	if (!UsesSharedDrawables() || prev_scene.UsesSharedDrawables()) {
		// Either we don't take shared, or we do and we got them from the previous scene.
		return;
	}
	// Previous scene did not use shared, that means the shared drawables are on the scene stack somewhere.
	// This can happen for example when you do Map -> Debug -> Battle.
	for (auto iter = instances.rbegin() + 1; iter != instances.rend(); ++iter) {
		auto& scene = *iter;
		if (scene->UsesSharedDrawables()) {
			drawable_list.TakeFrom(scene->GetDrawableList(), [](auto* draw) { return draw->IsShared(); });
			break;
		}
	}
}

void Scene::OnPartyChanged(Game_Actor*, bool) {
}

void Scene::OnEventHpChanged(Game_Battler*, int) {
}

void Scene::OnTranslationChanged() {
	if (Main_Data::game_actors) {
		Main_Data::game_actors->ReloadActors();
	}
	Game_Map::OnTranslationChanged();
}


/*end of file .\scene.cpp*/

/*start of file .\scene_actortarget.cpp*/

/* ... license chunk ... */

// Headers
#include "scene_actortarget.h"
#include "game_actors.h"
#include "game_party.h"
#include "game_system.h"
#include "input.h"
#include "main_data.h"
#include "scene_item.h"
#include "scene_skill.h"
#include "output.h"
#include <lcf/reader_util.h>
#include <player.h>

Scene_ActorTarget::Scene_ActorTarget(int item_id) :
	id(item_id), actor_index(0), use_item(true) {
	Scene::type = Scene::ActorTarget;
}

Scene_ActorTarget::Scene_ActorTarget(
	int skill_id, int actor_index) :
	id(skill_id), actor_index(actor_index), use_item(false) {
	Scene::type = Scene::ActorTarget;
}

void Scene_ActorTarget::Start() {
	// Create the windows
	help_window.reset(new Window_Help(0, 0, 136, 32));
	target_window.reset(new Window_ActorTarget(136, 0, 184, Player::screen_height));
	status_window.reset(new Window_TargetStatus(0, 32, 136, 32));

	target_window->SetActive(true);
	target_window->SetIndex(0);

	if (use_item) {
		const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, id);
		if (!item) {
			Output::Warning("Scene ActorTarget: Invalid item ID {}", id);
			Scene::Pop();
			return;
		}
		const lcf::rpg::Skill* skill = nullptr;
		if (item->type == lcf::rpg::Item::Type_special) {
			skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, item->skill_id);
			if (!skill) {
				Output::Warning("Scene ActorTarget: Item {} has invalid skill ID {}", id, item->skill_id);
				Scene::Pop();
				return;
			}
			if (skill->scope == lcf::rpg::Skill::Scope_party) {
				target_window->SetIndex(-100);
			}
		} else {
			if (item->entire_party) {
				target_window->SetIndex(-100);
			}
		}
		status_window->SetData(id, true, 0);
		help_window->SetText(ToString(item->name), Font::ColorDefault, Text::AlignLeft, false);
		return;
	} else {
		const lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, id);
		if (!skill) {
			Output::Warning("Scene ActorTarget: Invalid skill ID {}", id);
			Scene::Pop();
			return;
		}

		if (skill->scope == lcf::rpg::Skill::Scope_self) {
			target_window->SetIndex(-actor_index - 1);
		} else if (skill->scope == lcf::rpg::Skill::Scope_party) {
			target_window->SetIndex(-100);
		}

		status_window->SetData(id, false, actor_index);
		help_window->SetText(ToString(skill->name), Font::ColorDefault, Text::AlignLeft, false);
	}
}

void Scene_ActorTarget::vUpdate() {
	help_window->Update();
	target_window->Update();
	status_window->Update();

	if (use_item) {
		UpdateItem();
	} else {
		UpdateSkill();
	}

	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		Scene::Pop();
	}
}

void Scene_ActorTarget::UpdateItem() {
	if (Input::IsTriggered(Input::DECISION)) {
		if (Main_Data::game_party->GetItemCount(id) <= 0) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
			return;
		}
		if (Main_Data::game_party->UseItem(id, target_window->GetActor())) {
			auto* item = lcf::ReaderUtil::GetElement(lcf::Data::items, id);
			assert(item);

			bool do_skill = (item->type == lcf::rpg::Item::Type_special)
				|| (item->use_skill && (
							item->type == lcf::rpg::Item::Type_weapon
							|| item->type == lcf::rpg::Item::Type_shield
							|| item->type == lcf::rpg::Item::Type_armor
							|| item->type == lcf::rpg::Item::Type_helmet
							|| item->type == lcf::rpg::Item::Type_accessory
							)
				   );

			if (do_skill) {
				auto* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, item->skill_id);
				assert(skill);
				auto* animation = lcf::ReaderUtil::GetElement(lcf::Data::animations, skill->animation_id);
				if (animation) {
					Main_Data::game_system->SePlay(*animation);
				}
			} else {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_UseItem));
			}
		}
		else {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		}

		status_window->Refresh();
		target_window->Refresh();
	}
}

void Scene_ActorTarget::UpdateSkill() {
	if (Input::IsTriggered(Input::DECISION)) {
		Game_Actor* actor = &(*Main_Data::game_party)[actor_index];

		if (actor->GetSp() < actor->CalculateSkillCost(id) || actor->GetHp() <= actor->CalculateSkillHpCost(id)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
			return;
		}
		if (Main_Data::game_party->UseSkill(id, actor, target_window->GetActor())) {
			lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, id);
			lcf::rpg::Animation* animation = lcf::ReaderUtil::GetElement(lcf::Data::animations, skill->animation_id);
			if (animation) {
				Main_Data::game_system->SePlay(*animation);
			}
			else {
				Output::Warning("UpdateSkill: Skill {} references invalid animation {}", id, skill->animation_id);
			}
		}
		else {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		}

		status_window->Refresh();
		target_window->Refresh();
	}
}


/*end of file .\scene_actortarget.cpp*/

/*start of file .\scene_battle.cpp*/

/* ... license chunk ... */

// Headers
#include <algorithm>
#include <sstream>

#include "bitmap.h"
#include "input.h"
#include "output.h"
#include "player.h"
#include "transition.h"
#include "game_battlealgorithm.h"
#include "game_interpreter_battle.h"
#include "game_message.h"
#include "game_system.h"
#include "game_party.h"
#include "game_enemy.h"
#include "game_enemyparty.h"
#include "game_battle.h"
#include "game_screen.h"
#include "game_pictures.h"
#include "battle_animation.h"
#include <lcf/reader_util.h>
#include "scene_battle.h"
#include "scene_battle_rpg2k.h"
#include "scene_battle_rpg2k3.h"
#include "scene_gameover.h"
#include "scene_settings.h"
#include "scene_debug.h"
#include "game_interpreter.h"
#include "rand.h"
#include "autobattle.h"
#include "enemyai.h"
#include "feature.h"

Scene_Battle::Scene_Battle(const BattleArgs& args)
	: troop_id(args.troop_id),
	allow_escape(args.allow_escape),
	first_strike(args.first_strike),
	on_battle_end(args.on_battle_end)
{
	SetUseSharedDrawables(true);

	Scene::type = Scene::Battle;

	// Face graphic is cleared when battle scene is created.
	// Even if the battle gets interrupted by another scene and never starts.
	Main_Data::game_system->ClearMessageFace();
	Main_Data::game_system->SetBeforeBattleMusic(Main_Data::game_system->GetCurrentBGM());
	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_BeginBattle));
	Main_Data::game_system->BgmPlay(Main_Data::game_system->GetSystemBGM(Main_Data::game_system->BGM_Battle));

	Game_Battle::SetTerrainId(args.terrain_id);
	Game_Battle::ChangeBackground(args.background);
	Game_Battle::SetBattleCondition(args.condition);
	Game_Battle::SetBattleFormation(args.formation);
}

Scene_Battle::~Scene_Battle() {
	Game_Battle::Quit();
}

void Scene_Battle::Start() {
	if (Scene::Find(Scene::Map) == nullptr) {
		// Battletest mode - need to initialize screen
		Main_Data::game_screen->InitGraphics();
		Main_Data::game_pictures->InitGraphics();
	}

	// RPG_RT will cancel any active screen flash from the map, including
	// wiping out all flash LSD chunks.
	Main_Data::game_screen->FlashOnce(0, 0, 0, 0, 0);

	const lcf::rpg::Troop* troop = lcf::ReaderUtil::GetElement(lcf::Data::troops, troop_id);

	if (!troop) {
		Output::Warning("Invalid Monster Party ID {}", troop_id);
		EndBattle(BattleResult::Victory);
		return;
	}

	autobattle_algos.push_back(AutoBattle::CreateAlgorithm(AutoBattle::RpgRtCompat::name));
	autobattle_algos.push_back(AutoBattle::CreateAlgorithm(AutoBattle::RpgRtImproved::name));
	autobattle_algos.push_back(AutoBattle::CreateAlgorithm(AutoBattle::AttackOnly::name));
	enemyai_algos.push_back(EnemyAi::CreateAlgorithm(EnemyAi::RpgRtCompat::name));
	enemyai_algos.push_back(EnemyAi::CreateAlgorithm(EnemyAi::RpgRtImproved::name));

	if (lcf::Data::system.easyrpg_default_actorai == -1 || (Player::debug_flag && !Player::player_config.autobattle_algo.Get().empty())) {
		if (Player::player_config.autobattle_algo.Get().empty()) {
			Player::player_config.autobattle_algo.Set(ToString(autobattle_algos[0]->GetName()));
		}
		for (auto& algo : autobattle_algos) {
			if (algo->GetName() == Player::player_config.autobattle_algo.Get()) {
				default_autobattle_algo = algo->GetId();
				break;
			}
		}
	} else {
		default_autobattle_algo = lcf::Data::system.easyrpg_default_actorai;
	}
	if (lcf::Data::system.easyrpg_default_enemyai == -1 || (Player::debug_flag && !Player::player_config.enemyai_algo.Get().empty())) {
		if (Player::player_config.enemyai_algo.Get().empty()) {
			Player::player_config.enemyai_algo.Set(ToString(enemyai_algos[0]->GetName()));
		}
		for (auto& algo : enemyai_algos) {
			if (algo->GetName() == Player::player_config.enemyai_algo.Get()) {
				default_enemyai_algo = algo->GetId();
				break;
			}
		}
	} else {
		default_enemyai_algo = lcf::Data::system.easyrpg_default_enemyai;
	}

	Output::Debug("Starting battle {} ({}): algos=({}/{})", troop_id, troop->name, autobattle_algos[default_autobattle_algo]->GetName(), enemyai_algos[default_enemyai_algo]->GetName());

	Game_Battle::Init(troop_id);

	CreateUi();

	InitEscapeChance();

	SetState(State_Start);
}

void Scene_Battle::InitEscapeChance() {
	int avg_enemy_agi = Main_Data::game_enemyparty->GetAverageAgility();
	int avg_actor_agi = Main_Data::game_party->GetAverageAgility();

	int base_chance = Utils::RoundTo<int>(100.0 * static_cast<double>(avg_enemy_agi) / static_cast<double>(avg_actor_agi));
	this->escape_chance = Utils::Clamp(150 - base_chance, 0, 100);
}

bool Scene_Battle::TryEscape() {
	if (first_strike || Game_Battle::GetInterpreterBattle().IsForceFleeEnabled() || Rand::PercentChance(escape_chance)) {
		return true;
	}
	escape_chance += 10;
	return false;
}

void Scene_Battle::Continue(SceneType /* prev_scene */) {
	Game_Message::SetWindow(message_window.get());

	// Debug scene / other scene could have changed party status.
	status_window->Refresh();
}

void Scene_Battle::TransitionIn(SceneType prev_scene) {
	if (prev_scene == Scene::Debug) {
		Scene::TransitionIn(prev_scene);
		return;
	}
	Transition::instance().InitShow(Main_Data::game_system->GetTransition(Main_Data::game_system->Transition_BeginBattleShow), this);
}

void Scene_Battle::TransitionOut(SceneType next_scene) {
	auto& transition = Transition::instance();

	if (next_scene == Scene::Debug) {
		transition.InitErase(Transition::TransitionCutOut, this);
		return;
	}

	if (next_scene == Scene::Null || next_scene == Scene::Title) {
		Scene::TransitionOut(next_scene);
		return;
	}

	transition.InitErase(Main_Data::game_system->GetTransition(Main_Data::game_system->Transition_EndBattleErase), this);
}

void Scene_Battle::DrawBackground(Bitmap& dst) {
	dst.Clear();
}

void Scene_Battle::CreateOptions() {
	std::vector<std::string> commands;

	battle_options.clear();

	for (auto option : lcf::Data::system.easyrpg_battle_options) {
		battle_options.push_back((BattleOptionType)option);
	}

	// Add all menu items
	for (auto option : battle_options) {
		switch (option) {
		case Battle:
			commands.push_back(ToString(lcf::Data::terms.battle_fight));
			break;
		case AutoBattle:
			commands.push_back(ToString(lcf::Data::terms.battle_auto));
			break;
		case Escape:
			commands.push_back(ToString(lcf::Data::terms.battle_escape));
			break;
		case Win:
			commands.push_back("Win");
			break;
		case Lose:
			commands.push_back("Lose");
			break;
		}
	}

	options_window.reset(new Window_Command(commands, option_command_mov));
	options_window->SetHeight(80);
	options_window->SetX(Player::menu_offset_x);
	options_window->SetY(Player::menu_offset_y + MENU_HEIGHT - 80);
}

void Scene_Battle::CreateUi() {
	CreateOptions();

	help_window.reset(new Window_Help(Player::menu_offset_x, Player::menu_offset_y, MENU_WIDTH, 32));
	help_window->SetVisible(false);

	item_window.reset(new Window_Item(Player::menu_offset_x, (Player::menu_offset_y + MENU_HEIGHT - 80), MENU_WIDTH, 80));
	item_window->SetHelpWindow(help_window.get());
	item_window->Refresh();
	item_window->SetIndex(0);

	skill_window.reset(new Window_BattleSkill(Player::menu_offset_x, (Player::menu_offset_y + MENU_HEIGHT - 80), MENU_WIDTH, 80));
	skill_window->SetHelpWindow(help_window.get());

	message_window.reset(new Window_Message(Player::menu_offset_x, (Player::menu_offset_y + MENU_HEIGHT - 80), MENU_WIDTH, 80));
	Game_Message::SetWindow(message_window.get());
}

void Scene_Battle::UpdateScreen() {
	Main_Data::game_screen->Update();
	Main_Data::game_pictures->Update(true);
}

void Scene_Battle::UpdateBattlers() {
	std::vector<Game_Battler*> battlers;
	Main_Data::game_enemyparty->GetBattlers(battlers);
	Main_Data::game_party->GetBattlers(battlers);
	for (auto* b : battlers) {
		b->UpdateBattle();
	}
	Game_Battle::UpdateAnimation();
}

void Scene_Battle::UpdateUi() {
	options_window->Update();
	status_window->Update();
	command_window->Update();
	help_window->Update();
	item_window->Update();
	skill_window->Update();
	target_window->Update();

	Game_Message::Update();
}

bool Scene_Battle::UpdateEvents() {
	auto& interp = Game_Battle::GetInterpreterBattle();
	interp.Update();
	status_window->Refresh();

	if (interp.IsForceFleeEnabled()) {
		if (state != State_Escape) {
			SetState(State_Escape);
		}
	}

	auto call = TakeRequestedScene();
	if (call && (call->type == Scene::Gameover || call->type == Scene::Settings)) {
		Scene::Push(std::move(call));
	}

	if (interp.IsAsyncPending()) {
		auto aop = interp.GetAsyncOp();

		if (aop.GetType() == AsyncOp::eTerminateBattle) {
			EndBattle(static_cast<BattleResult>(aop.GetBattleResult()));
			return false;
		}

		if (CheckSceneExit(aop)) {
			return false;
		}
	}

	return true;
}

bool Scene_Battle::UpdateTimers() {
	const int timer1 = Main_Data::game_party->GetTimerSeconds(Game_Party::Timer1);
	const int timer2 = Main_Data::game_party->GetTimerSeconds(Game_Party::Timer2);

	// Screen Effects
	Main_Data::game_party->UpdateTimers();

	// Query Timer before and after update.
	// If it reached zero during update was a running battle timer.
	if ((Main_Data::game_party->GetTimerSeconds(Game_Party::Timer1) == 0 && timer1 > 0) ||
		(Main_Data::game_party->GetTimerSeconds(Game_Party::Timer2) == 0 && timer2 > 0)) {
		EndBattle(BattleResult::Abort);
		return false;
	}
	return true;
}

void Scene_Battle::UpdateGraphics() {
	Game_Battle::UpdateGraphics();
}

bool Scene_Battle::IsWindowMoving() {
	return options_window->IsMovementActive() || status_window->IsMovementActive() || command_window->IsMovementActive();
}

Game_Enemy* Scene_Battle::EnemySelected() {
	std::vector<Game_Battler*> enemies;
	Main_Data::game_enemyparty->GetActiveBattlers(enemies);

	Game_Enemy* target = static_cast<Game_Enemy*>(enemies[target_window->GetIndex()]);

	if (previous_state == State_SelectCommand) {
		active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Normal>(active_actor, target));
	} else if (previous_state == State_SelectSkill) {
		active_actor->SetBattleAlgorithm(
				std::make_shared<Game_BattleAlgorithm::Skill>(active_actor, target, *skill_window->GetSkill()));
	} else if (previous_state == State_SelectItem) {
		auto* item = item_window->GetItem();
		assert(item);
		if (item->type == lcf::rpg::Item::Type_special
				|| (item->use_skill && (item->type == lcf::rpg::Item::Type_weapon
						|| item->type == lcf::rpg::Item::Type_shield
						|| item->type == lcf::rpg::Item::Type_armor
						|| item->type == lcf::rpg::Item::Type_helmet
						|| item->type == lcf::rpg::Item::Type_accessory)))
		{
			const lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, item->skill_id);
			if (!skill) {
				Output::Warning("EnemySelected: Item {} references invalid skill {}", item->ID, item->skill_id);
				return nullptr;
			}
			active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Skill>(active_actor, target, *skill, item));
		} else {
			active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Item>(active_actor, target, *item));
		}
	} else {
		assert("Invalid previous state for enemy selection" && false);
	}

	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
	ActionSelectedCallback(active_actor);
	return target;
}

Game_Actor* Scene_Battle::AllySelected() {
	Game_Actor& target = (*Main_Data::game_party)[status_window->GetIndex()];

	if (previous_state == State_SelectSkill) {
		active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Skill>(active_actor, &target, *skill_window->GetSkill()));
	} else if (previous_state == State_SelectItem) {
		auto* item = item_window->GetItem();
		assert(item);
		if (item->type == lcf::rpg::Item::Type_special
				|| (item->use_skill && (item->type == lcf::rpg::Item::Type_weapon
						|| item->type == lcf::rpg::Item::Type_shield
						|| item->type == lcf::rpg::Item::Type_armor
						|| item->type == lcf::rpg::Item::Type_helmet
						|| item->type == lcf::rpg::Item::Type_accessory)))
		{
			const lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, item->skill_id);
			if (!skill) {
				Output::Warning("AllySelected: Item {} references invalid skill {}", item->ID, item->skill_id);
				return nullptr;
			}
			active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Skill>(active_actor, &target, *skill, item));
		} else {
			active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Item>(active_actor, &target, *item));
		}
	} else {
		assert("Invalid previous state for ally selection" && false);
	}

	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
	ActionSelectedCallback(active_actor);
	return &target;
}

void Scene_Battle::AttackSelected() {
	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));

	if (active_actor->HasAttackAll()) {
		active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Normal>(active_actor, Main_Data::game_enemyparty.get()));
		ActionSelectedCallback(active_actor);
	} else {
		SetState(State_SelectEnemyTarget);
	}
}

void Scene_Battle::DefendSelected() {
	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));

	active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Defend>(active_actor));

	ActionSelectedCallback(active_actor);
}

void Scene_Battle::ItemSelected() {
	const lcf::rpg::Item* item = item_window->GetItem();

	if (!item || !item_window->CheckEnable(item->ID)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		return;
	}

	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));

	switch (item->type) {
		case lcf::rpg::Item::Type_normal:
		case lcf::rpg::Item::Type_book:
		case lcf::rpg::Item::Type_material:
			assert(false);
			return;
		case lcf::rpg::Item::Type_weapon:
		case lcf::rpg::Item::Type_shield:
		case lcf::rpg::Item::Type_armor:
		case lcf::rpg::Item::Type_helmet:
		case lcf::rpg::Item::Type_accessory:
		case lcf::rpg::Item::Type_special: {
			const lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, item->skill_id);
			if (!skill) {
				Output::Warning("ItemSelected: Item {} references invalid skill {}", item->ID, item->skill_id);
				return;
			}
			AssignSkill(skill, item);
			break;
		}
		case lcf::rpg::Item::Type_medicine:
			if (item->entire_party) {
				active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Item>(active_actor, Main_Data::game_party.get(), *item_window->GetItem()));
				ActionSelectedCallback(active_actor);
			} else {
				SetState(State_SelectAllyTarget);
				status_window->SetChoiceMode(Window_BattleStatus::ChoiceMode_All);
			}
			break;
		case lcf::rpg::Item::Type_switch:
			active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Item>(active_actor, *item_window->GetItem()));
			ActionSelectedCallback(active_actor);
			break;
	}
}

void Scene_Battle::SkillSelected() {
	const lcf::rpg::Skill* skill = skill_window->GetSkill();

	if (!skill || !skill_window->CheckEnable(skill->ID)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		return;
	}

	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));

	AssignSkill(skill, nullptr);
}

void Scene_Battle::AssignSkill(const lcf::rpg::Skill* skill, const lcf::rpg::Item* item) {
	switch (skill->type) {
		case lcf::rpg::Skill::Type_teleport:
		case lcf::rpg::Skill::Type_escape:
		case lcf::rpg::Skill::Type_switch: {
			active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Skill>(active_actor, *skill, item));
			ActionSelectedCallback(active_actor);
			return;
		}
		default:
			break;
	}

	switch (skill->scope) {
		case lcf::rpg::Skill::Scope_enemy:
			SetState(State_SelectEnemyTarget);
			break;
		case lcf::rpg::Skill::Scope_ally:
			SetState(State_SelectAllyTarget);
			status_window->SetChoiceMode(Window_BattleStatus::ChoiceMode_All);
			break;
		case lcf::rpg::Skill::Scope_enemies:
			active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Skill>(
					active_actor, Main_Data::game_enemyparty.get(), *skill, item));
			ActionSelectedCallback(active_actor);
			break;
		case lcf::rpg::Skill::Scope_self:
			active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Skill>(
					active_actor, active_actor, *skill, item));
			ActionSelectedCallback(active_actor);
			break;
		case lcf::rpg::Skill::Scope_party:
			active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Skill>(
					active_actor, Main_Data::game_party.get(), *skill, item));
			ActionSelectedCallback(active_actor);
			break;
	}
}

std::shared_ptr<Scene_Battle> Scene_Battle::Create(const BattleArgs& args)
{
	if (Feature::HasRpg2kBattleSystem()) {
		return std::make_shared<Scene_Battle_Rpg2k>(args);
	}
	else {
		return std::make_shared<Scene_Battle_Rpg2k3>(args);
	}
}

void Scene_Battle::PrepareBattleAction(Game_Battler* battler) {
	if (battler->GetBattleAlgorithm() == nullptr) {
		return;
	}

	if (!battler->CanAct()) {
		if (battler->GetBattleAlgorithm()->GetType() != Game_BattleAlgorithm::Type::None) {
			battler->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::None>(battler));
		}
		return;
	}

	if (battler->GetSignificantRestriction() == lcf::rpg::State::Restriction_attack_ally) {
		Game_Battler *target = battler->GetType() == Game_Battler::Type_Enemy ?
			Main_Data::game_enemyparty->GetRandomActiveBattler() :
			Main_Data::game_party->GetRandomActiveBattler();

		battler->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Normal>(battler, target));
		return;
	}

	if (battler->GetSignificantRestriction() == lcf::rpg::State::Restriction_attack_enemy) {
		Game_Battler *target = battler->GetType() == Game_Battler::Type_Ally ?
			Main_Data::game_enemyparty->GetRandomActiveBattler() :
			Main_Data::game_party->GetRandomActiveBattler();

		battler->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Normal>(battler, target));
		return;
	}

	// If we can no longer perform the action (no more items, ran out of SP, etc..)
	if (!battler->GetBattleAlgorithm()->ActionIsPossible()) {
		battler->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::None>(battler));
	}
}

void Scene_Battle::RemoveCurrentAction() {
	battle_actions.front()->SetBattleAlgorithm(nullptr);
	battle_actions.pop_front();
}

void Scene_Battle::ActionSelectedCallback(Game_Battler* for_battler) {
	assert(for_battler->GetBattleAlgorithm() != nullptr);

	auto single_target = for_battler->GetBattleAlgorithm()->GetOriginalSingleTarget();
	auto group_targets = for_battler->GetBattleAlgorithm()->GetOriginalPartyTarget();
	// Target: 0 None, 1 Single Enemy, 2 All Enemies, 3 Single Ally, 4 All Allies
	Game_Battle::ManiacBattleHook(
		Game_Interpreter_Battle::ManiacBattleHookType::Targetting,
		for_battler->GetType() == Game_Battler::Type_Enemy,
		for_battler->GetPartyIndex(),
		for_battler->GetBattleAlgorithm()->GetActionType(),
		for_battler->GetBattleAlgorithm()->GetActionId(),
		single_target
			? (single_target->GetType() != Game_Battler::Type_Enemy ? 1 : 3)
			: (group_targets->GetRandomActiveBattler()->GetType() != Game_Battler::Type_Enemy ? 2 : 4),
		single_target ? single_target->GetPartyIndex() : 0
	);

	if (for_battler->GetBattleAlgorithm() == nullptr) {
		Output::Warning("ActionSelectedCallback: Invalid action for battler {} ({})",
				for_battler->GetId(), for_battler->GetName());
		Output::Warning("Please report a bug!");
	}

	battle_actions.push_back(for_battler);
}

bool Scene_Battle::CallDebug() {
	if (Player::debug_flag) {
		Scene::Push(std::make_shared<Scene_Debug>());
		return true;
	}
	return false;
}

void Scene_Battle::SelectionFlash(Game_Battler* battler) {
	if (battler) {
		battler->Flash(31, 31, 31, 24, 16);
	}
}

void Scene_Battle::EndBattle(BattleResult result) {
	assert(Scene::instance.get() == this && "EndBattle called multiple times!");

	Main_Data::game_party->IncBattleCount();
	switch (result) {
		case BattleResult::Victory: Main_Data::game_party->IncWinCount(); break;
		case BattleResult::Escape: Main_Data::game_party->IncRunCount(); break;
		case BattleResult::Defeat: Main_Data::game_party->IncDefeatCount(); break;
		case BattleResult::Abort: break;
	}

	Scene::Pop();

	// For RPG_RT compatibility, wait 30 frames if a battle test ends
	if (Game_Battle::battle_test.enabled) {
		Scene::instance->SetDelayFrames(30);
	}

	if (on_battle_end) {
		on_battle_end(result);
		on_battle_end = {};
	}
}



/*end of file .\scene_battle.cpp*/

/*start of file .\scene_battle_rpg2k.cpp*/

/* ... license chunk ... */

#include <algorithm>
#include <sstream>
#include "input.h"
#include "player.h"
#include "sprite.h"
#include "sprite_enemy.h"
#include "game_battler.h"
#include "game_system.h"
#include "game_party.h"
#include "game_enemy.h"
#include "game_enemyparty.h"
#include "game_message.h"
#include "game_battle.h"
#include "game_battlealgorithm.h"
#include "game_screen.h"
#include "battle_animation.h"
#include <lcf/reader_util.h>
#include "scene_battle_rpg2k.h"
#include "scene_battle.h"
#include "scene_gameover.h"
#include "game_interpreter_battle.h"
#include "output.h"
#include "rand.h"
#include "autobattle.h"
#include "enemyai.h"
#include "game_message_terms.h"
#include "feature.h"

Scene_Battle_Rpg2k::Scene_Battle_Rpg2k(const BattleArgs& args) :
	Scene_Battle(args)
{
}

Scene_Battle_Rpg2k::~Scene_Battle_Rpg2k() {
}

void Scene_Battle_Rpg2k::Start() {
	Scene_Battle::Start();
	CreateEnemySprites();
}

void Scene_Battle_Rpg2k::CreateUi() {
	Scene_Battle::CreateUi();

	status_window.reset(new Window_BattleStatus(Player::menu_offset_x, (Player::screen_height - Player::menu_offset_y - 80), MENU_WIDTH - option_command_mov, 80));

	CreateBattleTargetWindow();
	CreateBattleCommandWindow();

	battle_message_window.reset(new Window_BattleMessage(Player::menu_offset_x, (Player::screen_height - Player::menu_offset_y - 80), MENU_WIDTH, 80));

	if (!IsEscapeAllowed()) {
		auto it = std::find(battle_options.begin(), battle_options.end(), Escape);
		if (it != battle_options.end()) {
			options_window->DisableItem(std::distance(battle_options.begin(), it));
		}
	}

	SetCommandWindowsX();

	ResetWindows(true);
	battle_message_window->SetVisible(true);
}

void Scene_Battle_Rpg2k::CreateEnemySprites() {
	for (auto* enemy: Main_Data::game_enemyparty->GetEnemies()) {
		auto sprite = std::make_unique<Sprite_Enemy>(enemy);
		sprite->SetVisible(true);
		enemy->SetBattleSprite(std::move(sprite));
	}
}

static std::vector<std::string> GetEnemyTargetNames() {
	std::vector<std::string> commands;

	std::vector<Game_Battler*> enemies;
	Main_Data::game_enemyparty->GetActiveBattlers(enemies);

	for (auto& enemy: enemies) {
		commands.push_back(ToString(enemy->GetName()));
	}

	return commands;
}

void Scene_Battle_Rpg2k::CreateBattleTargetWindow() {
	auto commands = GetEnemyTargetNames();
	target_window.reset(new Window_Command(std::move(commands), 136, 4));
	target_window->SetHeight(80);
	target_window->SetX(Player::menu_offset_x);
	target_window->SetY(Player::screen_height - Player::menu_offset_y - 80);
	// Above other windows
	target_window->SetZ(Priority_Window + 10);
}

void Scene_Battle_Rpg2k::RefreshTargetWindow() {
	auto commands = GetEnemyTargetNames();
	target_window->ReplaceCommands(std::move(commands));
}

std::vector<std::string> Scene_Battle_Rpg2k::GetBattleCommandNames2k3(const Game_Actor* actor) {
	std::vector<std::string> commands;
	if (actor) {
		for (auto* cmd: actor->GetBattleCommands()) {
			if (cmd->type != lcf::rpg::BattleCommand::Type_escape) {
				commands.push_back(ToString(cmd->name));
			}
		}
	}

	return commands;
}

void Scene_Battle_Rpg2k::CreateBattleCommandWindow() {
	std::vector<std::string> commands = {
		ToString(lcf::Data::terms.command_attack),
		ToString(lcf::Data::terms.command_skill),
		ToString(lcf::Data::terms.command_defend),
		ToString(lcf::Data::terms.command_item)
	};

	command_window.reset(new Window_Command(std::move(commands), option_command_mov));
	command_window->SetHeight(80);
	command_window->SetY(Player::screen_height - Player::menu_offset_y - 80);
}

void Scene_Battle_Rpg2k::RefreshCommandWindow() {
	if (Player::IsRPG2k3() && Feature::HasRpg2kBattleSystem() && !lcf::Data::system.easyrpg_use_rpg2k_battle_commands) {
		int index = command_window->GetIndex();
		auto commands = GetBattleCommandNames2k3(active_actor);
		command_window->ReplaceCommands(std::move(commands));
		command_window->SetIndex(index);
	} else {
		command_window->SetItemText(1, active_actor->GetSkillName());
	}
}

void Scene_Battle_Rpg2k::SetState(Scene_Battle::State new_state) {
	previous_state = state;
	state = new_state;

	SetSceneActionSubState(0);
}

bool Scene_Battle_Rpg2k::UpdateBattleState() {
	if (resume_from_debug_scene) {
		resume_from_debug_scene = false;
		return true;
	}

	UpdateScreen();
	UpdateBattlers();
	UpdateUi();
	battle_message_window->Update();

	if (!UpdateEvents()) {
		return false;
	}

	if (!UpdateTimers()) {
		return false;
	}

	if (Input::IsTriggered(Input::DEBUG_MENU)) {
		if (this->CallDebug()) {
			// Set this flag so that when we return and run update again, we resume exactly from after this point.
			resume_from_debug_scene = true;
			return false;
		}
	}
	return true;
}

void Scene_Battle_Rpg2k::vUpdate() {
	const auto process_scene = UpdateBattleState();

	while (process_scene) {
		// Something ended the battle.
		if (Scene::instance.get() != this) {
			break;
		}

		if (IsWindowMoving()) {
			break;
		}

		if (Game_Message::IsMessageActive() || Game_Battle::GetInterpreter().IsRunning()) {
			break;
		}

		// this is checked separately because we want normal events to be processed
		// just not sub-events called by maniacs battle hooks.
		if (state != State_Victory && state != State_Defeat && Game_Battle::ManiacProcessSubEvents()) {
			break;
		}

		if (!CheckWait()) {
			break;
		}

		if (ProcessSceneAction() == SceneActionReturn::eWaitTillNextFrame) {
			break;
		}
	}

	Game_Battle::UpdateGraphics();
}

void Scene_Battle_Rpg2k::SetSceneActionSubState(int substate) {
	scene_action_substate = substate;
}

void Scene_Battle_Rpg2k::NextTurn() {
	Main_Data::game_party->IncTurns();
	Game_Battle::GetInterpreterBattle().ResetPagesExecuted();
}

bool Scene_Battle_Rpg2k::CheckBattleEndAndScheduleEvents() {
	if (CheckBattleEndConditions()) {
		return false;
	}

	auto& interp = Game_Battle::GetInterpreterBattle();

	int page = interp.ScheduleNextPage(nullptr);
#ifdef EP_DEBUG_BATTLE2K_STATE_MACHINE
	if (page) {
		Output::Debug("Battle2k ScheduleNextEventPage Scheduled Page {} frame={}", page, Main_Data::game_system->GetFrameCounter());
	} else {
		Output::Debug("Battle2k ScheduleNextEventPage No Events to Run frame={}", Main_Data::game_system->GetFrameCounter());
	}
#else
	(void)page;
#endif

	return !interp.IsRunning();
}


Scene_Battle_Rpg2k::SceneActionReturn Scene_Battle_Rpg2k::ProcessSceneAction() {
#ifdef EP_DEBUG_BATTLE2K_STATE_MACHINE
	static int last_state = -1;
	static int last_substate = -1;
	if (state != last_state || scene_action_substate != last_substate) {
		Output::Debug("Battle2k ProcessSceneAction({},{}) frames={}", state, scene_action_substate, Main_Data::game_system->GetFrameCounter());
		last_state = state;
		last_substate = scene_action_substate;
	}
#endif
	switch (state) {
		case State_Start:
			return ProcessSceneActionStart();
		case State_SelectOption:
			return ProcessSceneActionFightAutoEscape();
		case State_SelectActor:
			return ProcessSceneActionActor();
		case State_AutoBattle:
			return ProcessSceneActionAutoBattle();
		case State_SelectCommand:
			return ProcessSceneActionCommand();
		case State_SelectItem:
			return ProcessSceneActionItem();
		case State_SelectSkill:
			return ProcessSceneActionSkill();
		case State_SelectEnemyTarget:
			return ProcessSceneActionEnemyTarget();
		case State_SelectAllyTarget:
			return ProcessSceneActionAllyTarget();
		case State_Battle:
			return ProcessSceneActionBattle();
		case State_Victory:
			return ProcessSceneActionVictory();
		case State_Defeat:
			return ProcessSceneActionDefeat();
		case State_Escape:
			return ProcessSceneActionEscape();
	}
	assert(false && "Invalid SceneActionState!");
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k::SceneActionReturn Scene_Battle_Rpg2k::ProcessSceneActionStart() {
	enum SubState {
		eBegin,
		eDisplayMonsters,
		eFirstStrike,
		eClear
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(true);
		battle_message_window->SetVisible(true);

		std::vector<Game_Battler *> visible_enemies;
		// First time entered, initialize.
		Main_Data::game_enemyparty->GetActiveBattlers(visible_enemies);

		for (auto& enemy: visible_enemies) {
			// Format and wordwrap all messages, then pull them out and push them back 1 at a time.
			battle_message_window->PushWithSubject(lcf::Data::terms.encounter, enemy->GetName());
		}

		battle_result_messages = battle_message_window->GetLines();
		battle_result_messages_it = battle_result_messages.begin();
		battle_message_window->Clear();

		if (!visible_enemies.empty()) {
			SetWait(4, 4);
		}
		SetSceneActionSubState(eDisplayMonsters);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eDisplayMonsters) {
		if (battle_result_messages_it == battle_result_messages.end()) {
			SetSceneActionSubState(eFirstStrike);
			return SceneActionReturn::eContinueThisFrame;
		}

		if (battle_message_window->IsPageFilled()) {
			battle_message_window->Clear();
			SetWait(4, 4);
			return SceneActionReturn::eContinueThisFrame;
		}

		battle_message_window->Push(*battle_result_messages_it);
		++battle_result_messages_it;

		if (battle_result_messages_it == battle_result_messages.end() ||
				battle_message_window->IsPageFilled()) {
			SetWait(30, 70);
		}
		else {
			SetWait(8, 8);
		}

		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eFirstStrike) {
		battle_message_window->Clear();
		battle_result_messages.clear();
		battle_result_messages_it = battle_result_messages.end();

		if (first_strike) {
			battle_message_window->Push(lcf::Data::terms.special_combat);
			SetWait(30, 70);
		}

		SetSceneActionSubState(eClear);

		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eClear) {
		battle_message_window->Clear();
		SetState(State_SelectOption);
	}

	return SceneActionReturn::eContinueThisFrame;
}

void Scene_Battle_Rpg2k::ResetWindows(bool make_invisible) {
	options_window->SetActive(false);
	status_window->SetActive(false);
	command_window->SetActive(false);
	item_window->SetActive(false);
	skill_window->SetActive(false);
	target_window->SetActive(false);
	battle_message_window->SetActive(false);

	if (!make_invisible) {
		return;
	}

	options_window->SetVisible(false);
	status_window->SetVisible(false);
	command_window->SetVisible(false);
	target_window->SetVisible(false);
	battle_message_window->SetVisible(false);
	item_window->SetVisible(false);
	skill_window->SetVisible(false);
	help_window->SetVisible(false);
}

void Scene_Battle_Rpg2k::SetCommandWindowsX() {
	int x = Player::menu_offset_x;
	if (Player::screen_width >= battle_menu_offset_x) {
		x = std::max<int>((Player::screen_width - battle_menu_offset_x) / 2, 0);
	}

	options_window->SetX(x);
	x += options_window->GetWidth();
	status_window->SetX(x);
	x += status_window->GetWidth();
	command_window->SetX(x);
}

void Scene_Battle_Rpg2k::MoveCommandWindows(int x, int frames) {
	if (Player::screen_width >= battle_menu_offset_x) {
		// Do not animate as they fit on the screen in widescreen mode
		return;
	}

	options_window->InitMovement(options_window->GetX(), options_window->GetY(),
			x, options_window->GetY(), frames);

	x += options_window->GetWidth();
	status_window->InitMovement(status_window->GetX(), status_window->GetY(),
			x, status_window->GetY(), frames);

	x += status_window->GetWidth();
	command_window->InitMovement(command_window->GetX(), command_window->GetY(),
			x, command_window->GetY(), frames);
}

Scene_Battle_Rpg2k::SceneActionReturn Scene_Battle_Rpg2k::ProcessSceneActionFightAutoEscape() {
	enum SubState {
		eBegin,
		eCheckEvents,
		eMoveWindow,
		eWaitForInput,
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(true);
		battle_message_window->SetVisible(true);

		SetSceneActionSubState(eCheckEvents);
	}

	if (scene_action_substate == eCheckEvents) {
		if (!CheckBattleEndAndScheduleEvents()) {
			return SceneActionReturn::eContinueThisFrame;
		}

		// No Auto battle/Escape when all actors are sleeping or similar
		if (!Main_Data::game_party->IsAnyControllable()) {
			SetState(State_SelectActor);
			return SceneActionReturn::eContinueThisFrame;
		}

		SetSceneActionSubState(eMoveWindow);
	}

	if (scene_action_substate == eMoveWindow) {
		options_window->SetVisible(true);
		status_window->SetVisible(true);
		status_window->SetIndex(-1);
		command_window->SetIndex(-1);
		command_window->SetVisible(true);
		battle_message_window->SetVisible(false);
		status_window->Refresh();

		if (previous_state == State_SelectCommand) {
			MoveCommandWindows(Player::menu_offset_x, 8);
		} else {
			SetCommandWindowsX();
		}
		SetSceneActionSubState(eWaitForInput);
		// Prevent that DECISION from a closed message triggers a battle option in eWaitForInput
		Input::ResetTriggerKeys();
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eWaitForInput) {
		options_window->SetActive(true);

		if (Input::IsTriggered(Input::DECISION)) {
			if (!message_window->IsVisible()) {
				switch (battle_options[options_window->GetIndex()]) {
					case Battle: // Battle
						Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
						RefreshTargetWindow();
						target_window->SetVisible(false);
						SetState(State_SelectActor);
						break;
					case AutoBattle: // Auto Battle
						SetState(State_AutoBattle);
						Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
						break;
					case Escape: // Escape
						if (!IsEscapeAllowed()) {
							Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
						}
						else {
							Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
							SetState(State_Escape);
						}
						break;
					case Win: // Win
						for (Game_Enemy* enemy : Main_Data::game_enemyparty->GetEnemies()) {
							enemy->Kill();
						}
						SetState(State_Victory);
						break;
					case Lose: // Lose
						SetState(State_Defeat);
						break;
				}
			}
			return SceneActionReturn::eWaitTillNextFrame;
		}
	}
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k::SceneActionReturn Scene_Battle_Rpg2k::ProcessSceneActionActor() {
	SelectNextActor(false);
	return SceneActionReturn::eContinueThisFrame;
}

Scene_Battle_Rpg2k::SceneActionReturn Scene_Battle_Rpg2k::ProcessSceneActionAutoBattle() {
	SelectNextActor(true);
	return SceneActionReturn::eContinueThisFrame;
}

Scene_Battle_Rpg2k::SceneActionReturn Scene_Battle_Rpg2k::ProcessSceneActionCommand() {
	enum SubState {
		eMoveWindow,
		eWaitForInput,
	};

	if (scene_action_substate == eMoveWindow) {
		RefreshCommandWindow();

		ResetWindows(true);

		options_window->SetVisible(true);
		status_window->SetVisible(true);
		command_window->SetVisible(true);
		if (previous_state == State_SelectActor) {
			command_window->SetIndex(0);
		}

		MoveCommandWindows(Player::menu_offset_x - options_window->GetWidth(), 8);
		SetSceneActionSubState(eWaitForInput);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eWaitForInput) {
		command_window->SetActive(true);
		if (Input::IsTriggered(Input::DECISION)) {
			if (Player::IsRPG2k3() && Feature::HasRpg2kBattleSystem() && !lcf::Data::system.easyrpg_use_rpg2k_battle_commands) {
				int index = command_window->GetIndex();
				const auto* command = active_actor->GetBattleCommand(index);

				if (command) {
					active_actor->SetLastBattleAction(command->ID);
					switch (command->type) {
						case lcf::rpg::BattleCommand::Type_attack:
							AttackSelected();
							break;
						case lcf::rpg::BattleCommand::Type_defense:
							DefendSelected();
							break;
						case lcf::rpg::BattleCommand::Type_item:
							Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
							SetState(State_SelectItem);
							break;
						case lcf::rpg::BattleCommand::Type_skill:
							Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
							skill_window->SetSubsetFilter(0);
							SetState(State_SelectSkill);
							break;
						case lcf::rpg::BattleCommand::Type_special:
							Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
							SpecialSelected2k3();
							break;
						case lcf::rpg::BattleCommand::Type_subskill:
							Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
							SubskillSelected2k3(command->ID);
							break;
					}
				}
			} else {
				switch (command_window->GetIndex()) {
					case 0: // Attack
						AttackSelected();
						break;
					case 1: // Skill
						Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
						SetState(State_SelectSkill);
						break;
					case 2: // Defense
						DefendSelected();
						break;
					case 3: // Item
						Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
						SetState(State_SelectItem);
						break;
					default:
						// no-op
						break;
				}
			}
			return SceneActionReturn::eWaitTillNextFrame;
		}
		if (Input::IsTriggered(Input::CANCEL)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
			--actor_index;
			SelectPreviousActor();
			return SceneActionReturn::eWaitTillNextFrame;
		}
	}
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k::SceneActionReturn Scene_Battle_Rpg2k::ProcessSceneActionItem() {
	enum SubState {
		eBegin,
		eWaitForInput,
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(true);

		item_window->SetVisible(true);
		item_window->SetActive(true);
		item_window->SetActor(active_actor);
		item_window->Refresh();
		item_window->SetHelpWindow(help_window.get());
		help_window->SetVisible(true);

		SetSceneActionSubState(eWaitForInput);
	}

	if (scene_action_substate == eWaitForInput) {
		if (Input::IsTriggered(Input::DECISION)) {
			ItemSelected();
			return SceneActionReturn::eWaitTillNextFrame;
		}
		if (Input::IsTriggered(Input::CANCEL)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
			SetState(State_SelectCommand);
			return SceneActionReturn::eWaitTillNextFrame;
		}
	}
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k::SceneActionReturn Scene_Battle_Rpg2k::ProcessSceneActionSkill() {
	enum SubState {
		eBegin,
		eWaitForInput,
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(true);

		skill_window->SetActive(true);
		skill_window->SetActor(*active_actor);
		if (previous_state == State_SelectCommand) {
			skill_window->RestoreActorIndex(actor_index - 1);
		}
		skill_window->SetVisible(true);
		skill_window->SetHelpWindow(help_window.get());
		help_window->SetVisible(true);

		SetSceneActionSubState(eWaitForInput);
	}

	if (scene_action_substate == eWaitForInput) {
		if (Input::IsTriggered(Input::DECISION)) {
			skill_window->SaveActorIndex(actor_index - 1);
			SkillSelected();
			return SceneActionReturn::eWaitTillNextFrame;
		}
		if (Input::IsTriggered(Input::CANCEL)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
			skill_window->SaveActorIndex(actor_index - 1);
			SetState(State_SelectCommand);
			return SceneActionReturn::eWaitTillNextFrame;
		}
	}
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k::SceneActionReturn Scene_Battle_Rpg2k::ProcessSceneActionEnemyTarget() {
	enum SubState {
		eBegin,
		eWaitForInput,
	};

	std::vector<Game_Battler*> enemies;
	Main_Data::game_enemyparty->GetActiveBattlers(enemies);
	Game_Enemy* target = static_cast<Game_Enemy*>(enemies[target_window->GetIndex()]);

	if (scene_action_substate == eBegin) {
		select_target_flash_count = 0;
		ResetWindows(false);

		target_window->SetVisible(true);
		target_window->SetActive(true);
		target_window->SetVisible(true);
		target_window->SetIndex(0);

		SetSceneActionSubState(eWaitForInput);
	}

	++select_target_flash_count;

	if (select_target_flash_count == 60) {
		SelectionFlash(target);
		select_target_flash_count = 0;
	}

	if (scene_action_substate == eWaitForInput) {
		if (Input::IsTriggered(Input::DECISION)) {
			EnemySelected();
			return SceneActionReturn::eWaitTillNextFrame;
		}
		if (Input::IsTriggered(Input::CANCEL)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
			SetState(previous_state);
			return SceneActionReturn::eWaitTillNextFrame;
		}
	}
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k::SceneActionReturn Scene_Battle_Rpg2k::ProcessSceneActionAllyTarget() {
	enum SubState {
		eBegin,
		eWaitForInput,
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(false);
		status_window->SetActive(true);
		status_window->SetVisible(true);
		status_window->SetIndex(0);

		SetSceneActionSubState(eWaitForInput);
	}

	if (scene_action_substate == eWaitForInput) {
		if (Input::IsTriggered(Input::DECISION)) {
			AllySelected();
			return SceneActionReturn::eWaitTillNextFrame;
		}
		if (Input::IsTriggered(Input::CANCEL)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
			SetState(previous_state);
			return SceneActionReturn::eWaitTillNextFrame;
		}
	}
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k::SceneActionReturn Scene_Battle_Rpg2k::ProcessSceneActionBattle() {
	enum SubState {
		eBegin,
		ePreAction,
		eBattleAction,
		ePost,
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(true);
		battle_message_window->SetVisible(true);

		SetSceneActionSubState(ePreAction);
	}

	if (scene_action_substate == ePreAction) {
		// Remove actions for battlers who were killed or removed from the battle.
		while (!battle_actions.empty() && !battle_actions.front()->Exists()) {
			RemoveCurrentAction();
		}

		// Check for end battle, and run events before action
		// This happens before each battler acts and also right after the last battler acts.
		if (!CheckBattleEndAndScheduleEvents()) {
			return SceneActionReturn::eContinueThisFrame;
		}

		if (battle_actions.empty()) {
			SetSceneActionSubState(ePost);
			return SceneActionReturn::eContinueThisFrame;
		}

		auto* battler = battle_actions.front();
		// If we will start a new battle action, first check for state changes
		// such as death, paralyze, confuse, etc..
		PrepareBattleAction(battler);
		pending_battle_action = battler->GetBattleAlgorithm();

#ifdef EP_DEBUG_BATTLE2K_STATE_MACHINE
		Output::Debug("Battle2k StartBattleAction battler={} frame={}", battler->GetName(), Main_Data::game_system->GetFrameCounter());
#endif

		// Initialize battle state
		battle_action_wait = 0;
		SetBattleActionState(BattleActionState_Begin);
		battle_action_start_index = 0;
		battle_action_results_index = 0;
		battle_action_dmg_index = 0;
		battle_action_substate_index = 0;
		pending_message = {};

		SetSceneActionSubState(eBattleAction);
	}

	if (scene_action_substate == eBattleAction) {
		if (ProcessBattleAction(pending_battle_action.get()) == BattleActionReturn::eContinue) {
			return SceneActionReturn::eContinueThisFrame;
		}

		pending_battle_action = nullptr;
		RemoveCurrentAction();
		battle_message_window->Clear();

		SetSceneActionSubState(ePreAction);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == ePost) {
		// Everybody acted
		actor_index = 0;
		first_strike = false;

		SetState(State_SelectOption);
		return SceneActionReturn::eWaitTillNextFrame;
	}
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k::SceneActionReturn Scene_Battle_Rpg2k::ProcessSceneActionVictory() {
	enum SubState {
		eBegin = 0,
		eEnd = 1,
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(true);
		battle_message_window->Clear();
		battle_message_window->SetVisible(true);

		int exp = Main_Data::game_enemyparty->GetExp();
		int money = Main_Data::game_enemyparty->GetMoney();
		std::vector<int> drops;
		Main_Data::game_enemyparty->GenerateDrops(drops);

		PendingMessage pm(Game_Message::CommandCodeInserter);
		pm.SetEnableFace(false);

		pm.SetWordWrapped(Feature::HasPlaceholders());
		pm.PushLine(ToString(lcf::Data::terms.victory) + Player::escape_symbol + "|");

		std::stringstream ss;
		if (exp > 0) {
			PushExperienceGainedMessage(pm, exp);
		}
		if (money > 0) {
			PushGoldReceivedMessage(pm, money);
		}
		PushItemRecievedMessages(pm, drops);

		Main_Data::game_system->BgmPlay(Main_Data::game_system->GetSystemBGM(Main_Data::game_system->BGM_Victory));

		// Update attributes
		std::vector<Game_Battler*> ally_battlers;
		Main_Data::game_party->GetActiveBattlers(ally_battlers);

		pm.PushPageEnd();

		for (int i = 0; i < static_cast<int>(ally_battlers.size()); ++i) {
			Game_Actor* actor = static_cast<Game_Actor*>(ally_battlers[i]);
			int exp_gain = exp;
			RuntimePatches::EXPlus::ModifyExpGain(*actor, exp_gain);
			actor->ChangeExp(actor->GetExp() + exp_gain, &pm);
		}
		Main_Data::game_party->GainGold(money);
		for (auto& item: drops) {
			Main_Data::game_party->AddItem(item, 1);
		}

		Game_Message::SetPendingMessage(std::move(pm));

		SetSceneActionSubState(eEnd);
		return SceneActionReturn::eContinueThisFrame;
	}

	EndBattle(BattleResult::Victory);
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k::SceneActionReturn Scene_Battle_Rpg2k::ProcessSceneActionDefeat() {
	enum SubState {
		eBegin = 0,
		eEnd = 1,
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(true);
		battle_message_window->Clear();
		battle_message_window->SetVisible(true);

		Main_Data::game_system->SetMessagePositionFixed(true);
		Main_Data::game_system->SetMessagePosition(2);
		Main_Data::game_system->SetMessageTransparent(false);

		PendingMessage pm(Game_Message::CommandCodeInserter);
		pm.SetEnableFace(false);

		pm.SetWordWrapped(Feature::HasPlaceholders());

		pm.PushLine(ToString(lcf::Data::terms.defeat));

		Main_Data::game_system->BgmPlay(Main_Data::game_system->GetSystemBGM(Main_Data::game_system->BGM_GameOver));

		Game_Message::SetPendingMessage(std::move(pm));
		SetSceneActionSubState(eEnd);

		return SceneActionReturn::eContinueThisFrame;
	}

	EndBattle(BattleResult::Defeat);
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k::SceneActionReturn Scene_Battle_Rpg2k::ProcessSceneActionEscape() {
	enum SubState {
		eBegin = 0,
		eSuccess = 1,
		eFailure = 2,
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(true);
		battle_message_window->Clear();
		battle_message_window->SetVisible(true);

		auto next_ss = TryEscape() ? eSuccess : eFailure;

		if (next_ss == eSuccess) {
			battle_message_window->Push(lcf::Data::terms.escape_success);
		} else {
			battle_message_window->Push(lcf::Data::terms.escape_failure);
		}
		SetWait(10, 60);
		SetSceneActionSubState(next_ss);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eSuccess) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Escape));

		EndBattle(BattleResult::Escape);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eFailure) {
		SetState(State_Battle);
		NextTurn();

		CreateEnemyActions();
		CreateExecutionOrder();
		return SceneActionReturn::eContinueThisFrame;
	}
	return SceneActionReturn::eWaitTillNextFrame;
}

void Scene_Battle_Rpg2k::SetBattleActionState(BattleActionState state) {
	battle_action_state = state;
	SetBattleActionSubState(0);
}

void Scene_Battle_Rpg2k::SetBattleActionSubState(int substate, bool reset_index) {
	battle_action_substate = substate;
	if (reset_index) {
		battle_action_substate_index = 0;
	}
}

Scene_Battle_Rpg2k::BattleActionReturn Scene_Battle_Rpg2k::ProcessBattleAction(Game_BattleAlgorithm::AlgorithmBase* action) {
	if (action == nullptr) {
		Output::Warning("ProcessBattleAction: Invalid battle action");
		Output::Warning("Please report a bug!");
		return BattleActionReturn::eFinished;
	}

#ifdef EP_DEBUG_BATTLE2K_STATE_MACHINE
	static int last_state = -1;
	static int last_substate = -1;
	static int last_substate_index = -1;
	if (battle_action_state != last_state || battle_action_substate != last_substate || battle_action_substate_index != last_substate_index) {
		Output::Debug("Battle2k ProcessBattleAction({}, {},{},{}) frames={}", action->GetSource()->GetName(), battle_action_state, battle_action_substate, battle_action_substate_index, Main_Data::game_system->GetFrameCounter());
		last_state = battle_action_state;
		last_substate = battle_action_substate;
		last_substate_index = battle_action_substate_index;
	}
#endif

	switch (battle_action_state) {
		case BattleActionState_Begin:
			return ProcessBattleActionBegin(action);
		case BattleActionState_Usage:
			return ProcessBattleActionUsage(action);
		case BattleActionState_Animation:
			return ProcessBattleActionAnimation(action);
		case BattleActionState_AnimationReflect:
			return ProcessBattleActionAnimationReflect(action);
		case BattleActionState_Execute:
			return ProcessBattleActionExecute(action);
		case BattleActionState_Critical:
			return ProcessBattleActionCritical(action);
		case BattleActionState_Apply:
			return ProcessBattleActionApply(action);
		case BattleActionState_Failure:
			return ProcessBattleActionFailure(action);
		case BattleActionState_Damage:
			return ProcessBattleActionDamage(action);
		case BattleActionState_Params:
			return ProcessBattleActionParamEffects(action);
		case BattleActionState_States:
			return ProcessBattleActionStateEffects(action);
		case BattleActionState_Attributes:
			return ProcessBattleActionAttributeEffects(action);
		case BattleActionState_Finished:
			return ProcessBattleActionFinished(action);
	}

	assert(false && "Invalid BattleActionState!");

	return BattleActionReturn::eFinished;
}

Scene_Battle_Rpg2k::BattleActionReturn Scene_Battle_Rpg2k::ProcessBattleActionBegin(Game_BattleAlgorithm::AlgorithmBase* action) {
	enum SubState {
		eBegin = 0,
		eShowMessage,
		ePost,
	};

	auto* src = action->GetSource();

	if (battle_action_substate == eBegin) {
		assert(src->Exists());
		battle_message_window->Clear();

		bool show_message = false;
		src->NextBattleTurn();

		std::vector<int16_t> states_to_heal = src->BattleStateHeal();
		src->ApplyConditions();

		const lcf::rpg::State* pri_state = nullptr;
		bool pri_was_healed = false;
		for (size_t id = 1; id <= lcf::Data::states.size(); ++id) {
			auto was_healed = std::find(states_to_heal.begin(), states_to_heal.end(), id) != states_to_heal.end();
			if (!was_healed && !src->HasState(id)) {
				continue;
			}

			auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, id);
			if (!pri_state || state->priority >= pri_state->priority) {
				pri_state = state;
				pri_was_healed = was_healed;
			}
		}

		if (pri_state != nullptr) {
			std::string_view msg = pri_was_healed
				? pri_state->message_recovery
				: pri_state->message_affected;

			// RPG_RT behavior:
			// If state was healed, always prints.
			// If state is inflicted, only prints if msg not empty.
			if (pri_was_healed || !msg.empty()) {
				show_message = true;
				pending_message = ToString(msg);
			}
		}

		if (action->GetType() != Game_BattleAlgorithm::Type::None || show_message) {
			action->GetSource()->Flash(31, 31, 31, 10, 10);
		}

		if (show_message) {
			SetWait(4,4);
			SetBattleActionSubState(eShowMessage);
			return BattleActionReturn::eContinue;
		}
		battle_action_substate = ePost;
	}

	if (battle_action_substate == eShowMessage) {
		battle_message_window->PushWithSubject(std::move(pending_message), action->GetSource()->GetName());
		SetWait(20, 60);
		pending_message.clear();
		SetBattleActionSubState(ePost);
		return BattleActionReturn::eContinue;
	}

	if (battle_action_substate == ePost) {
		battle_message_window->Clear();

		if (action->GetType() == Game_BattleAlgorithm::Type::None) {
			SetBattleActionState(BattleActionState_Finished);
			return BattleActionReturn::eContinue;
		}

		SetWait(4,4);
	}

	SetBattleActionState(BattleActionState_Usage);
	return BattleActionReturn::eContinue;
}


Scene_Battle_Rpg2k::BattleActionReturn Scene_Battle_Rpg2k::ProcessBattleActionUsage(Game_BattleAlgorithm::AlgorithmBase* action) {
	enum SubState {
		eBegin = 0,
		eMessages,
		eLastMessage,
	};

	if (battle_action_substate == eBegin) {
		action->Start();
		battle_message_window->Clear();

		pending_message = action->GetStartMessage(0);

		SetBattleActionSubState(eMessages);
	}

	if (battle_action_substate == eMessages) {
		if (!pending_message.empty()) {
			battle_message_window->Push(std::move(pending_message));
			battle_message_window->ScrollToEnd();

			pending_message = action->GetStartMessage(++battle_action_substate_index);

			if (!pending_message.empty()) {
				SetWaitForUsage(action->GetType(), 0);
				return BattleActionReturn::eContinue;
			}
		}

		SetBattleActionSubState(eLastMessage);
	}

	if (battle_action_substate == eLastMessage) {
		battle_action_start_index = battle_message_window->GetLineCount();

		auto* se = action->GetStartSe();
		if (se) {
			Main_Data::game_system->SePlay(*se);
		}
	}

	SetBattleActionState(BattleActionState_Animation);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k::BattleActionReturn Scene_Battle_Rpg2k::ProcessBattleActionAnimation(Game_BattleAlgorithm::AlgorithmBase* action) {
	return ProcessBattleActionAnimationImpl(action, false);
}

Scene_Battle_Rpg2k::BattleActionReturn Scene_Battle_Rpg2k::ProcessBattleActionAnimationReflect(Game_BattleAlgorithm::AlgorithmBase* action) {
	return ProcessBattleActionAnimationImpl(action, true);
}

Scene_Battle_Rpg2k::BattleActionReturn Scene_Battle_Rpg2k::ProcessBattleActionAnimationImpl(Game_BattleAlgorithm::AlgorithmBase* action, bool reflect) {
	int frames = 0;
	while(1) {
		const int cur_anim = action->GetAnimationId(battle_action_substate_index);
		++battle_action_substate_index;
		int next_anim = 0;

		if (cur_anim) {
			if (action->GetTarget()->GetType() == Game_Battler::Type_Enemy) {
				frames = action->PlayAnimation(cur_anim);
			} else {
				frames = action->PlayAnimation(cur_anim, true, 40);
			}
			next_anim = action->GetAnimationId(battle_action_substate_index);
		}

		if (!next_anim) {
			break;
		}

		if (frames) {
			SetWait(frames, frames);
			return BattleActionReturn::eContinue;
		}
	}

	if (!reflect) {
		// Wait for last start message and last animation.
		SetWaitForUsage(action->GetType(), frames);

		// EasyRPG extension: Support 2k3 reflect feature in 2k battle system.
		if (action->ReflectTargets()) {
			SetBattleActionState(BattleActionState_AnimationReflect);
			return BattleActionReturn::eContinue;
		}
	} else {
		// Wait for reflected animation - no message.
		SetWait(frames, frames);
	}

	SetBattleActionState(BattleActionState_Execute);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k::BattleActionReturn Scene_Battle_Rpg2k::ProcessBattleActionExecute(Game_BattleAlgorithm::AlgorithmBase* action) {
	if (!action->IsCurrentTargetValid()) {
		// FIXME: Pick a new target instead of ending the action
		SetBattleActionState(BattleActionState_Finished);
		return BattleActionReturn::eContinue;
	}

	action->Execute();
	if (action->GetType() == Game_BattleAlgorithm::Type::Normal
			|| action->GetType() == Game_BattleAlgorithm::Type::Skill
			|| action->GetType() == Game_BattleAlgorithm::Type::SelfDestruct) {
		if (action->GetType() != Game_BattleAlgorithm::Type::Skill) {
			SetWait(4,4);
		}
		if (action->IsSuccess() && action->IsCriticalHit()) {
			SetBattleActionState(BattleActionState_Critical);
			return BattleActionReturn::eContinue;
		}
	}
	SetBattleActionState(BattleActionState_Apply);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k::BattleActionReturn Scene_Battle_Rpg2k::ProcessBattleActionCritical(Game_BattleAlgorithm::AlgorithmBase* action) {
	battle_message_window->Push(BattleMessage::GetCriticalHitMessage(*action->GetSource(), *action->GetTarget()));
	battle_message_window->ScrollToEnd();
	SetWait(10, 30);

	SetBattleActionState(BattleActionState_Apply);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k::BattleActionReturn Scene_Battle_Rpg2k::ProcessBattleActionApply(Game_BattleAlgorithm::AlgorithmBase* action) {
	action->ApplyCustomEffect();
	action->ApplySwitchEffect();

	battle_action_results_index = battle_message_window->GetLineCount();

	if (!action->IsSuccess()) {
		SetBattleActionState(BattleActionState_Failure);
		return BattleActionReturn::eContinue;
	}

	auto* target = action->GetTarget();

	if (!target) {
		SetBattleActionState(BattleActionState_Finished);
		return BattleActionReturn::eContinue;
	}

	SetBattleActionState(BattleActionState_Damage);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k::BattleActionReturn Scene_Battle_Rpg2k::ProcessBattleActionFailure(Game_BattleAlgorithm::AlgorithmBase* action) {
	enum SubState {
		eBegin = 0,
		eProcess,
	};

	if (battle_action_substate == eBegin) {
		SetWait(4,4);
		SetBattleActionSubState(eProcess);
		return BattleActionReturn::eContinue;
	}

	auto* se = action->GetFailureSe();
	if (se) {
		Main_Data::game_system->SePlay(*se);
	}

	const auto& fail_msg = action->GetFailureMessage();
	battle_message_window->Push(fail_msg);
	battle_message_window->ScrollToEnd();
	SetWait(20, 60);

	SetBattleActionState(BattleActionState_Finished);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k::BattleActionReturn Scene_Battle_Rpg2k::ProcessBattleActionDamage(Game_BattleAlgorithm::AlgorithmBase* action) {
	enum SubState {
		eBegin = 0,
		eMessage,
		eApply,
		ePreStates,
		eStates,
		ePost,
	};

	if (battle_action_substate == eBegin) {
		if (!action->IsAffectHp() || action->GetAffectedHp() > 0 || ((action->IsPositive() || action->IsAbsorbHp()) && action->GetAffectedHp() == 0)) {
			SetBattleActionState(BattleActionState_Params);
			return BattleActionReturn::eContinue;
		}

		SetWait(4,4);
		SetBattleActionSubState(eMessage);
		return BattleActionReturn::eContinue;
	}

	if (battle_action_substate == eMessage) {
		auto* target = action->GetTarget();
		assert(target);
		auto dmg = action->GetAffectedHp();

		if (!action->IsAbsorbHp()) {
			if (target->GetType() == Game_Battler::Type_Ally) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_AllyDamage));
				if (dmg < 0) {
					Main_Data::game_screen->ShakeOnce(3, 5, 8);
				}
			} else {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_EnemyDamage));
			}
			if (target->GetType() == Game_Battler::Type_Enemy) {
				static_cast<Game_Enemy*>(target)->SetBlinkTimer();
			}
		}

		std::string msg;
		if (action->IsAbsorbHp()) {
			msg = BattleMessage::GetHpAbsorbedMessage(*action->GetTarget(), *target, -dmg);
		} else {
			if (dmg == 0) {
				msg = BattleMessage::GetUndamagedMessage(*target);
			} else {
				msg = BattleMessage::GetDamagedMessage(*target, -dmg);
			}
		}

		battle_message_window->Push(msg);
		battle_message_window->ScrollToEnd();
		if (action->IsAbsorbHp()) {
			SetWait(20, 60);
		} else {
			SetWait(20, 40);
		}

		SetBattleActionSubState(eApply);
		return BattleActionReturn::eContinue;
	}

	if (battle_action_substate == eApply) {
		// Hp damage is delayed until after the message, so that the target death animation
		// occurs at the right time.
		action->ApplyHpEffect();

		auto* target = action->GetTarget();
		assert(target);
		if (target->IsDead()) {
			ProcessBattleActionDeath(action);
		}

		battle_action_dmg_index = battle_message_window->GetLineCount();

		SetBattleActionSubState(ePreStates);
		return BattleActionReturn::eContinue;
	}

	if (battle_action_substate == ePreStates) {
		auto* target = action->GetTarget();
		const auto& states = action->GetStateEffects();
		auto& idx = battle_action_substate_index;
		for (;idx < static_cast<int>(states.size()); ++idx) {
			auto& se = states[idx];
			auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, se.state_id);
			if (!state || se.effect != Game_BattleAlgorithm::StateEffect::HealedByAttack) {
				continue;
			}
			action->ApplyStateEffect(se);
			pending_message = BattleMessage::GetStateRecoveryMessage(*target, *state);
			++battle_action_substate_index;

			battle_message_window->PopUntil(battle_action_dmg_index);
			battle_message_window->ScrollToEnd();
			SetWait(4,4);

			SetBattleActionSubState(eStates, false);
			return BattleActionReturn::eContinue;
		}
		SetBattleActionSubState(ePost);
		return BattleActionReturn::eContinue;
	}

	if (battle_action_substate == eStates) {
		battle_message_window->Push(pending_message);
		battle_message_window->ScrollToEnd();
		SetWait(20, 40);

		SetBattleActionSubState(ePreStates, false);
		return BattleActionReturn::eContinue;
	}

	if (battle_action_substate == ePost) {
		SetWait(0, 10);
	}

	SetBattleActionState(BattleActionState_Params);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k::BattleActionReturn Scene_Battle_Rpg2k::ProcessBattleActionParamEffects(Game_BattleAlgorithm::AlgorithmBase* action) {
	enum SubState {
		ePreHp,
		eHp,
		ePreSp,
		eSp,
		ePreAtk,
		eAtk,
		ePreDef,
		eDef,
		ePreSpi,
		eSpi,
		ePreAgi,
		eAgi,
		eDone
	};

	const auto next_state = BattleActionState_States;
	auto* source = action->GetSource();
	auto* target = action->GetTarget();

	// All of the "Pre" states are even numbers, so catch all Pre here.
	if ((battle_action_substate & 1) == 0) {
		pending_message.clear();

		auto checkNext = [&]() {
			if (pending_message.empty()) {
				SetBattleActionSubState(battle_action_substate + 2);
			}
		};

		if (battle_action_substate == ePreHp) {
			// Damage is handled by Damage state, so only check healing here.
			if (action->GetAffectedHp() > 0 && !action->IsRevived()) {
				auto hp = action->ApplyHpEffect();
				pending_message = BattleMessage::GetHpRecoveredMessage(*target, hp);
			}
			checkNext();
		}

		if (battle_action_substate == ePreSp) {
			auto sp = action->ApplySpEffect();
			if (action->IsAbsorbSp()) {
				pending_message = BattleMessage::GetSpAbsorbedMessage(*source, *target, -sp);
			} else {
				if (sp > 0) {
					pending_message = BattleMessage::GetSpRecoveredMessage(*target, sp);
				}
				if (sp < 0) {
					pending_message = BattleMessage::GetSpReduceMessage(*target, -sp);
				}
			}
			checkNext();
		}

		if (battle_action_substate == ePreAtk) {
			auto atk = action->ApplyAtkEffect();
			if (atk != 0) {
				if (action->IsAbsorbAtk()) {
					pending_message = BattleMessage::GetAtkAbsorbedMessage(*source, *target, -atk);
				} else {
					pending_message = BattleMessage::GetAtkChangeMessage(*target, atk);
				}
			}
			checkNext();
		}

		if (battle_action_substate == ePreDef) {
			auto def = action->ApplyDefEffect();
			if (def != 0) {
				if (action->IsAbsorbDef()) {
					pending_message = BattleMessage::GetDefAbsorbedMessage(*source, *target, -def);
				} else {
					pending_message = BattleMessage::GetDefChangeMessage(*target, def);
				}
			}
			checkNext();
		}

		if (battle_action_substate == ePreSpi) {
			auto spi = action->ApplySpiEffect();
			if (spi != 0) {
				if (action->IsAbsorbSpi()) {
					pending_message = BattleMessage::GetSpiAbsorbedMessage(*source, *target, -spi);
				} else {
					pending_message = BattleMessage::GetSpiChangeMessage(*target, spi);
				}
			}
			checkNext();
		}

		if (battle_action_substate == ePreAgi) {
			auto agi = action->ApplyAgiEffect();
			if (agi != 0) {
				if (action->IsAbsorbAgi()) {
					pending_message = BattleMessage::GetAgiAbsorbedMessage(*source, *target, -agi);
				} else {
					pending_message = BattleMessage::GetAgiChangeMessage(*target, agi);
				}
			}
			checkNext();
		}

		if (!pending_message.empty()) {
			battle_message_window->PopUntil(battle_action_results_index);
			battle_message_window->ScrollToEnd();
			SetWait(4,4);

			SetBattleActionSubState(battle_action_substate + 1, false);
			return BattleActionReturn::eContinue;
		}
	}

	// Use >= here so that the each "pre" stage above can just call
	// checkNext() to increment +2 without worrying about overflowing
	// past eDone.
	if (battle_action_substate >= eDone) {
		SetBattleActionState(next_state);
		return BattleActionReturn::eContinue;
	}

	// All of the normal states are odd numbers.
	if ((battle_action_substate & 1) != 0) {
		battle_message_window->Push(pending_message);
		battle_message_window->ScrollToEnd();
		SetWait(20, 60);

		SetBattleActionSubState(battle_action_substate + 1);
		return BattleActionReturn::eContinue;
	}

	SetBattleActionState(next_state);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k::BattleActionReturn Scene_Battle_Rpg2k::ProcessBattleActionStateEffects(Game_BattleAlgorithm::AlgorithmBase* action) {
	enum SubState {
		eApply,
		ePreWait,
		eMessage,
		eDone
	};

	const auto next_state = BattleActionState_Attributes;

	auto* target = action->GetTarget();

	if (battle_action_substate == eApply) {
		pending_message.clear();

		const auto was_dead = target->IsDead();
		const auto& states = action->GetStateEffects();
		auto& idx = battle_action_substate_index;

		if (idx >= static_cast<int>(states.size())) {
			SetBattleActionState(next_state);
			return BattleActionReturn::eContinue;
		}

		for (;idx < (int)states.size(); ++idx) {
			auto& se = states[idx];
			// Already applied earlier after damage
			if (se.effect == Game_BattleAlgorithm::StateEffect::HealedByAttack) {
				++idx;
				return BattleActionReturn::eContinue;
			}

			auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, se.state_id);
			if (!state) {
				continue;
			}

			action->ApplyStateEffect(se);
			switch (se.effect) {
				case Game_BattleAlgorithm::StateEffect::Inflicted:
					pending_message = BattleMessage::GetStateInflictMessage(*target, *state);
					break;
				case Game_BattleAlgorithm::StateEffect::Healed:
					pending_message = BattleMessage::GetStateRecoveryMessage(*target, *state);
					break;
				case Game_BattleAlgorithm::StateEffect::AlreadyInflicted:
					pending_message = BattleMessage::GetStateAlreadyMessage(*target, *state);
					break;
				default:
					break;
			}

			if ((!was_dead && target->IsDead()) || !pending_message.empty()) {
				break;
			}
		}

		battle_message_window->PopUntil(battle_action_results_index);
		battle_message_window->ScrollToEnd();

		// If we were killed by state
		if (!was_dead && target->IsDead()) {
			ProcessBattleActionDeath(action);
			SetBattleActionState(next_state);
			// FIXES an RPG_RT bug where RPG_RT does an extra SetWait(4,4), SetWait(20,60) on death state infliction
			return BattleActionReturn::eContinue;
		}
		SetBattleActionSubState(ePreWait, false);
		return BattleActionReturn::eContinue;
	}

	if (battle_action_substate == ePreWait) {
		SetWait(4,4);
		SetBattleActionSubState(eMessage, false);
		return BattleActionReturn::eContinue;
	}

	if (battle_action_substate == eMessage) {
		battle_message_window->Push(pending_message);
		battle_message_window->ScrollToEnd();
		SetWait(20, 60);

		// Process the next state
		++battle_action_substate_index;
		SetBattleActionSubState(eApply, false);
		return BattleActionReturn::eContinue;
	}

	SetBattleActionState(next_state);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k::BattleActionReturn Scene_Battle_Rpg2k::ProcessBattleActionAttributeEffects(Game_BattleAlgorithm::AlgorithmBase* action) {
	enum SubState {
		eApply,
		eMessage,
	};

	const auto next_state = BattleActionState_Finished;

	// All of the "Pre" states are even numbers, so catch all Pre here.
	if (battle_action_substate == eApply) {
		pending_message.clear();

		const auto& attrs = action->GetShiftedAttributes();
		auto& idx = battle_action_substate_index;
		if (idx >= static_cast<int>(attrs.size())) {
			SetBattleActionState(next_state);
			return BattleActionReturn::eContinue;
		}

		for (;idx < (int)attrs.size(); ++idx) {
			auto& ae = attrs[battle_action_substate_index];
			auto shifted = action->ApplyAttributeShiftEffect(ae);
			if (shifted != 0) {
				auto* attr = lcf::ReaderUtil::GetElement(lcf::Data::attributes, ae.attr_id);
				pending_message = BattleMessage::GetAttributeShiftMessage(*action->GetTarget(), shifted, *attr);
				break;
			}
		}

		battle_message_window->PopUntil(battle_action_results_index);
		battle_message_window->ScrollToEnd();
		SetWait(4,4);

		SetBattleActionSubState(eMessage, false);
		return BattleActionReturn::eContinue;
	}

	// All of the normal states are odd numbers.
	if (battle_action_substate == eMessage) {
		battle_message_window->Push(pending_message);
		battle_message_window->ScrollToEnd();
		SetWait(20, 60);

		++battle_action_substate_index;
		SetBattleActionSubState(eApply, false);
		return BattleActionReturn::eContinue;
	}

	SetBattleActionState(next_state);
	return BattleActionReturn::eContinue;
}

void Scene_Battle_Rpg2k::ProcessBattleActionDeath(Game_BattleAlgorithm::AlgorithmBase* action) {
	auto* target = action->GetTarget();
	assert(target);

	battle_message_window->Push(BattleMessage::GetDeathMessage(*action->GetTarget()));
	battle_message_window->ScrollToEnd();
	SetWait(36, 60);

	if (target->GetType() == Game_Battler::Type_Enemy) {
		static_cast<Game_Enemy*>(target)->SetDeathTimer();
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_EnemyKill));
	}
}

Scene_Battle_Rpg2k::BattleActionReturn Scene_Battle_Rpg2k::ProcessBattleActionFinished(Game_BattleAlgorithm::AlgorithmBase* action) {
	if (action->RepeatNext(true) || action->TargetNext()) {
		// Clear the console for the next target
		battle_message_window->PopUntil(battle_action_start_index);
		battle_message_window->ScrollToEnd();

		SetBattleActionState(BattleActionState_Execute);
		return BattleActionReturn::eContinue;
	}

	battle_message_window->Clear();
	action->ProcessPostActionSwitches();
	return BattleActionReturn::eFinished;
}

void Scene_Battle_Rpg2k::SelectNextActor(bool auto_battle) {
	std::vector<Game_Actor*> allies = Main_Data::game_party->GetActors();

	if ((size_t)actor_index == allies.size()) {
		// All actor actions decided, player turn ends
		SetState(State_Battle);
		NextTurn();

		CreateEnemyActions();
		CreateExecutionOrder();

		return;
	}

	active_actor = allies[actor_index];
	status_window->SetIndex(actor_index);
	actor_index++;

	Game_Battler* random_target = NULL;

	if (!active_actor->CanAct()) {
		active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::None>(active_actor));
		battle_actions.push_back(active_actor);
		SelectNextActor(auto_battle);
		return;
	}

	switch (active_actor->GetSignificantRestriction()) {
		case lcf::rpg::State::Restriction_attack_ally:
			random_target = Main_Data::game_party->GetRandomActiveBattler();
			break;
		case lcf::rpg::State::Restriction_attack_enemy:
			random_target = Main_Data::game_enemyparty->GetRandomActiveBattler();
			break;
		default:
			break;
	}

	if (random_target) {
		// RPG_RT doesn't support "Attack All" weapons when battler is confused or provoked.
		active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Normal>(active_actor, random_target));
		battle_actions.push_back(active_actor);

		SelectNextActor(auto_battle);
		return;
	}

	if (auto_battle || active_actor->GetAutoBattle()) {
		if (active_actor->GetActorAi() == -1) {
			this->autobattle_algos[default_autobattle_algo]->SetAutoBattleAction(*active_actor);
		} else {
			this->autobattle_algos[active_actor->GetActorAi()]->SetAutoBattleAction(*active_actor);
		}
		assert(active_actor->GetBattleAlgorithm() != nullptr);
		battle_actions.push_back(active_actor);

		SelectNextActor(auto_battle);
		return;
	}

	SetState(Scene_Battle::State_SelectCommand);
}

void Scene_Battle_Rpg2k::SelectPreviousActor() {
	std::vector<Game_Actor*> allies = Main_Data::game_party->GetActors();

	if (allies[0] == active_actor) {
		SetState(State_SelectOption);
		actor_index = 0;
		return;
	}

	actor_index--;
	active_actor = allies[actor_index];

	battle_actions.back()->SetBattleAlgorithm(nullptr);
	battle_actions.pop_back();

	if (!active_actor->IsControllable()) {
		SelectPreviousActor();
		return;
	}

	SetState(State_SelectActor);
}

void Scene_Battle_Rpg2k::CreateExecutionOrder() {
	// Define random Agility. Must be done outside of the sort function because of the "strict weak ordering" property, so the sort is consistent
	for (auto battler : battle_actions) {
		int battle_order = battler->GetAgi() + Rand::GetRandomNumber(0, battler->GetAgi() / 4 + 3);
		if (battler->GetBattleAlgorithm()->GetType() == Game_BattleAlgorithm::Type::Normal && battler->HasPreemptiveAttack()) {
			// RPG_RT sets this value
			battle_order += 9999;
		}
		battler->SetBattleOrderAgi(battle_order);
	}
	std::sort(battle_actions.begin(), battle_actions.end(),
			[](Game_Battler* l, Game_Battler* r) {
			return l->GetBattleOrderAgi() > r->GetBattleOrderAgi();
			});

	for (const auto& battler : battle_actions) {
		if (std::count(battle_actions.begin(), battle_actions.end(), battler) > 1) {
			Output::Warning("CreateExecutionOrder: Battler {} ({}) has multiple battle actions", battler->GetId(), battler->GetName());
			Output::Warning("Please report a bug!");
			break;
		}
	}
}

void Scene_Battle_Rpg2k::CreateEnemyActions() {
	if (first_strike) {
		return;
	}

	for (auto* enemy : Main_Data::game_enemyparty->GetEnemies()) {
		if (enemy->IsHidden()) {
			continue;
		}

		if (!EnemyAi::SetStateRestrictedAction(*enemy)) {
			if (enemy->GetEnemyAi() == -1) {
				enemyai_algos[default_enemyai_algo]->SetEnemyAiAction(*enemy);
			} else {
				enemyai_algos[enemy->GetEnemyAi()]->SetEnemyAiAction(*enemy);
			}
		}
		assert(enemy->GetBattleAlgorithm() != nullptr);
		ActionSelectedCallback(enemy);
	}
}

void Scene_Battle_Rpg2k::SubskillSelected2k3(int command) {
	auto idx = command - 1;
	// Resolving a subskill battle command to skill id
	int subskill = lcf::rpg::Skill::Type_subskill;

	// Loop through all battle commands smaller then that ID and count subsets
	for (int i = 0; i < static_cast<int>(lcf::Data::battlecommands.commands.size()); ++i) {
		auto& cmd = lcf::Data::battlecommands.commands[i];
		if (i >= idx) {
			break;
		}
		if (cmd.type == lcf::rpg::BattleCommand::Type_subskill) {
			++subskill;
		}
	}

	// skill subset is 4 (Type_subskill) + counted subsets
	skill_window->SetSubsetFilter(subskill);
	SetState(State_SelectSkill);
}

void Scene_Battle_Rpg2k::SpecialSelected2k3() {
	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));

	active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::DoNothing>(active_actor));

	ActionSelectedCallback(active_actor);
}

void Scene_Battle_Rpg2k::ActionSelectedCallback(Game_Battler* for_battler) {
	Scene_Battle::ActionSelectedCallback(for_battler);

	if (for_battler->GetType() == Game_Battler::Type_Ally) {
		SetState(State_SelectActor);
	}
}

void Scene_Battle_Rpg2k::SetWait(int min_wait, int max_wait) {
#if defined(EP_DEBUG_BATTLE2K_MESSAGE) || defined(EP_DEBUG_BATTLE2K_STATE_MACHINE)
	Output::Debug("Battle2k Wait({},{}) frame={}", min_wait, max_wait, Main_Data::game_system->GetFrameCounter());
#endif
	battle_action_wait = max_wait;
	battle_action_min_wait = max_wait - min_wait;
}

void Scene_Battle_Rpg2k::SetWaitForUsage(Game_BattleAlgorithm::Type type, int anim_frames) {
	int min_wait = 0;
	int max_wait = 0;
	switch (type) {
		case Game_BattleAlgorithm::Type::Normal:
			min_wait = 20;
			max_wait = 40;
			break;
		case Game_BattleAlgorithm::Type::Escape:
			min_wait = 36;
			max_wait = 60;
			break;
		case Game_BattleAlgorithm::Type::None:
		case Game_BattleAlgorithm::Type::DoNothing:
			min_wait = max_wait = 0;
			break;
		default:
			min_wait = 20;
			max_wait = 60;
			break;
	}
	SetWait(std::max(min_wait, anim_frames), std::max(max_wait, anim_frames));
}

bool Scene_Battle_Rpg2k::CheckWait() {
	if (battle_action_wait > 0) {
		if (Input::IsPressed(Input::CANCEL)) {
			return false;
		}
		--battle_action_wait;
		if (battle_action_wait > battle_action_min_wait) {
			return false;
		}
		if (!Input::IsPressed(Input::DECISION)
			&& !Input::IsPressed(Input::SHIFT)
			&& battle_action_wait > 0) {
			return false;
		}
		battle_action_wait = 0;
	}
	return true;
}

void Scene_Battle_Rpg2k::PushExperienceGainedMessage(PendingMessage& pm, int exp) {
	pm.PushLine(
		PartyMessage::GetExperienceGainedMessage(exp)
		+ Player::escape_symbol + ".");
}

void Scene_Battle_Rpg2k::PushGoldReceivedMessage(PendingMessage& pm, int money) {
	pm.PushLine(
		PartyMessage::GetGoldReceivedMessage(money)
		+ Player::escape_symbol + ".");

}

void Scene_Battle_Rpg2k::PushItemRecievedMessages(PendingMessage& pm, std::vector<int> drops) {
	for (std::vector<int>::iterator it = drops.begin(); it != drops.end(); ++it) {
		const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, *it);
		pm.PushLine(
			PartyMessage::GetItemReceivedMessage(item)
			+ Player::escape_symbol + ".");
	}
}

bool Scene_Battle_Rpg2k::CheckBattleEndConditions() {
	if (state == State_Defeat || Game_Battle::CheckLose()) {
		if (state != State_Defeat) {
			SetState(State_Defeat);
		}
		return true;
	}

	if (state == State_Victory || Game_Battle::CheckWin()) {
		if (state != State_Victory) {
			SetState(State_Victory);
		}
		return true;
	}

	return false;
}



/*end of file .\scene_battle_rpg2k.cpp*/

/*start of file .\scene_battle_rpg2k3.cpp*/

/* ... license chunk ... */

#include <cmath>
#include "scene_battle_rpg2k3.h"
#include <lcf/rpg/battlecommand.h>
#include <lcf/rpg/battleranimation.h>
#include <lcf/reader_util.h>
#include "drawable.h"
#include "input.h"
#include "output.h"
#include "player.h"
#include "sprite.h"
#include "sprite_enemy.h"
#include "sprite_actor.h"
#include "sprite_weapon.h"
#include "cache.h"
#include "game_actors.h"
#include "game_system.h"
#include "game_party.h"
#include "game_enemy.h"
#include "game_enemyparty.h"
#include "game_message.h"
#include "game_battle.h"
#include "game_interpreter_battle.h"
#include "game_battlealgorithm.h"
#include "game_screen.h"
#include <lcf/reader_util.h>
#include "scene_gameover.h"
#include "utils.h"
#include "font.h"
#include "output.h"
#include "autobattle.h"
#include "enemyai.h"
#include <algorithm>
#include <memory>
#include "feature.h"
#include "game_message_terms.h"

//#define EP_DEBUG_BATTLE2K3_STATE_MACHINE

Scene_Battle_Rpg2k3::Scene_Battle_Rpg2k3(const BattleArgs& args) :
	Scene_Battle(args),
	first_strike(args.first_strike)
{
}

void Scene_Battle_Rpg2k3::Start() {
	Scene_Battle::Start();
	Game_Interpreter_Battle::InitBattle();
	InitBattleCondition(Game_Battle::GetBattleCondition());
	CreateEnemySprites();
	CreateActorSprites();

	// We need to wait for actor and enemy graphics to load before we can finish initializing the battle.
	AsyncNext([this]() { Start2(); });
}

void Scene_Battle_Rpg2k3::Start2() {
	InitEnemies();
	InitActors();
	InitAtbGauges();

	// Changed enemy place means we need to recompute Z order
	ResetAllBattlerZ();
}

void Scene_Battle_Rpg2k3::InitBattleCondition(lcf::rpg::System::BattleCondition condition) {
	if (condition == lcf::rpg::System::BattleCondition_pincers
			&& (lcf::Data::battlecommands.placement == lcf::rpg::BattleCommands::Placement_manual
				|| Main_Data::game_enemyparty->GetVisibleBattlerCount() <= 1))
	{
		condition = lcf::rpg::System::BattleCondition_back;
	}

	if (condition == lcf::rpg::System::BattleCondition_surround
			&& (lcf::Data::battlecommands.placement == lcf::rpg::BattleCommands::Placement_manual
				|| Main_Data::game_party->GetVisibleBattlerCount() <= 1))
	{
		condition = lcf::rpg::System::BattleCondition_initiative;
	}

	Game_Battle::SetBattleCondition(condition);

	if (condition == lcf::rpg::System::BattleCondition_back || condition == lcf::rpg::System::BattleCondition_pincers) {
		first_strike = false;
	}
}

void Scene_Battle_Rpg2k3::InitEnemies() {
	const auto& enemies = Main_Data::game_enemyparty->GetEnemies();
	const auto cond = Game_Battle::GetBattleCondition();

	// PLACEMENT AND DIRECTION
	for (int real_idx = 0, visible_idx = 0; real_idx < static_cast<int>(enemies.size()); ++real_idx) {
		auto& enemy = *enemies[real_idx];
		const auto idx = enemy.IsHidden() ? real_idx : visible_idx;

		enemy.SetBattlePosition(Game_Battle::Calculate2k3BattlePosition(enemy));

		switch(cond) {
			case lcf::rpg::System::BattleCondition_none:
				enemy.SetDirectionFlipped(false);
				break;
			case lcf::rpg::System::BattleCondition_initiative:
			case lcf::rpg::System::BattleCondition_back:
			case lcf::rpg::System::BattleCondition_surround:
				enemy.SetDirectionFlipped(true);
				break;
			case lcf::rpg::System::BattleCondition_pincers:
				enemy.SetDirectionFlipped(!(idx & 1));
				break;
		}

		visible_idx += !enemy.IsHidden();
	}
}

void Scene_Battle_Rpg2k3::InitActors() {
	const auto& actors = Main_Data::game_party->GetActors();
	const auto cond = Game_Battle::GetBattleCondition();

	// ROW ADJUSTMENT
	// If all actors in the front row have battle loss conditions,
	// all back row actors forced to the front row.
	bool force_front_row = true;
	for (auto& actor: actors) {
		if (actor->GetBattleRow() == Game_Actor::RowType::RowType_front
				&& !actor->IsHidden()
				&& actor->CanActOrRecoverable()) {
			force_front_row = false;
		}
	}
	if (force_front_row) {
		for (auto& actor: actors) {
			actor->SetBattleRow(Game_Actor::RowType::RowType_front);
		}
	}

	// PLACEMENT AND DIRECTION
	for (int idx = 0; idx < static_cast<int>(actors.size()); ++idx) {
		auto& actor = *actors[idx];

		actor.SetBattlePosition(Game_Battle::Calculate2k3BattlePosition(actor));

		if (cond == lcf::rpg::System::BattleCondition_surround) {
			actor.SetDirectionFlipped(idx & 1);
		} else {
			actor.SetDirectionFlipped(false);
		}
	}
}

Scene_Battle_Rpg2k3::~Scene_Battle_Rpg2k3() {
}

void Scene_Battle_Rpg2k3::InitAtbGauge(Game_Battler& battler, int preempt_atb, int ambush_atb) {
	if (battler.IsHidden() || !battler.CanActOrRecoverable()) {
		return;
	}

	switch(Game_Battle::GetBattleCondition()) {
		case lcf::rpg::System::BattleCondition_initiative:
		case lcf::rpg::System::BattleCondition_surround:
			battler.SetAtbGauge(preempt_atb);
			break;
		case lcf::rpg::System::BattleCondition_back:
		case lcf::rpg::System::BattleCondition_pincers:
			battler.SetAtbGauge(ambush_atb);
			break;
		case lcf::rpg::System::BattleCondition_none:
			if (first_strike || battler.HasPreemptiveAttack()) {
				battler.SetAtbGauge(preempt_atb);
			} else {
				battler.SetAtbGauge(Game_Battler::GetMaxAtbGauge() / 2);
			}
			break;
	}
}

void Scene_Battle_Rpg2k3::InitAtbGauges() {
	for (auto& enemy: Main_Data::game_enemyparty->GetEnemies()) {
		InitAtbGauge(*enemy, 0, Game_Battler::GetMaxAtbGauge());
	}
	for (auto& actor: Main_Data::game_party->GetActors()) {
		InitAtbGauge(*actor, Game_Battler::GetMaxAtbGauge(), 0);
	}
}

template <typename O, typename M, typename C>
static bool CheckFlip(const O& others, const M& me, bool prefer_flipped, C&& cmp) {
	for (auto& other: others) {
			if (!other->IsHidden() && cmp(other->GetBattlePosition().x, me.GetBattlePosition().x)) {
				return prefer_flipped;
			}
		}
		return !prefer_flipped;
	}

void Scene_Battle_Rpg2k3::UpdateEnemiesDirection() {
	const auto& enemies = Main_Data::game_enemyparty->GetEnemies();
	const auto& actors = Main_Data::game_party->GetActors();

	for (int real_idx = 0, visible_idx = 0; real_idx < static_cast<int>(enemies.size()); ++real_idx) {
		auto& enemy = *enemies[real_idx];
		const auto idx = enemy.IsHidden() ? real_idx : visible_idx;

		switch(Game_Battle::GetBattleCondition()) {
			case lcf::rpg::System::BattleCondition_none:
			case lcf::rpg::System::BattleCondition_initiative:
				enemy.SetDirectionFlipped(CheckFlip(actors, enemy, false, std::greater_equal<>()));
				break;
			case lcf::rpg::System::BattleCondition_back:
				enemy.SetDirectionFlipped(CheckFlip(actors, enemy, true, std::less_equal<>()));
				break;
			case lcf::rpg::System::BattleCondition_surround:
			case lcf::rpg::System::BattleCondition_pincers:
				enemy.SetDirectionFlipped(!(idx & 1));
				break;
		}

		visible_idx += !enemy.IsHidden();
	}
}

void Scene_Battle_Rpg2k3::UpdateActorsDirection() {
	const auto& actors = Main_Data::game_party->GetActors();
	const auto& enemies = Main_Data::game_enemyparty->GetEnemies();

	for (int idx = 0; idx < static_cast<int>(actors.size()); ++idx) {
		auto& actor = *actors[idx];

		switch(Game_Battle::GetBattleCondition()) {
			case lcf::rpg::System::BattleCondition_none:
			case lcf::rpg::System::BattleCondition_initiative:
				actor.SetDirectionFlipped(CheckFlip(enemies, actor, false, std::less_equal<>()));
				break;
			case lcf::rpg::System::BattleCondition_back:
				actor.SetDirectionFlipped(CheckFlip(enemies, actor, true, std::greater_equal<>()));
				break;
			case lcf::rpg::System::BattleCondition_surround:
			case lcf::rpg::System::BattleCondition_pincers:
				actor.SetDirectionFlipped(idx & 1);
				break;
		}
	}
}

void Scene_Battle_Rpg2k3::FaceTarget(Game_Actor& source, const Game_Battler& target) {
	const auto sx = source.GetBattlePosition().x;
	const auto tx = target.GetBattlePosition().x;
	const bool flipped = source.IsDirectionFlipped();
	if ((flipped && tx < sx) || (!flipped && tx > sx)) {
		source.SetDirectionFlipped(1 - flipped);
	}
}

void Scene_Battle_Rpg2k3::OnSystem2Ready(FileRequestResult* result) {
	Cache::SetSystem2Name(result->file);

	SetupSystem2Graphics();
}

void Scene_Battle_Rpg2k3::SetupSystem2Graphics() {
	BitmapRef system2 = Cache::System2();
	if (!system2) {
		return;
	}

	ally_cursor->SetBitmap(system2);
	ally_cursor->SetZ(Priority_Window);
	ally_cursor->SetVisible(false);

	enemy_cursor->SetBitmap(system2);
	enemy_cursor->SetZ(Priority_Window);
	enemy_cursor->SetVisible(false);
}

void Scene_Battle_Rpg2k3::CreateUi() {
	Scene_Battle::CreateUi();

	CreateBattleTargetWindow();
	CreateBattleStatusWindow();
	CreateBattleCommandWindow();

	RecreateSpWindow(nullptr);

	ally_cursor.reset(new Sprite());
	enemy_cursor.reset(new Sprite());

	if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_gauge) {
		item_window->SetX(Player::menu_offset_x);
		item_window->SetY(Player::menu_offset_y + 64);
		skill_window->SetX(Player::menu_offset_x);
		skill_window->SetY(Player::menu_offset_y + 64);
	}

	if (lcf::Data::battlecommands.battle_type != lcf::rpg::BattleCommands::BattleType_traditional) {
		int transp = IsTransparent() ? 160 : 255;
		options_window->SetBackOpacity(transp);
		item_window->SetBackOpacity(transp);
		skill_window->SetBackOpacity(transp);
		help_window->SetBackOpacity(transp);
		status_window->SetBackOpacity(transp);
	}

	if (!Cache::System2() && Main_Data::game_system->HasSystem2Graphic()) {
		FileRequestAsync* request = AsyncHandler::RequestFile("System2", Main_Data::game_system->GetSystem2Name());
		request->SetGraphicFile(true);
		request_id = request->Bind(&Scene_Battle_Rpg2k3::OnSystem2Ready, this);
		request->Start();
	} else {
		SetupSystem2Graphics();
	}

	if (lcf::Data::battlecommands.window_size == lcf::rpg::BattleCommands::WindowSize_small) {
		int height = 68;
		int y = Player::screen_height - Player::menu_offset_y - height;

		auto small_window = [&](auto& window) {
			if (window) {
				window->SetHeight(height);
				window->SetY(y);
				window->SetBorderY(5);
				window->SetContents(Bitmap::Create(window->GetWidth() - window->GetBorderX() * 2, window->GetHeight() - window->GetBorderY() * 2));
				window->SetMenuItemHeight(14);
			}
		};

		small_window(options_window);
		small_window(command_window);
		small_window(skill_window);
		small_window(item_window);
		small_window(target_window);

		options_window->Refresh();
		status_window->SetY(y);

		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_gauge) {
			command_window->SetY(Player::screen_height / 2 - 80 / 2 + 12);
			item_window->SetY(76);
			skill_window->SetY(76);
		}
	}

	ResetWindows(true);
}

void Scene_Battle_Rpg2k3::CreateEnemySprites() {
	for (auto* enemy: Main_Data::game_enemyparty->GetEnemies()) {
		enemy->SetBattleSprite(std::make_unique<Sprite_Enemy>(enemy));
	}
}

void Scene_Battle_Rpg2k3::CreateActorSprites() {
	for (auto* actor: Main_Data::game_party->GetActors()) {
		actor->SetBattleSprite(std::make_unique<Sprite_Actor>(actor));
		actor->SetWeaponSprite(std::make_unique<Sprite_Weapon>(actor));
	}
}

void Scene_Battle_Rpg2k3::ResetAllBattlerZ() {
	for (auto* enemy: Main_Data::game_enemyparty->GetEnemies()) {
		auto* sprite = enemy->GetBattleSprite();
		if (sprite) {
			sprite->ResetZ();
		}
	}

	for (auto* actor: Main_Data::game_party->GetActors()) {
		auto* sprite = actor->GetActorBattleSprite();
		if (sprite) {
			sprite->ResetZ();
			sprite->UpdatePosition();
			sprite->DetectStateChange();
		}
	}
}

void Scene_Battle_Rpg2k3::UpdateAnimations() {
	for (auto it = floating_texts.begin(); it != floating_texts.end();) {
		int &time = it->remaining_time;

		if (time % 2 == 0) {
			int modifier = time <= 10 ? 1 :
						   time < 20 ? 0 :
						   -1;
			it->sprite->SetY(it->sprite->GetY() + modifier);
		}

		--time;
		if (time <= 0) {
			it = floating_texts.erase(it);
		} else {
			++it;
		}
	}

	if (running_away) {
		for (auto& actor: Main_Data::game_party->GetActors()) {
			Point p = actor->GetBattlePosition();
			if (actor->IsDirectionFlipped()) {
				p.x -= 6;
			} else {
				p.x += 6;
			}
			actor->SetBattlePosition(p);
		}
	}

	auto frame_counter = static_cast<uint32_t>(Main_Data::game_system->GetFrameCounter());

	bool ally_set = false;
	if (status_window->GetActive()
			&& lcf::Data::battlecommands.battle_type != lcf::rpg::BattleCommands::BattleType_traditional)
	{
		auto* actor = Main_Data::game_party->GetActor(status_window->GetIndex());
		if (actor) {
			const auto* sprite = actor->GetBattleSprite();
			if (sprite) {
				static const int frames[] = { 0, 1, 2, 1 };
				int sprite_frame = frames[(frame_counter / 15) % 4];
				ally_cursor->SetSrcRect(Rect(sprite_frame * 16, 16, 16, 16));

				ally_cursor->SetVisible(true);
				ally_cursor->SetX(Player::menu_offset_x + actor->GetBattlePosition().x);
				ally_cursor->SetY(Player::menu_offset_y + actor->GetBattlePosition().y - 40);

				if (frame_counter % 30 == 0) {
					SelectionFlash(actor);
				}
				ally_set = true;
			}
		}
	}
	if (!ally_set) {
		ally_cursor->SetVisible(false);
	}

	bool enemy_set = false;
	if (target_window->GetActive()) {
		std::vector<Game_Battler*> battlers;
		Main_Data::game_enemyparty->GetActiveBattlers(battlers);
		auto idx = target_window->GetIndex();
		if (idx >= 0) {
			auto* enemy = battlers[idx];
			if (enemy) {
				const auto* sprite = enemy->GetBattleSprite();
				if (sprite) {
					static const int frames[] = { 0, 1, 2, 1 };
					int sprite_frame = frames[(frame_counter / 15) % 4];
					enemy_cursor->SetSrcRect(Rect(sprite_frame * 16, 0, 16, 16));

					enemy_cursor->SetVisible(true);
					enemy_cursor->SetX(Player::menu_offset_x + enemy->GetBattlePosition().x + sprite->GetWidth() / 2);
					enemy_cursor->SetY(Player::menu_offset_y + enemy->GetBattlePosition().y);

					std::vector<lcf::rpg::State*> ordered_states = enemy->GetInflictedStatesOrderedByPriority();
					if (ordered_states.size() > 0) {
						help_window->Clear();
						int state_counter = 0;
						for (lcf::rpg::State* state : ordered_states) {
							std::string state_name = fmt::format("{:9s}", state->name);
							help_window->AddText(state_name, state->color, Text::AlignLeft, false);
							if (++state_counter >= 5) break;
						}
						help_window->SetVisible(true);
					} else {
						help_window->SetVisible(false);
					}

					if (sprite_frame % 30 == 0) {
						SelectionFlash(enemy);
					}
					enemy_set = true;
				}
			}
		}
		if (!enemy_set) {
			help_window->Clear();
		}
	}

	if (!enemy_set) {
		enemy_cursor->SetVisible(false);
	}
}

void Scene_Battle_Rpg2k3::DrawFloatText(int x, int y, int color, std::string_view text, Game_Battler* battler, FloatTextType type) {
	std::stringstream ss(ToString(text));
	int value = 0;
	ss >> value;
	bool should_override = Game_Battle::ManiacBattleHook(
		Game_Interpreter_Battle::ManiacBattleHookType::DamagePop,
		battler->GetType() == Game_Battler::Type_Enemy,
		battler->GetPartyIndex(),
		x,
		y,
		static_cast<int>(type),
		value
	);

	if (should_override) {
		return;
	}

	Rect rect = Text::GetSize(*Font::Default(), text);

	BitmapRef graphic = Bitmap::Create(rect.width, rect.height);
	graphic->Clear();
	graphic->TextDraw(-rect.x, -rect.y, color, text);

	std::shared_ptr<Sprite> floating_text = std::make_shared<Sprite>();
	floating_text->SetBitmap(graphic);
	floating_text->SetOx(rect.width / 2);
	floating_text->SetOy(rect.height + 5);
	floating_text->SetX(Player::menu_offset_x + x);
	// Move 5 pixel down because the number "jumps" with the intended y as the peak
	floating_text->SetY(Player::menu_offset_y + y + 5);
	floating_text->SetZ(Priority_Window + y);

	FloatText float_text;
	float_text.sprite = floating_text;

	floating_texts.push_back(float_text);
}

bool Scene_Battle_Rpg2k3::IsTransparent() const {
	return lcf::Data::battlecommands.transparency == lcf::rpg::BattleCommands::Transparency_transparent;
}

static std::vector<std::string> GetEnemyTargetNames() {
	std::vector<std::string> commands;

	std::vector<Game_Battler*> enemies;
	Main_Data::game_enemyparty->GetActiveBattlers(enemies);

	for (auto& enemy: enemies) {
		commands.push_back(ToString(enemy->GetName()));
	}

	return commands;
}

void Scene_Battle_Rpg2k3::CreateBattleTargetWindow() {
	auto commands = GetEnemyTargetNames();

	int width = (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_traditional) ? 104 : 136;
	int height = 80;

	target_window.reset(new Window_Command(std::move(commands), width, 4));
	target_window->SetHeight(height);
	target_window->SetX(Player::menu_offset_x);
	target_window->SetY(Player::screen_height - Player::menu_offset_y - height);
	// Above other windows
	target_window->SetZ(Priority_Window + 10);

	if (lcf::Data::battlecommands.battle_type != lcf::rpg::BattleCommands::BattleType_traditional) {
		int transp = IsTransparent() ? 160 : 255;
		target_window->SetBackOpacity(transp);
	}

	target_window->SetSingleColumnWrapping(true);
}

void Scene_Battle_Rpg2k3::RefreshTargetWindow() {
	// FIXME: Handle live refresh in traditional when the window is always visible
	auto commands = GetEnemyTargetNames();
	target_window->ReplaceCommands(std::move(commands));
	if (!target_window->GetActive()) {
		target_window->SetIndex(-1);
	}
}

void Scene_Battle_Rpg2k3::CreateBattleStatusWindow() {
	int w = MENU_WIDTH;
	int h = 80;
	int x = Player::menu_offset_x;
	int y = Player::screen_height - Player::menu_offset_y - h;

	switch (lcf::Data::battlecommands.battle_type) {
		case lcf::rpg::BattleCommands::BattleType_traditional:
			x = Player::menu_offset_x + target_window->GetWidth();
			w = MENU_WIDTH - target_window->GetWidth();
			break;
		case lcf::rpg::BattleCommands::BattleType_alternative:
			x = Player::menu_offset_x + options_window->GetWidth();
			w = MENU_WIDTH - options_window->GetWidth();
			break;
		case lcf::rpg::BattleCommands::BattleType_gauge:
			x = Player::menu_offset_x + options_window->GetWidth();
			// Default window too small for 4 actors
			w = MENU_WIDTH;
			break;
	}

	status_window.reset(new Window_BattleStatus(x, y, w, h));
	status_window->SetZ(Priority_Window + 1);
}

std::vector<std::string> Scene_Battle_Rpg2k3::GetBattleCommandNames(const Game_Actor* actor) {
	std::vector<std::string> commands;
	if (actor) {
		for (auto* cmd: actor->GetBattleCommands()) {
			commands.push_back(ToString(cmd->name));
		}
	}
	if (Feature::HasRow() && lcf::Data::battlecommands.easyrpg_enable_battle_row_command) {
		commands.push_back(ToString(lcf::Data::terms.row));
	}

	return commands;
}

void Scene_Battle_Rpg2k3::SetBattleCommandsDisable(Window_Command& window, const Game_Actor* actor) {
	if (actor) {
		const auto& cmds = actor->GetBattleCommands();
		for (size_t i = 0; i < cmds.size(); ++i) {
			auto* cmd = cmds[i];
			if (cmd->type == lcf::rpg::BattleCommand::Type_escape && !IsEscapeAllowedFromActorCommand()) {
				window.DisableItem(i);
			} else {
				window.EnableItem(i);
			}
		}
	}
}

void Scene_Battle_Rpg2k3::CreateBattleCommandWindow() {
	auto* actor = Main_Data::game_party->GetActor(0);
	auto commands = GetBattleCommandNames(actor);

	command_window.reset(new Window_Command(std::move(commands), option_command_mov));

	SetBattleCommandsDisable(*command_window, actor);

	int height = 80;

	command_window->SetHeight(height);
	switch (lcf::Data::battlecommands.battle_type) {
		case lcf::rpg::BattleCommands::BattleType_traditional:
			command_window->SetX(Player::menu_offset_x + target_window->GetWidth() - command_window->GetWidth());
			command_window->SetY(Player::screen_height - Player::menu_offset_y - height);
			break;
		case lcf::rpg::BattleCommands::BattleType_alternative:
			command_window->SetX(Player::menu_offset_x + MENU_WIDTH);
			command_window->SetY(Player::screen_height - Player::menu_offset_y - height);
			break;
		case lcf::rpg::BattleCommands::BattleType_gauge:
			command_window->SetX(Player::menu_offset_x);
			command_window->SetY(Player::screen_height / 2 - height / 2);
			break;
	}
	// Above the target window
	command_window->SetZ(Priority_Window + 20);

	if (lcf::Data::battlecommands.battle_type != lcf::rpg::BattleCommands::BattleType_traditional) {
		int transp = IsTransparent() ? 160 : 255;
		command_window->SetBackOpacity(transp);
	}
}

void Scene_Battle_Rpg2k3::RefreshCommandWindow(const Game_Actor* actor) {
	auto commands = GetBattleCommandNames(actor);
	command_window->ReplaceCommands(std::move(commands));
	SetBattleCommandsDisable(*command_window, actor);
	command_window->SetIndex(-1);
}

void Scene_Battle_Rpg2k3::SetActiveActor(int idx) {
#ifdef EP_DEBUG_BATTLE2K3_STATE_MACHINE
	Output::Debug("Battle2k3 SetActiveActor({}) frame={}", idx, Main_Data::game_system->GetFrameCounter());
#endif
	status_window->SetIndex(idx);
	active_actor = Main_Data::game_party->GetActor(idx);
	auto* display_actor = active_actor ? active_actor : Main_Data::game_party->GetActor(0);
	RefreshCommandWindow(display_actor);
}

void Scene_Battle_Rpg2k3::ResetWindows(bool make_invisible) {
	item_window->SetHelpWindow(nullptr);
	skill_window->SetHelpWindow(nullptr);

	options_window->SetActive(false);
	status_window->SetActive(false);
	command_window->SetActive(false);
	item_window->SetActive(false);
	skill_window->SetActive(false);
	target_window->SetActive(false);
	sp_window->SetActive(false);

	if (!make_invisible) {
		return;
	}

	options_window->SetVisible(false);
	status_window->SetVisible(false);
	command_window->SetVisible(false);
	target_window->SetVisible(false);
	item_window->SetVisible(false);
	skill_window->SetVisible(false);
	help_window->SetVisible(false);
	sp_window->SetVisible(false);
}

void Scene_Battle_Rpg2k3::MoveCommandWindows(int x, int frames) {
	if (lcf::Data::battlecommands.battle_type != lcf::rpg::BattleCommands::BattleType_traditional) {
		options_window->InitMovement(options_window->GetX(), options_window->GetY(),
				x, options_window->GetY(), frames);

		x += options_window->GetWidth();

		status_window->InitMovement(status_window->GetX(), status_window->GetY(),
				x, status_window->GetY(), frames);

		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_alternative) {
			x += status_window->GetWidth();
			command_window->InitMovement(command_window->GetX(), command_window->GetY(),
					x, command_window->GetY(), frames);
		}
	}
}

void Scene_Battle_Rpg2k3::SetState(Scene_Battle::State new_state) {
	previous_state = state;
	state = new_state;

	if (new_state == State_SelectActor) {
		auto_battle = false;
	}
	if (new_state == State_AutoBattle) {
		auto_battle = true;
	}

	SetSceneActionSubState(0);

#ifdef EP_DEBUG_BATTLE2K3_STATE_MACHINE
	Output::Debug("Battle2k3 SetState state={} prev={} auto_battle={}", state, previous_state, auto_battle);
#endif
}

void Scene_Battle_Rpg2k3::ReturnToMainBattleState() {
	SetState(auto_battle ? State_AutoBattle : State_SelectActor);
}

void Scene_Battle_Rpg2k3::SetSceneActionSubState(int substate) {
	scene_action_substate = substate;
}

static bool BattlerReadyToAct(const Game_Battler* battler) {
	return battler->IsAtbGaugeFull() && battler->Exists() && battler->CanAct();
}

void Scene_Battle_Rpg2k3::UpdateReadyActors() {
	const auto& actors = Main_Data::game_party->GetActors();
	for (auto actor: actors) {
		auto position = std::find(atb_order.begin(), atb_order.end(), actor->GetId());
		if (BattlerReadyToAct(actor)) {
			if (position == atb_order.end()) {
#ifdef EP_DEBUG_BATTLE2K3_STATE_MACHINE
				Output::Debug("Battle2k3 UpdateReadyActors add={} frame={}", actor->GetId(), Main_Data::game_system->GetFrameCounter());
#endif
				atb_order.push_back(actor->GetId());
			}
		} else {
			if (position != atb_order.end()) {
#ifdef EP_DEBUG_BATTLE2K3_STATE_MACHINE
				Output::Debug("Battle2k3 UpdateReadyActors remove={} frame={}", actor->GetId(), Main_Data::game_system->GetFrameCounter());
#endif
				atb_order.erase(position);
			}
		}
	}
}

int Scene_Battle_Rpg2k3::GetNextReadyActor() {
	if (!atb_order.empty()) {
#ifdef EP_DEBUG_BATTLE2K3_STATE_MACHINE
		Output::Debug("Battle2k3 GetNextReadyActor actor={} frame={}", atb_order.front(), Main_Data::game_system->GetFrameCounter());
#endif
		return Main_Data::game_party->GetActorPositionInParty(atb_order.front());
	}
#ifdef EP_DEBUG_BATTLE2K3_STATE_MACHINE
	Output::Debug("Battle2k3 GetNextReadyActor (none) frame={}", Main_Data::game_system->GetFrameCounter());
#endif
	return -1;
}


bool Scene_Battle_Rpg2k3::IsAtbAccumulating() const {
	if (Game_Battle::IsBattleAnimationWaiting()) {
		return false;
	}

	const bool active_atb = Main_Data::game_system->GetAtbMode() == lcf::rpg::SaveSystem::AtbMode_atb_active;

	switch(state) {
		case State_SelectEnemyTarget:
		case State_SelectAllyTarget:
		case State_SelectItem:
		case State_SelectSkill:
		case State_SelectCommand:
			return active_atb;
		case State_AutoBattle:
		case State_SelectActor:
			return true;
		default:
			break;
	}
	return false;
}

void Scene_Battle_Rpg2k3::CreateEnemyActions() {
	// FIXME: RPG_RT checks animations and event ready flag?
	for (auto* enemy: Main_Data::game_enemyparty->GetEnemies()) {
		if (enemy->IsAtbGaugeFull() && !enemy->GetBattleAlgorithm()) {
			if (!EnemyAi::SetStateRestrictedAction(*enemy)) {
				if (enemy->GetEnemyAi() == -1) {
					enemyai_algos[default_enemyai_algo]->SetEnemyAiAction(*enemy);
				} else {
					enemyai_algos[enemy->GetEnemyAi()]->SetEnemyAiAction(*enemy);
				}
			}
			assert(enemy->GetBattleAlgorithm() != nullptr);
			ActionSelectedCallback(enemy);
#ifdef EP_DEBUG_BATTLE2K3_STATE_MACHINE
			Output::Debug("Battle2k3 ScheduleEnemyAction name={} type={} frame={}", enemy->GetName(), static_cast<int>(enemy->GetBattleAlgorithm()->GetType()), Main_Data::game_system->GetFrameCounter());
#endif
		}
	}
}

void Scene_Battle_Rpg2k3::CreateActorAutoActions() {
	if (state != State_SelectActor
			&& state != State_AutoBattle
			&& state != State_Battle
			) {
		return;
	}

	// FIXME: RPG_RT checks only actor animations?
	for (auto* actor: Main_Data::game_party->GetActors()) {
		if (!BattlerReadyToAct(actor)
				|| actor->GetBattleAlgorithm()
				|| (actor->IsControllable() && state != State_AutoBattle)
				) {
			continue;
		}

		Game_Battler* random_target = nullptr;
		switch (actor->GetSignificantRestriction()) {
			case lcf::rpg::State::Restriction_attack_ally:
				random_target = Main_Data::game_party->GetRandomActiveBattler();
				break;
			case lcf::rpg::State::Restriction_attack_enemy:
				random_target = Main_Data::game_enemyparty->GetRandomActiveBattler();
				break;
			default:
				break;
		}
		if (random_target) {
			actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Normal>(actor, random_target));
		} else {
			if (actor->GetActorAi() == -1) {
				this->autobattle_algos[default_autobattle_algo]->SetAutoBattleAction(*actor);
			} else {
				this->autobattle_algos[actor->GetActorAi()]->SetAutoBattleAction(*actor);
			}
			assert(actor->GetBattleAlgorithm() != nullptr);
		}

		actor->SetLastBattleAction(-1);
		ActionSelectedCallback(actor);
	}
}

bool Scene_Battle_Rpg2k3::UpdateAtb() {
	if (Game_Battle::GetInterpreter().IsRunning() || Game_Message::IsMessageActive()) {
		return true;
	}
	if (IsAtbAccumulating()) {
		// FIXME: If one monster can act now, he gets his battle algo set, and we abort updating atb for other monsters
		Game_Battle::UpdateAtbGauges();
	}

	CreateEnemyActions();
	CreateActorAutoActions();

	return true;
}

bool Scene_Battle_Rpg2k3::IsBattleActionPending() const {
	return !battle_actions.empty();
}

bool Scene_Battle_Rpg2k3::UpdateBattleState() {
	if (resume_from_debug_scene) {
		resume_from_debug_scene = false;
		return true;
	}

	UpdateScreen();
	// FIXME: RPG_RT updates actors first, and this goes into doing CBA actor battle actions initiated last frame
	UpdateBattlers();

	UpdateUi();

	const auto battle_ending = (state == State_Victory || state == State_Defeat);

	if (!battle_ending) {
		// FIXME: Interpreter also blocked by an RPG_RT continueBattle flag. What is this flag?
		if (!Game_Battle::IsBattleAnimationWaiting()) {
			if (!UpdateEvents()) {
				return false;
			}
		}
	}

	// FIXME: Update Panorama

	if (!battle_ending) {
		if (!UpdateTimers()) {
			return false;
		}

		if (Input::IsTriggered(Input::DEBUG_MENU)) {
			if (this->CallDebug()) {
				// Set this flag so that when we return and run update again, we resume exactly from after this point.
				resume_from_debug_scene = true;
				return false;
			}
		}

		CheckBattleEndConditions();
		UpdateAtb();
	}
	return true;
}

void Scene_Battle_Rpg2k3::vUpdate() {
	const auto process_scene = UpdateBattleState();

	while (process_scene) {
		// Something ended the battle.
		if (Scene::instance.get() != this) {
			break;
		}

		if (IsWindowMoving()) {
			break;
		}

		if (Game_Message::IsMessageActive()) {
			break;
		}

		if (state != State_Victory && state != State_Defeat && Game_Battle::GetInterpreter().IsRunning()) {
			break;
		}

		// this is checked separately because we want normal events to be processed
		// just not sub-events called by maniacs battle hooks.
		if (state != State_Victory && state != State_Defeat && Game_Battle::ManiacProcessSubEvents()) {
			break;
		}

		if (!CheckWait()) {
			break;
		}

		if (ProcessSceneAction() == SceneActionReturn::eWaitTillNextFrame) {
			break;
		}
	}

	UpdateAnimations();
	UpdateGraphics();
}

void Scene_Battle_Rpg2k3::NextTurn(Game_Battler* battler) {
	Main_Data::game_party->IncTurns();
	battler->NextBattleTurn();
	Game_Battle::GetInterpreterBattle().ResetPagesExecuted();
}

bool Scene_Battle_Rpg2k3::CheckBattleEndConditions() {
	if (state == State_Defeat || Game_Battle::CheckLose()) {
		if (state != State_Defeat) {
			SetState(State_Defeat);
		}
		return true;
	}

	if (state == State_Victory || Game_Battle::CheckWin()) {
		if (state != State_Victory) {
			SetState(State_Victory);
		}
		return true;
	}

	return false;
}


bool Scene_Battle_Rpg2k3::CheckBattleEndAndScheduleEvents(EventTriggerType tt, Game_Battler* source) {
	auto& interp = Game_Battle::GetInterpreterBattle();

	if (interp.IsRunning()) {
		return false;
	}

	if (tt == EventTriggerType::eAfterBattleAction
			&& (Game_Message::IsMessageActive() || interp.IsWaitingForWaitCommand())) {
		return true;
	}

	if (CheckBattleEndConditions()) {
		return false;
	}

	lcf::rpg::TroopPageCondition::Flags flags;
	switch (tt) {
		case EventTriggerType::eBeforeBattleAction:
			flags.turn = flags.turn_actor = flags.turn_enemy = flags.command_actor = true;
			break;
		case EventTriggerType::eAfterBattleAction:
			flags.switch_a = flags.switch_b = flags.variable = flags.fatigue = flags.enemy_hp = flags.actor_hp = true;
			break;
		case EventTriggerType::eAll:
			for (auto& ff: flags.flags) ff = true;
			break;
	}

	int page = interp.ScheduleNextPage(flags, source);
#ifdef EP_DEBUG_BATTLE2K3_STATE_MACHINE
	if (page) {
		Output::Debug("Battle2k3 ScheduleNextEventPage Scheduled Page {} frame={}", page, Main_Data::game_system->GetFrameCounter());
	} else {
		Output::Debug("Battle2k3 ScheduleNextEventPage No Events to Run frame={}", Main_Data::game_system->GetFrameCounter());
	}
#else
	(void)page;
#endif
	RefreshTargetWindow();

	return !interp.IsRunning();
}

Scene_Battle_Rpg2k3::SceneActionReturn Scene_Battle_Rpg2k3::ProcessSceneAction() {
#ifdef EP_DEBUG_BATTLE2K3_STATE_MACHINE
	static int last_state = -1;
	static int last_substate = -1;
	if (state != last_state || scene_action_substate != last_substate) {
		int actor_id = active_actor ? active_actor->GetId() : 0;
		std::string_view actor_name = active_actor ? std::string_view(active_actor->GetName()) : "Null";
		Output::Debug("Battle2k3 ProcessSceneAction({}, {}) actor={}({}) frames={} auto_battle={}", state, scene_action_substate, actor_name, actor_id, Main_Data::game_system->GetFrameCounter(), auto_battle);
		last_state = state;
		last_substate = scene_action_substate;
	}
#endif

	// If actor was killed or event removed from the party, immediately cancel out of menu states
	if (active_actor && !active_actor->Exists()) {
		status_window->Refresh();
		SetActiveActor(-1);
		if (state != State_Battle) {
			ReturnToMainBattleState();
		}
	}

	switch (state) {
		case State_Start:
			return ProcessSceneActionStart();
		case State_SelectOption:
			return ProcessSceneActionFightAutoEscape();
		case State_SelectActor:
			return ProcessSceneActionActor();
		case State_AutoBattle:
			return ProcessSceneActionAutoBattle();
		case State_SelectCommand:
			return ProcessSceneActionCommand();
		case State_SelectItem:
			return ProcessSceneActionItem();
		case State_SelectSkill:
			return ProcessSceneActionSkill();
		case State_SelectEnemyTarget:
			return ProcessSceneActionEnemyTarget();
		case State_SelectAllyTarget:
			return ProcessSceneActionAllyTarget();
		case State_Battle:
			return ProcessSceneActionBattle();
		case State_Victory:
			return ProcessSceneActionVictory();
		case State_Defeat:
			return ProcessSceneActionDefeat();
		case State_Escape:
			return ProcessSceneActionEscape();
	}
	assert(false && "Invalid SceneActionState!");
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k3::SceneActionReturn Scene_Battle_Rpg2k3::ProcessSceneActionStart() {
	enum SubState {
		eStartMessage,
		eSpecialMessage,
		eUpdateBattlers,
		eUpdateEvents,
	};

	if (scene_action_substate == eStartMessage) {
		ResetWindows(true);

		if (!lcf::Data::terms.battle_start.empty()) {
			ShowNotification(ToString(lcf::Data::terms.battle_start));
			SetWait(10, 80);
		}
		SetSceneActionSubState(eSpecialMessage);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eSpecialMessage) {
		EndNotification();
		const auto cond = Game_Battle::GetBattleCondition();
		if ((!lcf::Data::terms.special_combat.empty() || !lcf::Data::terms.easyrpg_battle2k3_special_combat_back.empty()) && (cond != lcf::rpg::System::BattleCondition_none || first_strike)) {
			if (!lcf::Data::terms.special_combat.empty() && (cond == lcf::rpg::System::BattleCondition_initiative || cond == lcf::rpg::System::BattleCondition_surround || (cond == lcf::rpg::System::BattleCondition_none && first_strike))) {
				ShowNotification(ToString(lcf::Data::terms.special_combat));
			}
			if (!lcf::Data::terms.easyrpg_battle2k3_special_combat_back.empty() && (cond == lcf::rpg::System::BattleCondition_back || cond == lcf::rpg::System::BattleCondition_pincers)) {
				ShowNotification(ToString(lcf::Data::terms.easyrpg_battle2k3_special_combat_back));
			}
			SetWait(30, 70);
		}
		SetSceneActionSubState(eUpdateBattlers);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eUpdateBattlers) {
		EndNotification();
		UpdateEnemiesDirection();
		UpdateActorsDirection();
		SetSceneActionSubState(eUpdateEvents);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eUpdateEvents) {
		if (!CheckBattleEndAndScheduleEvents(EventTriggerType::eAll, nullptr)) {
			return SceneActionReturn::eContinueThisFrame;
		}

		SetState(State_SelectOption);
		return SceneActionReturn::eContinueThisFrame;
	}

	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k3::SceneActionReturn Scene_Battle_Rpg2k3::ProcessSceneActionFightAutoEscape() {
	enum SubState {
		eBegin,
		eWaitInput,
		ePreActor,
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(true);
		target_window->SetIndex(-1);

		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_traditional
				|| ((std::find(battle_options.begin(), battle_options.end(), AutoBattle) == battle_options.end()) && (std::find(battle_options.begin(), battle_options.end(), Win) == battle_options.end()) && (std::find(battle_options.begin(), battle_options.end(), Lose) == battle_options.end()) && !IsEscapeAllowedFromOptionWindow())) {
			if (lcf::Data::battlecommands.battle_type != lcf::rpg::BattleCommands::BattleType_traditional) MoveCommandWindows(Player::menu_offset_x - options_window->GetWidth(), 1);
			SetState(State_SelectActor);
			return SceneActionReturn::eContinueThisFrame;
		} else if (battle_options.size() == 1 && (std::find(battle_options.begin(), battle_options.end(), AutoBattle) != battle_options.end())) {
			if (lcf::Data::battlecommands.battle_type != lcf::rpg::BattleCommands::BattleType_traditional) MoveCommandWindows(Player::menu_offset_x - options_window->GetWidth(), 1);
			SetState(State_AutoBattle);
			return SceneActionReturn::eContinueThisFrame;
		}

		options_window->SetActive(true);

		auto it = std::find(battle_options.begin(), battle_options.end(), Escape);
		if (IsEscapeAllowedFromOptionWindow()) {
			if (it != battle_options.end()) {
				options_window->EnableItem(std::distance(battle_options.begin(), it));
			}
		} else {
			if (it != battle_options.end()) {
				options_window->DisableItem(std::distance(battle_options.begin(), it));
			}
		}

		options_window->SetVisible(true);
		status_window->SetVisible(true);
		if (lcf::Data::battlecommands.battle_type != lcf::rpg::BattleCommands::BattleType_gauge) {
			command_window->SetVisible(true);
		}
		SetActiveActor(-1);
		RefreshCommandWindow(Main_Data::game_party->GetActor(0));
		status_window->Refresh();
		command_window->SetIndex(-1);

		if (previous_state != State_Start) {
			MoveCommandWindows(Player::menu_offset_x, 8);
		}

		SetSceneActionSubState(eWaitInput);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eWaitInput) {
		if (Input::IsTriggered(Input::DECISION)) {
			if (message_window->IsVisible()) {
				return SceneActionReturn::eWaitTillNextFrame;
			}
			switch (battle_options[options_window->GetIndex()]) {
				case Battle: // Battle
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
					MoveCommandWindows(Player::menu_offset_x - options_window->GetWidth(), 8);
					SetState(State_SelectActor);
					break;
				case AutoBattle: // Auto Battle
					MoveCommandWindows(Player::menu_offset_x - options_window->GetWidth(), 8);
					SetState(State_AutoBattle);
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
					break;
				case Escape: // Escape
					if (IsEscapeAllowedFromOptionWindow()) {
						Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
						SetState(State_Escape);
					} else {
						Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
					}
					break;
				case Win: // Win
					for (Game_Enemy* enemy : Main_Data::game_enemyparty->GetEnemies()) {
						enemy->Kill();
					}
					SetState(State_Victory);
					break;
				case Lose: // Lose
					SetState(State_Defeat);
					break;
			}
		}
		return SceneActionReturn::eWaitTillNextFrame;
	}

	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k3::SceneActionReturn Scene_Battle_Rpg2k3::ProcessSceneActionActor() {
	enum SubState {
		eBegin,
		eWaitInput,
		eWaitActor,
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(true);
		target_window->SetIndex(-1);

		status_window->SetVisible(true);
		command_window->SetIndex(-1);

		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_traditional) {
			status_window->SetChoiceMode(Window_BattleStatus::ChoiceMode_None);
			target_window->SetVisible(true);

			SetSceneActionSubState(eWaitActor);
			return SceneActionReturn::eContinueThisFrame;
		}

		status_window->SetChoiceMode(Window_BattleStatus::ChoiceMode_Ready);

		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_alternative) {
			command_window->SetVisible(true);
		}

		if (lcf::Data::battlecommands.easyrpg_sequential_order) {
			SetSceneActionSubState(eWaitActor);
			return SceneActionReturn::eContinueThisFrame;
		}

		SetSceneActionSubState(eWaitInput);
	}

	if (scene_action_substate == eWaitInput) {
		UpdateReadyActors();

		auto* selected_actor = Main_Data::game_party->GetActor(status_window->GetIndex());
		if (selected_actor == nullptr || !BattlerReadyToAct(selected_actor)) {
			// If current selection is no longer valid, force a new selection
			const auto idx = GetNextReadyActor();
			if (idx != status_window->GetIndex()) {
				SetActiveActor(idx);
			}
		} else if (selected_actor != active_actor) {
			// If selection changed due to player input
			SetActiveActor(status_window->GetIndex());
		}
		status_window->SetActive(active_actor != nullptr);

		if (lcf::Data::battlecommands.battle_type != lcf::rpg::BattleCommands::BattleType_alternative) {
			command_window->SetVisible(status_window->GetActive());
		}
	}

	if (scene_action_substate == eWaitActor) {
		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_traditional) {
			UpdateReadyActors();
			SetActiveActor(GetNextReadyActor());
		}
	}

	// If any battler is waiting to attack, immediately interrupt and do the attack.
	if (IsBattleActionPending()) {
		SetState(State_Battle);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eWaitInput) {
		if (Input::IsTriggered(Input::CANCEL)) {
			SetActiveActor(-1);
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
			SetState(State_SelectOption);
			return SceneActionReturn::eWaitTillNextFrame;
		}

		if (status_window->GetActive() && status_window->GetIndex() >= 0) {
			if (Input::IsTriggered(Input::DECISION)) {
				command_window->SetIndex(0);
				SetState(State_SelectCommand);
				return SceneActionReturn::eWaitTillNextFrame;
			}
		}

		return SceneActionReturn::eWaitTillNextFrame;
	}

	if (scene_action_substate == eWaitActor) {
		const auto idx = GetNextReadyActor();
		SetActiveActor(idx);
		if (idx >= 0) {
			command_window->SetIndex(0);
			SetState(State_SelectCommand);
			return SceneActionReturn::eWaitTillNextFrame;
		}

		if (lcf::Data::battlecommands.battle_type != lcf::rpg::BattleCommands::BattleType_traditional) {
			if (Input::IsTriggered(Input::CANCEL)) {
				SetActiveActor(-1);
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
				SetState(State_SelectOption);
				return SceneActionReturn::eWaitTillNextFrame;
			}
		}

		return SceneActionReturn::eWaitTillNextFrame;
	}

	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k3::SceneActionReturn Scene_Battle_Rpg2k3::ProcessSceneActionAutoBattle() {
	enum SubState {
		eBegin,
		eWaitInput,
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(true);
		target_window->SetIndex(-1);

		status_window->SetVisible(true);
		command_window->SetIndex(-1);
		status_window->SetChoiceMode(Window_BattleStatus::ChoiceMode_None);
		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_alternative) {
			command_window->SetVisible(true);
		}
		SetActiveActor(-1);

		SetSceneActionSubState(eWaitInput);
	}

	// If any battler is waiting to attack, immediately interrupt and do the attack.
	if (IsBattleActionPending()) {
		SetState(State_Battle);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eWaitInput) {
		if (Input::IsTriggered(Input::CANCEL)) {
			SetActiveActor(-1);
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
			SetState(State_SelectOption);
			return SceneActionReturn::eWaitTillNextFrame;
		}
		return SceneActionReturn::eWaitTillNextFrame;
	}

	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k3::SceneActionReturn Scene_Battle_Rpg2k3::ProcessSceneActionCommand() {
	assert(active_actor != nullptr);
	enum SubState {
		eBegin,
		eWaitInput,
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(true);
		target_window->SetIndex(-1);

		status_window->SetVisible(true);
		command_window->SetVisible(true);
		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_traditional) {
			target_window->SetVisible(true);
		}
		command_window->SetActive(true);

		SetSceneActionSubState(eWaitInput);
	}

	// If any battler is waiting to attack, immediately interrupt and do the attack.
	if (Main_Data::game_system->GetAtbMode() == lcf::rpg::SaveSystem::AtbMode_atb_active && IsBattleActionPending()) {
		SetState(State_Battle);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eWaitInput) {
		if (Input::IsTriggered(Input::DECISION)) {
			int index = command_window->GetIndex();
			// Row command always uses the last index
			if (!Feature::HasRow() || !lcf::Data::battlecommands.easyrpg_enable_battle_row_command || index < command_window->GetRowMax() - 1) {
				const auto* command = active_actor->GetBattleCommand(index);

				if (command) {
					active_actor->SetLastBattleAction(command->ID);
					switch (command->type) {
						case lcf::rpg::BattleCommand::Type_attack:
							AttackSelected();
							break;
						case lcf::rpg::BattleCommand::Type_defense:
							DefendSelected();
							break;
						case lcf::rpg::BattleCommand::Type_escape:
							EscapeSelected();
							break;
						case lcf::rpg::BattleCommand::Type_item:
							Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
							SetState(State_SelectItem);
							break;
						case lcf::rpg::BattleCommand::Type_skill:
							Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
							skill_window->SetSubsetFilter(0);
							RecreateSpWindow(active_actor);
							SetState(State_SelectSkill);
							break;
						case lcf::rpg::BattleCommand::Type_special:
							Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
							SpecialSelected();
							break;
						case lcf::rpg::BattleCommand::Type_subskill:
							Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
							SubskillSelected(command->ID);
							break;
					}
				}
			} else {
				active_actor->SetLastBattleAction(-1);
				// FIXME: Verify how battle interpreter runs with row command
				RowSelected();
			}
			return SceneActionReturn::eWaitTillNextFrame;
		}
		if (lcf::Data::battlecommands.battle_type != lcf::rpg::BattleCommands::BattleType_traditional) {
			if (Input::IsTriggered(Input::CANCEL)) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
				SetState(State_SelectOption);

				return SceneActionReturn::eWaitTillNextFrame;
			}
		}
		return SceneActionReturn::eWaitTillNextFrame;
	}
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k3::SceneActionReturn Scene_Battle_Rpg2k3::ProcessSceneActionItem() {
	assert(active_actor != nullptr);
	enum SubState {
		eBegin,
		eWaitInput,
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(true);
		item_window->SetVisible(true);
		item_window->SetActive(true);
		item_window->SetActor(active_actor);

		item_window->SetHelpWindow(help_window.get());
		help_window->SetVisible(true);

		item_window->Refresh();

		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_gauge) {
			status_window->SetVisible(true);
		}

		SetSceneActionSubState(eWaitInput);
	}

	if (scene_action_substate == eWaitInput) {
		if (Input::IsTriggered(Input::DECISION)) {
			ItemSelected();
			return SceneActionReturn::eWaitTillNextFrame;
		}
		if (Input::IsTriggered(Input::CANCEL)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
			SetState(State_SelectCommand);
			return SceneActionReturn::eWaitTillNextFrame;
		}
	}
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k3::SceneActionReturn Scene_Battle_Rpg2k3::ProcessSceneActionSkill() {
	assert(active_actor != nullptr);
	enum SubState {
		eBegin,
		eWaitInput,
	};

	const auto actor_index = Main_Data::game_party->GetActorPositionInParty(active_actor->GetId());

	if (scene_action_substate == eBegin) {
		ResetWindows(true);

		skill_window->SetActive(true);
		skill_window->SetActor(*active_actor);
		if (previous_state == State_SelectCommand) {
			skill_window->RestoreActorIndex(actor_index);
		}

		skill_window->SetVisible(true);
		skill_window->SetHelpWindow(help_window.get());
		help_window->SetVisible(true);
		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_traditional) {
			sp_window->SetVisible(true);
		}
		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_gauge) {
			status_window->SetVisible(true);
		}

		SetSceneActionSubState(eWaitInput);
	}

	skill_window->SaveActorIndex(actor_index);

	if (scene_action_substate == eWaitInput) {
		if (Input::IsTriggered(Input::DECISION)) {
			SkillSelected();
			skill_window->SaveActorIndex(actor_index);
			return SceneActionReturn::eWaitTillNextFrame;
		}
		if (Input::IsTriggered(Input::CANCEL)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
			SetState(State_SelectCommand);
			skill_window->SaveActorIndex(actor_index);
			return SceneActionReturn::eWaitTillNextFrame;
		}
	}
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k3::SceneActionReturn Scene_Battle_Rpg2k3::ProcessSceneActionEnemyTarget() {
	assert(active_actor != nullptr);
	enum SubState {
		eBegin,
		eWaitInput,
	};

	if (scene_action_substate == eBegin) {
		RefreshTargetWindow();
		target_window->SetIndex(0);

		switch (lcf::Data::battlecommands.battle_type) {
			case lcf::rpg::BattleCommands::BattleType_traditional:
				ResetWindows(false);
				command_window->SetVisible(false);
				target_window->SetVisible(true);
				break;
			case lcf::rpg::BattleCommands::BattleType_alternative:
				ResetWindows(true);
				status_window->SetVisible(true);
				command_window->SetVisible(true);
				break;
			case lcf::rpg::BattleCommands::BattleType_gauge:
				ResetWindows(true);
				status_window->SetVisible(true);
				break;
		}

		target_window->SetActive(true);

		SetSceneActionSubState(eWaitInput);
	}

	if (scene_action_substate == eWaitInput) {
		if (Input::IsTriggered(Input::DECISION)) {
			auto* actor = active_actor;
			// active_actor gets reset after the next call, so save it.
			auto* enemy = EnemySelected();
			if (enemy) {
				FaceTarget(*actor, *enemy);
			}
			target_window->SetIndex(-1);
			return SceneActionReturn::eWaitTillNextFrame;
		}
		if (Input::IsTriggered(Input::CANCEL)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
			SetState(previous_state);
			target_window->SetIndex(-1);
			return SceneActionReturn::eWaitTillNextFrame;
		}
	}
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k3::SceneActionReturn Scene_Battle_Rpg2k3::ProcessSceneActionAllyTarget() {
	assert(active_actor != nullptr);
	enum SubState {
		eBegin,
		eWaitInput,
	};

	if (scene_action_substate == eBegin) {
		switch (lcf::Data::battlecommands.battle_type) {
			case lcf::rpg::BattleCommands::BattleType_traditional:
				ResetWindows(false);
				status_window->SetVisible(true);
				break;
			case lcf::rpg::BattleCommands::BattleType_alternative:
				ResetWindows(true);
				status_window->SetVisible(true);
				command_window->SetVisible(true);
				command_window->SetIndex(-1);
				break;
			case lcf::rpg::BattleCommands::BattleType_gauge:
				ResetWindows(true);
				status_window->SetVisible(true);
				break;
		}

		status_window->SetActive(true);

		SetSceneActionSubState(eWaitInput);
	}

	if (scene_action_substate == eWaitInput) {
		if (Input::IsTriggered(Input::DECISION)) {
			AllySelected();
			return SceneActionReturn::eWaitTillNextFrame;
		}
		if (Input::IsTriggered(Input::CANCEL)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
			status_window->SetIndex(Main_Data::game_party->GetActorPositionInParty(active_actor->GetId()));
			SetState(previous_state);
			return SceneActionReturn::eWaitTillNextFrame;
		}
	}
	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k3::SceneActionReturn Scene_Battle_Rpg2k3::ProcessSceneActionBattle() {
	enum SubState {
		eBegin,
		ePreAction,
		eBattleAction,
		ePostEvents,
		ePost,
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(false);

		SetSceneActionSubState(ePreAction);
	}

	if (scene_action_substate == ePreAction) {
		if (battle_actions.empty()) {
			SetSceneActionSubState(ePost);
			return SceneActionReturn::eContinueThisFrame;
		}

		auto* battler = battle_actions.front();
		// If we will start a new battle action, first check for state changes
		// such as death, paralyze, confuse, etc..
		PrepareBattleAction(battler);

		pending_battle_action = battler->GetBattleAlgorithm();
		SetBattleActionState(BattleActionState_Begin);

		NextTurn(battler);

#ifdef EP_DEBUG_BATTLE2K3_STATE_MACHINE
		Output::Debug("Battle2k3 StartBattleAction battler={} frame={} auto_battle={}", battler->GetName(), Main_Data::game_system->GetFrameCounter(), auto_battle);
#endif
		SetSceneActionSubState(eBattleAction);
	}

	if (scene_action_substate == eBattleAction) {
		auto rc = ProcessBattleAction(pending_battle_action.get());
		// If interpreter or something else changed the battle state, cleanup before we abort.
		if (state != State_Battle) {
			pending_battle_action = {};
			RemoveCurrentAction();
		}
		if (rc == BattleActionReturn::eContinue) {
			return SceneActionReturn::eContinueThisFrame;
		}
		if (rc == BattleActionReturn::eWait) {
			return SceneActionReturn::eWaitTillNextFrame;
		}

		assert(pending_battle_action->GetSource() != active_actor);

		pending_battle_action = {};
		RemoveCurrentAction();

		// If battle ended, quit now
		if (CheckBattleEndConditions()) {
			return SceneActionReturn::eContinueThisFrame;
		}

		// Try next battler
		SetSceneActionSubState(ePreAction);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == ePost) {
		// If the selected actor acted, or if they were killed / removed, then cancel out of their menus
		if (active_actor == nullptr || !active_actor->Exists()) {
			ReturnToMainBattleState();
		} else {
			SetState(previous_state);
		}
		return SceneActionReturn::eWaitTillNextFrame;
	}

	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k3::SceneActionReturn Scene_Battle_Rpg2k3::ProcessSceneActionVictory() {
	enum SubState {
		eCBAInit,
		eCBAMove,
		eBegin,
		ePreMessage,
		eMessages,
		eEnd,
	};

	if (scene_action_substate == eCBAInit) {
		for (auto* actor: Main_Data::game_party->GetActors()) {
			auto* sprite = actor->GetActorBattleSprite();
			if (actor->Exists() && sprite) {
				sprite->SetNormalAttacking(false);
				sprite->ResetFixedFacingDirection();
				auto* weapon = actor->GetWeaponSprite();
				if (weapon) {
					weapon->StopAttack();
				}
			}
		}

		if (cba_action != nullptr && cba_direction_back) {
			CBAInit();
			SetSceneActionSubState(eCBAMove);
		} else {
			SetSceneActionSubState(eBegin);
		}
		return SceneActionReturn::eWaitTillNextFrame;
	}

	if (scene_action_substate == eCBAMove) {
		CBAMove();
		if (cba_move_frame >= cba_num_move_frames) {
			SetSceneActionSubState(eBegin);
		}
		return SceneActionReturn::eWaitTillNextFrame;
	}

	if (scene_action_substate == eBegin) {
		ResetWindows(true);
		status_window->SetVisible(true);

		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_traditional) {
			status_window->SetChoiceMode(Window_BattleStatus::ChoiceMode_None);
			target_window->SetVisible(true);
		}
		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_alternative) {
			command_window->SetVisible(true);
		}
		battle_end_timer = 60;
		SetSceneActionSubState(ePreMessage);
	}

	if (scene_action_substate == ePreMessage) {
		if (battle_end_timer > 0) {
			--battle_end_timer;
			return SceneActionReturn::eContinueThisFrame;
		}

		for (auto* actor: Main_Data::game_party->GetActors()) {
			auto* sprite = actor->GetActorBattleSprite();
			if (actor->Exists() && sprite) {
				actor->SetIsDefending(false);
				sprite->SetAnimationState(Sprite_Actor::AnimationState_Victory);
			}
		}
		Main_Data::game_system->BgmPlay(Main_Data::game_system->GetSystemBGM(Main_Data::game_system->BGM_Victory));
		SetWait(30, 30);
		SetSceneActionSubState(eMessages);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eMessages) {
		int exp = Main_Data::game_enemyparty->GetExp();
		int money = Main_Data::game_enemyparty->GetMoney();
		std::vector<int> drops;
		Main_Data::game_enemyparty->GenerateDrops(drops);

		PendingMessage pm(Game_Message::CommandCodeInserter);
		pm.SetEnableFace(false);

		pm.PushLine(ToString(lcf::Data::terms.victory) + Player::escape_symbol + "|");
		pm.PushPageEnd();

		if (exp > 0) {
			pm.PushLine(PartyMessage::GetExperienceGainedMessage(exp));
			pm.PushPageEnd();
		}
		if (money > 0) {
			pm.PushLine(PartyMessage::GetGoldReceivedMessage(money));
			pm.PushPageEnd();
		}
		for (auto& item_id: drops) {
			const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
			pm.PushLine(PartyMessage::GetItemReceivedMessage(item));
			pm.PushPageEnd();
		}

		for (auto* actor: Main_Data::game_party->GetActors()) {
			if (actor->Exists()) {
				int exp_gain = exp;
				RuntimePatches::EXPlus::ModifyExpGain(*actor, exp_gain);
				actor->ChangeExp(actor->GetExp() + exp_gain, &pm);
			}
		}

		Main_Data::game_party->GainGold(money);
		for (auto& item: drops) {
			Main_Data::game_party->AddItem(item, 1);
		}

		message_window->SetHeight(32);
		message_window->SetMaxLinesPerPage(1);
		Game_Message::SetPendingMessage(std::move(pm));

		status_window->Refresh();

		SetSceneActionSubState(eEnd);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eEnd) {
		EndBattle(BattleResult::Victory);
		return SceneActionReturn::eContinueThisFrame;
	}

	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k3::SceneActionReturn Scene_Battle_Rpg2k3::ProcessSceneActionDefeat() {
	enum SubState {
		eBegin,
		ePreMessage,
		eMessages,
		eEnd,
	};

	if (scene_action_substate == eBegin) {
		ResetWindows(true);
		status_window->SetVisible(true);

		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_traditional) {
			status_window->SetChoiceMode(Window_BattleStatus::ChoiceMode_None);
			target_window->SetVisible(true);
		}
		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_alternative) {
			command_window->SetVisible(true);
		}

		battle_end_timer = 60;
		SetSceneActionSubState(ePreMessage);
	}

	if (scene_action_substate == ePreMessage) {
		if (battle_end_timer > 0) {
			--battle_end_timer;
			return SceneActionReturn::eContinueThisFrame;
		}
		Main_Data::game_system->BgmPlay(Main_Data::game_system->GetSystemBGM(Main_Data::game_system->BGM_GameOver));
		SetWait(60, 60);
		SetSceneActionSubState(eMessages);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eMessages) {
		Main_Data::game_system->SetMessagePositionFixed(true);
		Main_Data::game_system->SetMessagePosition(0);
		Main_Data::game_system->SetMessageTransparent(false);

		PendingMessage pm(Game_Message::CommandCodeInserter);
		pm.SetEnableFace(false);
		pm.PushLine(ToString(lcf::Data::terms.defeat));

		message_window->SetHeight(32);
		message_window->SetMaxLinesPerPage(1);
		Game_Message::SetPendingMessage(std::move(pm));

		SetSceneActionSubState(eEnd);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eEnd) {
		EndBattle(BattleResult::Defeat);
		return SceneActionReturn::eContinueThisFrame;
	}

	return SceneActionReturn::eWaitTillNextFrame;
}

Scene_Battle_Rpg2k3::SceneActionReturn Scene_Battle_Rpg2k3::ProcessSceneActionEscape() {
	enum SubState {
		eBegin,
		eFailure,
		eSuccess,
	};

	if (scene_action_substate == eBegin) {
		if (previous_state == State_SelectOption || TryEscape()) {
			// There is no success text for escape in 2k3, however 2k3 still waits the same as if there was.
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Escape));
			for (auto& actor: Main_Data::game_party->GetActors()) {
				auto* sprite = actor->GetActorBattleSprite();
				if (sprite) {
					sprite->SetAnimationState(Sprite_Actor::AnimationState_WalkingRight);
				}
			}
			running_away = true;
			SetSceneActionSubState(eSuccess);
		} else {
			SetSceneActionSubState(eFailure);
			ShowNotification(ToString(lcf::Data::terms.escape_failure));
		}
		SetWait(10, 30);
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eFailure) {
		EndNotification();
		ReturnToMainBattleState();
		return SceneActionReturn::eContinueThisFrame;
	}

	if (scene_action_substate == eSuccess) {
		EndNotification();
		EndBattle(BattleResult::Escape);
		return SceneActionReturn::eContinueThisFrame;
	}

	return SceneActionReturn::eWaitTillNextFrame;
}

static int AdjustPoseForDirection(const Game_Battler* battler, int pose) {
	if (battler->IsDirectionFlipped()) {
		switch (pose) {
			case lcf::rpg::BattlerAnimation::Pose_AttackRight:
				return lcf::rpg::BattlerAnimation::Pose_AttackLeft;
			case lcf::rpg::BattlerAnimation::Pose_AttackLeft:
				return lcf::rpg::BattlerAnimation::Pose_AttackRight;
			case lcf::rpg::BattlerAnimation::Pose_WalkRight:
				return lcf::rpg::BattlerAnimation::Pose_WalkLeft;
			case lcf::rpg::BattlerAnimation::Pose_WalkLeft:
				return lcf::rpg::BattlerAnimation::Pose_WalkRight;
		}
	}
	return pose;
}

void Scene_Battle_Rpg2k3::SetBattleActionState(BattleActionState state) {
	battle_action_state = state;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleAction(Game_BattleAlgorithm::AlgorithmBase* action) {
	// End any notification started by battle action
	EndNotification();
	auto* source = action->GetSource();

	if (action == nullptr) {
		return BattleActionReturn::eFinished;
	}

	// Immediately quit for dead actors no move. Prevents any animations or delays.
	if (action->GetType() == Game_BattleAlgorithm::Type::None && action->GetSource()->IsDead()) {
		return BattleActionReturn::eFinished;
	}

	if (Game_Battle::IsBattleAnimationWaiting() && !(action->GetType() == Game_BattleAlgorithm::Type::Normal && source->GetType() == Game_Battler::Type_Enemy)) {
		return BattleActionReturn::eWait;
	}

	if (source->GetType() == Game_Battler::Type_Ally) {
		auto* sprite = static_cast<Game_Actor*>(source)->GetActorBattleSprite();
		if (sprite && !sprite->IsIdling()) {
			switch (battle_action_state) {
				case BattleActionState_CBAMove:
				case BattleActionState_StartAnimation:
				case BattleActionState_CBARangedWeaponInit:
				case BattleActionState_CBARangedWeaponMove:
				case BattleActionState_Animation:
					break;
				default:
					return BattleActionReturn::eWait;
			}
		}
	}

#ifdef EP_DEBUG_BATTLE2K3_STATE_MACHINE
	static int last_state = -1;
	if (battle_action_state != last_state) {
		auto* source = action->GetSource();
		Output::Debug("Battle2k3 ProcessBattleAction({}, {}) actor={}({}) frames={} auto_battle={}", action->GetSource()->GetName(), battle_action_state,
				source->GetName(), source->GetId(),
				Main_Data::game_system->GetFrameCounter(), auto_battle);
		last_state = battle_action_state;
	}
#endif

	switch (battle_action_state) {
		case BattleActionState_Begin:
			return ProcessBattleActionBegin(action);
		case BattleActionState_PreEvents:
			return ProcessBattleActionPreEvents(action);
		case BattleActionState_Conditions:
			return ProcessBattleActionConditions(action);
		case BattleActionState_Notify:
			return ProcessBattleActionNotify(action);
		case BattleActionState_Combo:
			return ProcessBattleActionCombo(action);
		case BattleActionState_StartAlgo:
			return ProcessBattleActionStartAlgo(action);
		case BattleActionState_CBAInit:
			return ProcessBattleActionCBAInit(action);
		case BattleActionState_CBAMove:
			return ProcessBattleActionCBAMove(action);
		case BattleActionState_StartAnimation:
			return ProcessBattleActionStartAnimation(action);
		case BattleActionState_CBARangedWeaponInit:
			return ProcessBattleActionCBARangedWeaponInit(action);
		case BattleActionState_CBARangedWeaponMove:
			return ProcessBattleActionCBARangedWeaponMove(action);
		case BattleActionState_Animation:
			return ProcessBattleActionAnimation(action);
		case BattleActionState_AnimationReflect:
			return ProcessBattleActionAnimationReflect(action);
		case BattleActionState_FinishPose:
			return ProcessBattleActionFinishPose(action);
		case BattleActionState_Execute:
			return ProcessBattleActionExecute(action);
		case BattleActionState_SwitchEvents:
			return ProcessBattleActionSwitchEvents(action);
		case BattleActionState_Apply:
			return ProcessBattleActionApply(action);
		case BattleActionState_PostAction:
			return ProcessBattleActionPostAction(action);
		case BattleActionState_PostEvents:
			return ProcessBattleActionPostEvents(action);
		case BattleActionState_Finished:
			return ProcessBattleActionFinished(action);
	}

	assert(false && "Invalid BattleActionState!");

	return BattleActionReturn::eFinished;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionBegin(Game_BattleAlgorithm::AlgorithmBase* action) {
	auto* source = action->GetSource();

	// Emulate an RPG_RT bug where whenver actors attack, the damage and evasion calculations are performed
	// as if the enemies are in the front row.
	if (source->GetType() == Game_Battler::Type_Ally) {
		if (action->GetType() == Game_BattleAlgorithm::Type::Normal) {
			static_cast<Game_BattleAlgorithm::Normal*>(action)->SetTreatEnemiesAsIfInFrontRow(true);
		} else if (action->GetType() == Game_BattleAlgorithm::Type::Skill) {
			static_cast<Game_BattleAlgorithm::Skill*>(action)->SetTreatEnemiesAsIfInFrontRow(true);
		}
	}

	// Setup enemy targets
	// FIXME: This is not 100% bug compatible with RPG_RT but pretty close
	// See: https://github.com/EasyRPG/Player/issues/2405#issuecomment-716298981
	if (source->GetType() == Game_Battler::Type_Ally) {
		auto& interp = Game_Battle::GetInterpreterBattle();
		auto* actor = static_cast<Game_Actor*>(source);
		interp.SetCurrentActingActorId(actor->GetId());

		if (action->GetType() == Game_BattleAlgorithm::Type::Normal
				|| action->GetType() == Game_BattleAlgorithm::Type::Skill
				|| action->GetType() == Game_BattleAlgorithm::Type::Item)
		{
			auto* original_target = action->GetOriginalSingleTarget();

			if (original_target && original_target->GetType() == Game_Battler::Type_Enemy) {
				auto* enemy = static_cast<Game_Enemy*>(original_target);
				interp.SetCurrentEnemyTargetIndex(Main_Data::game_enemyparty->GetEnemyPositionInParty(enemy));
				interp.SetCurrentActionTargetsSingleEnemy(true);
			} else {
				interp.SetCurrentActionTargetsSingleEnemy(false);
			}
		}
	}
	// Enemy doesn't change the values, and inherits whatever the last actor did...
	// Defend, row, etc.. is similar..

	SetBattleActionState(BattleActionState_PreEvents);
	return BattleActionReturn::eContinue;
}


Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionPreEvents(Game_BattleAlgorithm::AlgorithmBase* action) {
	auto* source = action->GetSource();

	// RPG_RT always runs the interpreter before starting the action.
	if (!CheckBattleEndAndScheduleEvents(EventTriggerType::eBeforeBattleAction, source)) {
		return BattleActionReturn::eContinue;
	}

	// If any battle animation is running for any reason, RPG_RT waits until the animation finishes.
	// This also means that the interpreter can run again.
	if (Game_Battle::IsBattleAnimationWaiting()) {
		return BattleActionReturn::eWait;
	}

	// If the event made the current action ususable, such as MP loss or silence etc..
	PrepareBattleAction(source);
	pending_battle_action = source->GetBattleAlgorithm();
	action = pending_battle_action.get();

	// Now perform filtering. RPG_RT will run events but will early abort the battle algo if any of the following conditions hold.
	// FIXME: RPG_RT doesn't actually check hidden (maybe it's impossible?) But we do it here for extensions.
	// FIXME: RPG_RT doesn't check for dead enemies, only actors. Why?
	if (source->IsHidden()
			|| !source->IsInParty()
			|| !source->CanActOrRecoverable()
			) {
		return BattleActionReturn::eFinished;
	}

	// RPG_RT cancels all enemy actions when first_strike flag is still active. This is different than
	// initiative / surround, unless the flag is set for those too.
	if (source->GetType() == Game_Battler::Type_Enemy
			&& !source->Exists()
			&& first_strike) {
		return BattleActionReturn::eFinished;
	}

	if (source->GetType() == Game_Battler::Type_Enemy) {
		if (action->GetType() != Game_BattleAlgorithm::Type::None
				&& action->GetType() != Game_BattleAlgorithm::Type::DoNothing) {
			if (Player::IsEnglish() || Player::IsPatchDynRpg()) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_EnemyAttacks));
			}
			source->Flash(31, 31,31, 32, 48);
		}
	}

	SetBattleActionState(BattleActionState_Conditions);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionConditions(Game_BattleAlgorithm::AlgorithmBase* action) {
	(void)action;

	std::vector<Game_Battler*> battlers;
	Main_Data::game_party->GetActiveBattlers(battlers);
	Main_Data::game_enemyparty->GetActiveBattlers(battlers);

	for (auto* b : battlers) {
		b->BattleStateHeal();
		int damageTaken = b->ApplyConditions();
		if (damageTaken != 0) {
			DrawFloatText(
					b->GetBattlePosition().x,
					b->GetBattlePosition().y,
					damageTaken < 0 ? Font::ColorDefault : Font::ColorHeal,
					std::to_string(std::abs(damageTaken)),
					b,
					damageTaken < 0 ? Scene_Battle_Rpg2k3::FloatTextType::Damage : Scene_Battle_Rpg2k3::FloatTextType::Heal);
		}
		if (b->GetType() == Game_Battler::Type_Ally) {
			auto* sprite = static_cast<Game_Actor*>(b)->GetActorBattleSprite();
			if (sprite) {
				sprite->DetectStateChange();
			}
		}
	}

	status_window->Refresh();

	SetBattleActionState(BattleActionState_Notify);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionNotify(Game_BattleAlgorithm::AlgorithmBase* action) {
	std::string notification = action->GetStartMessage(0);
	ShowNotification(notification);
	if (!notification.empty()) {
		if (action->GetType() == Game_BattleAlgorithm::Type::Skill) {
			SetWait(15, 50);
		} else {
			SetWait(10, 40);
		}
	}

	SetBattleActionState(BattleActionState_Combo);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionCombo(Game_BattleAlgorithm::AlgorithmBase* action) {
	auto* source = action->GetSource();
	if (source->GetType() == Game_Battler::Type_Ally) {
		auto* actor = static_cast<Game_Actor*>(source);
		auto combo_cmd = actor->GetBattleComboCommand();
		auto combo_times = actor->GetBattleComboTimes();

		if (combo_times > 1 && combo_cmd >= 0 && combo_cmd == actor->GetLastBattleAction()) {
			auto* cmd = lcf::ReaderUtil::GetElement(lcf::Data::battlecommands.commands, combo_cmd);
			if (cmd && (cmd->type == lcf::rpg::BattleCommand::Type_attack
						|| cmd->type == lcf::rpg::BattleCommand::Type_skill
						|| cmd->type == lcf::rpg::BattleCommand::Type_subskill))
			{
				// RPG_RT doesn't allow combo for item or other actions other than attack and skills.
				action->ApplyComboHitsMultiplier(combo_times);
			}
		}
	}
	SetBattleActionState(BattleActionState_StartAlgo);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionStartAlgo(Game_BattleAlgorithm::AlgorithmBase* action) {
	const auto is_target_party = action->GetOriginalPartyTarget() != nullptr;
	auto* source = action->GetSource();

	action->Start();

	// Drop out of the battle state machine to process actor escape.
	if (action->GetType() == Game_BattleAlgorithm::Type::Escape && source->GetType() == Game_Battler::Type_Ally) {
		SetState(State_Escape);
		return BattleActionReturn::eContinue;
	}

	// FIXME: This needs to be attached to the monster target window.
	// Counterexample is weapon with attack all, engine still makes you target a specific enemy,
	// even though your weapon will hit all enemies.
	if (action->GetSource()->GetType() == Game_Battler::Type_Ally
			&& !is_target_party
			&& action->GetTarget()
			&& action->GetTarget()->GetType() == Game_Battler::Type_Enemy)
	{
		auto* actor = static_cast<Game_Actor*>(action->GetSource());
		FaceTarget(*actor, *action->GetTarget());
	}

	if (action->GetCurrentRepeat() == 0 && action->GetCBAMovement() != lcf::rpg::BattlerAnimationItemSkill::Movement_none && source->GetType() == Game_Battler::Type_Ally) {
		cba_action = action;
		cba_direction_back = false;
		SetBattleActionState(BattleActionState_CBAInit);
	} else {
		SetBattleActionState(BattleActionState_StartAnimation);
	}
	return BattleActionReturn::eWait;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionCBAInit(Game_BattleAlgorithm::AlgorithmBase*) {
	CBAInit();

	SetBattleActionState(BattleActionState_CBAMove);
	return BattleActionReturn::eWait;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionCBAMove(Game_BattleAlgorithm::AlgorithmBase*) {
	CBAMove();

	if (cba_move_frame >= cba_num_move_frames) {
		if (cba_direction_back) {
			SetBattleActionState(BattleActionState_PostAction);
		} else {
			SetBattleActionState(BattleActionState_StartAnimation);
		}
	}
	return BattleActionReturn::eWait;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionStartAnimation(Game_BattleAlgorithm::AlgorithmBase* action) {
	auto* source = action->GetSource();
	bool ranged_weapon = false;

	if (source->GetType() == Game_Battler::Type_Ally) {
		auto* actor = static_cast<Game_Actor*>(source);
		auto* sprite = actor->GetActorBattleSprite();
		if (sprite) {
			const auto pose = AdjustPoseForDirection(action->GetSource(), action->GetSourcePose());
			if (pose != lcf::rpg::BattlerAnimation::Pose_Idle) {
				auto action_state = static_cast<Sprite_Actor::AnimationState>(pose + 1);

				if (action->GetType() == Game_BattleAlgorithm::Type::Normal) {
					sprite->SetNormalAttacking(true);
					auto* weapon = actor->GetWeaponSprite();
					int weapon_animation_id = 0;
					if (weapon) {
						auto* weapon_animation_data = action->GetWeaponAnimationData();
						if (weapon_animation_data) {
							if (weapon_animation_data->type == lcf::rpg::BattlerAnimationItemSkill::AnimType_weapon) {
								if (weapon_animation_data->weapon_animation_id >= 0) {
									weapon->SetWeaponAnimation(weapon_animation_data->weapon_animation_id + 1);
									weapon->StartAttack(action->GetSourcePose() == lcf::rpg::BattlerAnimation::Pose_AttackLeft);
								}
							} else {
								if (weapon_animation_data->type == lcf::rpg::BattlerAnimationItemSkill::AnimType_battle) {
									weapon_animation_id = weapon_animation_data->battle_animation_id;
								}
							}
							if (weapon_animation_data->ranged) {
								ranged_weapon = true;
							}
						}
					}
					sprite->SetAnimationState(
							action_state,
							Sprite_Actor::LoopState_WaitAfterFinish,
							weapon_animation_id);
				} else {
					sprite->SetAnimationState(
							action_state,
							Sprite_Actor::LoopState_WaitAfterFinish);
				}
			} else {
				sprite->SetAnimationLoop(Sprite_Actor::LoopState_DefaultAnimationAfterFinish);
			}
		}
	}

	if (ranged_weapon) {
		SetBattleActionState(BattleActionState_CBARangedWeaponInit);
	} else {
		SetBattleActionState(BattleActionState_Animation);
	}
	return BattleActionReturn::eWait;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionCBARangedWeaponInit(Game_BattleAlgorithm::AlgorithmBase* action) {
	auto* source = action->GetSource();
	cba_ranged_weapon_move_frame = 0;
	cba_ranged.clear();

	if (source->GetType() == Game_Battler::Type_Ally) {
		auto* actor = static_cast<Game_Actor*>(source);

		if (action->GetType() == Game_BattleAlgorithm::Type::Normal) {
			auto* weapon_animation_data = action->GetWeaponAnimationData();
			if (weapon_animation_data) {
				cba_num_ranged_weapon_move_frames = (weapon_animation_data->ranged_speed + 1) * 20;

				// The ranged weapon animation targets the original single target
				// if the weapon has the "Attack All" flag set and the ranged attack
				// range is set to "Single Enemy"
				if (action->GetWeaponData()->attack_all) {
					if (action->GetWeaponData()->ranged_target == lcf::rpg::Item::Target_single) {
						cba_ranged.emplace_back(*action->GetOriginalSingleTarget(), nullptr);
					} else if (action->GetWeaponData()->ranged_target == lcf::rpg::Item::Target_center) {
						std::vector<Game_Battler*> enemies;
						Main_Data::game_enemyparty->GetActiveBattlers(enemies);
						int x = 0;
						int y = 0;
						for (Game_Battler* enemy : enemies) {
							x += enemy->GetBattlePosition().x;
							y += enemy->GetBattlePosition().y;
						}
						if (enemies.size() > 0) {
							x /= enemies.size();
							y /= enemies.size();
						}
						cba_ranged_center = Point(x, y);

						// This is needed to make the ranged weapon animation appear
						// even if the real target of the animation is the center
						cba_ranged.emplace_back(*action->GetTarget(), nullptr);
					} else if (action->GetWeaponData()->ranged_target == lcf::rpg::Item::Target_simultaneous) {
						std::vector<Game_Battler*> battlers;
						Main_Data::game_enemyparty->GetActiveBattlers(battlers);
						for (auto& b: battlers) {
							cba_ranged.emplace_back(*b, nullptr);
						}
					}
				} else {
					assert(action->GetTarget());
					cba_ranged.emplace_back(*action->GetTarget(), nullptr);
				}

				for (auto& it: cba_ranged) {
					std::unique_ptr<Sprite_Weapon> cba_ranged_weapon = std::make_unique<Sprite_Weapon>(actor);
					cba_ranged_weapon->SetWeaponAnimation(weapon_animation_data->ranged_animation_id + 1);
					cba_ranged_weapon->SetRanged(true);
					cba_ranged_weapon->StartAttack(action->GetSourcePose() == lcf::rpg::BattlerAnimation::Pose_AttackLeft);
					cba_ranged_weapon->Update();
					it.second = std::move(cba_ranged_weapon);
				}
			}
		}
	}

	SetBattleActionState(BattleActionState_CBARangedWeaponMove);
	return BattleActionReturn::eWait;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionCBARangedWeaponMove(Game_BattleAlgorithm::AlgorithmBase* action) {
	auto* source = action->GetSource();

	if (cba_ranged_weapon_move_frame < cba_num_ranged_weapon_move_frames) {
		cba_ranged_weapon_move_frame++;
		for (auto& it: cba_ranged) {
			int offset_x = 0;
			int offset_y = 0;
			if (action->GetWeaponData()->ranged_target == lcf::rpg::Item::Target_center && action->GetWeaponData()->attack_all) {
				offset_x = cba_ranged_center.x - source->GetBattlePosition().x;
				offset_y = cba_ranged_center.y - source->GetBattlePosition().y;
			} else {
				auto& battler = it.first;
				offset_x = battler.GetBattlePosition().x - source->GetBattlePosition().x;
				offset_y = battler.GetBattlePosition().y - source->GetBattlePosition().y;
			}
			auto& weapon = it.second;
			assert(weapon);
			weapon->SetX(source->GetBattlePosition().x + (offset_x * cba_ranged_weapon_move_frame / cba_num_ranged_weapon_move_frames));
			weapon->SetY(source->GetBattlePosition().y + (offset_y * cba_ranged_weapon_move_frame / cba_num_ranged_weapon_move_frames));
			weapon->Update();
		}
	}

	if (cba_ranged_weapon_move_frame >= cba_num_ranged_weapon_move_frames) {
		for (auto& it: cba_ranged) {
			auto& weapon = it.second;
			weapon->StopAttack();
			weapon = nullptr;
		}
		SetBattleActionState(BattleActionState_Animation);
	}

	return BattleActionReturn::eWait;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionAnimation(Game_BattleAlgorithm::AlgorithmBase* action) {
	const auto anim_id = action->GetAnimationId(0);
	if (anim_id) {
		action->PlayAnimation(anim_id, false, -1, CheckAnimFlip(action->GetSource()));
	}
	if (action->GetStartSe()) {
		Main_Data::game_system->SePlay(*action->GetStartSe());
	}

	if (action->GetCBAMovement() != lcf::rpg::BattlerAnimationItemSkill::Movement_none) {
		cba_direction_back = true;
	}

	if (action->ReflectTargets()) {
		SetBattleActionState(BattleActionState_AnimationReflect);
	} else {
		SetBattleActionState(BattleActionState_Execute);
	}
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionAnimationReflect(Game_BattleAlgorithm::AlgorithmBase* action) {
	const auto anim_id = action->GetAnimationId(0);
	if (anim_id) {
		assert(action->GetReflectTarget());
		action->PlayAnimation(anim_id, false, -1, CheckAnimFlip(action->GetReflectTarget()));
	}
	SetBattleActionState(BattleActionState_FinishPose);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionFinishPose(Game_BattleAlgorithm::AlgorithmBase* action) {
	auto* source = action->GetSource();
	if (source->GetType() == Game_Battler::Type_Ally) {
		auto* sprite = static_cast<Game_Actor*>(source)->GetActorBattleSprite();
		if (sprite) {
			sprite->SetAnimationLoop(Sprite_Actor::LoopState_DefaultAnimationAfterFinish);
		}
	}

	SetBattleActionState(BattleActionState_Execute);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionExecute(Game_BattleAlgorithm::AlgorithmBase* action) {
	if (!action->IsCurrentTargetValid()) {
		if (action->GetCBAMovement() != lcf::rpg::BattlerAnimationItemSkill::Movement_none) {
			SetBattleActionState(BattleActionState_CBAInit);
		} else {
			SetBattleActionState(BattleActionState_PostAction);
		}
		return BattleActionReturn::eContinue;
	}

	auto* source = action->GetSource();
	if (source->GetType() == Game_Battler::Type_Ally) {
		auto* sprite = static_cast<Game_Actor*>(source)->GetActorBattleSprite();
		if (sprite) {
			sprite->SetAnimationLoop(Sprite_Actor::LoopState_DefaultAnimationAfterFinish);
		}
	}

	action->Execute();
	action->ApplyCustomEffect();
	action->ApplySwitchEffect();

	if (action->GetAffectedSwitch() > 0) {
		SetBattleActionState(BattleActionState_SwitchEvents);
	} else {
		SetBattleActionState(BattleActionState_Apply);
	}
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionSwitchEvents(Game_BattleAlgorithm::AlgorithmBase* action) {
	// RPG_RT always runs the interpreter before starting the action.
	if (!CheckBattleEndAndScheduleEvents(EventTriggerType::eAfterBattleAction, action->GetSource())) {
		return BattleActionReturn::eContinue;
	}

	SetBattleActionState(BattleActionState_Apply);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionApply(Game_BattleAlgorithm::AlgorithmBase* action) {
	auto* source = action->GetSource();
	auto* target = action->GetTarget();

	Sprite_Actor* target_sprite = nullptr;
	if (target->GetType() == Game_Battler::Type_Ally) {
		target_sprite = static_cast<Game_Actor*>(target)->GetActorBattleSprite();
	}

	const bool was_dead = target->IsDead();


	const bool was_absorb_hp = action->IsAbsorbHp();
	// Emulates an RPG_RT bug where inverted absorb damage doesn't absorb hp anymore.
	// This bug only affects hp, not sp.
	if (action->IsAbsorbHp() && action->GetAffectedHp() > 0) {
		action->SetIsAbsorbHp(false);
	}

	action->ApplyHpEffect();

	// Emulates an RPG_RT bug where damage which is reversed into healing due to negative attributes is applied twice.
	// The displayed numbers are normal, but the actual effect is doubled.
	if (!action->IsPositive() && !was_absorb_hp && action->IsAffectHp() && action->GetAffectedHp() > 0) {
		action->ApplyHpEffect();
	}

	action->ApplySpEffect();
	action->ApplyAtkEffect();
	action->ApplyDefEffect();
	action->ApplySpiEffect();
	action->ApplyAgiEffect();
	action->ApplyStateEffects();
	action->ApplyAttributeShiftEffects();

	if (action->IsSuccess() && action->IsAffectHp() && action->GetAffectedHp() <= 0) {
		if (target->GetType() == Game_Battler::Type_Enemy) {
			auto* enemy = static_cast<Game_Enemy*>(target);
			enemy->SetBlinkTimer();
		} else if (action->GetAffectedHp() < 0) {
			if (!target->IsDead()) {
				target_sprite->SetAnimationState(Sprite_Actor::AnimationState_Damage, Sprite_Actor::LoopState_DefaultAnimationAfterFinish);
			}
		}
	}

	if (!was_dead && target->GetType() == Game_Battler::Type_Ally && target->IsDead()) {
		target_sprite->SetAnimationState(Sprite_Actor::AnimationState_Dead, Sprite_Actor::LoopState_WaitAfterFinish);
	}

	if (action->IsSuccess() && target->GetType() == Game_Battler::Type_Enemy) {
		auto* enemy = static_cast<Game_Enemy*>(target);
		if (!was_dead && enemy->IsDead()) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_EnemyKill));
			enemy->SetDeathTimer();
			RefreshTargetWindow();
		}
	}

	if (target_sprite) {
		target_sprite->DetectStateChange();
	}

	if (action->IsSuccess()) {
		if (action->IsCriticalHit()) {
			Main_Data::game_screen->FlashOnce(28, 28, 28, 20, 8);
		}
		if (action->IsAffectHp()) {
			const auto hp = action->GetAffectedHp();
			if (hp != 0 || (!action->IsPositive() && !action->IsAbsorbHp())) {
				DrawFloatText(
						target->GetBattlePosition().x,
						target->GetBattlePosition().y,
						hp > 0 ? Font::ColorHeal : Font::ColorDefault,
						std::to_string(std::abs(hp)),
						target,
						hp > 0 ? Scene_Battle_Rpg2k3::FloatTextType::Heal : Scene_Battle_Rpg2k3::FloatTextType::Damage);

				if (action->IsAbsorbHp()) {
					DrawFloatText(
							source->GetBattlePosition().x,
							source->GetBattlePosition().y,
							hp > 0 ? Font::ColorDefault : Font::ColorHeal,
							std::to_string(std::abs(hp)),
							source,
							hp > 0 ? Scene_Battle_Rpg2k3::FloatTextType::Damage : Scene_Battle_Rpg2k3::FloatTextType::Heal);
				}
			}

			if (!action->IsPositive() && !action->IsAbsorbHp()) {
				if (target->GetType() == Game_Battler::Type_Ally) {
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_AllyDamage));
				} else {
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_EnemyDamage));
				}
			}
		}
	} else {
		auto* se = action->GetFailureSe();
		if (se) {
			Main_Data::game_system->SePlay(*se);
		}
		DrawFloatText(
				target->GetBattlePosition().x,
				target->GetBattlePosition().y,
				0,
				lcf::Data::terms.miss,
				target,
				Scene_Battle_Rpg2k3::FloatTextType::Miss);
	}

	status_window->Refresh();

	// Repeat on next target
	if (action->TargetNext()) {
		SetBattleActionState(BattleActionState_Execute);
		return BattleActionReturn::eContinue;
	}

	// If action does multiple attacks, repeat again.
	if (action->RepeatNext(false)) {
		SetBattleActionState(BattleActionState_StartAlgo);
		return BattleActionReturn::eContinue;
	}

	if (source->GetType() == Game_Battler::Type_Ally) {
		if (action->GetType() == Game_BattleAlgorithm::Type::Normal) {
			auto* actor = static_cast<Game_Actor*>(source);
			auto* source_sprite = actor->GetActorBattleSprite();
			if (source_sprite) {
				source_sprite->SetNormalAttacking(false);
				auto* weapon = actor->GetWeaponSprite();
				if (weapon) {
					auto* weapon_animation_data = action->GetWeaponAnimationData();
					if (weapon_animation_data) {
						if (weapon_animation_data->type == lcf::rpg::BattlerAnimationItemSkill::AnimType_weapon) {
							weapon->StopAttack();
						}
					}
				}
			}
		}
	}

	if (action->GetCBAMovement() != lcf::rpg::BattlerAnimationItemSkill::Movement_none) {
		SetBattleActionState(BattleActionState_CBAInit);
	} else {
		SetBattleActionState(BattleActionState_PostAction);
	}
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionPostAction(Game_BattleAlgorithm::AlgorithmBase* action) {
	auto* source = action->GetSource();
	action->ProcessPostActionSwitches();

	// RPG_RT bug: Final interpreter call is only done for normal and skill for actors
	if (source->GetType() == Game_Battler::Type_Enemy
			|| action->GetType() == Game_BattleAlgorithm::Type::Normal
			|| action->GetType() == Game_BattleAlgorithm::Type::Skill) {
		SetBattleActionState(BattleActionState_PostEvents);
	} else {
		SetBattleActionState(BattleActionState_Finished);
	}

	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionPostEvents(Game_BattleAlgorithm::AlgorithmBase* action) {
	// RPG_RT always runs the interpreter before starting the action.
	if (!CheckBattleEndAndScheduleEvents(EventTriggerType::eAfterBattleAction, action->GetSource())) {
		return BattleActionReturn::eContinue;
	}

	SetBattleActionState(BattleActionState_Finished);
	return BattleActionReturn::eContinue;
}

Scene_Battle_Rpg2k3::BattleActionReturn Scene_Battle_Rpg2k3::ProcessBattleActionFinished(Game_BattleAlgorithm::AlgorithmBase* action) {
	(void)action;
	first_strike = false;

	return BattleActionReturn::eFinished;
}

bool Scene_Battle_Rpg2k3::IsEscapeAllowedFromOptionWindow() const {
	auto cond = Game_Battle::GetBattleCondition();

	return Scene_Battle::IsEscapeAllowed() && (Game_Battle::GetTurn() == 0)
		&& (first_strike || cond == lcf::rpg::System::BattleCondition_initiative || cond == lcf::rpg::System::BattleCondition_surround);
}

bool Scene_Battle_Rpg2k3::IsEscapeAllowedFromActorCommand() const {
	auto cond = Game_Battle::GetBattleCondition();

	return Scene_Battle::IsEscapeAllowed() && cond != lcf::rpg::System::BattleCondition_pincers;
}

void Scene_Battle_Rpg2k3::AttackSelected() {
	// RPG_RT still requires you to select an enemy target, even if your weapon has attack all.
	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
	SetState(State_SelectEnemyTarget);
}

void Scene_Battle_Rpg2k3::SubskillSelected(int command) {
	auto idx = command - 1;
	// Resolving a subskill battle command to skill id
	int subskill = lcf::rpg::Skill::Type_subskill;

	// Loop through all battle commands smaller then that ID and count subsets
	for (int i = 0; i < static_cast<int>(lcf::Data::battlecommands.commands.size()); ++i) {
		auto& cmd = lcf::Data::battlecommands.commands[i];
		if (i >= idx) {
			break;
		}
		if (cmd.type == lcf::rpg::BattleCommand::Type_subskill) {
			++subskill;
		}
	}

	// skill subset is 4 (Type_subskill) + counted subsets
	skill_window->SetSubsetFilter(subskill);
	SetState(State_SelectSkill);
	RecreateSpWindow(active_actor);
}

void Scene_Battle_Rpg2k3::SpecialSelected() {
	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));

	active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::DoNothing>(active_actor));

	ActionSelectedCallback(active_actor);
}

void Scene_Battle_Rpg2k3::EscapeSelected() {
	if (!IsEscapeAllowedFromActorCommand()) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		return;
	}
	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
	active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::Escape>(active_actor));
	ActionSelectedCallback(active_actor);
}

void Scene_Battle_Rpg2k3::RowSelected() {
	// Switching rows is only possible if in back row or
	// if at least 2 party members are in front row
	int current_row = active_actor->GetBattleRow();
	int front_row_battlers = 0;
	if (current_row == static_cast<int>(active_actor->IsDirectionFlipped())) {
		for (auto& actor: Main_Data::game_party->GetActors()) {
			if (actor->GetBattleRow() == static_cast<int>(actor->IsDirectionFlipped())) front_row_battlers++;
		}
	}
	if (current_row != static_cast<int>(active_actor->IsDirectionFlipped()) || front_row_battlers >= 2) {
		if (active_actor->GetBattleRow() == Game_Actor::RowType::RowType_front) {
			active_actor->SetBattleRow(Game_Actor::RowType::RowType_back);
		} else {
			active_actor->SetBattleRow(Game_Actor::RowType::RowType_front);
		}
		active_actor->SetBattlePosition(Game_Battle::Calculate2k3BattlePosition(*active_actor));
		active_actor->SetBattleAlgorithm(std::make_shared<Game_BattleAlgorithm::DoNothing>(active_actor));
		ActionSelectedCallback(active_actor);
	} else {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
	}
}

void Scene_Battle_Rpg2k3::ActionSelectedCallback(Game_Battler* for_battler) {
	for_battler->SetAtbGauge(0);

	if (for_battler == active_actor) {
		auto idx = GetNextReadyActor();
		SetActiveActor(idx);
	}

	Scene_Battle::ActionSelectedCallback(for_battler);

	if (for_battler->GetType() == Game_Battler::Type_Ally) {
		ReturnToMainBattleState();
	}

#ifdef EP_DEBUG_BATTLE2K3_STATE_MACHINE
	Output::Debug("Battle2k3 ScheduleAction {} name={} type={} frame={}",
			((for_battler->GetType() == Game_Battler::Type_Ally) ? "Actor" : "Enemy"),
			for_battler->GetName(), static_cast<int>(for_battler->GetBattleAlgorithm()->GetType()), Main_Data::game_system->GetFrameCounter());
#endif
}

void Scene_Battle_Rpg2k3::ShowNotification(std::string text) {
	if (text.empty()) {
		return;
	}
	help_window->SetVisible(true);
	help_window->SetText(std::move(text), Font::ColorDefault, Text::AlignLeft, false);
}

void Scene_Battle_Rpg2k3::EndNotification() {
	help_window->SetVisible(false);
}

bool Scene_Battle_Rpg2k3::CheckAnimFlip(Game_Battler* battler) {
	if (Main_Data::game_system->GetInvertAnimations()) {
		return battler->IsDirectionFlipped() ^ (battler->GetType() == Game_Battler::Type_Enemy);
	}
	return false;
}

void Scene_Battle_Rpg2k3::SetWait(int min_wait, int max_wait) {
	battle_action_wait = max_wait;
	battle_action_min_wait = max_wait - min_wait;
}

bool Scene_Battle_Rpg2k3::CheckWait() {
	if (battle_action_wait > 0) {
		if (Input::IsPressed(Input::CANCEL)) {
			return false;
		}
		--battle_action_wait;
		if (battle_action_wait > battle_action_min_wait) {
			return false;
		}
		if (!Input::IsPressed(Input::DECISION)
			&& !Input::IsPressed(Input::SHIFT)
			&& battle_action_wait > 0) {
			return false;
		}
		battle_action_wait = 0;
	}
	return true;
}

void Scene_Battle_Rpg2k3::OnPartyChanged(Game_Actor* actor, bool added) {
	if (!added) {
		actor->SetBattleSprite(nullptr);
		return;
	}

	actor->SetBattleSprite(std::make_unique<Sprite_Actor>(actor));

	// RPG_RT only does this when actors added to party
	// Wait until sprites loaded
	AsyncNext([this]() {
			InitActors();
			ResetAllBattlerZ();
			});
}

void Scene_Battle_Rpg2k3::OnEventHpChanged(Game_Battler* battler, int hp) {
	DrawFloatText(
			battler->GetBattlePosition().x,
			battler->GetBattlePosition().y,
			hp < 0 ? Font::ColorDefault : Font::ColorHeal,
			std::to_string(std::abs(hp)),
			battler,
			hp < 0 ? Scene_Battle_Rpg2k3::FloatTextType::Damage : Scene_Battle_Rpg2k3::FloatTextType::Heal);
}

void Scene_Battle_Rpg2k3::RecreateSpWindow(Game_Battler* battler) {
	bool small_window = (lcf::Data::battlecommands.window_size == lcf::rpg::BattleCommands::WindowSize_small);
	int spwindow_size = 60;
	int spwindow_height = (small_window ? 20 : 32);
	if (battler && battler->MaxSpValue() >= 1000) {
		spwindow_size = 72;
	}
	sp_window = std::make_unique<Window_ActorSp>(Player::screen_width - Player::menu_offset_x - spwindow_size, (small_window ? Player::menu_offset_y + 154 : Player::menu_offset_y + 136), spwindow_size, spwindow_height);
	sp_window->SetVisible(false);
	sp_window->SetBorderY(small_window ? 2 : 8);
	sp_window->SetContents(Bitmap::Create(sp_window->GetWidth() - sp_window->GetBorderX() / 2, sp_window->GetHeight() - sp_window->GetBorderY() * 2));
	sp_window->SetZ(Priority_Window + 2);
	if (battler) {
		sp_window->SetBattler(*battler);
	}
}

void Scene_Battle_Rpg2k3::CBAInit() {
	auto* source = cba_action->GetSource();
	cba_move_frame = 0;

	auto* actor = static_cast<Game_Actor*>(source);
	auto* sprite = actor->GetActorBattleSprite();
	if (!cba_direction_back) {
		cba_start_pos = source->GetBattlePosition();
		if (sprite) {
			sprite->SetAnimationState(Sprite_Actor::AnimationState_WalkingLeft);
		}
		if (cba_action->GetCBAMovement() == lcf::rpg::BattlerAnimationItemSkill::Movement_move) {
			auto* target = cba_action->GetTarget();
			if (target != nullptr) {
				auto* enemy = static_cast<Game_Enemy*>(target);
				auto* enemysprite = enemy->GetEnemyBattleSprite();
				if (enemysprite) {
					cba_end_pos = Point(target->GetBattlePosition().x + (source->IsDirectionFlipped() ? -(enemysprite->GetWidth() / 2) : enemysprite->GetWidth() / 2), target->GetBattlePosition().y);
				}
			}
		}
	} else {
		if (sprite) {
			if (cba_action->GetType() == Game_BattleAlgorithm::Type::Normal || cba_action->GetCBAMovement() == lcf::rpg::BattlerAnimationItemSkill::Movement_move) {
				sprite->SetAnimationState(Sprite_Actor::AnimationState_WalkingRight);
			} else {
				sprite->SetAnimationState(Sprite_Actor::AnimationState_WalkingLeft);
			}
		}
	}

	if (cba_action->GetCBAMovement() != lcf::rpg::BattlerAnimationItemSkill::Movement_none) {
		sprite->SetAfterimageAmount(cba_action->GetCBAAfterimage() == lcf::rpg::BattlerAnimationItemSkill::Afterimage_add ? 3 : 0);
	}
}

void Scene_Battle_Rpg2k3::CBAMove() {
	auto* source = cba_action->GetSource();

	if (cba_move_frame < cba_num_move_frames) {
		// RPG_RT increments the frame counter twice per frame,
		// so we emulate this behavior here
		cba_move_frame += 2;
		int frame = (cba_direction_back ? std::max(0, cba_num_move_frames - cba_move_frame) : std::min(cba_num_move_frames, cba_move_frame));
		int move_dir_mult = (source->IsDirectionFlipped() ? 1 : -1);
		int offset_x = 0;
		int offset_y = 0;
		if (cba_action->GetCBAMovement() == lcf::rpg::BattlerAnimationItemSkill::Movement_step || cba_action->GetCBAMovement() == lcf::rpg::BattlerAnimationItemSkill::Movement_jump) {
			offset_x = 25 * move_dir_mult * frame / cba_num_move_frames;
		}
		if (cba_action->GetCBAMovement() == lcf::rpg::BattlerAnimationItemSkill::Movement_jump) {
			offset_y = -25 * sin(M_PI * frame / cba_num_move_frames) / 2;
		}
		if (cba_action->GetCBAMovement() == lcf::rpg::BattlerAnimationItemSkill::Movement_move) {
			offset_x = (cba_end_pos.x - cba_start_pos.x) * frame / cba_num_move_frames;
			offset_y = (cba_end_pos.y - cba_start_pos.y) * frame / cba_num_move_frames;
		}
		source->SetBattlePosition(Point(cba_start_pos.x + offset_x, cba_start_pos.y + offset_y));

		if (source->GetType() == Game_Battler::Type_Ally) {
			auto* sprite = static_cast<Game_Actor*>(source)->GetActorBattleSprite();
			if (sprite) {
				sprite->ResetZ();
			}
		}
	}

	if (cba_move_frame >= cba_num_move_frames) {
		auto* actor = static_cast<Game_Actor*>(source);
		auto* sprite = actor->GetActorBattleSprite();
		if (sprite) {
			sprite->DoAfterimageFade();
		}
		if (cba_direction_back) {
			if (sprite) {
				sprite->DoIdleAnimation();
			}
			cba_action = nullptr;
		}
	}
}


/*end of file .\scene_battle_rpg2k3.cpp*/

/*start of file .\scene_debug.cpp*/

/* ... license chunk ... */

// Headers
#include <vector>
#include <sstream>
#include <cmath>
#include <iomanip>
#include "baseui.h"
#include "cache.h"
#include "input.h"
#include "game_variables.h"
#include "game_switches.h"
#include "game_strings.h"
#include "game_map.h"
#include "game_system.h"
#include "game_battle.h"
#include "scene_debug.h"
#include "scene_load.h"
#include "scene_menu.h"
#include "scene_save.h"
#include "scene_map.h"
#include "scene_battle.h"
#include "player.h"
#include "window_command.h"
#include "window_varlist.h"
#include "window_numberinput.h"
#include "bitmap.h"
#include "game_party.h"
#include "game_player.h"
#include <lcf/data.h>
#include "output.h"
#include "transition.h"
#include "lcf/reader_util.h"

namespace {
struct IndexSet {
	int range_index = 0;
	int range_page = 0;
	int range_page_index = 0;
};

std::array<IndexSet,Scene_Debug::eLastMainMenuOption> prev = {};
}

constexpr int arrow_animation_frames = 20;

Scene_Debug::Scene_Debug() {
	Scene::type = Scene::Debug;
}

void Scene_Debug::ResetPrevIndices() {
	prev = {};
}

void Scene_Debug::Start() {
	CreateRangeWindow();
	CreateVarListWindow();
	CreateNumberInputWindow();
	CreateChoicesWindow();
	CreateStringViewWindow();
	CreateInterpreterWindow();

	SetupUiRangeList();

	range_window->SetActive(true);
	var_window->SetActive(false);
	stringview_window->SetActive(false);
	interpreter_window->SetActive(false);

	UpdateRangeListWindow();
	RefreshDetailWindow();

	interpreter_states_cached = false;
}

Scene_Debug::StackFrame& Scene_Debug::GetFrame(int n) {
	auto i = stack_index - n;
	assert(i >= 0 && i < static_cast<int>(stack.size()));
	return stack[i];
}

const Scene_Debug::StackFrame& Scene_Debug::GetFrame(int n) const {
	auto i = stack_index - n;
	assert(i >= 0 && i < static_cast<int>(stack.size()));
	return stack[i];
}

int Scene_Debug::GetStackSize() const {
	return stack_index + 1;
}

Window_VarList::Mode Scene_Debug::GetWindowMode() const {
	return GetWindowMode(mode);
}

void Scene_Debug::UpdateFrameValueFromUi() {
	auto& frame = GetFrame();
	auto& idx = prev[mode];
	switch (frame.uimode) {
		case eUiMain:
			idx.range_index = range_index;
			idx.range_page = range_page;
			break;
		case eUiRangeList:
			idx.range_index = range_index;
			idx.range_page = range_page;
			frame.value = GetSelectedIndexFromRange() - 1;
			break;
		case eUiVarList:
			idx.range_page_index = var_window->GetItemIndex();
			frame.value = GetSelectedIndexFromRange() + var_window->GetItemIndex();
			break;
		case eUiNumberInput:
			frame.value = numberinput_window->GetNumber();
			break;
		case eUiChoices:
			frame.value = choices_window->GetIndex();
			break;
		case eUiStringView:
			frame.value = stringview_window->GetIndex();
			break;
		case eUiInterpreterView:
			idx.range_page_index = interpreter_window->GetIndex();
			frame.value = GetSelectedIndexFromRange() + interpreter_window->GetIndex();
			state_interpreter.selected_frame = interpreter_window->GetSelectedStackFrameLine();
			break;
	}
}

void Scene_Debug::Push(UiMode ui) {
	++stack_index;
	assert(stack_index < static_cast<int>(stack.size()));
	stack[stack_index] = { ui, 0 };

	range_window->SetActive(false);
	var_window->SetActive(false);
	interpreter_window->SetActive(false);
	interpreter_window->SetVisible(false);
	numberinput_window->SetActive(false);
	numberinput_window->SetVisible(false);
	stringview_window->SetActive(false);
	stringview_window->SetVisible(false);
}

int Scene_Debug::GetSelectedIndexFromRange() const {
	return GetSelectedIndexFromRange(GetWindowMode(), this->range_page, this->range_index);
}

int Scene_Debug::GetSelectedIndexFromRange(Window_VarList::Mode window_mode, int range_page, int range_index) const {
	switch (mode) {
		case eInterpreter:
			return range_page * 10 + range_index + 1;
		default:
			break;
	}
	if (window_mode == Window_VarList::eNone) {
		return range_page * 100 + range_index * 10 + 1;
	}
	const int item_count = var_window->GetItemCount();
	return range_page * item_count * 10 + range_index * item_count + 1;;
}


void Scene_Debug::RestoreRangeSelectionFromSelectedValue(int value) {
	switch (mode) {
		case eInterpreter:
			range_index = value % 10;
			range_page = value / 10;
			break;
		default:
			break;
	}
	auto window_mode = GetWindowMode();
	if (window_mode == Window_VarList::eNone) {
		range_index = (value % 100) / 10;
		range_page = value / 100;
	} else {
		const int item_count = var_window->GetItemCount();
		range_index = (value % (item_count * 10)) / item_count;
		range_page = value / (item_count * 10);
	}
}

void Scene_Debug::SetupUiRangeList() {
	auto& idx = prev[mode];
	auto vmode = GetWindowMode();

	range_index = idx.range_index;
	range_page = idx.range_page;

	var_window->SetMode(vmode);
	UpdateDetailWindow();

	range_window->SetIndex(range_index);
}

void Scene_Debug::PushUiRangeList() {
	Push(eUiRangeList);

	SetupUiRangeList();

	range_window->SetActive(true);

	UpdateRangeListWindow();
	RefreshDetailWindow();

	if (mode == eInterpreter) {
		interpreter_window->SetVisible(true);
	}
}

void Scene_Debug::PushUiVarList() {
	const bool was_range_list = (GetFrame().uimode == eUiRangeList);

	Push(eUiVarList);

	auto& idx = prev[mode];

	if (!was_range_list) {
		SetupUiRangeList();
	}

	var_window->SetActive(true);
	var_window->SetItemIndex(idx.range_page_index);

	UpdateRangeListWindow();
	var_window->Refresh();
}

void Scene_Debug::PushUiNumberInput(int init_value, int digits, bool show_operator) {
	Push(eUiNumberInput);

	numberinput_window->SetNumber(init_value);
	numberinput_window->SetShowOperator(show_operator);
	numberinput_window->SetVisible(true);
	numberinput_window->SetActive(true);
	numberinput_window->SetMaxDigits(digits);
	numberinput_window->Refresh();

	RefreshDetailWindow();
	UpdateRangeListWindow();
}

void Scene_Debug::PushUiChoices(std::vector<std::string> choices, std::vector<bool> choices_enabled) {
	Push(eUiChoices);

	choices_window->ReplaceCommands(choices);
	choices_window->SetY(Player::menu_offset_y + (choices.size() + 1) * 8 + 72);
	choices_window->SetHeight((choices.size() + 1) * 16);
	choices_window->SetVisible(true);
	choices_window->SetActive(true);
	choices_window->Refresh();

	for (int i = 0; i < static_cast<int>(choices_enabled.size()); i++) {
		choices_window->SetItemEnabled(i, choices_enabled[i]);
	}

	RefreshDetailWindow();
	UpdateRangeListWindow();
}

void Scene_Debug::PushUiStringView() {
	const auto str_id = GetFrame().value;

	auto value = ToString(Main_Data::game_strings->Get(str_id));

	if (value.empty()) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		return;
	}
	Push(eUiStringView);

	var_window->SetActive(false);
	stringview_window->SetActive(true);
	stringview_window->SetVisible(true);

	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));

#ifdef HAVE_NLOHMANN_JSON
	auto& json_cache = Main_Data::game_strings->_json_cache;

	auto it = json_cache.find(str_id);
	if (it != json_cache.end()) {
		stringview_window->SetDisplayData(value, it->second);
	} else {
		stringview_window->SetDisplayData(value);
	}
#else
	stringview_window->SetDisplayData(value);
#endif

	stringview_window->SetIndex(0);
	stringview_window->Refresh();
}

void Scene_Debug::PushUiInterpreterView() {
	const bool was_range_list = (GetFrame().uimode == eUiRangeList);

	if (!interpreter_window->IsValid()) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		return;
	}

	Push(eUiInterpreterView);

	if (!was_range_list) {
		SetupUiRangeList();
	}

	interpreter_window->SetVisible(true);
	var_window->SetVisible(false);

	interpreter_window->SetActive(true);
	interpreter_window->SetIndex(0);

	UpdateRangeListWindow();
	interpreter_window->Refresh();
}


void Scene_Debug::Pop() {
	range_window->SetActive(false);
	var_window->SetActive(false);
	numberinput_window->SetActive(false);
	numberinput_window->SetVisible(false);
	choices_window->SetActive(false);
	choices_window->SetVisible(false);
	stringview_window->SetActive(false);
	stringview_window->SetVisible(false);
	interpreter_window->SetActive(false);

	if (mode == eInterpreter) {
		interpreter_window->SetIndex(-1);
		interpreter_window->SetVisible(true);
		var_window->SetVisible(false);
	} else {
		var_window->SetIndex(-1);
		var_window->SetVisible(true);
		interpreter_window->SetVisible(false);
	}

	if (stack_index == 0) {
		Scene::Pop();
		return;
	}

	--stack_index;

	auto& frame = GetFrame();
	auto nui = frame.uimode;
	switch (nui) {
		case eUiMain:
			var_window->SetMode(Window_VarList::eNone);
			interpreter_window->SetVisible(false);
			range_index = (static_cast<int>(mode) - 1) % 10;
			range_page = (static_cast<int>(mode) - 1) / 10;
			range_window->SetActive(true);
			range_window->SetIndex(range_index);
			break;
		case eUiRangeList:
			range_window->SetActive(true);
			RestoreRangeSelectionFromSelectedValue(frame.value);
			range_window->SetIndex(range_index);
			break;
		case eUiVarList:
			var_window->SetActive(true);
			var_window->SetItemIndex((frame.value - 1) % var_window->GetItemCount());
			break;
		case eUiNumberInput:
			numberinput_window->SetNumber(frame.value);
			numberinput_window->SetActive(true);
			numberinput_window->SetVisible(true);
			break;
		case eUiChoices:
			choices_window->SetIndex(frame.value);
			choices_window->SetActive(true);
			choices_window->SetVisible(true);
			break;
		case eUiStringView:
			stringview_window->SetActive(true);
			stringview_window->SetVisible(true);
			break;
		case eUiInterpreterView:
			interpreter_window->SetActive(true);
			interpreter_window->SetIndex(frame.value - 1);
			var_window->SetVisible(false);
			interpreter_window->SetVisible(true);
			break;
	}

	if (stack_index == 0) {
		mode = eMain;
	}

	UpdateRangeListWindow();
	RefreshDetailWindow();
}

void Scene_Debug::vUpdate() {
	range_window->Update();
	if (range_index != range_window->GetIndex()){
		range_index = range_window->GetIndex();
		UpdateDetailWindow();
		RefreshDetailWindow();
	}
	var_window->Update();

	if (stringview_window->GetActive())
		stringview_window->Update();

	if (numberinput_window->GetActive())
		numberinput_window->Update();

	if (choices_window->GetActive())
		choices_window->Update();

	if (interpreter_window->GetActive())
		interpreter_window->Update();

	if (Input::IsTriggered(Input::CANCEL)) {
		UpdateFrameValueFromUi();
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		Pop();

		const auto sz = GetStackSize();
		if ((mode == eInterpreter) && sz == 4) {
			Pop(); //skip over choices window
		}
	} else if (Input::IsTriggered(Input::DECISION)) {
		UpdateFrameValueFromUi();
		if (mode == eMain) {
			auto next_mode = static_cast<Mode>(range_window->GetIndex() + range_page * 10 + 1);
			if (next_mode > eMain && next_mode <= GetNumMainMenuItems()) {
				if (!range_window->IsItemEnabled(range_window->GetIndex())) {
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
				} else {
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
					mode = next_mode;
				}
			}
		}

		const auto sz = GetStackSize();
		const auto& frame = GetFrame();

		if (frame.uimode == eUiRangeList && !range_window->IsItemEnabled(range_window->GetIndex())) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
			UpdateArrows();
			return;
		}

		switch (mode) {
			case eMain:
			case eLastMainMenuOption:
				break;
			case eSave:
				Scene::PopUntil(Scene::Map);
				Scene::Push(std::make_shared<Scene_Save>());
				break;
			case eLoad:
				Scene::Push(std::make_shared<Scene_Load>());
				mode = eMain;
				break;
			case eSwitch:
				if (sz > 2) {
					DoSwitch();
				} else if (sz > 1) {
					PushUiVarList();
				} else if (sz > 0) {
					PushUiRangeList();
				}
				break;
			case eVariable:
				if (sz > 3) {
					DoVariable();
				} else if (sz > 2) {
					if (Main_Data::game_variables->IsValid(frame.value)) {
						PushUiNumberInput(Main_Data::game_variables->Get(frame.value), Main_Data::game_variables->GetMaxDigits(), true);
					}
				} else if (sz > 1) {
					PushUiVarList();
				} else {
					PushUiRangeList();
				}
				break;
			case eGold:
				if (sz > 1) {
					DoGold();
				} else {
					PushUiNumberInput(Main_Data::game_party->GetGold(), 6, false);
					range_index = 0;
					range_window->SetIndex(range_index);
				}
				break;
			case eItem:
				if (sz > 3) {
					DoItem();
				} else if (sz > 2) {
					if (frame.value <= static_cast<int>(lcf::Data::items.size())) {
						PushUiNumberInput(Main_Data::game_party->GetItemCount(frame.value), Main_Data::game_party->GetMaxItemCount(frame.value) >= 100 ? 3 : 2, false);
					}
				} else if (sz > 1) {
					PushUiVarList();
				} else {
					PushUiRangeList();
				}
				break;
			case eBattle:
				if (sz > 2) {
					DoBattle();
				} else if (sz > 1) {
					PushUiVarList();
				} else {
					PushUiRangeList();
				}
				break;
			case eMap:
				if (sz > 4) {
					DoMap();
				} else if (sz > 3) {
					// FIXME: Remember previous y
					PushUiNumberInput(GetFrame(-1).value, 4, false);
				} else if (sz > 2) {
					const auto map_id = GetFrame().value;
					if (IsValidMapId(map_id)) {
						// Reset x and y values
						GetFrame(-1).value = 0;
						GetFrame(-2).value = 0;
						PushUiNumberInput(GetFrame(-1).value, 4, false);
					}
				} else if (sz > 1) {
					PushUiVarList();
				} else {
					PushUiRangeList();
				}
				break;
			case eFullHeal:
				if (sz > 1) {
					DoFullHeal();
				} else {
					PushUiVarList();
				}
				break;
			case eLevel:
				if (sz > 2) {
					DoLevel();
				} else if (sz > 1) {
					if (frame.value <= static_cast<int>(Main_Data::game_party->GetActors().size())) {
						auto* actor = Main_Data::game_party->GetActors()[frame.value - 1];
						PushUiNumberInput(actor->GetLevel(), actor->GetMaxLevel() >= 100 ? 3 : 2, false);
					}
				} else {
					PushUiVarList();
				}
				break;
			case eMoveSpeed:
				if (sz > 1) {
					DoMoveSpeed();
				} else {
					PushUiNumberInput(Main_Data::game_player->GetMoveSpeed(), 1, false);
					range_index = 0;
					range_window->SetIndex(range_index);
				}
				break;
			case eCallCommonEvent:
				if (sz > 2) {
					DoCallCommonEvent();
				} else if (sz > 1) {
					PushUiVarList();
				} else {
					PushUiRangeList();
				}
				break;
			case eCallMapEvent:
				if (sz > 3) {
					DoCallMapEvent();
				} else if (sz > 2) {
					auto* event = Game_Map::GetEvent(GetFrame().value);
					if (event) {
						const auto num_digits = static_cast<int>(std::log10(event->GetNumPages()) + 1);
						PushUiNumberInput(1, num_digits, false);
					}
				} else if (sz > 1) {
					PushUiVarList();
				} else {
					PushUiRangeList();
				}
				break;
			case eCallBattleEvent:
				if (sz > 1) {
					DoCallBattleEvent();
				} else {
					auto* troop = Game_Battle::GetActiveTroop();
					if (troop) {
						const auto num_digits = static_cast<int>(std::log10(troop->pages.size()) + 1);
						PushUiNumberInput(0, num_digits, false);
					}
				}
				break;
			case eString:
				if (sz == 3) {
					PushUiStringView();
				} else if (sz == 2) {
					PushUiVarList();
				} else if (sz == 1) {
					PushUiRangeList();
				}
				break;
			case eInterpreter:
				if (sz == 3) {
					auto action = interpreter_window->GetSelectedAction();
					if (action == Window_Interpreter::UiAction::ShowStackItem) {
						/* */
					}
				} else if (sz == 2) {
					PushUiInterpreterView();
				} else if (sz == 1) {
					if (!interpreter_states_cached) {
						state_interpreter.background_states = Debug::ParallelInterpreterStates::GetCachedStates();
						interpreter_states_cached = true;
					}
					PushUiRangeList();
					interpreter_window->SetVisible(true);
					UpdateInterpreterWindow(GetSelectedIndexFromRange());
				}
				break;
			case eOpenMenu:
				DoOpenMenu();
				break;
		}
		Game_Map::SetNeedRefresh(true);
	} else if (range_window->GetActive() && Input::IsRepeated(Input::RIGHT)) {
		int range_page_prev = range_page;
		if (range_page < GetLastPage()) {
			++range_page;
		} else {
			range_page = 0;
		}
		if (range_page != range_page_prev) {
			UpdateDetailWindow();
			RefreshDetailWindow();
			UpdateRangeListWindow();
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
		}
	} else if (range_window->GetActive() && Input::IsRepeated(Input::LEFT)) {
		int range_page_prev = range_page;
		if (range_page > 0) {
			--range_page;
		} else {
			range_page = GetLastPage();
		}
		if (range_page != range_page_prev) {
			UpdateDetailWindow();
			RefreshDetailWindow();
			UpdateRangeListWindow();
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
		}
	} else if (range_window->GetActive() && Input::IsTriggered(Input::SHIFT)) {
		if (mode == eString) {
			var_window->SetShowDetail(!var_window->GetShowDetail());
			UpdateDetailWindow();
			RefreshDetailWindow();
			UpdateRangeListWindow();
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
		}
	}

	UpdateArrows();
}

void Scene_Debug::CreateRangeWindow() {

	std::vector<std::string> ranges;
	for (int i = 0; i < 10; i++)
		ranges.push_back("");
	range_window.reset(new Window_Command(ranges, 96));

	int height = 176;
	range_window->SetHeight(height);
	range_window->SetX(Player::menu_offset_x);
	range_window->SetY(Player::menu_offset_y + ((MENU_HEIGHT - height) / 2));
}

void Scene_Debug::UpdateRangeListWindow() {
	int idx = 0;
	const bool is_battle = Game_Battle::IsBattleRunning();

	auto addItem = [&](const auto& name, bool enabled = true) {
		range_window->SetItemText(idx, name);
		range_window->SetItemEnabled(idx, enabled);
		++idx;
	};

	auto fillRange = [&](Window_VarList::Mode mode) {
		auto prefix = Window_VarList::GetPrefix(mode);
		int digits = Window_VarList::GetDigitCount(mode);
		const int item_count = Window_VarList::GetItemCount(mode, var_window->GetShowDetail());
		assert(digits >= 2 && digits <= 5);

		// Allow some extra space when displaying switches & variables that go above the usual range
		if (mode == Window_VarList::eSwitch || mode == Window_VarList::eVariable) {
			const auto st = GetSelectedIndexFromRange(mode, range_page, 0);
			if (st > 9999) {
				digits = 5;
				prefix = prefix.substr(0, 1);
			} else if (st > 99999) {
				digits = 6;
				prefix = prefix.substr(0, 1);
			}
		}

		const int num_elements = Window_VarList::GetNumElements(mode);

		for (int i = 0; i < 10; i++) {
			const auto st = GetSelectedIndexFromRange(mode, range_page, i);
			if (st > num_elements) {
				addItem("", false);
				continue;
			}
			int end = st + item_count - 1;
			if (num_elements > 0 && end > num_elements) {
				end = num_elements;
			}
			switch (digits) {
				case 2:
					addItem(fmt::format("{}[{:02d}-{:02d}]", prefix, st, end));
					break;
				case 3:
					addItem(fmt::format("{}[{:03d}-{:03d}]", prefix, st, end));
					break;
				case 4:
					addItem(fmt::format("{}[{:04d}-{:04d}]", prefix, st, end));
					break;
				case 5:
					addItem(fmt::format("{}[{:05d}...{:02d}]", prefix, st, end % 100));
					break;
				case 6:
					addItem(fmt::format("{}[{:06d}..{:02d}]", prefix, st, end % 100));
					break;
				default: break;
			}
		}
	};

	switch (mode) {
		case eMain:
			if (range_page == 0) {
				addItem("Save", !is_battle);
				addItem("Load");
				addItem("Switches");
				addItem("Variables");
				addItem(lcf::Data::terms.gold.c_str());
				addItem("Items");
				addItem("Battle", !is_battle);
				addItem("Goto Map", !is_battle);
				addItem("Full Heal");
				addItem("Level");
			} else {
				addItem("Move Speed", !is_battle);
				addItem("Call ComEvent");
				addItem("Call MapEvent", Scene::Find(Scene::Map) != nullptr);
				addItem("Call BtlEvent", is_battle);
				addItem("Strings", Player::IsPatchManiac());
				addItem("Interpreter");
				addItem("Open Menu", !is_battle);
			}
			break;
		case eSwitch:
		case eVariable:
		case eItem:
		case eBattle:
		case eString:
			fillRange(GetWindowMode());
			break;
		case eMap:
			if (GetStackSize() > 3) {
				if (GetStackSize() > 4) {
					addItem("Map: " + std::to_string(GetFrame(2).value));
					addItem("X: " + std::to_string(GetFrame(1).value));
					addItem("Y: ");
				} else {
					addItem("Map: " + std::to_string(GetFrame(1).value));
					addItem("X: ");
				}
			} else {
				fillRange(Window_VarList::eMap);
			}
			break;
		case eCallCommonEvent:
			fillRange(GetWindowMode());
			break;
		case eCallMapEvent:
			if (GetStackSize() > 3) {
				auto* event = Game_Map::GetEvent(GetFrame(1).value);
				if (event) {
					addItem(fmt::format("{:04d}: {}", event->GetId(), event->GetName()));
					addItem(fmt::format("NumPages: {}", event->GetNumPages()));
					const auto* page = event->GetActivePage();
					const auto page_id = page ? page->ID : 0;
					addItem(fmt::format("ActvPage: {}", page_id));
					addItem(fmt::format("Enabled: {}", event->IsActive() ? 'Y' : 'N'));
					addItem(fmt::format("X: {}", event->GetX()));
					addItem(fmt::format("Y: {}", event->GetY()));
				}
			} else {
				fillRange(GetWindowMode());
			}
			break;
		case eGold:
			addItem(lcf::Data::terms.gold);
			for (int i = 1; i < 10; i++){
				range_window->SetItemText(i, "");
			}
			break;
		case eFullHeal:
			addItem("Full Heal");
			break;
		case eLevel:
			addItem("Level");
			break;
		case eMoveSpeed:
			addItem("Move Speed");
			addItem("Range: 1-7");
			break;
		case eCallBattleEvent:
			if (is_battle) {
				auto* troop = Game_Battle::GetActiveTroop();
				if (troop) {
					addItem(troop->name);
					addItem(fmt::format("TroopId: {}", troop->ID));
					addItem(fmt::format("NumEnemies: {}", troop->members.size()));
					addItem(fmt::format("NumPages: {}", troop->pages.size()));
				}
			}
			break;
		case eInterpreter:
		{
			auto& bg_states = state_interpreter.background_states;
			int skip_items = range_page * 10;
			int count_items = 0;
			if (range_page == 0) {
				addItem(fmt::format("{}Main", Game_Interpreter::GetForegroundInterpreter().GetState().wait_movement ? "(W) " : ""));
				skip_items = 1;
				count_items = 1;
			}
			for (int i = 0; i < bg_states.CountEventInterpreters() && count_items < 10; i++) {
				if (skip_items > 0) {
					skip_items--;
					continue;
				}
				const auto& [evt_id, state] = bg_states.GetEventInterpreter(i);
				addItem(fmt::format("{}EV{:04d}: {}", state.wait_movement ? "(W) " : "", evt_id, Game_Map::GetEvent(evt_id)->GetName()));
				count_items++;
			}
			for (int i = 0; i < bg_states.CountCommonEventInterpreters() && count_items < 10; i++) {
				if (skip_items > 0) {
					skip_items--;
					continue;
				}
				const auto& [ce_id, state] = bg_states.GetCommonEventInterpreter(i);
				auto* ce = lcf::ReaderUtil::GetElement(lcf::Data::commonevents, ce_id);
				addItem(fmt::format("{}CE{:04d}: {}", state.wait_movement ? "(W) " : "", ce_id, ce->name));
				count_items++;
			}
		}
		break;
		default:
			break;
	}

	while (idx < 10) {
		addItem("", true);
	}
}

void Scene_Debug::UpdateDetailWindow() {
	if (mode == eInterpreter) {
		UpdateInterpreterWindow(GetSelectedIndexFromRange());
	} else {
		var_window->UpdateList(GetSelectedIndexFromRange());
	}
}

void Scene_Debug::RefreshDetailWindow() {
	if (mode == eInterpreter) {
		interpreter_window->Refresh();
	} else {
		var_window->Refresh();
	}
}

void Scene_Debug::CreateVarListWindow() {
	var_window.reset(new Window_VarList());
	var_window->SetX(Player::menu_offset_x + range_window->GetWidth());
	var_window->SetY(range_window->GetY());
	var_window->SetVisible(false);
	var_window->SetIndex(-1);

	var_window->UpdateList(GetSelectedIndexFromRange());
}

void Scene_Debug::CreateNumberInputWindow() {
	numberinput_window.reset(new Window_NumberInput(Player::menu_offset_x + 160 - (Main_Data::game_variables->GetMaxDigits() + 1) * 6 - 8, Player::menu_offset_y + 104,
		(Main_Data::game_variables->GetMaxDigits() + 1) * 12 + 16, 32));
	numberinput_window->SetVisible(false);
	numberinput_window->SetOpacity(255);
	numberinput_window->SetShowOperator(true);
}

void Scene_Debug::CreateChoicesWindow() {
	std::vector<std::string> vars;
	for (int i = 0; i < 2; i++)
		vars.push_back("");
	choices_window.reset(new Window_Command(vars));
	choices_window->SetX(Player::menu_offset_x + 160 - choice_window_width / 2);
	choices_window->SetY(Player::menu_offset_y + 104);
	choices_window->SetWidth(choice_window_width);
	choices_window->SetHeight(64);
	choices_window->SetVisible(false);
	choices_window->SetOpacity(255);
}

void Scene_Debug::CreateStringViewWindow() {
	stringview_window.reset(new Window_StringView(Player::menu_offset_x + 15, Player::menu_offset_y + 16, 288, 208));
	stringview_window->SetVisible(false);
	stringview_window->SetIndex(-1);
}

void Scene_Debug::CreateInterpreterWindow() {
	interpreter_window.reset(new Window_Interpreter(Player::menu_offset_x + range_window->GetWidth(), range_window->GetY(), 224, 176));
	interpreter_window->SetVisible(false);
	interpreter_window->SetIndex(-1);
}

int Scene_Debug::GetNumMainMenuItems() const {
	return static_cast<int>(eLastMainMenuOption) - 1;
}

int Scene_Debug::GetLastPage() const {
	size_t num_elements = 0;
	switch (mode) {
		case eMain:
			return GetNumMainMenuItems() / 10;
		case eSwitch:
			num_elements = Main_Data::game_switches->GetSizeWithLimit();
			break;
		case eVariable:
			num_elements = Main_Data::game_variables->GetSizeWithLimit();
			break;
		case eItem:
			num_elements = lcf::Data::items.size();
			break;
		case eBattle:
			num_elements = lcf::Data::troops.size();
			break;
		case eMap:
			num_elements = lcf::Data::treemap.maps.size() > 0 ? lcf::Data::treemap.maps.back().ID : 0;
			break;
		case eFullHeal:
			num_elements = Main_Data::game_party->GetBattlerCount() + 1;
			break;
		case eLevel:
			num_elements = Main_Data::game_party->GetBattlerCount();
			break;
		case eCallCommonEvent:
			num_elements = lcf::Data::commonevents.size();
			break;
		case eCallMapEvent:
			num_elements = Game_Map::GetHighestEventId();
			break;
		case eString:
			num_elements = Main_Data::game_strings->GetSizeWithLimit();
			break;
		case eInterpreter:
			num_elements = 1 + state_interpreter.background_states.Count();
			return (static_cast<int>(num_elements) - 1) / 10;
		default:
			break;
	}

	if (num_elements > 0) {
		return (static_cast<int>(num_elements) - 1) / 100;
	}
	return 0;
}

bool Scene_Debug::IsValidMapId(int map_id) const {
	auto iter = std::lower_bound(lcf::Data::treemap.maps.begin(), lcf::Data::treemap.maps.end(), map_id,
			[](const lcf::rpg::MapInfo& l, int r) { return l.ID < r; });
	return (iter != lcf::Data::treemap.maps.end()
			&& iter->ID == map_id
			&& iter->type == lcf::rpg::TreeMap::MapType_map);
}

void Scene_Debug::DoSwitch() {
	const auto sw_id = GetFrame().value;
	if (Main_Data::game_switches->IsValid(sw_id)) {
		Main_Data::game_switches->Flip(sw_id);
		Game_Map::SetNeedRefresh(true);

		RefreshDetailWindow();
	}
}

void Scene_Debug::DoVariable() {
	const auto var_id = GetFrame(1).value;
	const auto value = GetFrame(0).value;
	Main_Data::game_variables->Set(var_id, value);
	Game_Map::SetNeedRefresh(true);

	Pop();
}

void Scene_Debug::DoGold() {
	const auto delta = GetFrame().value - Main_Data::game_party->GetGold();
	Main_Data::game_party->GainGold(delta);

	Pop();
}

void Scene_Debug::DoItem() {
	const auto item_id = GetFrame(1).value;
	auto delta = GetFrame().value - Main_Data::game_party->GetItemCount(item_id);

	Main_Data::game_party->AddItem(item_id, delta);

	Game_Map::SetNeedRefresh(true);

	Pop();
}

void Scene_Debug::DoBattle() {
	auto troop_id = GetFrame(0).value;
	if (troop_id > static_cast<int>(lcf::Data::troops.size())) {
		return;
	}

	Scene::PopUntil(Scene::Map);
	if (!Scene::instance) {
		return;
	}

	BattleArgs args;
	args.troop_id = troop_id;
	args.first_strike = false;
	args.allow_escape = true;

	Output::Debug("Debug Scene starting battle {}.", troop_id);

	Game_Map::SetupBattle(args);

	Scene::Push(Scene_Battle::Create(std::move(args)));
}

void Scene_Debug::DoMap() {
	auto y = GetFrame(0).value;
	auto x = GetFrame(1).value;
	auto map_id = GetFrame(2).value;

	Scene::PopUntil(Scene::Map);
	if (Scene::instance) {
		Main_Data::game_player->ReserveTeleport(map_id, x, y, -1, TeleportTarget::eSkillTeleport);
	}
}

void Scene_Debug::DoFullHeal() {
	const auto id = GetFrame(0).value;

	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_UseItem));
	auto actors = Main_Data::game_party->GetActors();
	if (id <= 1) {
		for (auto& actor: actors) {
			actor->FullHeal();
		}
	} else {
		int idx = id - 2;
		if (idx < static_cast<int>(actors.size())) {
			actors[idx]->FullHeal();
		}
	}
	var_window->UpdateList(1);
	var_window->Refresh();
}

void Scene_Debug::DoLevel() {
	const auto id = GetFrame(1).value;
	const auto level = GetFrame(0).value;

	auto actors = Main_Data::game_party->GetActors();
	int idx = id - 1;
	if (idx < static_cast<int>(actors.size())) {
		if (actors[idx]->GetLevel() != level) {
			actors[idx]->ChangeLevel(level, nullptr);
		}
	}

	Pop();
}

void Scene_Debug::DoMoveSpeed() {
	Main_Data::game_player->SetMoveSpeed(Utils::Clamp<int>(GetFrame().value, 1, 7));

	Pop();
}

void Scene_Debug::DoCallCommonEvent() {
	const auto ceid = GetFrame(0).value;

	if (ceid > static_cast<int>(lcf::Data::commonevents.size())) {
		return;
	}

	auto& ce = Game_Map::GetCommonEvents()[ceid - 1];

	if (Game_Battle::IsBattleRunning()) {
		Game_Battle::GetInterpreter().Push<InterpreterExecutionType::DebugCall>(&ce);
		Scene::PopUntil(Scene::Battle);
		Output::Debug("Debug Scene Forced execution of common event {} on the battle foreground interpreter.", ce.GetIndex());
	} else {
		Game_Map::GetInterpreter().Push<InterpreterExecutionType::DebugCall>(&ce);
		Scene::PopUntil(Scene::Map);
		Output::Debug("Debug Scene Forced execution of common event {} on the map foreground interpreter.", ce.GetIndex());
	}
}

void Scene_Debug::DoCallMapEvent() {
	if (!Scene::Find(Scene::Map)) {
		return;
	}

	const auto me_id = GetFrame(1).value;
	const auto page_id = GetFrame(0).value;

	auto* me = Game_Map::GetEvent(me_id);
	if (!me) {
		return;
	}

	auto* page = me->GetPage(page_id);
	if (!page) {
		return;
	}

	if (Game_Battle::IsBattleRunning()) {
		Game_Battle::GetInterpreter().Push<InterpreterExecutionType::DebugCall>(me, page);
		Scene::PopUntil(Scene::Battle);
		Output::Debug("Debug Scene Forced execution of map event {} page {} on the battle foreground interpreter.", me->GetId(), page->ID);
	} else {
		Game_Map::GetInterpreter().Push<InterpreterExecutionType::DebugCall>(me, page);
		Scene::PopUntil(Scene::Map);
		Output::Debug("Debug Scene Forced execution of map event {} page {} on the map foreground interpreter.", me->GetId(), page->ID);
	}
}

void Scene_Debug::DoCallBattleEvent() {
	if (!Game_Battle::IsBattleRunning()) {
		return;
	}

	auto* troop = Game_Battle::GetActiveTroop();
	if (!troop) {
		return;
	}

	const auto page_idx = GetFrame(0).value - 1;

	if (page_idx < 0 || page_idx >= static_cast<int>(troop->pages.size())) {
		return;
	}

	auto& page = troop->pages[page_idx];

	Game_Battle::GetInterpreter().Push<InterpreterExecutionType::DebugCall, InterpreterEventType::BattleEvent>(page.event_commands, 0, false);
	Scene::PopUntil(Scene::Battle);
	Output::Debug("Debug Scene Forced execution of battle troop {} event page {} on the battle foreground interpreter.", troop->ID, page.ID);
}

void Scene_Debug::DoOpenMenu() {
	if (Scene::Find(Scene::Menu)) {
		Scene::PopUntil(Scene::Menu);
	} else {
		Scene::Push(std::make_shared<Scene_Menu>(), true);
	}
}

void Scene_Debug::TransitionIn(SceneType /* prev_scene */) {
	Transition::instance().InitShow(Transition::TransitionCutIn, this);
}

void Scene_Debug::TransitionOut(SceneType /* next_scene */) {
	Transition::instance().InitErase(Transition::TransitionCutOut, this);
}

void Scene_Debug::UpdateArrows() {
	bool show_left_arrow = (range_page > 0);
	bool show_right_arrow = (range_page < GetLastPage());

	if (show_left_arrow || show_right_arrow) {
		arrow_frame = (arrow_frame + 1) % (arrow_animation_frames * 2);
	}
	bool arrow_visible = (arrow_frame < arrow_animation_frames);
	range_window->SetLeftArrow(show_left_arrow && arrow_visible);
	range_window->SetRightArrow(show_right_arrow && arrow_visible);
}

void Scene_Debug::UpdateInterpreterWindow(int index) {
	lcf::rpg::SaveEventExecState state_display;
	std::string first_line = "";
	bool valid = false;

	auto& bg_states = state_interpreter.background_states;

	if (index == 1) {
		state_display = Game_Interpreter::GetForegroundInterpreter().GetState();
		first_line = Game_Battle::IsBattleRunning() ? "Foreground (Battle)" : "Foreground (Map)";
		valid = true;
	} else if (index <= bg_states.CountEventInterpreters()) {
		const auto& [evt_id, state] = bg_states.GetEventInterpreter(index - 1);
		first_line = Debug::FormatEventName(*Game_Map::GetEvent(evt_id));
		state_display = state;
		valid = true;
	} else if ((index - bg_states.CountEventInterpreters()) <= bg_states.CountCommonEventInterpreters()) {
		const auto& [ce_id, state] = bg_states.GetCommonEventInterpreter(index - bg_states.CountEventInterpreters() - 1);
		state_display = state;
		for (auto& ce : Game_Map::GetCommonEvents()) {
			if (ce.GetId() == ce_id) {
				first_line = Debug::FormatEventName(ce);
				valid = true;
				break;
			}
		}
	}

	if (valid) {
		state_interpreter.selected_state = index;
		interpreter_window->SetStackState(first_line, state_display);
	} else {
		state_interpreter.selected_state = -1;
		interpreter_window->SetStackState("", {});
	}
}

lcf::rpg::SaveEventExecFrame const& Scene_Debug::GetSelectedInterpreterFrameFromUiState() const {
	static lcf::rpg::SaveEventExecFrame empty;

	if (state_interpreter.selected_state <= 0 || state_interpreter.selected_frame < 0) {
		return empty;
	}

	Game_Interpreter_Inspector inspector;

	int index = state_interpreter.selected_state;
	const auto& bg_states = state_interpreter.background_states;

	if (index == 1) {
		auto const& state = inspector.GetForegroundExecState();
		return state.stack[state_interpreter.selected_frame];
	} else if (index <= bg_states.CountEventInterpreters()) {
		int evt_id = std::get<0>(bg_states.GetEventInterpreter(index - 1));
		auto ev = Game_Map::GetEvent(evt_id);

		auto const& state = inspector.GetExecState(*ev);
		return state.stack[state_interpreter.selected_frame];
	} else if ((index - bg_states.CountEventInterpreters()) <= bg_states.CountCommonEventInterpreters()) {
		int ce_id = std::get<0>(bg_states.GetEventInterpreter(index - bg_states.CountEventInterpreters() - 1));
		for (auto& ce : Game_Map::GetCommonEvents()) {
			if (ce.GetId() == ce_id) {
				auto const& state = inspector.GetExecState(ce);
				return state.stack[state_interpreter.selected_frame];
			}
		}
	}
	return empty;
}


/*end of file .\scene_debug.cpp*/

/*start of file .\scene_end.cpp*/

/* ... license chunk ... */

// Headers
#include <vector>
#include "audio.h"
#include "baseui.h"
#include "cache.h"
#include "game_system.h"
#include "input.h"
#include "scene_end.h"
#include "scene_menu.h"
#include "scene_title.h"
#include "util_macro.h"
#include "bitmap.h"
#include <player.h>

Scene_End::Scene_End(SceneType target_scene)
	: target_scene(target_scene) {

	Scene::type = Scene::End;
}

void Scene_End::Start() {
	CreateCommandWindow();
	CreateHelpWindow();
}

void Scene_End::vUpdate() {
	command_window->Update();

	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		Scene::Pop(); // Select End Game
	} else if (Input::IsTriggered(Input::DECISION)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
		switch (command_window->GetIndex()) {
		case 0: // Yes
			Main_Data::game_system->BgmFade(400);
			if (target_scene == Scene::Title) {
				Scene::ReturnToTitleScene();
			} else {
				Scene::PopUntil(target_scene);
			}
			break;
		case 1: // No
			Scene::Pop();
			break;
		}
	}
}

void Scene_End::CreateCommandWindow() {
	// Create Options Window
	std::vector<std::string> options;

	std::string term_yes = ToString(lcf::Data::terms.yes);
	if (term_yes.empty()) {
		term_yes = "Yes";
	}

	std::string term_no = ToString(lcf::Data::terms.no);
	if (term_no.empty()) {
		term_no = "No";
	}

	options.push_back(term_yes);
	options.push_back(term_no);

	command_window.reset(new Window_Command(options));
	command_window->SetX((Player::screen_width / 2) - (command_window->GetWidth() / 2));
	command_window->SetY(Player::menu_offset_y + 72 + 48);
	command_window->SetIndex(1);
}

void Scene_End::CreateHelpWindow() {
	std::string term_exit_message = ToString(lcf::Data::terms.exit_game_message);
	if (term_exit_message.empty()) {
		term_exit_message = "Do you really want to quit?";
	}

	int text_size = Text::GetSize(*Font::Default(), term_exit_message).width;

	int window_width = text_size + 16;

	help_window.reset(new Window_Help(Player::menu_offset_x + (MENU_WIDTH / 2) - (window_width / 2),
									  Player::menu_offset_y + 72, window_width, 32));
	help_window->SetText(term_exit_message, Font::ColorDefault, Text::AlignLeft, false);

	command_window->SetHelpWindow(help_window.get());
}


/*end of file .\scene_end.cpp*/

/*start of file .\scene_equip.cpp*/

/* ... license chunk ... */

// Headers
#include "scene_equip.h"
#include "game_actors.h"
#include "game_party.h"
#include "game_system.h"
#include "game_screen.h"
#include "input.h"
#include "player.h"
#include <lcf/reader_util.h>
#include "scene_menu.h"
#include <lcf/rpg/item.h>

Scene_Equip::Scene_Equip(std::vector<Game_Actor*> actors, int actor_index, int equip_index) :
	actors(actors), actor_index(actor_index), equip_index(equip_index) {
	type = Scene::Equip;

	assert(!actors.empty());
}

void Scene_Equip::Start() {
	// Create the windows
	int menu_help_height = 32;
	int menu_equip_status_width = 124;
	int menu_equip_status_height = 96;
	int menu_equip_height = 96;

	const auto& actor = *actors[actor_index];

	help_window.reset(new Window_Help(Player::menu_offset_x, Player::menu_offset_y, MENU_WIDTH, menu_help_height));
	equipstatus_window.reset(new Window_EquipStatus(Player::menu_offset_x, Player::menu_offset_y + menu_help_height, menu_equip_status_width, menu_equip_status_height, actor));
	equip_window.reset(new Window_Equip(Player::menu_offset_x + menu_equip_status_width, Player::menu_offset_y + menu_help_height, (MENU_WIDTH - menu_equip_status_width), menu_equip_height, actor));

	equip_window->SetIndex(equip_index);

	for (int i = 0; i < 5; ++i) {
		item_windows.push_back(std::make_shared<Window_EquipItem>(Player::menu_offset_x, Player::menu_offset_y + menu_help_height + menu_equip_status_height, MENU_WIDTH, MENU_HEIGHT - menu_help_height - menu_equip_status_height, actor, i));
	}

	// Assign the help windows
	for (size_t i = 0; i < item_windows.size(); ++i) {
		item_windows[i]->SetVisible((unsigned)equip_window->GetIndex() == i);
		item_windows[i]->SetHelpWindow(help_window.get());
		item_windows[i]->SetActive(false);
		item_windows[i]->Refresh();
	}
	equip_window->SetHelpWindow(help_window.get());
}

void Scene_Equip::vUpdate() {
	help_window->Update();

	UpdateEquipWindow();
	UpdateStatusWindow();
	UpdateItemWindows();

	if (equip_window->GetActive()) {
		UpdateEquipSelection();
	} else if (item_window->GetActive()) {
		UpdateItemSelection();
	}
}

void Scene_Equip::UpdateItemWindows() {
	for (size_t i = 0; i < item_windows.size(); ++i) {
		item_windows[i]->SetVisible((unsigned)equip_window->GetIndex() == i);
		item_windows[i]->Update();
	}

	item_window = item_windows[equip_window->GetIndex()];
}

void Scene_Equip::UpdateEquipWindow() {
	equip_window->Update();
}

void Scene_Equip::UpdateStatusWindow() {
	if (equip_window->GetActive()) {
		equipstatus_window->ClearParameters();
	} else if (item_window->GetActive()) {
		const lcf::rpg::Item* current_item = item_window->GetItem();

		const auto eidx = equip_window->GetIndex();
		const auto& actor = *actors[actor_index];

		auto atk = actor.GetBaseAtk(Game_Battler::WeaponAll, true, false);
		auto def = actor.GetBaseDef(Game_Battler::WeaponAll, true, false);
		auto spi = actor.GetBaseSpi(Game_Battler::WeaponAll, true, false);
		auto agi = actor.GetBaseAgi(Game_Battler::WeaponAll, true, false);

		auto add_item = [&](const lcf::rpg::Item* item, int mod = 1) {
			if (item) {
				atk += item->atk_points1 * mod;
				def += item->def_points1 * mod;
				spi += item->spi_points1 * mod;
				agi += item->agi_points1 * mod;
			}
		};

		for (int i = 1; i <= 5; i++) {
			auto* count_item = actor.GetEquipment(i);
			add_item(count_item, 1);
		}

		auto* old_item = actor.GetEquipment(eidx + 1);
		// If its a weapon or shield, get the other hand
		const lcf::rpg::Item* other_old_item = nullptr;
		if (eidx == 0) {
			other_old_item = actor.GetEquipment(eidx + 2);
		} else if (eidx == 1) {
			other_old_item = actor.GetEquipment(eidx);
		}

		add_item(old_item, -1);
		// If other hand had a two handed weapon, or we considering a 2 handed weapon, remove the other hand.
		if (current_item && other_old_item &&
				((other_old_item->type == lcf::rpg::Item::Type_weapon && other_old_item->two_handed) || (current_item->type == lcf::rpg::Item::Type_weapon && current_item->two_handed))) {
			add_item(other_old_item, -1);
		}
		add_item(current_item, 1);

		int limit = actor.MaxStatBaseValue();

		atk = Utils::Clamp(atk, 1, limit);
		def = Utils::Clamp(def, 1, limit);
		spi = Utils::Clamp(spi, 1, limit);
		agi = Utils::Clamp(agi, 1, limit);

		atk = actor.CalcValueAfterAtkStates(atk);
		def = actor.CalcValueAfterDefStates(def);
		spi = actor.CalcValueAfterSpiStates(spi);
		agi = actor.CalcValueAfterAgiStates(agi);

		equipstatus_window->SetNewParameters(atk, def, spi, agi);

		equipstatus_window->Refresh();
	}

	equipstatus_window->Update();
}

static bool CanRemoveEquipment(const Game_Actor& actor, int index) {
	if (actor.IsEquipmentFixed(true)) {
		return false;
	}
	auto* item = actor.GetEquipment(index + 1);
	if (item && item->cursed) {
		return false;
	}
	return true;
}

void Scene_Equip::UpdateEquipSelection() {
	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		Scene::Pop();
	} else if (Input::IsTriggered(Input::DECISION)) {
		const auto& actor = *actors[actor_index];
		if (!CanRemoveEquipment(actor, equip_window->GetIndex())) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
			return;
		}

		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
		equip_window->SetActive(false);
		item_window->SetActive(true);
		item_window->SetIndex(0);
	} else if (actors.size() > 1 && Input::IsTriggered(Input::RIGHT)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
		actor_index = (actor_index + 1) % actors.size();
		Scene::Push(std::make_shared<Scene_Equip>(actors, actor_index, equip_window->GetIndex()), true);
	} else if (actors.size() > 1 && Input::IsTriggered(Input::LEFT)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
		actor_index = actor_index - 1;
		if (actor_index < 0) {
			actor_index = actors.size() - 1;
		}
		Scene::Push(std::make_shared<Scene_Equip>(actors, actor_index, equip_window->GetIndex()), true);
	}
}

void Scene_Equip::UpdateItemSelection() {
	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		equip_window->SetActive(true);
		item_window->SetActive(false);
		item_window->SetIndex(-1);
	} else if (Input::IsTriggered(Input::DECISION)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));

		const lcf::rpg::Item* current_item = item_window->GetItem();
		int current_item_id = current_item ? current_item->ID : 0;
		auto& actor = *actors[actor_index];

		actor.ChangeEquipment(
			equip_window->GetIndex() + 1, current_item_id);

		equip_window->SetActive(true);
		item_window->SetActive(false);
		item_window->SetIndex(-1);

		equip_window->Refresh();

		for (size_t i = 0; i < item_windows.size(); ++i) {
			item_windows[i]->Refresh();
		}
	}
}


/*end of file .\scene_equip.cpp*/

/*start of file .\scene_file.cpp*/

/* ... license chunk ... */

// Headers
#include <algorithm>
#include <sstream>
#include <vector>
#include "baseui.h"
#include "cache.h"
#include <lcf/data.h>
#include "game_system.h"
#include "game_party.h"
#include "input.h"
#include <lcf/lsd/reader.h>
#include "player.h"
#include "scene_file.h"
#include "bitmap.h"
#include <lcf/reader_util.h>
#include "output.h"

#ifdef EMSCRIPTEN
#  include <emscripten.h>
#  include "platform/emscripten/interface.h"
#endif

constexpr int arrow_animation_frames = 20;

Scene_File::Scene_File(std::string message) :
	message(message) {
}

std::unique_ptr<Sprite> Scene_File::MakeBorderSprite(int y) {
	int border_height = 8;
	auto bitmap = Bitmap::Create(MENU_WIDTH, border_height, Cache::System()->GetBackgroundColor());
	auto sprite = std::unique_ptr<Sprite>(new Sprite());
	sprite->SetVisible(true);
	sprite->SetZ(Priority_Window + 1);
	sprite->SetBitmap(bitmap);
	sprite->SetX(Player::menu_offset_x);
	sprite->SetY(y);
	return sprite;
}

std::unique_ptr<Sprite> Scene_File::MakeArrowSprite(bool down) {
	int sprite_width = 8;
	int sprite_height = 8;

	Rect rect = Rect(40, (down ? 16 : sprite_height), 16, sprite_height);
	auto bitmap = Bitmap::Create(*(Cache::System()), rect);
	auto sprite = std::unique_ptr<Sprite>(new Sprite());
	sprite->SetVisible(false);
	sprite->SetZ(Priority_Window + 2);
	sprite->SetBitmap(bitmap);
	sprite->SetX((MENU_WIDTH / 2) - sprite_width + Player::menu_offset_x);
	sprite->SetY(down ? Player::screen_height - sprite_height : 32);
	return sprite;
}

void Scene_File::CreateHelpWindow() {
	help_window.reset(new Window_Help(Player::menu_offset_x, 0, MENU_WIDTH, 32));
	help_window->SetText(message);
	help_window->SetZ(Priority_Window + 1);
}

void Scene_File::PopulatePartyFaces(Window_SaveFile& win, int /* id */, lcf::rpg::Save& savegame) {
	win.SetParty(savegame.title);
	win.SetHasSave(true);
}

void Scene_File::UpdateLatestTimestamp(int id, lcf::rpg::Save& savegame) {
	if (savegame.title.timestamp > latest_time) {
		latest_time = savegame.title.timestamp;
		latest_slot = id;
	}
}

void Scene_File::PopulateSaveWindow(Window_SaveFile& win, int id) {
	// Try to access file
	std::stringstream ss;
	ss << "Save" << (id <= 8 ? "0" : "") << (id + 1) << ".lsd";

	std::string file = fs.FindFile(ss.str());

	if (!file.empty()) {
		// File found
		auto save_stream = FileFinder::Save().OpenInputStream(file);
		if (!save_stream) {
			Output::Debug("Save {} read error", file);
			win.SetCorrupted(true);
			return;
		}

		std::unique_ptr<lcf::rpg::Save> savegame = lcf::LSD_Reader::Load(save_stream, Player::encoding);

		if (savegame) {
			PopulatePartyFaces(win, id, *savegame);
			UpdateLatestTimestamp(id, *savegame);
		} else {
			Output::Debug("Save {} corrupted", file);
			win.SetCorrupted(true);
		}
	}
}

void Scene_File::Start() {
	CreateHelpWindow();
	border_top = Scene_File::MakeBorderSprite(32);

	// Refresh File Finder Save Folder
	fs = FileFinder::Save();

	for (int i = 0; i < Utils::Clamp<int32_t>(lcf::Data::system.easyrpg_max_savefiles, 3, 99); i++) {
		std::shared_ptr<Window_SaveFile>
			w(new Window_SaveFile(Player::menu_offset_x, 40 + i * 64, MENU_WIDTH, 64));
		w->SetIndex(i);
		w->SetZ(Priority_Window);
		PopulateSaveWindow(*w, i);
		w->Refresh();

		file_windows.push_back(w);
	}

	border_bottom = Scene_File::MakeBorderSprite(Player::screen_height - 8);

	up_arrow = Scene_File::MakeArrowSprite(false);
	down_arrow = Scene_File::MakeArrowSprite(true);

	index = latest_slot;
	top_index = std::max(0, index - 2);

	RefreshWindows();

	for (auto& fw: file_windows) {
		fw->Update();
	}

	std::vector<std::string> commands;
#ifdef EMSCRIPTEN
	commands.emplace_back("Download Savegame");
	commands.emplace_back("Upload Savegame");
#endif
	extra_commands_window = std::make_unique<Window_Command>(commands);
	extra_commands_window->SetZ(Priority_Window + 100);
	extra_commands_window->SetVisible(false);
}

void Scene_File::RefreshWindows() {
	for (int i = 0; i < (int)file_windows.size(); i++) {
		Window_SaveFile *w = file_windows[i].get();
		w->SetY(40 + (i - top_index) * 64);
		w->SetActive(i == index);
		w->Refresh();
	}
}

void Scene_File::Refresh() {
	for (int i = 0; i < Utils::Clamp<int32_t>(lcf::Data::system.easyrpg_max_savefiles, 3, 99); i++) {
		Window_SaveFile *w = file_windows[i].get();
		PopulateSaveWindow(*w, i);
		w->Refresh();
	}
}

void Scene_File::vUpdate() {
	UpdateArrows();

	if (IsWindowMoving()) {
		for (auto& fw: file_windows) {
			fw->Update();
		}
		return;
	}

	if (HandleExtraCommandsWindow()) {
		return;
	}

	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		Scene::Pop();
	} else if (Input::IsTriggered(Input::DECISION)) {
		if (IsSlotValid(index)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
			Action(index);
		}
		else {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		}
	} else if (Input::IsTriggered(Input::SHIFT)) {
#ifdef EMSCRIPTEN
		extra_commands_window->SetX(SCREEN_TARGET_WIDTH - extra_commands_window->GetWidth() - 8);
		extra_commands_window->SetY(file_windows[index]->GetY() + 8);
		extra_commands_window->SetItemEnabled(0, file_windows[index]->IsValid() && file_windows[index]->HasParty());
		extra_commands_window->SetVisible(true);
		return;
#endif
	}

	int old_top_index = top_index;
	int old_index = index;
	int max_index = static_cast<int>(file_windows.size()) - 1;

	if (Input::IsRepeated(Input::DOWN) || Input::IsTriggered(Input::SCROLL_DOWN)) {
		if (Input::IsTriggered(Input::DOWN) || Input::IsTriggered(Input::SCROLL_DOWN)
			|| index < max_index) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
			index = (index + 1) % file_windows.size();
		}

		//top_index = std::max(top_index, index - 3 + 1);
	}
	if (Input::IsRepeated(Input::UP) || Input::IsTriggered(Input::SCROLL_UP)) {
		if (Input::IsTriggered(Input::UP) || Input::IsTriggered(Input::SCROLL_UP)
			|| index >= 1) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
			index = (index + max_index) % file_windows.size();
		}

		//top_index = std::min(top_index, index);
	}

	if (Input::IsRepeated(Input::PAGE_DOWN) && index < max_index) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
		index = (index + 3 <= max_index) ? index + 3 : max_index;
	}
	if (Input::IsRepeated(Input::PAGE_UP) && index >= 1) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
		index = (index > 3) ? index - 3 : 0;
	}

	if (index > top_index + 2) {
		MoveFileWindows((top_index + 2 - index) * 64, 7);
		top_index = std::max(top_index, index - 3 + 1);
	}
	else if (index < top_index) {
		MoveFileWindows((top_index - index) * 64, 7);
		top_index = std::min(top_index, index);
	}

	//top_index = std::min(top_index, std::max(top_index, index - 3 + 1));

	if (top_index != old_top_index || index != old_index)
		RefreshWindows();

	for (auto& fw: file_windows) {
		fw->Update();
	}
}


bool Scene_File::IsWindowMoving() const {
	for (auto& fw: file_windows) {
		if (fw->IsMovementActive()) {
			return true;
		}
	}
	return false;
}

void Scene_File::MoveFileWindows(int dy, int dt) {
	for (auto& fw: file_windows) {
		fw->InitMovement(fw->GetX(), fw->GetY(), fw->GetX(), fw->GetY() + dy, dt);
	}
}

void Scene_File::UpdateArrows() {
	int max_index = static_cast<int>(file_windows.size()) - 1;

	bool show_up_arrow = (top_index > 0);
	bool show_down_arrow = (top_index < max_index - 2);

	if (show_up_arrow || show_down_arrow) {
		arrow_frame = (arrow_frame + 1) % (arrow_animation_frames * 2);
	}
	bool arrow_visible = (arrow_frame < arrow_animation_frames);
	up_arrow->SetVisible(show_up_arrow && arrow_visible);
	down_arrow->SetVisible(show_down_arrow && arrow_visible);
}

bool Scene_File::HandleExtraCommandsWindow() {
	if (!extra_commands_window->IsVisible()) {
		return false;
	}

	extra_commands_window->Update();

#ifdef EMSCRIPTEN
	if (Input::IsTriggered(Input::DECISION)) {
		if (extra_commands_window->GetIndex() == 0) {
			// Download
			if (!extra_commands_window->IsItemEnabled(0)) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
				return true;
			}

			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
			Emscripten_Interface::DownloadSavegame(index + 1);
			extra_commands_window->SetVisible(false);
		} else {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
			Emscripten_Interface::UploadSavegame(index + 1);
			extra_commands_window->SetVisible(false);
		}
	} else if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		extra_commands_window->SetVisible(false);
	}
#endif

	return true;
}


/*end of file .\scene_file.cpp*/

/*start of file .\scene_gamebrowser.cpp*/

/* ... license chunk ... */

// Headers
#include "scene_gamebrowser.h"

#include <memory>
#include "options.h"
#include "scene_settings.h"
#include "audio_midi.h"
#include "audio_secache.h"
#include "cache.h"
#include "game_system.h"
#include "input.h"
#include "player.h"
#include "scene_logo.h"
#include "bitmap.h"
#include "audio.h"
#include "output.h"

Scene_GameBrowser::Scene_GameBrowser() {
	type = Scene::GameBrowser;
}

void Scene_GameBrowser::Start() {
	initial_debug_flag = Player::debug_flag;
	Main_Data::game_system = std::make_unique<Game_System>();
	Main_Data::game_system->SetSystemGraphic(CACHE_DEFAULT_BITMAP, lcf::rpg::System::Stretch_stretch, lcf::rpg::System::Font_gothic);
	stack.push_back({ FileFinder::Game(), 0 });
	CreateWindows();
	Game_Clock::ResetFrame(Game_Clock::now());
}

void Scene_GameBrowser::Continue(SceneType /* prev_scene */) {
	Main_Data::game_system->BgmStop();

	Cache::ClearAll();
	AudioSeCache::Clear();
	MidiDecoder::Reset();
	lcf::Data::Clear();
	Player::ResetGameObjects();

	// Restore the base resolution
	Player::RestoreBaseResolution();

	Player::game_title = "";
	Player::game_title_original = "";

	Player::translation.Reset();

	Font::ResetDefault();

	Main_Data::game_system = std::make_unique<Game_System>();
	Main_Data::game_system->SetSystemGraphic(CACHE_DEFAULT_BITMAP, lcf::rpg::System::Stretch_stretch, lcf::rpg::System::Font_gothic);

	Player::debug_flag = initial_debug_flag;
}

void Scene_GameBrowser::vUpdate() {
	if (game_loading) {
		BootGame();
		return;
	}

	command_window->Update();
	gamelist_window->Update();

	if (command_window->GetActive()) {
		UpdateCommand();
	}
	else if (gamelist_window->GetActive()) {
		UpdateGameListSelection();
	}
}

void Scene_GameBrowser::CreateWindows() {
	// Create Options Window
	std::vector<std::string> options;

	options.push_back("Games");
	options.push_back("Settings");
	options.push_back("About");
	options.push_back("Exit");

	command_window = std::make_unique<Window_Command_Horizontal>(options, Player::screen_width);
	command_window->SetY(32);
	command_window->SetIndex(0);

	gamelist_window = std::make_unique<Window_GameList>(0, 64, Player::screen_width, Player::screen_height - 64);
	gamelist_window->Refresh(stack.back().filesystem, false);

	if (stack.size() == 1 && !gamelist_window->HasValidEntry()) {
		command_window->DisableItem(0);
	}

	help_window = std::make_unique<Window_Help>(0, 0, Player::screen_width, 32);
	help_window->SetText("EasyRPG Player - RPG Maker 2000/2003 interpreter");

	load_window = std::make_unique<Window_Help>(Player::screen_width / 4, Player::screen_height / 2 - 16, Player::screen_width / 2, 32);
	load_window->SetText("Loading...");
	load_window->SetVisible(false);

	about_window = std::make_unique<Window_About>(0, 64, Player::screen_width, Player::screen_height - 64);
	about_window->Refresh();
	about_window->SetVisible(false);
}

void Scene_GameBrowser::UpdateCommand() {
	int menu_index = command_window->GetIndex();

	switch (menu_index) {
		case GameList:
			gamelist_window->SetVisible(true);
			about_window->SetVisible(false);
			break;
		case About:
			gamelist_window->SetVisible(false);
			about_window->SetVisible(true);
			break;
		default:
			break;
	}

	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		Scene::Pop();
	} else if (Input::IsTriggered(Input::DECISION)) {

		switch (menu_index) {
			case GameList:
				if (stack.size() == 1 && !gamelist_window->HasValidEntry()) {
					return;
				}
				command_window->SetActive(false);
				command_window->SetIndex(-1);
				gamelist_window->SetActive(true);
				gamelist_window->SetIndex(old_gamelist_index);
				break;
			case About:
				break;
			case Options:
				Scene::Push(std::make_shared<Scene_Settings>());
				break;
			default:
				Scene::Pop();
		}
	}
}

void Scene_GameBrowser::UpdateGameListSelection() {
	if (Input::IsTriggered(Input::CANCEL)) {
		command_window->SetActive(true);
		command_window->SetIndex(0);
		gamelist_window->SetActive(false);
		old_gamelist_index = gamelist_window->GetIndex();
		gamelist_window->SetIndex(-1);
	} else if (Input::IsTriggered(Input::DECISION)) {
		load_window->SetVisible(true);
		game_loading = true;
	} else if (Input::IsTriggered(Input::DEBUG_MENU) || Input::IsTriggered(Input::SHIFT)) {
		Player::debug_flag = true;
		load_window->SetVisible(true);
		game_loading = true;
	}
}

void Scene_GameBrowser::BootGame() {
	if (stack.size() > 1 && gamelist_window->GetIndex() == 0) {
		// ".." -> Go one level up
		int index = stack.back().index;
		stack.pop_back();
		gamelist_window->Refresh(stack.back().filesystem, stack.size() > 1);
		gamelist_window->SetIndex(index);
		load_window->SetVisible(false);
		game_loading = false;
		return;
	}

	auto entry = gamelist_window->GetFilesystemEntry();

	if (!entry.fs) {
		Output::Warning("The selected file or directory cannot be opened");
		load_window->SetVisible(false);
		game_loading = false;
		return;
	}

	if (entry.type == FileFinder::ProjectType::Unknown) {
		// Fetched again for platforms where the type is not populated due to bad IO performance
		entry.type = FileFinder::GetProjectType(entry.fs);
	}

	if (entry.type > FileFinder::ProjectType::Supported) {
		// Game is using a known unsupported engine
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		Output::Warning(
				"{} has unsupported engine {}",
				FileFinder::GetPathAndFilename(entry.fs.GetFullPath()).second,
				FileFinder::kProjectType.tag(entry.type)
		);
		load_window->SetVisible(false);
		game_loading = false;
		return;
	}

	if (entry.type == FileFinder::ProjectType::Unknown && !FileFinder::OpenViewToEasyRpgFile(entry.fs)) {
		// Not a game: Open as directory
		load_window->SetVisible(false);
		game_loading = false;
		if (!gamelist_window->Refresh(entry.fs, true)) {
			Output::Warning("The selected file or directory cannot be opened");
			return;
		}
		stack.push_back({ entry.fs, gamelist_window->GetIndex() });
		gamelist_window->SetIndex(0);

		return;
	}

	FileFinder::SetGameFilesystem(entry.fs);
	Player::CreateGameObjects();

	game_loading = false;
	load_window->SetVisible(false);

	auto logos = Scene_Logo::LoadLogos();
	if (!logos.empty()) {
		// Delegate to Scene_Logo when a startup graphic was found
		Scene::Push(std::make_shared<Scene_Logo>(std::move(logos), 1));
		return;
	}

	Scene::PushTitleScene();
}


/*end of file .\scene_gamebrowser.cpp*/

/*start of file .\scene_gameover.cpp*/

/* ... license chunk ... */

// Headers
#include "scene_gameover.h"
#include "bitmap.h"
#include "cache.h"
#include "game_system.h"
#include "input.h"
#include "main_data.h"
#include "transition.h"
#include "player.h"

Scene_Gameover::Scene_Gameover() {
	type = Scene::Gameover;
}

void Scene_Gameover::Start() {
	if (!lcf::Data::system.gameover_name.empty()) {
		FileRequestAsync* request = AsyncHandler::RequestFile("GameOver", lcf::Data::system.gameover_name);
		request->SetGraphicFile(true);
		request_id = request->Bind(&Scene_Gameover::OnBackgroundReady, this);
		request->Start();
	}
	// Play gameover music
	Main_Data::game_system->BgmPlay(Main_Data::game_system->GetSystemBGM(Main_Data::game_system->BGM_GameOver));
}

void Scene_Gameover::vUpdate() {
	if (Input::IsTriggered(Input::DECISION)) {
		Scene::ReturnToTitleScene();
	}
}

void Scene_Gameover::OnBackgroundReady(FileRequestResult* result) {
	// Load Background Graphic
	background.reset(new Sprite());

	BitmapRef bitmapRef = Cache::Gameover(result->file);
	background->SetBitmap(bitmapRef);

	// If the sprite doesn't fill the screen, center it to support custom resolutions
	if (bitmapRef->GetWidth() < Player::screen_width) {
		background->SetX(Player::menu_offset_x);
	}
	if (bitmapRef->GetHeight() < Player::screen_height) {
		background->SetY(Player::menu_offset_y);
	}
}

void Scene_Gameover::TransitionIn(SceneType /* prev_scene */) {
	Transition::instance().InitShow(Transition::TransitionFadeIn, this, 80);
}

void Scene_Gameover::TransitionOut(SceneType /* next_scene */) {
	Transition::instance().InitErase(Transition::TransitionFadeOut, this, 80);
}


/*end of file .\scene_gameover.cpp*/

/*start of file .\scene_import.cpp*/

/* ... license chunk ... */

// Headers
#include <sstream>
#include "filefinder.h"
#include "game_system.h"
#include "input.h"
#include <lcf/lsd/reader.h>
#include "output.h"
#include "player.h"
#include "scene_file.h"
#include "scene_import.h"

Scene_Import::Scene_Import() :
	Scene_File(Player::meta->GetExVocabImportSaveHelpText()) {
	Scene::type = Scene::Load;  // For all intents and purposes, treat Import as an extension of Load
}

void Scene_Import::PopulateSaveWindow(Window_SaveFile& win, int id) {
	// File access is already determined
	if (id < static_cast<int>(files.size())) {
		win.SetDisplayOverride(files[id].short_path, files[id].file_id);

		std::unique_ptr<lcf::rpg::Save> savegame =
			lcf::LSD_Reader::Load(files[id].full_path, Player::encoding);

		if (savegame.get()) {
			PopulatePartyFaces(win, id, *savegame);
			UpdateLatestTimestamp(id, *savegame);
		} else {
			win.SetCorrupted(true);
		}
	} else {
		win.SetDisplayOverride("No lcf::Data", 0);
	}
}

void Scene_Import::Start() {
	CreateHelpWindow();
	border_top = Scene_File::MakeBorderSprite(32);

	// For consistency, we only show 15 windows
	// We don't populate them until later (once we've loaded all potential importable files).
	for (int i = 0; i < 15; i++) {
		std::shared_ptr<Window_SaveFile>
			w(new Window_SaveFile(0, 40 + i * 64, Player::screen_width, 64));
		w->SetIndex(i);
		w->SetVisible(false);
		w->SetZ(Priority_Window);

		file_windows.push_back(w);
	}

	// Create a window to show scanning progress, since this can take a while.
	progress_window.reset(new Window_ImportProgress(Player::screen_width/4, 40 + 64, Player::screen_width/2, 64));
	progress_window->SetZ(Priority_Window + 1);

	border_bottom = Scene_File::MakeBorderSprite(232);

	index = latest_slot;
	top_index = std::max(0, index - 2);

	Scene_File::Start();

	Refresh();
	Update();
}

void Scene_Import::vUpdate() {
	if (progress_window->IsVisible()) {
		UpdateScanAndProgress();
		return;
	}

	Scene_File::vUpdate();
}

void Scene_Import::UpdateScanAndProgress() {
	// Every tick, we still check for user input specifically for canceling...
	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		Scene::Pop();
		return;
	}

	// Leads to better fading.
	if (!first_frame_skipped) {
		first_frame_skipped = true;
		return;
	}

	// Gather the list of children, if it does not exist.
	if (children.empty()) {
		std::string parentPath = FileFinder::Save().MakePath("../");
		if (FileFinder::Save().Exists("../")) {
			parent_fs = FileFinder::Root().Create(parentPath);
			if (parent_fs) {
				children = Player::meta->GetImportChildPaths(parent_fs);
			}
		}
		if (children.empty()) {
			FinishScan();
		}
	} else if (curr_child_id < children.size()) {
		auto candidates = Player::meta->SearchImportPaths(parent_fs, children[curr_child_id]);
		files.insert(files.end(), candidates.begin(), candidates.end());

		progress_window->SetProgress((curr_child_id*100)/children.size(), children[curr_child_id]);
		curr_child_id += 1;
	} else {
		FinishScan();
	}
}

void Scene_Import::FinishScan() {
	for (int i = 0; i < 15; i++) {
		auto w = file_windows[i];
		PopulateSaveWindow(*w, i);
		w->Refresh();
		w->SetVisible(true);
	}
	progress_window->SetVisible(false);
}

void Scene_Import::Action(int index) {
	Player::LoadSavegame(files[index].full_path);
}

bool Scene_Import::IsSlotValid(int index) {
	return index < static_cast<int>(files.size());
}


/*end of file .\scene_import.cpp*/

/*start of file .\scene_item.cpp*/

/* ... license chunk ... */

// Headers
#include "scene_item.h"
#include "game_map.h"
#include "game_party.h"
#include "game_player.h"
#include "game_switches.h"
#include "game_system.h"
#include "game_targets.h"
#include "input.h"
#include <lcf/reader_util.h>
#include "scene_actortarget.h"
#include "scene_map.h"
#include "scene_teleport.h"
#include "output.h"
#include "transition.h"
#include "player.h"

Scene_Item::Scene_Item(int item_index) :
	item_index(item_index) {
	Scene::type = Scene::Item;
}

void Scene_Item::Start() {
	// Create the windows
	int menu_help_height = 32;
	help_window.reset(new Window_Help(Player::menu_offset_x, Player::menu_offset_y, MENU_WIDTH, menu_help_height));
	item_window.reset(new Window_Item(Player::menu_offset_x, Player::menu_offset_y + menu_help_height, MENU_WIDTH, MENU_HEIGHT - menu_help_height));
	item_window->SetHelpWindow(help_window.get());
	item_window->Refresh();
	item_window->SetIndex(item_index);
}

void Scene_Item::Continue(SceneType /* prev_scene */) {
	item_window->Refresh();
}

void Scene_Item::vUpdate() {
	help_window->Update();
	item_window->Update();

	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		Scene::Pop();
	} else if (Input::IsTriggered(Input::DECISION)) {
		int item_id = item_window->GetItem() == NULL ? 0 : item_window->GetItem()->ID;

		if (item_id > 0 && item_window->CheckEnable(item_id)) {
			// The party only has valid items
			const lcf::rpg::Item& item = *item_window->GetItem();

			if (item.type == lcf::rpg::Item::Type_switch) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
				Main_Data::game_party->ConsumeItemUse(item_id);
				Main_Data::game_switches->Set(item.switch_id, true);
				Scene::PopUntil(Scene::Map);
				Game_Map::SetNeedRefresh(true);
			} else if (item.type == lcf::rpg::Item::Type_special && item.skill_id > 0) {
				const lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, item.skill_id);
				if (!skill) {
					Output::Warning("Scene Item: Item references invalid skill ID {}", item.skill_id);
					return;
				}

				if (skill->type == lcf::rpg::Skill::Type_teleport) {
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
					Scene::Push(std::make_shared<Scene_Teleport>(item, *skill));
				} else if (skill->type == lcf::rpg::Skill::Type_escape) {
					Main_Data::game_party->ConsumeItemUse(item_id);
					Main_Data::game_system->SePlay(skill->sound_effect);

					Main_Data::game_player->ForceGetOffVehicle();
					Main_Data::game_player->ReserveTeleport(Main_Data::game_targets->GetEscapeTarget());

					Scene::PopUntil(Scene::Map);
				} else if (skill->type == lcf::rpg::Skill::Type_switch) {
					Main_Data::game_party->ConsumeItemUse(item_id);
					Main_Data::game_system->SePlay(skill->sound_effect);
					Main_Data::game_switches->Set(skill->switch_id, true);
					Scene::PopUntil(Scene::Map);
					Game_Map::SetNeedRefresh(true);
				} else {
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
					Scene::Push(std::make_shared<Scene_ActorTarget>(item_id));
					item_index = item_window->GetIndex();
				}
			} else {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
				Scene::Push(std::make_shared<Scene_ActorTarget>(item_id));
				item_index = item_window->GetIndex();
			}
		} else {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		}
	}
}

void Scene_Item::TransitionOut(Scene::SceneType next_scene) {
	const auto* item = item_window->GetItem();
	const lcf::rpg::Skill* skill = nullptr;
	if (item && item->type == lcf::rpg::Item::Type_special && item->skill_id > 0) {
		skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, item->skill_id);
	}

	if (next_scene == Map && skill && skill->type == lcf::rpg::Skill::Type_escape) {
		Transition::instance().InitErase(Transition::TransitionFadeOut, this);
	} else {
		Scene::TransitionOut(next_scene);
	}
}


/*end of file .\scene_item.cpp*/

/*start of file .\scene_language.cpp*/

/* ... license chunk ... */
#include "scene_language.h"
#include "scene_logo.h"
#include "audio.h"
#include "bitmap.h"
#include "input.h"
#include "game_system.h"
#include "cache.h"
#include "input_buttons.h"
#include "input_source.h"
#include "keys.h"
#include "main_data.h"
#include "options.h"
#include "player.h"
#include "baseui.h"
#include "output.h"
#include "scene_title.h"
#include "utils.h"
#include "scene_end.h"
#include "window_about.h"
#include "window_command_horizontal.h"
#include "window_help.h"
#include "window_input_settings.h"
#include "window_numberinput.h"
#include "window_selectable.h"
#include "window_settings.h"
#include <memory>

Scene_Language::Scene_Language() {
	Scene::type = Scene::LanguageMenu;
}

void Scene_Language::CreateTitleGraphic() {
	// Load Title Graphic
	if (lcf::Data::system.title_name.empty()) {
		return;
	}
	title = std::make_unique<Sprite>();
	FileRequestAsync* request = AsyncHandler::RequestFile("Title", lcf::Data::system.title_name);
	request->SetGraphicFile(true);
	request_id = request->Bind(&Scene_Language::OnTitleSpriteReady, this);
	request->Start();
}


void Scene_Language::CreateTranslationWindow() {
	// Build a list of 'Default' and all known languages.
	std::vector<std::string> lang_names;
	lang_names.push_back("Default Language");
	lang_dirs.push_back("");
	lang_helps.push_back("Play the game in its original language.");

	// Push menu entries with the display name, but also save the directory location and help text.
	for (const Language& lg : Player::translation.GetLanguages()) {
		lang_names.push_back(lg.lang_name);
		lang_dirs.push_back(lg.lang_dir);
		lang_helps.push_back(lg.lang_desc);
	}

	// Allow overwriting text of the default language
	const Language& def = Player::translation.GetDefaultLanguage();
	if (!def.lang_name.empty()) {
		lang_names.front() = def.lang_name;
	}
	if (!def.lang_desc.empty()) {
		lang_helps.front() = def.lang_desc;
	}

	translate_window = std::make_unique<Window_Command>(lang_names, -1, lang_names.size() > 9 ? 9 : static_cast<int>(lang_names.size()));
	translate_window->UpdateHelpFn = [this](Window_Help& win, int index) {
		if (index >= 0 && index < static_cast<int>(lang_helps.size())) {
			win.SetText(lang_helps[index]);
		}
		else {
			win.SetText("");
		}
	};
	Scene_Title::RepositionWindow(*translate_window, Player::hide_title_flag);

	if (Player::IsRPG2k3E() && lcf::Data::battlecommands.transparency == lcf::rpg::BattleCommands::Transparency_transparent) {
		translate_window->SetBackOpacity(160);
		translate_window->SetBackgroundPreserveTransparentColor(true);
	}

	translate_window->SetVisible(false);
}

void Scene_Language::CreateHelpWindow() {
	help_window.reset(new Window_Help(0, 0, Player::screen_width, 32));

	if (Player::IsRPG2k3E() && lcf::Data::battlecommands.transparency == lcf::rpg::BattleCommands::Transparency_transparent) {
		help_window->SetBackOpacity(160);
		help_window->SetBackgroundPreserveTransparentColor(true);
	}

	help_window->SetVisible(false);
	translate_window->SetHelpWindow(help_window.get());
}

void Scene_Language::Start() {
	CreateTitleGraphic();
	CreateTranslationWindow();
	CreateHelpWindow();

	translate_window->SetActive(true);
	translate_window->SetVisible(true);
	help_window->SetVisible(true);
}


void Scene_Language::vUpdate() {
	if (shutdown) {
		PopOrTitle();
		return;
	}

	translate_window->Update();
	help_window->Update();


	if (Input::IsTriggered(Input::DECISION)) {
		int index = translate_window->GetIndex();
		ChangeLanguage(lang_dirs.at(index));
	}
	else if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));

		auto peek_scene = Scene::Peek();
		if (!peek_scene || peek_scene->type == SceneType::Null || peek_scene->type == SceneType::Logo) {
			Transition::instance().InitErase(Transition::TransitionFadeOut, this);
		}
		Scene::Pop();
	}
}

void Scene_Language::OnTranslationChanged() {
	Main_Data::game_system->ReloadSystemGraphic();

	Scene::OnTranslationChanged();
}

void Scene_Language::OnTitleSpriteReady(FileRequestResult* result) {
	BitmapRef bitmapRef = Cache::Title(result->file);

	title->SetBitmap(bitmapRef);

	// If the title sprite doesn't fill the screen, center it to support custom resolutions
	if (bitmapRef->GetWidth() < Player::screen_width) {
		title->SetX(Player::menu_offset_x);
	}
	if (bitmapRef->GetHeight() < Player::screen_height) {
		title->SetY(Player::menu_offset_y);
	}
}

void Scene_Language::ChangeLanguage(const std::string& lang_str) {
	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));

	// No-op?
	if (lang_str == Player::translation.GetCurrentLanguage().lang_dir) {
		PopOrTitle();
		return;
	}

	// First change the language
	Player::translation.SelectLanguage(lang_str);
	Main_Data::game_system->ReloadSystemGraphic();

	// Delay scene shutdown by one frame to allow async requests for language change
	// and system graphic reload to finish before the scene switches
	shutdown = true;
}

void Scene_Language::PopOrTitle() {
	if (!Find(Title)) {
		Scene::Push(std::make_shared<Scene_Title>(), true);
	} else {
		Scene::Pop();
	}
}


/*end of file .\scene_language.cpp*/

/*start of file .\scene_load.cpp*/

/* ... license chunk ... */

// Headers
#include <sstream>
#include "filefinder.h"
#include "output.h"
#include "player.h"
#include "scene_load.h"
#include "scene_map.h"

Scene_Load::Scene_Load() :
	Scene_File(ToString(lcf::Data::terms.load_game_message)) {
	Scene::type = Scene::Load;
}

void Scene_Load::Action(int index) {
	std::string save_name = fs.FindFile(fmt::format("Save{:02d}.lsd", index + 1));

	Player::LoadSavegame(save_name, index + 1);
}

bool Scene_Load::IsSlotValid(int index) {
	return file_windows[index]->IsValid();
}


/*end of file .\scene_load.cpp*/

/*start of file .\scene_logo.cpp*/

/* ... license chunk ... */

// Headers
#include "scene_logo.h"
#include "async_handler.h"
#include "bitmap.h"
#include "exe_reader.h"
#include "filefinder.h"
#include "game_battle.h"
#include "input.h"
#include "options.h"
#include "player.h"
#include "scene_gamebrowser.h"
#include "scene_settings.h"
#include "output.h"
#include "generated/logo.h"
#include "generated/logo2.h"
#include "utils.h"
#include "rand.h"
#include "text.h"
#include "version.h"
#include <ctime>
#include <memory>

Scene_Logo::Scene_Logo() :
	frame_counter(0) {
	type = Scene::Logo;
	skip_logos = Player::debug_flag || Game_Battle::battle_test.enabled;
}

Scene_Logo::Scene_Logo(std::vector<std::vector<uint8_t>> logos, unsigned current_logo_index) :
	frame_counter(0), logos(std::move(logos)), current_logo_index(current_logo_index) {

	type = Scene::Logo;

	assert(current_logo_index > 0);
	detected_game = true;
}

void Scene_Logo::Start() {
	if (!skip_logos) {
		logo_img = LoadLogo();
		DrawTextOnLogo(false);
		DrawLogo(logo_img);
	}
}

void Scene_Logo::vUpdate() {
	if (current_logo_index == 0 && frame_counter == 0) {
		Font::ResetDefault();

		if (!DetectGame()) {
			// async delay for emscripten
			return;
		}

		logos = LoadLogos();
	}

	++frame_counter;

	if (Input::IsPressed(Input::SHIFT)) {
		DrawTextOnLogo(true);
		--frame_counter;
	}

	// Allow calling the settings when the first logo was shown (startup completed)
	if (current_logo_index > 0 && Input::IsTriggered(Input::SETTINGS_MENU)) {
		Scene::Push(std::make_shared<Scene_Settings>());
	}

	// other logos do not invoke the slow CreateGameObjects: display them longer
	bool frame_limit_reached = (frame_counter == (current_logo_index == 0 ? 60 : 90));

	if (skip_logos ||
		frame_limit_reached ||
		Input::IsTriggered(Input::DECISION) ||
		Input::IsTriggered(Input::CANCEL)) {

		if (detected_game) {
			if (!skip_logos) {
				// Check for another logo
				if (current_logo_index < logos.size()) {
					Scene::Push(std::make_shared<Scene_Logo>(std::move(logos), current_logo_index + 1), true);
					return;
				}
			}

			Scene::PushTitleScene(true);

			if (Player::load_game_id > 0) {
				auto save = FileFinder::Save();

				std::stringstream ss;
				ss << "Save" << (Player::load_game_id <= 9 ? "0" : "") << Player::load_game_id << ".lsd";

				Output::Debug("Loading Save {}", ss.str());

				std::string save_name = save.FindFile(ss.str());
				Player::LoadSavegame(save_name, Player::load_game_id);
			}
		}
		else {
			Scene::Push(std::make_shared<Scene_GameBrowser>(), true);
		}
	}
}

bool Scene_Logo::DetectGame() {
	auto fs = FileFinder::Game();
	if (!fs) {
		fs = FileFinder::Root().Create(Main_Data::GetDefaultProjectPath());
		if (!fs) {
			Output::Error("{} is not a valid path", Main_Data::GetDefaultProjectPath());
		}
		FileFinder::SetGameFilesystem(fs);
	}

#ifdef EMSCRIPTEN
	static bool once = true;
	if (once) {
		FileRequestAsync* index = AsyncHandler::RequestFile("index.json");
		index->SetImportantFile(true);
		request_id = index->Bind(&Scene_Logo::OnIndexReady, this);
		once = false;
		index->Start();
		return false;
	}
	if (!async_ready) {
		return false;
	}
#endif

	if (FileFinder::IsValidProject(fs) || FileFinder::OpenViewToEasyRpgFile(fs)) {
		FileFinder::SetGameFilesystem(fs);
		Player::CreateGameObjects();
		detected_game = true;
	}

	return true;
}

BitmapRef Scene_Logo::LoadLogo() {
	BitmapRef current_logo;
	std::time_t t = std::time(nullptr);
	std::tm* tm = std::localtime(&t);

	if (current_logo_index == 0) {
		// Load the built-in logo
		if (Rand::ChanceOf(1, 32) || (tm->tm_mday == 1 && tm->tm_mon == 3)) {
			current_logo = Bitmap::Create(easyrpg_logo2, sizeof(easyrpg_logo2), false);
		}
		else {
			current_logo = Bitmap::Create(easyrpg_logo, sizeof(easyrpg_logo), false);
		}
	} else {
		// Load external logos
		const auto& logo_bytes = logos[current_logo_index - 1];
		current_logo = Bitmap::Create(logo_bytes.data(), logo_bytes.size(), false);
	}

	return current_logo;
}

void Scene_Logo::DrawLogo(BitmapRef logo_img) {
	logo = std::make_unique<Sprite>();
	logo->SetBitmap(logo_img);
	logo->SetX((Player::screen_width - logo->GetWidth()) / 2);
	logo->SetY((Player::screen_height - logo->GetHeight()) / 2);
}

void Scene_Logo::DrawBackground(Bitmap& dst) {
	dst.Clear();
}

void Scene_Logo::DrawTextOnLogo(bool verbose) {
	if (current_logo_index > 0) {
		// only render version info on EasyRPG startup logo
		return;
	}

	Rect text_rect = { 17, 215, 320 - 32, 16 * verbose }; //last argument (rect height) is now 0 to remove a black rectangle that appears as text background color.
	Color text_color = {185, 199, 173, 255};
	Color shadow_color = {69, 69, 69, 255};
	logo_img->ClearRect(text_rect);

	for (auto& color: {shadow_color, text_color}) {
		logo_img->TextDraw(text_rect, color, "v" + Version::GetVersionString(verbose, verbose), Text::AlignLeft);
		if (!verbose) {
			logo_img->TextDraw(text_rect, color, WEBSITE_ADDRESS, Text::AlignRight);
		}
		text_rect.x--;
		text_rect.y--;
	}
}

std::vector<std::vector<uint8_t>> Scene_Logo::LoadLogos() {
	if (Player::player_config.show_startup_logos.Get() == ConfigEnum::StartupLogos::None) {
		return {};
	}

	std::vector<std::vector<uint8_t>> logos;

	for (int i = 1; i < 100; ++i) {
		auto is = FileFinder::OpenImage("Logo", "LOGO" + std::to_string(i));
		if (is) {
			logos.push_back(Utils::ReadStream(is));
		} else {
			break;
		}
	}

#ifndef EMSCRIPTEN
	if (logos.empty()) {
		// Attempt reading Logos from RPG_RT.exe (not supported on Emscripten)
		auto exeis = FileFinder::Game().OpenFile(EXE_NAME);

		if (exeis) {
			std::unique_ptr<EXEReader> exe_reader = std::make_unique<EXEReader>(std::move(exeis));
			logos = exe_reader->GetLogos();
		}
	}
#endif

	return logos;
}

void Scene_Logo::OnIndexReady(FileRequestResult*) {
	async_ready = true;

	if (!FileFinder::Game().Exists("index.json")) {
		Output::Debug("index.json not found. The game does not exist or was not correctly deployed.");
		return;
	}

	AsyncHandler::CreateRequestMapping("index.json");

	auto startup_files = Utils::MakeSvArray(
		DATABASE_NAME, // Essential game files
		TREEMAP_NAME,
		INI_NAME,
		EASYRPG_INI_NAME, // EasyRPG specific configuration
		"Font/ExFont", // Custom ExFont
		"Font/Font", // Custom Gothic Font
		"Font/Font2", // Custom Mincho Font
		"easyrpg.soundfont", // Custom SF2 soundfont
		"autorun.script", // Key Patch Startup script,
		"Logo/Logo1", // up to 3 custom startup logos
		"Logo/Logo2",
		"Logo/Logo3"
	);

	for (auto file: startup_files) {
		FileRequestAsync* req = AsyncHandler::RequestFile(file);
		req->SetImportantFile(true);
		req->Start();
	}
}


/*end of file .\scene_logo.cpp*/

/*start of file .\scene_map.cpp*/

/* ... license chunk ... */

// Headers
#include "scene_map.h"
#include "scene_save.h"
#include "scene_debug.h"
#include "scene_settings.h"
#include "main_data.h"
#include "game_map.h"
#include "game_message.h"
#include "game_party.h"
#include "game_player.h"
#include "game_system.h"
#include "game_screen.h"
#include "game_pictures.h"
#include "game_variables.h"
#include <lcf/rpg/system.h>
#include <lcf/lsd/reader.h>
#include "player.h"
#include "transition.h"
#include "audio.h"
#include "input.h"
#include "game_dynrpg.h"

using namespace std::chrono_literals;

static bool GetRunForegroundEvents(TeleportTarget::Type tt) {
	switch (tt) {
		case TeleportTarget::eForegroundTeleport:
			return true;
		case TeleportTarget::eParallelTeleport:
		case TeleportTarget::eSkillTeleport:
		case TeleportTarget::eAsyncQuickTeleport:
			break;
	}
	return false;
}

Scene_Map::Scene_Map(int from_save_id)
	: from_save_id(from_save_id)
{
	type = Scene::Map;

	SetUseSharedDrawables(true);

	// New Game and Load Game always have a delay, so it set it by default in constructor.
	SetDelayFrames(Scene::kStartGameDelayFrames);
}

Scene_Map::~Scene_Map() {
}

void Scene_Map::Start() {
	Scene_Debug::ResetPrevIndices();
	spriteset.reset(new Spriteset_Map());
	message_window.reset(new Window_Message(Player::message_box_offset_x, Player::screen_height - MESSAGE_BOX_HEIGHT, MESSAGE_BOX_WIDTH, MESSAGE_BOX_HEIGHT));

	Game_Message::SetWindow(message_window.get());

	// Called here instead of Scene Load, otherwise wrong graphic stack
	// is used.
	if (from_save_id > 0) {
		auto current_music = Main_Data::game_system->GetCurrentBGM();
		Main_Data::game_system->BgmStop();
		Main_Data::game_system->BgmPlay(current_music);
		Main_Data::game_dynrpg->Load(from_save_id);
	} else {
		Game_Map::PlayBgm();
	}

	Main_Data::game_screen->InitGraphics();
	Main_Data::game_pictures->InitGraphics();
	Game_Clock::ResetFrame(Game_Clock::now());

	Start2(MapUpdateAsyncContext());
}

void Scene_Map::StartFromSave(int from_save_id) {
	this->from_save_id = from_save_id;
	Start();
}

void Scene_Map::Start2(MapUpdateAsyncContext actx) {
	PreUpdate(actx);

	if (actx.IsActive()) {
		OnAsyncSuspend([this,actx]() { Start2(actx); }, actx.GetAsyncOp(), true);
		return;
	}

	if (Main_Data::game_player->IsPendingTeleport()) {
		TeleportParams tp;
		auto tt = Main_Data::game_player->GetTeleportTarget().GetType();
		tp.run_foreground_events = GetRunForegroundEvents(tt);
		tp.erase_screen = false;
		tp.use_default_transition_in = true;
		tp.defer_recursive_teleports = false;
		StartPendingTeleport(tp);
		return;
	}

	// We do the start game fade in transition here instead of TransitionIn callback,
	// in order to make async logic work properly.
	auto& transition = Transition::instance();
	if (transition.IsErasedNotActive()) {
		transition.InitShow(Transition::TransitionFadeIn, this);
	}

	// Call any requested scenes when transition is done.
	AsyncNext([this]() { UpdateSceneCalling(); });
}

void Scene_Map::Continue(SceneType prev_scene) {
	Game_Message::SetWindow(message_window.get());

	if (prev_scene == Scene::Battle) {
		Game_Map::OnContinueFromBattle();
	}

	// Player cast Escape / Teleport from menu
	if (Main_Data::game_player->IsPendingTeleport()) {
		auto tt = Main_Data::game_player->GetTeleportTarget().GetType();
		TeleportParams tp;
		tp.run_foreground_events = GetRunForegroundEvents(tt);
		tp.erase_screen = false;
		tp.use_default_transition_in = true;
		tp.defer_recursive_teleports = (tt == TeleportTarget::eSkillTeleport);
		FinishPendingTeleport(tp);
		return;
	}

	UpdateGraphics();
}

void Scene_Map::UpdateGraphics() {
	spriteset->Update();
}

void Scene_Map::TransitionIn(SceneType prev_scene) {
	auto& transition = Transition::instance();

	// Teleport already setup a transition.
	if (transition.IsActive()) {
		return;
	}

	// If an event erased the screen, don't transition in.
	if (screen_erased_by_event) {
		return;
	}

	if (prev_scene == Scene::Battle) {
		transition.InitShow(Main_Data::game_system->GetTransition(Main_Data::game_system->Transition_EndBattleShow), this);
		return;
	}

	Scene::TransitionIn(prev_scene);
}

void Scene_Map::TransitionOut(SceneType next_scene) {
	auto& transition = Transition::instance();

	if (next_scene != Scene::Battle
			&& next_scene != Scene::Debug
			&& next_scene != Scene::Settings
			&& next_scene != Scene::LanguageMenu) {
		screen_erased_by_event = false;
	}

	if (next_scene == Scene::Debug) {
		transition.InitErase(Transition::TransitionCutOut, this);
		return;
	}

	if (next_scene == Scene::Battle) {
		if (!transition.IsErasedNotActive()) {
			auto tt = Main_Data::game_system->GetTransition(Main_Data::game_system->Transition_BeginBattleErase);
			if (tt == Transition::TransitionNone) {
				// If transition type is none, RPG_RT flashes and then waits 40 frames before starting the battle.
				transition.InitErase(Transition::TransitionCutOut, this, 40);
			} else {
				transition.InitErase(tt, this);
			}
			transition.PrependFlashes(31, 31, 31, 31, 10, 2);
		} else {
			// If screen is already erased, RPG_RT does nothing for 40 frames.
			transition.InitErase(Transition::TransitionNone, this, 40);
		}
		return;
	}

	if (next_scene == Scene::Gameover) {
		transition.InitErase(Transition::TransitionFadeOut, this);
		return;
	}

	if (next_scene == Scene::Title) {
		Main_Data::game_system->BgmStop();
	}

	Scene::TransitionOut(next_scene);
}

void Scene_Map::DrawBackground(Bitmap& dst) {
	if (spriteset->RequireClear(GetDrawableList())) {
		dst.Clear();
	}
}

void Scene_Map::OnTranslationChanged() {
	// FIXME: Map events are not reloaded
	// They require leaving and reentering the map
	Scene::OnTranslationChanged();
}

void Scene_Map::PreUpdate(MapUpdateAsyncContext& actx) {
	Game_Map::Update(actx, true);
	UpdateGraphics();
}

void Scene_Map::PreUpdateForegroundEvents(MapUpdateAsyncContext& actx) {
	Game_Map::UpdateForegroundEvents(actx);
	UpdateGraphics();
}

void Scene_Map::vUpdate() {
	if (activate_inn) {
		UpdateInn();
		return;
	}

	MapUpdateAsyncContext actx;
	UpdateStage1(actx);
}

void Scene_Map::UpdateStage1(MapUpdateAsyncContext actx) {
	Game_Map::Update(actx);
	UpdateGraphics();

	// Waiting for async operation from map update.
	if (actx.IsActive()) {
		OnAsyncSuspend([this,actx]() { UpdateStage1(actx); }, actx.GetAsyncOp(), false);
		return;
	}

	// On platforms with async loading (emscripten) graphical assets loaded this frame
	// may require us to wait for them to download before we can start the transitions.
	AsyncNext([this]() { UpdateStage2(); });
}

void Scene_Map::UpdateStage2() {
	if (Main_Data::game_player->IsPendingTeleport()) {
		const auto tt = Main_Data::game_player->GetTeleportTarget().GetType();
		TeleportParams tp;
		tp.run_foreground_events = GetRunForegroundEvents(tt);
		tp.erase_screen = true;
		tp.use_default_transition_in = false;
		tp.defer_recursive_teleports = false;

		StartPendingTeleport(tp);
		return;
	}
	UpdateSceneCalling();
}

void Scene_Map::UpdateSceneCalling() {
	auto call = TakeRequestedScene();

	if (call == nullptr) {
		if (Input::IsTriggered(Input::SETTINGS_MENU)) {
			call = std::make_shared<Scene_Settings>();
		}
	}

	if (Player::debug_flag) {
		if (call == nullptr && Input::IsTriggered(Input::DEBUG_MENU)) {
			call = std::make_shared<Scene_Debug>();
		}

		if (call == nullptr && Input::IsTriggered(Input::DEBUG_SAVE)) {
			call = std::make_shared<Scene_Save>();
		}
	}

	if (call != nullptr) {
		Scene::Push(std::move(call));
	}
}

void Scene_Map::StartPendingTeleport(TeleportParams tp) {
	auto& transition = Transition::instance();

	if (!transition.IsErasedNotActive() && tp.erase_screen) {
		transition.InitErase(Main_Data::game_system->GetTransition(Main_Data::game_system->Transition_TeleportErase), this);
	}

	AsyncNext([=]() { FinishPendingTeleport(tp); });
}

void Scene_Map::FinishPendingTeleport(TeleportParams tp) {
	auto old_map_id = Game_Map::GetMapId();
	Main_Data::game_player->PerformTeleport();

	if (Game_Map::GetMapId() != old_map_id) {
		spriteset->Refresh();
	}
	FinishPendingTeleport2(MapUpdateAsyncContext(), tp);
}

void Scene_Map::FinishPendingTeleport2(MapUpdateAsyncContext actx, TeleportParams tp) {
	PreUpdate(actx);

	if (actx.IsActive()) {
		OnAsyncSuspend([=] { FinishPendingTeleport2(actx, tp); }, actx.GetAsyncOp(), true);
		return;
	}

	if (!tp.defer_recursive_teleports) {
		// RPG_RT behavior - Escape and Teleport skills silently ignore any teleport commands
		// executed by events during pre-update frame and defer them until first frame.
		if (Main_Data::game_player->IsPendingTeleport()) {
			tp.erase_screen = false;
			StartPendingTeleport(tp);
			return;
		}
	}

	auto& transition = Transition::instance();

	// This logic was tested against RPG_RT and works this way ...
	if (tp.use_default_transition_in && transition.IsErasedNotActive()) {
		transition.InitShow(Transition::TransitionFadeIn, this);
	} else if (!tp.use_default_transition_in && !screen_erased_by_event) {
		transition.InitShow(Main_Data::game_system->GetTransition(Main_Data::game_system->Transition_TeleportShow), this);
	}

	// Call any requested scenes when transition is done.
	AsyncNext([=]() { FinishPendingTeleport3(actx, tp); });
}

void Scene_Map::FinishPendingTeleport3(MapUpdateAsyncContext actx, TeleportParams tp) {
	if (tp.run_foreground_events) {
		PreUpdateForegroundEvents(actx);

		if (actx.IsActive()) {
			OnAsyncSuspend([=] { FinishPendingTeleport3(actx, tp); }, actx.GetAsyncOp(), true);
			return;
		}

		if (!tp.defer_recursive_teleports) {
			// See comments about defer_recursive_teleports in FinishPendingTeleport2
			// Deferring in this block can actually never occur, since an Escape/Teleport won't ever
			// also trigger foreground events to run in pre-update. We leave the check in here for symmetry.
			if (Main_Data::game_player->IsPendingTeleport()) {
				tp.erase_screen = false;
				StartPendingTeleport(tp);
				return;
			}
		}
	}

	// Call any requested scenes when transition is done.
	AsyncNext([this]() { UpdateSceneCalling(); });
}

void Scene_Map::PerformAsyncTeleport(TeleportTarget original_tt) {
	Main_Data::game_player->PerformTeleport();
	Main_Data::game_player->ResetTeleportTarget(original_tt);

	spriteset->Refresh();

	AsyncNext(std::move(map_async_continuation));
}

template <typename F>
void Scene_Map::OnAsyncSuspend(F&& f, AsyncOp aop, bool is_preupdate) {
	if (CheckSceneExit(aop)) {
		return;
	}

	if (aop.GetType() == AsyncOp::eSave) {
		auto savefs = FileFinder::Save();
		bool success = Scene_Save::Save(savefs, aop.GetSaveSlot());
		if (aop.GetSaveResultVar() > 0) {
			Main_Data::game_variables->Set(aop.GetSaveResultVar(), success ? 1 : 0);
			Game_Map::SetNeedRefresh(true);
		}
	}

	if (aop.GetType() == AsyncOp::eLoad) {
		auto savefs = FileFinder::Save();
		std::string save_name = Scene_Save::GetSaveFilename(savefs, aop.GetSaveSlot());
		Player::LoadSavegame(save_name, aop.GetSaveSlot());
	}

	if (aop.GetType() == AsyncOp::eCloneMapEvent) {
		Game_Map::CloneMapEvent(aop.GetMapId(), aop.GetSourceEventId(), aop.GetX(), aop.GetY(), aop.GetTargetEventId(), aop.GetEventName());
	}

	if (aop.GetType() == AsyncOp::eDestroyMapEvent) {
		Game_Map::DestroyMapEvent(aop.GetTargetEventId());
	}

	auto& transition = Transition::instance();

	if (aop.GetType() == AsyncOp::eEraseScreen) {
		auto tt = static_cast<Transition::Type>(aop.GetTransitionType());
		if (tt == Transition::TransitionNone) {
			// Emulates an RPG_RT bug where instantaneous transitions cause a
			// 30 frame pause and then make the screen black.
			transition.InitErase(Transition::TransitionCutOut, this, 30);
		} else {
			transition.InitErase(tt, this);
		}

		if (!is_preupdate) {
			// RPG_RT behavior: EraseScreen commands performed during pre-update don't stick.
			screen_erased_by_event = true;
		}
	}

	if (aop.GetType() == AsyncOp::eShowScreen) {
		auto tt = static_cast<Transition::Type>(aop.GetTransitionType());
		transition.InitShow(tt, this);
		screen_erased_by_event = false;
	}

	if (aop.GetType() == AsyncOp::eCallInn) {
		activate_inn = true;
		inn_started = false;
		music_before_inn = Main_Data::game_system->GetCurrentBGM();
		map_async_continuation = std::forward<F>(f);

		Main_Data::game_system->BgmFade(800);

		UpdateInn();
		return;
	}

	if (aop.GetType() == AsyncOp::eQuickTeleport) {
		map_async_continuation = std::forward<F>(f);

		// If there is already a real teleport pending we need to make sure it gets executed after
		// the async teleport.
		auto orig_tt = Main_Data::game_player->GetTeleportTarget();

		Main_Data::game_player->ReserveTeleport(aop.GetTeleportMapId(), aop.GetTeleportX(), aop.GetTeleportY(), -1, TeleportTarget::eAsyncQuickTeleport);

		AsyncNext([=]() { PerformAsyncTeleport(orig_tt); });
		return;
	}

	AsyncNext(std::forward<F>(f));
}

void Scene_Map::StartInn() {
	const lcf::rpg::Music& bgm_inn = Main_Data::game_system->GetSystemBGM(Main_Data::game_system->BGM_Inn);
	if (Main_Data::game_system->IsStopMusicFilename(bgm_inn.name)) {
		FinishInn();
		return;
	}

	Main_Data::game_system->BgmPlay(bgm_inn);
}

void Scene_Map::FinishInn() {
	// RPG_RT will always transition in, regardless of whether an EraseScreen command
	// was issued previously.
	screen_erased_by_event = false;

	auto& transition = Transition::instance();

	transition.InitShow(Transition::TransitionFadeIn, Scene::instance.get());
	Main_Data::game_system->BgmPlay(music_before_inn);

	// Full heal
	std::vector<Game_Actor*> actors = Main_Data::game_party->GetActors();
	for (Game_Actor* actor : actors) {
		actor->FullHeal();
	}

	activate_inn = false;
	inn_started = false;
	AsyncNext(std::move(map_async_continuation));
}

void Scene_Map::UpdateInn() {
	// Allow message box to render during inn sequence.
	if (Game_Message::IsMessageActive()) {
		Game_Message::Update();
		return;
	}

	if (!inn_started) {
		Transition::instance().InitErase(Transition::TransitionFadeOut, Scene::instance.get());
		inn_started = true;
		inn_timer = Game_Clock::GetFrameTime();

		AsyncNext([=]() { StartInn(); });
		return;
	}

	// Do not use Game_System::BgmPlayedOnce here as it does not report looping for WAV correctly
	if (Audio().BGM_IsPlaying() && !Audio().BGM_PlayedOnce() && (Game_Clock::GetFrameTime() - inn_timer < 10s)) {
		return;
	}

	Main_Data::game_system->BgmStop();
	FinishInn();
}


/*end of file .\scene_map.cpp*/

/*start of file .\scene_menu.cpp*/

/* ... license chunk ... */

// Headers
#include <cassert>
#include "scene_menu.h"
#include "audio.h"
#include "cache.h"
#include "game_party.h"
#include "game_system.h"
#include "input.h"
#include "player.h"
#include "scene_settings.h"
#include "scene_debug.h"
#include "scene_end.h"
#include "scene_equip.h"
#include "scene_item.h"
#include "scene_skill.h"
#include "scene_order.h"
#include "scene_save.h"
#include "scene_status.h"
#include "bitmap.h"
#include "feature.h"

constexpr int menu_command_width = 88;
constexpr int gold_window_width = 88;
constexpr int gold_window_height = 32;

Scene_Menu::Scene_Menu(int menu_index) :
	menu_index(menu_index) {
	type = Scene::Menu;
}

void Scene_Menu::Start() {
	CreateCommandWindow();

	// Gold Window
	gold_window.reset(new Window_Gold(Player::menu_offset_x, (Player::screen_height - gold_window_height - Player::menu_offset_y), gold_window_width, gold_window_height));

	// Status Window
	menustatus_window.reset(new Window_MenuStatus(Player::menu_offset_x + menu_command_width, Player::menu_offset_y, (MENU_WIDTH - menu_command_width), MENU_HEIGHT));
	menustatus_window->SetActive(false);
}

void Scene_Menu::Continue(SceneType /* prev_scene */) {
	menustatus_window->Refresh();
	gold_window->Refresh();
}

void Scene_Menu::vUpdate() {
	command_window->Update();
	gold_window->Update();
	menustatus_window->Update();

	if (command_window->GetActive()) {
		UpdateCommand();
	}
	else if (menustatus_window->GetActive()) {
		UpdateActorSelection();
	}
}

void Scene_Menu::CreateCommandWindow() {
	// Create Options Window
	std::vector<std::string> options;

	if (Player::IsRPG2k()) {
		command_options.push_back(Item);
		command_options.push_back(Skill);
		command_options.push_back(Equipment);
		command_options.push_back(Save);
		if (Player::player_config.settings_in_menu.Get()) {
			command_options.push_back(Settings);
		}
		if (Player::debug_flag) {
			command_options.push_back(Debug);
		}
		command_options.push_back(Quit);
	} else {
		for (std::vector<int16_t>::iterator it = lcf::Data::system.menu_commands.begin();
			it != lcf::Data::system.menu_commands.end(); ++it) {
				switch (*it) {
				case Row:
					if (Feature::HasRow()) {
						command_options.push_back((CommandOptionType)*it);
					}
					break;
				case Wait:
					if (Feature::HasRpg2k3BattleSystem()) {
						command_options.push_back((CommandOptionType)*it);
					}
					break;
				default:
					command_options.push_back((CommandOptionType)*it);
					break;
				}
		}
		if (Player::player_config.settings_in_menu.Get()) {
			command_options.push_back(Settings);
		}
		if (Player::debug_flag) {
			command_options.push_back(Debug);
		}
		command_options.push_back(Quit);
	}

	// Add all menu items
	std::vector<CommandOptionType>::iterator it;
	for (it = command_options.begin(); it != command_options.end(); ++it) {
		switch(*it) {
		case Item:
			options.push_back(ToString(lcf::Data::terms.command_item));
			break;
		case Skill:
			options.push_back(ToString(lcf::Data::terms.command_skill));
			break;
		case Equipment:
			options.push_back(ToString(lcf::Data::terms.menu_equipment));
			break;
		case Save:
			options.push_back(ToString(lcf::Data::terms.menu_save));
			break;
		case Status:
			options.push_back(ToString(lcf::Data::terms.status));
			break;
		case Row:
			options.push_back(ToString(lcf::Data::terms.row));
			break;
		case Order:
			options.push_back(ToString(lcf::Data::terms.order));
			break;
		case Wait:
			options.push_back(ToString(Main_Data::game_system->GetAtbMode() == lcf::rpg::SaveSystem::AtbMode_atb_wait ? lcf::Data::terms.wait_on : lcf::Data::terms.wait_off));
			break;
		case Settings:
			options.push_back("Settings");
			break;
		case Debug:
			options.push_back("Debug");
			break;
		default:
			options.push_back(ToString(lcf::Data::terms.menu_quit));
			break;
		}
	}

	command_window.reset(new Window_Command(options, menu_command_width));
	command_window->SetX(Player::menu_offset_x);
	command_window->SetY(Player::menu_offset_y);
	command_window->SetIndex(menu_index);

	// Disable items
	for (it = command_options.begin(); it != command_options.end(); ++it) {
		switch(*it) {
		case Save:
			// If save is forbidden disable this item
			if (!Main_Data::game_system->GetAllowSave()) {
				command_window->DisableItem(it - command_options.begin());
			}
		case Wait:
		case Quit:
		case Settings:
		case Debug:
			break;
		case Order:
			if (Main_Data::game_party->GetActors().size() <= 1) {
				command_window->DisableItem(it - command_options.begin());
			}
			break;
		default:
			if (Main_Data::game_party->GetActors().empty()) {
				command_window->DisableItem(it - command_options.begin());
			}
			break;
		}
	}
}

void Scene_Menu::UpdateCommand() {
	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		Scene::Pop();
	} else if (Input::IsTriggered(Input::DECISION)) {
		menu_index = command_window->GetIndex();

		switch (command_options[menu_index]) {
		case Item:
			if (Main_Data::game_party->GetActors().empty()) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
			} else {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
				Scene::Push(std::make_shared<Scene_Item>());
			}
			break;
		case Skill:
		case Equipment:
		case Status:
		case Row:
			if (Main_Data::game_party->GetActors().empty()) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
			} else {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
				command_window->SetActive(false);
				menustatus_window->SetActive(true);
				menustatus_window->SetIndex(0);
			}
			break;
		case Save:
			if (!Main_Data::game_system->GetAllowSave()) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
			} else {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
				Scene::Push(std::make_shared<Scene_Save>());
			}
			break;
		case Order:
			if (Main_Data::game_party->GetActors().size() <= 1) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
			} else {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
				Scene::Push(std::make_shared<Scene_Order>());
			}
			break;
		case Wait:
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
			Main_Data::game_system->ToggleAtbMode();
			command_window->SetItemText(menu_index,
				Main_Data::game_system->GetAtbMode() == lcf::rpg::SaveSystem::AtbMode_atb_wait ? lcf::Data::terms.wait_on : lcf::Data::terms.wait_off);
			break;
		case Settings:
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Decision));
			Scene::Push(std::make_shared<Scene_Settings>());
			break;
		case Debug:
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
			Scene::Push(std::make_shared<Scene_Debug>());
			break;
		case Quit:
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
			Scene::Push(std::make_shared<Scene_End>());
			break;
		}
	}
}

void Scene_Menu::UpdateActorSelection() {
	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		command_window->SetActive(true);
		menustatus_window->SetActive(false);
		menustatus_window->SetIndex(-1);
	} else if (Input::IsTriggered(Input::DECISION)) {
		switch (command_options[command_window->GetIndex()]) {
		case Skill:
			if (!menustatus_window->GetActor()->CanAct()) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
				return;
			}
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
			Scene::Push(std::make_shared<Scene_Skill>(Main_Data::game_party->GetActors(), menustatus_window->GetIndex()));
			break;
		case Equipment:
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
			Scene::Push(std::make_shared<Scene_Equip>(Main_Data::game_party->GetActors(), menustatus_window->GetIndex()));
			break;
		case Status:
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
			Scene::Push(std::make_shared<Scene_Status>(Main_Data::game_party->GetActors(), menustatus_window->GetIndex()));
			break;
		case Row:
		{
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
			// Don't allow entire party in the back row.
			const auto& actors = Main_Data::game_party->GetActors();
			int num_in_back = 0;
			for (auto* actor: actors) {
				if (actor->GetBattleRow() == Game_Actor::RowType::RowType_back) {
					++num_in_back;
				}
			}
			Game_Actor* actor = actors[menustatus_window->GetIndex()];
			if (actor->GetBattleRow() == Game_Actor::RowType::RowType_front) {
				if (num_in_back < int(actors.size() - 1)) {
					actor->SetBattleRow(Game_Actor::RowType::RowType_back);
				}
			} else {
				actor->SetBattleRow(Game_Actor::RowType::RowType_front);
			}
			menustatus_window->Refresh();
			break;
		}
		default:
			assert(false);
			break;
		}

		command_window->SetActive(true);
		menustatus_window->SetActive(false);
		menustatus_window->SetIndex(-1);
	}
}


/*end of file .\scene_menu.cpp*/

/*start of file .\scene_name.cpp*/

/* ... license chunk ... */

#include <cassert>

#include "scene_name.h"
#include "game_actors.h"
#include "game_system.h"
#include "input.h"
#include "player.h"
#include "output.h"

Scene_Name::Scene_Name(Game_Actor& actor, int charset, bool use_default_name)
	: layout_index(charset), use_default_name(use_default_name), actor(actor)
{
	Scene::type = Scene::Name;
}

void Scene_Name::Start() {
	// Create the windows
	int margin_x = 32;
	int margin_y = 8;
	int window_face_width = 64;
	int window_face_height = 64;
	int window_name_width = 192;
	int window_name_height = 32;
	int window_keyboard_width = 256;
	int window_keyboard_height = 160;

	face_window.reset(new Window_Face(Player::menu_offset_x + margin_x, Player::menu_offset_y + margin_y, window_face_width, window_face_height));
	face_window->Set(actor);
	face_window->Refresh();

	name_window.reset(new Window_Name(Player::menu_offset_x + window_face_width + margin_x, Player::menu_offset_y + margin_y + 32, window_name_width, window_name_height));
	name_window->Set(use_default_name ? ToString(actor.GetName()) : "");
	name_window->Refresh();

	const char* done = Window_Keyboard::DONE;
	// Japanese pages
	if (Player::IsCP932()) {
		layouts.push_back(Window_Keyboard::Hiragana);
		layouts.push_back(Window_Keyboard::Katakana);
		done = Window_Keyboard::DONE_JP;
	// Korean pages
	} else if (Player::IsCP949()) {
		layouts.push_back(Window_Keyboard::Hangul1);
		layouts.push_back(Window_Keyboard::Hangul2);
		done = Window_Keyboard::DONE_KO;
	// Simp. Chinese pages
	} else if (Player::IsCP936()) {
		layouts.push_back(Window_Keyboard::ZhCn1);
		layouts.push_back(Window_Keyboard::ZhCn2);
		done = Window_Keyboard::DONE_ZH_CN;
	// Trad. Chinese pages
	} else if (Player::IsBig5()) {
		layouts.push_back(Window_Keyboard::ZhTw1);
		layouts.push_back(Window_Keyboard::ZhTw2);
		done = Window_Keyboard::DONE_ZH_TW;
	// Cyrillic page (we assume it's Russian since we have no way to detect Serbian etc.)
	} else if (Player::IsCP1251()) {
		layouts.push_back(Window_Keyboard::RuCyrl);
		done = Window_Keyboard::DONE_RU;
	}

	// Letter and symbol pages are used everywhere
	layouts.push_back(Window_Keyboard::Letter);
	layouts.push_back(Window_Keyboard::Symbol);
	kbd_window.reset(new Window_Keyboard(Player::menu_offset_x + margin_x, Player::menu_offset_y + window_face_height + margin_y, window_keyboard_width, window_keyboard_height, done));

	auto next_index = layout_index + 1;
	if (next_index >= static_cast<int>(layouts.size())) {
		next_index = 0;
	}
	kbd_window->SetMode(layouts[layout_index], layouts[next_index]);

	kbd_window->Refresh();
	kbd_window->UpdateCursorRect();
}

void Scene_Name::vUpdate() {
	kbd_window->Update();
	name_window->Update();

	if (Input::IsTriggered(Input::CANCEL)) {
		if (name_window->Get().size() > 0) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
			name_window->Erase();
		} else {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		}
	} else if (Input::IsTriggered(Input::DECISION)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
		std::string const& s = kbd_window->GetSelected();

		assert(!s.empty());

		if (s == Window_Keyboard::DONE) {
			if (name_window->Get().empty()) {
				name_window->Set(ToString(actor.GetName()));
				name_window->Refresh();
			} else {
				actor.SetName(name_window->Get());
				Scene::Pop();
			}
		} else if (s == Window_Keyboard::NEXT_PAGE) {
			++layout_index;
			if (layout_index >= static_cast<int>(layouts.size())) {
				layout_index = 0;
			}

			auto next_index = layout_index + 1;
			if (next_index >= static_cast<int>(layouts.size())) {
				next_index = 0;
			}
			kbd_window->SetMode(layouts[layout_index], layouts[next_index]);
		} else if (s == Window_Keyboard::SPACE) {
			name_window->Append(" ");
		} else {
			name_window->Append(s);
		}
	}
}


/*end of file .\scene_name.cpp*/

/*start of file .\scene_order.cpp*/

/* ... license chunk ... */

// Headers
#include <algorithm>
#include <string>
#include <vector>
#include "scene_order.h"
#include "game_actor.h"
#include "game_party.h"
#include "game_player.h"
#include "game_system.h"
#include "input.h"
#include "scene_map.h"
#include "player.h"

Scene_Order::Scene_Order() :
	actor_counter(0) {
	type = Scene::Order;
}

void Scene_Order::Start() {
	actors.resize(Main_Data::game_party->GetActors().size());

	CreateCommandWindow();
}

void Scene_Order::vUpdate() {
	window_left->Update();
	window_right->Update();
	window_confirm->Update();

	if (window_left->GetActive()) {
		UpdateOrder();
	} else if (window_confirm->GetActive()) {
		UpdateConfirm();
	}
}

void Scene_Order::UpdateOrder() {
	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		if (actor_counter == 0) {
			Scene::Pop();
		} else {
			--actor_counter;
			window_left->SetItemText(actors[actor_counter] - 1, Main_Data::game_party->GetActors()[actors[actor_counter] - 1]->GetName());
			window_right->SetItemText(actor_counter, "");
			actors[actor_counter] = 0;
		}
	} else if (Input::IsTriggered(Input::DECISION)) {
		if (std::find(actors.begin(), actors.end(), window_left->GetIndex() + 1) != actors.end()) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		} else {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
			window_left->SetItemText(window_left->GetIndex(), "");
			window_right->SetItemText(actor_counter, Main_Data::game_party->GetActors()[window_left->GetIndex()]->GetName());

			actors[actor_counter] = window_left->GetIndex() + 1;

			++actor_counter;

			// Display Confirm/Redo window
			if (actor_counter == (int)Main_Data::game_party->GetActors().size()) {
				window_left->SetIndex(-1);
				window_left->SetActive(false);
				window_confirm->SetIndex(0);
				window_confirm->SetActive(true);
				window_confirm->SetVisible(true);
			}
		}
	}
}

void Scene_Order::UpdateConfirm() {
	if (Input::IsTriggered(Input::CANCEL)) {
		Redo();
	} else if (Input::IsTriggered(Input::DECISION)) {
		if (window_confirm->GetIndex() == 0) {
			Confirm();
			Scene::Pop();
		} else {
			Redo();
		}
	}
}

void Scene_Order::CreateCommandWindow() {
	std::vector<std::string> options_left;
	std::vector<std::string> options_right;
	std::vector<std::string> options_confirm;

	const auto actors = Main_Data::game_party->GetActors();
	for (auto& actor: actors) {
		options_left.push_back(ToString(actor->GetName()));
		options_right.push_back("");
	}

	options_confirm.push_back(lcf::rpg::Terms::TermOrDefault(lcf::Data::terms.easyrpg_order_scene_confirm, "Confirm"));
	options_confirm.push_back(lcf::rpg::Terms::TermOrDefault(lcf::Data::terms.easyrpg_order_scene_redo, "Redo"));

	window_left.reset(new Window_Command(options_left, 88, 4));
	window_left->SetX(Player::menu_offset_x + 68);
	window_left->SetY(Player::menu_offset_y + 48);

	window_right.reset(new Window_Command(options_right, 88, 4));
	window_right->SetX(Player::menu_offset_x + 164);
	window_right->SetY(Player::menu_offset_y + 48);
	window_right->SetActive(false);
	window_right->SetIndex(-1);

	window_confirm.reset(new Window_Command(options_confirm, 80));
	window_confirm->SetX(Player::menu_offset_x + 120);
	window_confirm->SetY(Player::menu_offset_y + 144);
	window_confirm->SetActive(false);
	window_confirm->SetVisible(false);
}

void Scene_Order::Redo() {
	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));

	actors.clear();
	actors.resize(Main_Data::game_party->GetActors().size());

	std::vector<Game_Actor*> actors = Main_Data::game_party->GetActors();
	for (std::vector<Game_Actor*>::const_iterator it = actors.begin();
		it != actors.end(); ++it) {
		int index = it - actors.begin();
		window_left->SetItemText(index, (*it)->GetName());
		window_right->SetItemText(index, "");
	}

	window_left->SetActive(true);
	window_left->SetIndex(0);

	window_confirm->SetActive(false);
	window_confirm->SetVisible(false);
	window_confirm->SetIndex(-1);

	actor_counter = 0;
	actors.clear();
	actors.resize(actors.size());
}

void Scene_Order::Confirm() {
	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));

	std::vector<Game_Actor*> party_actors = Main_Data::game_party->GetActors();

	std::vector<int>::const_iterator it;

	for (it = actors.begin(); it != actors.end(); ++it) {
		Main_Data::game_party->RemoveActor(party_actors[*it - 1]->GetId());
	}

	for (it = actors.begin(); it != actors.end(); ++it) {
		Main_Data::game_party->AddActor(party_actors[*it - 1]->GetId());
	}

	// TODO: Where is the best place to overwrite the character map graphic?
}


/*end of file .\scene_order.cpp*/

/*start of file .\scene_save.cpp*/

/* ... license chunk ... */

// Headers
#include <sstream>

#ifdef EMSCRIPTEN
#  include <emscripten.h>
#endif

#include <lcf/data.h>
#include "game_dynrpg.h"
#include "filefinder.h"
#include "game_actor.h"
#include "game_map.h"
#include "game_party.h"
#include "game_switches.h"
#include "game_variables.h"
#include "game_strings.h"
#include "game_party.h"
#include "game_actors.h"
#include "game_system.h"
#include "game_targets.h"
#include "game_screen.h"
#include "game_pictures.h"
#include "game_windows.h"
#include <lcf/lsd/reader.h>
#include "output.h"
#include "player.h"
#include "scene_save.h"
#include "translation.h"
#include "version.h"

Scene_Save::Scene_Save() :
	Scene_File(ToString(lcf::Data::terms.save_game_message)) {
	Scene::type = Scene::Save;
}

void Scene_Save::Start() {
	Scene_File::Start();

	for (int i = 0; i < Utils::Clamp<int32_t>(lcf::Data::system.easyrpg_max_savefiles, 3, 99); i++) {
		file_windows[i]->SetHasSave(true);
		file_windows[i]->Refresh();
	}
}

void Scene_Save::Action(int index) {
	Save(fs, index + 1);

	Scene::Pop();
}

std::string Scene_Save::GetSaveFilename(const FilesystemView& fs, int slot_id) {
	const auto save_file = fmt::format("Save{:02d}.lsd", slot_id);

	std::string filename = fs.FindFile(save_file);

	if (filename.empty()) {
		filename = save_file;
	}
	return filename;
}

bool Scene_Save::Save(const FilesystemView& fs, int slot_id, bool prepare_save) {
	const auto filename = GetSaveFilename(fs, slot_id);
	Output::Debug("Saving to {}", filename);

	auto save_stream = FileFinder::Save().OpenOutputStream(filename);

	if (!save_stream) {
		Output::Warning("Failed saving to {}", filename);
		return false;
	}

	return Save(save_stream, slot_id, prepare_save);
}

bool Scene_Save::Save(std::ostream& os, int slot_id, bool prepare_save) {
	lcf::rpg::Save save;
	auto& title = save.title;
	// TODO: Maybe find a better place to setup the save file?

	int size = (int)Main_Data::game_party->GetActors().size();
	Game_Actor* actor;

	if (size > 3) {
		actor = Main_Data::game_party->GetActors()[3];
		title.face4_id = actor->GetFaceIndex();
		title.face4_name = ToString(actor->GetFaceName());
	}
	if (size > 2) {
		actor = Main_Data::game_party->GetActors()[2];
		title.face3_id = actor->GetFaceIndex();
		title.face3_name = ToString(actor->GetFaceName());
	}
	if (size > 1) {
		actor = Main_Data::game_party->GetActors()[1];
		title.face2_id = actor->GetFaceIndex();
		title.face2_name = ToString(actor->GetFaceName());
	}
	if (size > 0) {
		actor = Main_Data::game_party->GetActors()[0];
		title.face1_id = actor->GetFaceIndex();
		title.face1_name = ToString(actor->GetFaceName());
		title.hero_hp = actor->GetHp();
		title.hero_level = actor->GetLevel();
		title.hero_name = ToString(actor->GetName());
	}

	Main_Data::game_system->SetSaveSlot(slot_id);
	save.party_location = Main_Data::game_player->GetSaveData();
	Game_Map::PrepareSave(save);

	if (prepare_save) {
		// When a translation is loaded always store in Unicode to prevent data loss
		int codepage = Tr::HasActiveTranslation() ? 65001 : 0;

		lcf::LSD_Reader::PrepareSave(save, PLAYER_SAVEGAME_VERSION, codepage);
		Main_Data::game_system->IncSaveCount();
	}

	save.targets = Main_Data::game_targets->GetSaveData();
	save.system = Main_Data::game_system->GetSaveData();
	save.system.switches = Main_Data::game_switches->GetData();
	save.system.variables = Main_Data::game_variables->GetData();
	save.system.maniac_strings = Main_Data::game_strings->GetLcfData();
	save.inventory = Main_Data::game_party->GetSaveData();
	save.actors = Main_Data::game_actors->GetSaveData();
	save.screen = Main_Data::game_screen->GetSaveData();
	save.pictures = Main_Data::game_pictures->GetSaveData();
	save.easyrpg_data.windows = Main_Data::game_windows->GetSaveData();

	save.system.scene = Scene::instance ? Scene::rpgRtSceneFromSceneType(Scene::instance->type) : -1;

	// 2k RPG_RT always stores SaveMapEvent with map_id == 0.
	if (Player::IsRPG2k()) {
		for (auto& sme: save.map_info.events) {
			sme.map_id = 0;
		}
	}
	auto lcf_engine = Player::IsRPG2k3() ? lcf::EngineVersion::e2k3 : lcf::EngineVersion::e2k;
	bool res = lcf::LSD_Reader::Save(os, save, lcf_engine, Player::encoding);

	Main_Data::game_dynrpg->Save(slot_id);

	AsyncHandler::SaveFilesystem();

	return res;
}

bool Scene_Save::IsSlotValid(int) {
	return true;
}


/*end of file .\scene_save.cpp*/

/*start of file .\scene_settings.cpp*/

/* ... license chunk ... */
#include "scene_settings.h"
#include "audio.h"
#include "bitmap.h"
#include "input.h"
#include "game_system.h"
#include "cache.h"
#include "input_buttons.h"
#include "input_source.h"
#include "keys.h"
#include "main_data.h"
#include "options.h"
#include "player.h"
#include "baseui.h"
#include "output.h"
#include "utils.h"
#include "scene_language.h"
#include "scene_end.h"
#include "window_about.h"
#include "window_command_horizontal.h"
#include "window_help.h"
#include "window_input_settings.h"
#include "window_numberinput.h"
#include "window_selectable.h"
#include "window_settings.h"
#include <memory>

#ifdef EMSCRIPTEN
#  include <emscripten.h>
#endif

Scene_Settings::Scene_Settings() {
	Scene::type = Scene::Settings;
}

void Scene_Settings::CreateTitleGraphic() {
	// Load Title Graphic
	if (lcf::Data::system.title_name.empty()) {
		return;
	}
	title = std::make_unique<Sprite>();
	FileRequestAsync* request = AsyncHandler::RequestFile("Title", lcf::Data::system.title_name);
	request->SetGraphicFile(true);
	request_id = request->Bind(&Scene_Settings::OnTitleSpriteReady, this);
	request->Start();
}

void Scene_Settings::CreateMainWindow() {
	root_options.clear();
	root_options.insert(root_options.end(), {
		{ Window_Settings::eVideo,	"Video" },
		{ Window_Settings::eAudio,	"Audio" },
		{ Window_Settings::eInput,	"Input"},
		{ Window_Settings::eEngine,	"Engine"},
		{ Window_Settings::eLicense,"License"},
		{ Window_Settings::eSave,	"<Save Settings>"}
	});

	if (Player::translation.HasTranslations() && Scene::Peek()->type != Scene::Title && Scene::Peek()->type != Scene::LanguageMenu) {
		root_options.insert(root_options.begin() + 3, { Window_Settings::eLanguage, "Language" });
	}

	if (Scene::Find(Scene::Title)) {
		root_options.insert(root_options.end(), { Window_Settings::eEnd, "<Exit Game>" });
	}

	std::vector<std::string> options;
	options.reserve(root_options.size());
	std::for_each(root_options.begin(), root_options.end(), [&](std::pair<Window_Settings::UiMode, std::string> v) { options.emplace_back(v.second); });

	main_window = std::make_unique<Window_Command>(std::move(options));
	main_window->SetHeight(176);
	main_window->SetY((Player::screen_height - main_window->GetHeight()) / 2);
	main_window->SetX((Player::screen_width - main_window->GetWidth()) / 2);

	if (Player::no_audio_flag) {
		main_window->SetItemEnabled(1, !Player::no_audio_flag);
	}
#ifndef SUPPORT_AUDIO
	main_window->DisableItem(1);
#endif
}

void Scene_Settings::CreateOptionsWindow() {
	help_window = std::make_unique<Window_Help>(Player::menu_offset_x, 0, MENU_WIDTH, 32);
	help_window->SetAnimation(Window_Help::Animation::Loop);
	options_window = std::make_unique<Window_Settings>(Player::menu_offset_x + 32, 32, MENU_WIDTH - 64, Player::screen_height - 32 * 2);
	options_window->SetHelpWindow(help_window.get());

	help_window2 = std::make_unique<Window_Help>(Player::menu_offset_x, options_window->GetBottomY(), MENU_WIDTH, 32);
	help_window2->SetAnimation(Window_Help::Animation::Loop);
	options_window->help_window2 = help_window2.get();

	input_window = std::make_unique<Window_InputSettings>(Player::menu_offset_x, 32, MENU_WIDTH, Player::screen_height - 32 * 3);
	input_window->SetHelpWindow(help_window.get());

	std::vector<std::string> input_mode_items = {"Add", "Remove", "Reset"};
	input_mode_window = std::make_unique<Window_Command_Horizontal>(input_mode_items, MENU_WIDTH - 32 * 2);
	input_mode_window->SetX(Player::menu_offset_x + 32);
	input_mode_window->SetY(Player::screen_height - 32);
	input_mode_window->SetHelpWindow(help_window.get());
	input_mode_window->UpdateHelpFn = [](Window_Help& win, int index) {
		if (index == 0) {
			win.SetText("Add a new keybinding");
		} else if (index == 1) {
			win.SetText("Remove a keybinding");
		} else if (index == 2) {
			win.SetText("Reset the keybindings to the default");
		}
	};

	input_help_window = std::make_unique<Window_Help>(Player::menu_offset_x, Player::screen_height - 64, MENU_WIDTH, 32);

	about_window = std::make_unique<Window_About>(Player::menu_offset_x, Player::menu_offset_y + 32, MENU_WIDTH, MENU_HEIGHT - 64);
	about_window->Refresh();
}

void Scene_Settings::Start() {
	CreateTitleGraphic();
	CreateMainWindow();
	CreateOptionsWindow();

	options_window->Push(Window_Settings::eMain);
	SetMode(Window_Settings::eMain);
}

void Scene_Settings::SetMode(Window_Settings::UiMode new_mode) {
	if (new_mode == mode) {
		return;
	}
	mode = new_mode;

	main_window->SetActive(false);
	main_window->SetVisible(false);
	options_window->SetActive(false);
	options_window->SetVisible(false);
	input_window->SetActive(false);
	input_window->SetVisible(false);
	input_mode_window->SetActive(false);
	input_mode_window->SetVisible(false);
	input_help_window->SetVisible(false);
	help_window->SetVisible(false);
	help_window2->SetVisible(false);
	about_window->SetVisible(false);

	picker_window.reset();
	font_size_window.reset();

	switch (mode) {
		case Window_Settings::eNone:
		case Window_Settings::eMain:
			main_window->SetActive(true);
			main_window->SetVisible(true);
			break;
		case Window_Settings::eInputButtonOption:
			help_window->SetVisible(true);
			input_window->SetVisible(true);
			input_window->SetInputButton(static_cast<Input::InputButton>(options_window->GetFrame().arg));
			input_window->SetIndex(-1);
			input_mode_window->SetActive(true);
			input_mode_window->SetVisible(true);
			input_help_window->SetVisible(true);
			input_help_window->SetText("Emergency reset: Hold 4 keys and follow instructions");
			RefreshInputActionAllowed();
			break;
		case Window_Settings::eInputButtonAdd:
			help_window->SetVisible(true);
			input_window->SetVisible(true);
			input_window->SetInputButton(static_cast<Input::InputButton>(options_window->GetFrame().arg));
			input_mode_window->SetVisible(true);
			input_help_window->SetVisible(true);
			input_help_window->SetText("Press a key to bind. To abort the mapping wait 3 seconds");
			break;
		case Window_Settings::eInputButtonRemove:
			help_window->SetVisible(true);
			input_window->SetActive(true);
			input_window->SetVisible(true);
			input_window->SetIndex(0);
			input_mode_window->SetVisible(true);
			input_help_window->SetVisible(true);
			input_help_window->SetText("Select the keybinding you want to remove");
			break;
		case Window_Settings::eAbout:
			about_window->SetVisible(true);
			break;
		default:
			help_window->SetVisible(true);
			options_window->SetActive(true);
			options_window->SetVisible(true);
			break;
	}
}

void Scene_Settings::Refresh() {
	options_window->Refresh();
}

void Scene_Settings::vUpdate() {
	if (RefreshInputEmergencyReset()) {
		return;
	}

	main_window->Update();
	help_window->Update();
	help_window2->Update();
	options_window->Update();
	input_window->Update();
	input_mode_window->Update();

	auto opt_mode = options_window->GetMode();

	SetMode(opt_mode);

	if (Input::IsTriggered(Input::CANCEL) && opt_mode != Window_Settings::eInputButtonAdd) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Cancel));

		if (number_window) {
			number_window.reset();
			auto& option = options_window->GetCurrentOption();
			option.current_value = option.original_value;
			option.action();
			options_window->SetActive(true);
			return;
		}

		if (picker_window) {
			picker_window.reset();
			auto& option = options_window->GetCurrentOption();
			option.current_value = option.original_value;
			option.action();
			options_window->SetActive(true);
			return;
		}

		help_window2->SetFont(nullptr);
		options_window->Pop();
		SetMode(options_window->GetMode());
		if (mode == Window_Settings::eNone) {
			Scene::Pop();
		}
	}

	switch (opt_mode) {
		case Window_Settings::eNone:
		case Window_Settings::eSave:
		case Window_Settings::eEnd:
		case Window_Settings::eAbout:
		case Window_Settings::eLanguage: // fix compiler warning, not implemented
			break;
		case Window_Settings::eMain:
			UpdateMain();
			break;
		case Window_Settings::eInput:
		case Window_Settings::eVideo:
		case Window_Settings::eAudio:
		case Window_Settings::eAudioMidi:
		case Window_Settings::eAudioSoundfont:
		case Window_Settings::eLicense:
		case Window_Settings::eEngine:
		case Window_Settings::eInputButtonCategory:
		case Window_Settings::eInputListButtonsGame:
		case Window_Settings::eInputListButtonsEngine:
		case Window_Settings::eInputListButtonsDeveloper:
			UpdateOptions();
			break;
		case Window_Settings::eEngineFont1:
			UpdateFont(false);
			break;
		case Window_Settings::eEngineFont2:
			UpdateFont(true);
			break;
		case Window_Settings::eInputButtonOption:
			UpdateButtonOption();
			break;
		case Window_Settings::eInputButtonAdd:
			UpdateButtonAdd();
			break;
		case Window_Settings::eInputButtonRemove:
			UpdateButtonRemove();
			break;
		case Window_Settings::eLastMode:
			assert(false);
	}
}

void Scene_Settings::OnTitleSpriteReady(FileRequestResult* result) {
	BitmapRef bitmapRef = Cache::Title(result->file);

	title->SetBitmap(bitmapRef);

	// If the title sprite doesn't fill the screen, center it to support custom resolutions
	if (bitmapRef->GetWidth() < Player::screen_width) {
		title->SetX(Player::menu_offset_x);
	}
	if (bitmapRef->GetHeight() < Player::screen_height) {
		title->SetY(Player::menu_offset_y);
	}
}

void Scene_Settings::UpdateMain() {

	if (Input::IsTriggered(Input::DECISION)) {
		auto idx = main_window->GetIndex();

		if (main_window->IsItemEnabled(idx)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Decision));
		} else {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Buzzer));
			return;
		}

		auto mode = root_options[idx].first;

		if (mode == Window_Settings::eLanguage) {
			Scene::Push(std::make_shared<Scene_Language>());
			return;
		} if (mode == Window_Settings::eSave) {
			SaveConfig();
			return;
		} else if (mode == Window_Settings::eEnd) {
			if (Scene::Find(Scene::GameBrowser)) {
				Scene::Push(std::make_unique<Scene_End>(Scene::GameBrowser));
			} else {
				Scene::Push(std::make_unique<Scene_End>(Scene::Null));
			}
			return;
		}

		SetMode(mode);
		options_window->Push(mode);
	}
}

void Scene_Settings::UpdateOptions() {
	if (number_window) {
		number_window->Update();
		auto& option = options_window->GetCurrentOption();
		option.current_value = Utils::Clamp(number_window->GetNumber(), option.min_value, option.max_value);
		option.action();

		if (Input::IsTriggered(Input::DECISION)) {
			options_window->Refresh();
			number_window.reset();
			options_window->SetActive(true);
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Decision));
		}
		return;
	} else if (picker_window) {
		picker_window->Update();
		auto& option = options_window->GetCurrentOption();
		option.current_value = option.options_index[picker_window->GetIndex()];
		option.action();

		if (Input::IsTriggered(Input::DECISION)) {
			options_window->Refresh();
			picker_window.reset();
			options_window->SetActive(true);
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Decision));
		}
		return;
	}

	if (Input::IsTriggered(Input::DECISION)) {
		if (options_window->IsCurrentActionEnabled()) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Decision));
			auto& option = options_window->GetCurrentOption();
			if (option.mode == Window_Settings::eOptionNone) {
				option.action();
				options_window->Refresh();
			} else if (option.mode == Window_Settings::eOptionRangeInput) {
				number_window.reset(new Window_NumberInput(0, 0, 128, 32));
				number_window->SetNumber(option.current_value);
				number_window->SetMaxDigits(std::log10(option.max_value) + 1);
				number_window->SetX(options_window->GetX() + options_window->GetWidth() / 2 - number_window->GetWidth() / 2);
				number_window->SetY(options_window->GetY() + options_window->GetHeight() / 2 - number_window->GetHeight() / 2);
				number_window->SetZ(options_window->GetZ() + 1);
				number_window->SetOpacity(255);
				number_window->SetActive(true);
				help_window->SetText(fmt::format("Input a value from {} to {}", option.min_value, option.max_value));
				options_window->SetActive(false);
			} else if (option.mode == Window_Settings::eOptionPicker) {
				picker_window.reset(new Window_Command(option.options_text));
				picker_window->SetX(options_window->GetX() + options_window->GetWidth() / 2 - picker_window->GetWidth() / 2);
				picker_window->SetY(options_window->GetY() + options_window->GetHeight() / 2 - picker_window->GetHeight() / 2);
				picker_window->SetZ(options_window->GetZ() + 1);
				picker_window->SetIndex(option.current_value);
				picker_window->SetHelpWindow(help_window.get());
				picker_window->SetActive(true);
				options_window->SetActive(false);
				picker_window->UpdateHelpFn = [this](Window_Help& win, int index) {
					win.SetText(options_window->GetCurrentOption().options_help[index]);
				};
			}
		} else {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Buzzer));
		}
	}

	if (Input::IsTriggered(Input::LEFT) || Input::IsRepeated(Input::LEFT)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Cursor));
		if (options_window->IsCurrentActionEnabled()) {
			auto& option = options_window->GetCurrentOption();
			if (option.mode == Window_Settings::eOptionRangeInput) {
				--option.current_value;
				if (option.current_value < option.min_value) {
					option.current_value = option.max_value;
				}
				option.action();
			} else if (option.mode == Window_Settings::eOptionPicker) {
				auto it = std::find(option.options_index.begin(), option.options_index.end(), option.current_value);
				assert(it != option.options_index.end());

				if (it == option.options_index.begin()) {
					it = std::prev(option.options_index.end());
				} else {
					std::advance(it, -1);
				}
				option.current_value = *it;
			}
			option.action();
			options_window->Refresh();
		}
	}

	if (Input::IsTriggered(Input::RIGHT) || Input::IsRepeated(Input::RIGHT)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Cursor));
		if (options_window->IsCurrentActionEnabled()) {
			auto& option = options_window->GetCurrentOption();
			if (option.mode == Window_Settings::eOptionRangeInput) {
				++option.current_value;
				if (option.current_value > option.max_value) {
					option.current_value = option.min_value;
				}
				option.action();
			} else if (option.mode == Window_Settings::eOptionPicker) {
				auto it = std::find(option.options_index.begin(), option.options_index.end(), option.current_value);
				assert(it != option.options_index.end());

				std::advance(it, 1);
				if (it == option.options_index.end()) {
					it = option.options_index.begin();
				}
				option.current_value = *it;
			}
			option.action();
			options_window->Refresh();
		}
	}
}

void Scene_Settings::UpdateFont(bool mincho) {
	auto fs = Game_Config::GetFontFilesystem();

	auto& last_index = options_window->GetFrame().scratch;

	if (font_size_window) {
		font_size_window->SetY(options_window->GetY() + options_window->GetCursorRect().y);
		font_size_window->Update();
	}

	int index = options_window->GetIndex();
	if (last_index == index) {
		if (index == 0 || !help_window2->GetFont() || help_window2->GetFont()->GetCurrentStyle().size == options_window->font_size.Get()) {
			// Same index or font size did not change
			UpdateOptions();
			return;
		}
	}
	last_index = index;

	if (!font_size_window) {
		font_size_window = std::make_unique<Window_Help>(options_window->GetRightX(), 0, 32, 32);
		font_size_window->SetLeftArrow(true);
		font_size_window->SetRightArrow(true);
		font_size_window->SetAnimateArrows(true);
	}

	font_size_window->SetVisible(false);
	font_size_window->SetText(std::to_string(options_window->font_size.Get()));

	if (index == 0) {
		// Built-In font
		help_window2->Clear();
		help_window2->SetFont(Font::DefaultBitmapFont(mincho));
		help_window2->SetVisible(true);
	} else if (index >= options_window->GetRowMax() - 2) {
		// Sample or browse
		help_window2->Clear();
		help_window2->SetFont(nullptr);
		help_window2->SetVisible(true);
	} else {
		auto is = fs.OpenInputStream(options_window->GetCurrentOption().text);
		if (is) {
			auto font = Font::CreateFtFont(std::move(is), options_window->font_size.Get(), false, false);
			if (font) {
				help_window2->Clear();
				help_window2->SetFont(font);
				help_window2->SetVisible(true);
				font_size_window->SetVisible(true);
			} else {
				auto& opt = options_window->GetCurrentOption();
				opt.action = nullptr;
				opt.value_text = "[Broken]";
				opt.help2.clear();
				options_window->DrawOption(options_window->GetIndex());
			}
		}
	}

	UpdateOptions();
}

void Scene_Settings::UpdateButtonOption() {
	if (Input::IsTriggered(Input::DECISION)) {
		switch (input_mode_window->GetIndex()) {
			case 0:
				if (!input_mode_window->IsItemEnabled(0)) {
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Buzzer));
				} else {
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Decision));
					options_window->Push(Window_Settings::eInputButtonAdd, options_window->GetFrame().arg);
				}
				break;
			case 1:
				if (!input_mode_window->IsItemEnabled(1)) {
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Buzzer));
				} else {
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Decision));
					options_window->Push(Window_Settings::eInputButtonRemove, options_window->GetFrame().arg);
				}
				break;
			case 2:
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Decision));
				input_window->ResetMapping();
				break;
		}
		RefreshInputActionAllowed();
	}
}

void Scene_Settings::UpdateButtonAdd() {
	const Input::KeyStatus* keys = &Input::GetAllRawPressed();

	auto& frame = options_window->GetFrame();
	int& started = frame.scratch;
	int& cancel_timer = frame.scratch2;

	if (cancel_timer == Game_Clock::GetTargetGameFps() * 3) {
		options_window->Pop();
		input_window->Refresh();
		return;
	}
	++cancel_timer;

	// Delay button reading on startup until 0 keys are pressed
	// Prevents that CONFIRM is directly detected as pressed key
	// on some platforms
	if (started == 0) {
		keys = &Input::GetAllRawPressed();
		if (keys->count() != 0) {
			return;
		}
		started = 1;
	}

	for (size_t i = 0; i < keys->size(); ++i) {
		if ((*keys)[i]) {
			auto button = static_cast<Input::InputButton>(frame.arg);
			auto& mappings = Input::GetInputSource()->GetButtonMappings();
			mappings.Add({button, static_cast<Input::Keys::InputKey>(i) });
			options_window->Pop();
			input_window->Refresh();
			break;
		}
	}
}

void Scene_Settings::UpdateButtonRemove() {
	if (Input::IsTriggered(Input::DECISION)) {
		if (input_window->RemoveMapping()) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Decision));
			options_window->Pop();
		} else {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Game_System::SFX_Buzzer));
		}
	}
}

bool Scene_Settings::RefreshInputEmergencyReset() {
	if (Input::GetAllRawPressed().count() >= 4) {
		if (input_reset_counter == 0) {
			Output::InfoStr("Input emergency reset started");
			Output::InfoStr("Hold the keys for 3 seconds");
		}
		input_reset_counter++;

		if (input_reset_counter == Game_Clock::GetTargetGameFps() * 3) {
			if (input_window->GetInputButton() == Input::InputButton::BUTTON_COUNT) {
				// No last button yet: reset everything
				Output::InfoStr("All buttons reset to default");
				if (input_window->GetActive()) {
					input_window->SetIndex(0);
				}
				Input::ResetAllMappings();
			} else {
				Output::Info("Button {} reset to default", Input::kInputButtonNames.tag(input_window->GetInputButton()));
				Output::Info("To reset all buttons hold 3 seconds longer");
				if (input_window->GetActive()) {
					input_window->SetIndex(0);
				}
				input_window->ResetMapping();
			}
		} else if (input_reset_counter == Game_Clock::GetTargetGameFps() * 6) {
			Output::InfoStr("All buttons reset to default");
			if (input_window->GetActive()) {
				input_window->SetIndex(0);
			}
			Input::ResetAllMappings();
		}
	} else {
		if (input_reset_counter > 0) {
			Output::InfoStr("Input emergency reset ended");
			input_reset_counter = 0;
		}
	}

	return input_reset_counter > 0;
}

void Scene_Settings::RefreshInputActionAllowed() {
	auto button = static_cast<Input::InputButton>(options_window->GetFrame().arg);
	auto mapping_count =  Input::GetInputSource()->GetButtonMappings().Count(button);
	input_mode_window->SetItemEnabled(0, mapping_count < Window_InputSettings::mapping_limit);
	input_mode_window->SetItemEnabled(1, mapping_count > (Input::IsProtectedButton(button) ? 1 : 0));
}

bool Scene_Settings::SaveConfig(bool silent) {
	auto cfg_out = Game_Config::GetGlobalConfigFileOutput();

	if (!cfg_out) {
		if (silent) {
			Output::Debug("Saving configuration file failed!");
		} else {
			Output::Warning("Saving configuration file failed!");
		}
		return false;
	}

	Game_Config cfg;
	cfg.video = DisplayUi->GetConfig();
	cfg.audio = Audio().GetConfig();
	cfg.input = Input::GetInputSource()->GetConfig();
	cfg.player = Player::player_config;

	cfg.WriteToStream(cfg_out);

	AsyncHandler::SaveFilesystem();

	if (silent) {
		Output::Debug("Configuration saved to {}", cfg_out.GetName());
	} else {
		Output::Info("Configuration saved to {}", cfg_out.GetName());
	}

	return true;
}


/*end of file .\scene_settings.cpp*/

/*start of file .\scene_shop.cpp*/

/* ... license chunk ... */

// Headers
#include "game_system.h"
#include "game_party.h"
#include "input.h"
#include <lcf/reader_util.h>
#include "scene_shop.h"
#include "output.h"

Scene_Shop::Scene_Shop(
		std::vector<int> goods,
		int shop_type,
		bool allow_buy,
		bool allow_sell,
		Continuation on_finish)
	: on_finish(std::move(on_finish)),
	goods(std::move(goods)),
	shop_type(shop_type),
	allow_buy(allow_buy),
	allow_sell(allow_sell)
{
	Scene::type = Scene::Shop;
}

void Scene_Shop::Start() {
	// Sanitize shop items
	for (auto it = goods.begin(); it != goods.end();) {
		const auto* item = lcf::ReaderUtil::GetElement(lcf::Data::items, *it);
		if (!item) {
			Output::Warning("Removed invalid item {} from shop", *it);
			it = goods.erase(it);
		} else {
			++it;
		}
	}

	int window_help_height = 32;
	int window_buy_width = 184;
	int window_buy_height = 128;
	int window_party_width = 136;
	int window_party_height = 48;
	int window_status_width = 136;
	int window_status_height = 48;
	int window_gold_width = 136;
	int window_gold_height = 32;
	int window_shop_height = 80;

	help_window.reset(new Window_Help(Player::menu_offset_x, Player::menu_offset_y, MENU_WIDTH, window_help_height));
	buy_window.reset(new Window_ShopBuy(goods, Player::menu_offset_x, Player::menu_offset_y + window_help_height, window_buy_width, window_buy_height));
	number_window.reset(new Window_ShopNumber(Player::menu_offset_x, Player::menu_offset_y + window_help_height, window_buy_width, window_buy_height));
	party_window.reset(new Window_ShopParty(Player::menu_offset_x + window_buy_width, Player::menu_offset_y + window_help_height, window_party_width, window_party_height));
	status_window.reset(new Window_ShopStatus(Player::menu_offset_x + window_buy_width, Player::menu_offset_y + window_help_height + window_party_height, window_status_width, window_status_height));
	gold_window.reset(new Window_Gold(Player::menu_offset_x + window_buy_width, Player::menu_offset_y + window_help_height + window_party_height + window_status_height, window_gold_width, window_gold_height));
	shop_window.reset(new Window_Shop(shop_type, Player::menu_offset_x, Player::menu_offset_y + window_help_height + window_party_height + window_status_height + window_gold_height, MENU_WIDTH, window_shop_height));
	sell_window.reset(new Window_ShopSell(Player::menu_offset_x, Player::menu_offset_y + window_help_height, MENU_WIDTH, window_buy_height));
	empty_window.reset(new Window_Base(Player::menu_offset_x, Player::menu_offset_y + window_help_height, MENU_WIDTH, window_buy_height));
	empty_window2.reset(new Window_Base(Player::menu_offset_x, Player::menu_offset_y + window_help_height, window_buy_width, window_buy_height));

	buy_window->SetActive(false);
	buy_window->SetVisible(false);
	buy_window->SetHelpWindow(help_window.get());

	sell_window->SetActive(false);
	sell_window->SetVisible(false);
	sell_window->SetHelpWindow(help_window.get());

	number_window->SetActive(false);
	number_window->SetVisible(false);

	status_window->SetVisible(false);
	sell_window->Refresh();
	sell_window->SetIndex(0);
	sell_window->SetActive(true);

	timer = 0;

	if (allow_buy && allow_sell) {
		SetMode(BuySellLeave);
	} else if (allow_buy) {
		shop_window->SetChoice(Buy);
		SetMode(Buy);
	} else {
		shop_window->SetChoice(Sell);
		SetMode(Sell);
	}
}

static void Enable(Window* window, bool state) {
	window->SetVisible(state);
	window->SetActive(state);
}

void Scene_Shop::SetMode(int nmode) {
	mode = nmode;
	help_window->SetText("");

	// Central panel
	switch (mode) {
		case BuySellLeave:
		case BuySellLeave2:
			empty_window->SetVisible(true);
			Enable(sell_window.get(), false);
			break;
		case Sell:
			empty_window->SetVisible(false);
			Enable(sell_window.get(), true);
			break;
		case Buy:
		case BuyHowMany:
		case SellHowMany:
		case Bought:
		case Sold:
			empty_window->SetVisible(false);
			Enable(sell_window.get(), false);
			break;
	}

	// Right-hand panels
	switch (mode) {
		case BuySellLeave:
		case BuySellLeave2:
		case Sell:
			party_window->SetVisible(false);
			status_window->SetVisible(false);
			gold_window->SetVisible(false);
			break;
		case Buy:
		case BuyHowMany:
		case SellHowMany:
		case Bought:
		case Sold:
			party_window->SetVisible(true);
			status_window->SetVisible(true);
			gold_window->SetVisible(true);
			break;
	}

	// Left-hand panels
	switch (mode) {
		case BuySellLeave:
		case BuySellLeave2:
			Enable(buy_window.get(), false);
			Enable(number_window.get(), false);
			empty_window2->SetVisible(false);
			break;
		case Sell:
			sell_window->Refresh();
			Enable(number_window.get(), false);
			empty_window2->SetVisible(false);
			break;
		case Buy:
			buy_window->Refresh();
			Enable(buy_window.get(), true);
			Enable(number_window.get(), false);
			empty_window2->SetVisible(false);
			break;
		case BuyHowMany:
		case SellHowMany:
			number_window.get()->Refresh();
			Enable(buy_window.get(), false);
			Enable(number_window.get(), true);
			break;
		case Bought:
		case Sold:
			Enable(buy_window.get(), false);
			Enable(number_window.get(), false);
			empty_window2->SetVisible(true);

			timer = DEFAULT_FPS;
			break;
	}

	shop_window->SetMode(mode);
}

void Scene_Shop::vUpdate() {
	buy_window->Update();
	sell_window->Update();
	shop_window->Update();
	number_window->Update();
	party_window->Update();

	switch (mode) {
		case BuySellLeave:
		case BuySellLeave2:
			UpdateCommandSelection();
			break;
		case Buy:
			UpdateBuySelection();
			break;
		case Sell:
			UpdateSellSelection();
			break;
		case BuyHowMany:
		case SellHowMany:
			UpdateNumberInput();
			break;
		case Bought:
			timer--;
			if (timer == 0)
				SetMode(Buy);
			break;
		case Sold:
			timer--;
			if (timer == 0)
				SetMode(Sell);
			break;
		default:
			break;
	}
}

void Scene_Shop::UpdateCommandSelection() {
	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		Scene::Pop();
	} else if (Input::IsTriggered(Input::DECISION)) {
		switch (shop_window->GetChoice()) {
			case Buy:
			case Sell:
				SetMode(shop_window->GetChoice());
				break;
			case Leave:
				Scene::Pop();
				break;
		}
	}
}

void Scene_Shop::UpdateBuySelection() {
	status_window->SetItemId(buy_window->GetItemId());
	party_window->SetItemId(buy_window->GetItemId());

	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		if (allow_sell) {
			SetMode(BuySellLeave2);
		} else {
			Scene::Pop();
		}
	} else if (Input::IsTriggered(Input::DECISION)) {
		int item_id = buy_window->GetItemId();

		// checks the money and number of items possessed before buy
		if (buy_window->CheckEnable(item_id)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));

			// Items are guaranteed to be valid
			const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);

			int max = Main_Data::game_party->GetMaxItemCount(item_id) - Main_Data::game_party->GetItemCount(item_id);
			if (item->price > 0) {
				max = std::min<int>(max, Main_Data::game_party->GetGold() / item->price);
			}
			number_window->SetData(item_id, max, item->price);

			SetMode(BuyHowMany);
		}
		else {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		}
	}
}

void Scene_Shop::UpdateSellSelection() {
	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		if (allow_buy) {
			SetMode(BuySellLeave2);
		} else {
			Scene::Pop();
		}
	} else if (Input::IsTriggered(Input::DECISION)) {
		const lcf::rpg::Item* item = sell_window->GetItem();
		int item_id = (item != nullptr) ? item->ID : 0;
		status_window->SetItemId(item_id);
		party_window->SetItemId(item_id);

		if (item && item->price > 0) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
			number_window->SetData(item->ID, Main_Data::game_party->GetItemCount(item->ID), item->price / 2);
			SetMode(SellHowMany);
		} else {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		}
	}
}

void Scene_Shop::UpdateNumberInput() {
	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		switch (shop_window->GetChoice()) {
		case Buy:
			SetMode(Buy); break;
		case Sell:
			SetMode(Sell); break;
		}
	} else if (Input::IsTriggered(Input::DECISION)) {
		int item_id;
		switch (shop_window->GetChoice()) {
		case Buy:
			item_id = buy_window->GetItemId();
			Main_Data::game_party->LoseGold(number_window->GetTotal());
			Main_Data::game_party->AddItem(item_id, number_window->GetNumber());
			gold_window->Refresh();
			buy_window->Refresh();
			status_window->Refresh();
			SetMode(Bought); break;
		case Sell:
			item_id = sell_window->GetItem() == NULL ? 0 : sell_window->GetItem()->ID;
			Main_Data::game_party->GainGold(number_window->GetTotal());
			Main_Data::game_party->RemoveItem(item_id, number_window->GetNumber());
			gold_window->Refresh();
			sell_window->Refresh();
			status_window->Refresh();
			SetMode(Sold); break;
		}
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));

		did_transaction = true;
	}
}

void Scene_Shop::Suspend(SceneType /* next_scene */) {
	if (on_finish) {
		on_finish(did_transaction);
	}
}


/*end of file .\scene_shop.cpp*/

/*start of file .\scene_skill.cpp*/

/* ... license chunk ... */

// Headers
#include "scene_skill.h"
#include "algo.h"
#include "game_actors.h"
#include "game_map.h"
#include "game_party.h"
#include "game_player.h"
#include "game_system.h"
#include "game_targets.h"
#include "input.h"
#include "scene_actortarget.h"
#include "scene_teleport.h"
#include "transition.h"
#include "player.h"

Scene_Skill::Scene_Skill(std::vector<Game_Actor*> actors, int actor_index, int skill_index) :
	actors(actors), actor_index(actor_index), skill_index(skill_index) {
	Scene::type = Scene::Skill;

	assert(!actors.empty());
}

void Scene_Skill::Start() {
	// Create the windows
	int window_help_height = 32;
	int window_skillstatus_height = 32;
	help_window.reset(new Window_Help(Player::menu_offset_x, Player::menu_offset_y, MENU_WIDTH, window_help_height));
	skillstatus_window.reset(new Window_SkillStatus(Player::menu_offset_x, Player::menu_offset_y + window_help_height, MENU_WIDTH, window_skillstatus_height));
	skill_window.reset(new Window_Skill(Player::menu_offset_x, Player::menu_offset_y + window_help_height + window_skillstatus_height, MENU_WIDTH, MENU_HEIGHT - (window_help_height + window_skillstatus_height)));

	const auto& actor = *actors[actor_index];

	// Assign actors and help to windows
	skill_window->SetActor(actor);
	skillstatus_window->SetActor(actor);
	skill_window->SetIndex(skill_index);
	skill_window->SetHelpWindow(help_window.get());
}

void Scene_Skill::Continue(SceneType) {
	skillstatus_window->Refresh();
	skill_window->Refresh();
}

void Scene_Skill::vUpdate() {
	help_window->Update();
	skillstatus_window->Update();
	skill_window->Update();

	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		Scene::Pop();
	} else if (Input::IsTriggered(Input::DECISION)) {
		const lcf::rpg::Skill* skill = skill_window->GetSkill();
		int skill_id = skill ? skill->ID : 0;

		auto& actor = *actors[actor_index];

		if (skill && skill_window->CheckEnable(skill_id)) {
			if (skill->type == lcf::rpg::Skill::Type_switch) {
				Main_Data::game_system->SePlay(skill->sound_effect);
				Main_Data::game_party->UseSkill(skill_id, &actor, &actor);
				Scene::PopUntil(Scene::Map);
				Game_Map::SetNeedRefresh(true);
			} else if (Algo::IsNormalOrSubskill(*skill)) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
				Scene::Push(std::make_shared<Scene_ActorTarget>(skill_id, actor_index));
				skill_index = skill_window->GetIndex();
			} else if (skill->type == lcf::rpg::Skill::Type_teleport) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
				Scene::Push(std::make_shared<Scene_Teleport>(actor, *skill));
			} else if (skill->type == lcf::rpg::Skill::Type_escape) {
				Main_Data::game_system->SePlay(skill->sound_effect);
				Main_Data::game_party->UseSkill(skill_id, &actor, &actor);
				Main_Data::game_player->ForceGetOffVehicle();
				Main_Data::game_player->ReserveTeleport(Main_Data::game_targets->GetEscapeTarget());

				Scene::PopUntil(Scene::Map);
			}
		} else {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		}
	}
}

void Scene_Skill::TransitionOut(SceneType next_scene) {
	const auto* skill = skill_window->GetSkill();
	if (next_scene == Map && skill && skill->type == lcf::rpg::Skill::Type_escape) {
		Transition::instance().InitErase(Transition::TransitionFadeOut, this);
	} else {
		Scene::TransitionOut(next_scene);
	}
}


/*end of file .\scene_skill.cpp*/

/*start of file .\scene_status.cpp*/

/* ... license chunk ... */

// Headers
#include <string>
#include <vector>
#include "scene_status.h"
#include "game_actors.h"
#include "game_party.h"
#include "game_system.h"
#include "input.h"
#include "player.h"

Scene_Status::Scene_Status(std::vector<Game_Actor*> actors, int actor_index) :
	actors(actors), actor_index(actor_index) {
	type = Scene::Status;

	assert(!actors.empty());
}

void Scene_Status::Start() {
	int window_actor_info_width = 124;
	int window_actor_info_height = 208;
	int window_gold_width = 124;
	int window_gold_height = 32;
	int window_actor_status_width = 196;
	int window_actor_status_height = 64;
	int window_param_status_width = 196;
	int window_param_status_height = 80;
	int window_equip_width = 196;
	int window_equip_height = 96;

	const auto& actor = *actors[actor_index];
	actorinfo_window.reset(new Window_ActorInfo(Player::menu_offset_x, Player::menu_offset_y, window_actor_info_width, window_actor_info_height, actor));
	gold_window.reset(new Window_Gold(Player::menu_offset_x, Player::menu_offset_y + window_actor_info_height, window_gold_width, window_gold_height));
	actorstatus_window.reset(new Window_ActorStatus(Player::menu_offset_x + window_actor_info_width, Player::menu_offset_y, window_actor_status_width, window_actor_status_height, actor));
	paramstatus_window.reset(new Window_ParamStatus(Player::menu_offset_x + window_actor_info_width, Player::menu_offset_y + window_actor_status_height, window_param_status_width, window_param_status_height, actor));
	equip_window.reset(new Window_Equip(Player::menu_offset_x + window_actor_info_width, Player::menu_offset_y + window_actor_status_height + window_param_status_height, window_equip_width, window_equip_height, actor));

	equip_window->SetActive(false);
	paramstatus_window->SetActive(false);

	equip_window->SetIndex(-1);
}

void Scene_Status::vUpdate() {
	gold_window->Update();
	paramstatus_window->Update();
	equip_window->Update();

	if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
		Scene::Pop();
	} else if (actors.size() > 1 && Input::IsTriggered(Input::RIGHT)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
		actor_index = (actor_index + 1) % actors.size();
		Scene::Push(std::make_shared<Scene_Status>(actors, actor_index), true);
	} else if (actors.size() > 1 && Input::IsTriggered(Input::LEFT)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
		actor_index = actor_index - 1;
		if (actor_index < 0) {
			actor_index = actors.size() - 1;
		}
		Scene::Push(std::make_shared<Scene_Status>(actors, actor_index), true);
	}
}


/*end of file .\scene_status.cpp*/

/*start of file .\scene_teleport.cpp*/

/* ... license chunk ... */

// Headers
#include "scene_teleport.h"
#include "game_party.h"
#include "game_player.h"
#include "game_system.h"
#include "input.h"
#include "transition.h"
#include <player.h>

Scene_Teleport::Scene_Teleport(Game_Actor& actor, const lcf::rpg::Skill& skill)
		: actor(&actor), skill(&skill) {
	type = Scene::Teleport;
}

Scene_Teleport::Scene_Teleport(const lcf::rpg::Item& item, const lcf::rpg::Skill& skill)
		: skill(&skill), item(&item) {
	type = Scene::Teleport;
	assert(item.skill_id == skill.ID && "Item doesn't invoke the skill");
}

void Scene_Teleport::Start() {
	teleport_window.reset(new Window_Teleport(0, Player::screen_height - 80, Player::screen_width, 80));
	teleport_window->SetActive(true);
	teleport_window->SetIndex(0);
}

void Scene_Teleport::vUpdate() {
	teleport_window->Update();

	if (Input::IsTriggered(Input::DECISION)) {
		if (item) {
			Main_Data::game_party->ConsumeItemUse(item->ID);
		} else {
			Main_Data::game_party->UseSkill(skill->ID, actor, actor);
		}

		Main_Data::game_system->SePlay(skill->sound_effect);

		const lcf::rpg::SaveTarget& target = teleport_window->GetTarget();

		Main_Data::game_player->ForceGetOffVehicle();
		Main_Data::game_player->ReserveTeleport(target);

		Scene::PopUntil(Scene::Map);
	} else if (Input::IsTriggered(Input::CANCEL)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));

		Scene::Pop();
	}
}

void Scene_Teleport::TransitionOut(SceneType next_scene) {
	if (next_scene == Map) {
		Transition::instance().InitErase(Transition::TransitionFadeOut, this);
	} else {
		Scene::TransitionOut(next_scene);
	}
}


/*end of file .\scene_teleport.cpp*/

/*start of file .\scene_title.cpp*/

/* ... license chunk ... */

// Headers
#include <fstream>
#include <sstream>
#include <vector>
#include "game_config.h"
#include "options.h"
#include "scene_settings.h"
#include "scene_title.h"
#include "scene_language.h"
#include "audio.h"
#include "audio_secache.h"
#include "cache.h"
#include "game_battle.h"
#include "game_ineluki.h"
#include "game_screen.h"
#include "game_system.h"
#include "transition.h"
#include "input.h"
#include "main_data.h"
#include "meta.h"
#include "output.h"
#include "player.h"
#include "translation.h"
#include "scene_battle.h"
#include "scene_import.h"
#include "scene_load.h"
#include "window_command.h"
#include "baseui.h"
#include <lcf/reader_util.h>

Scene_Title::Scene_Title() {
	type = Scene::Title;
}

void Scene_Title::Start() {
	Main_Data::game_system->ResetSystemGraphic();

	// Change the resolution of the window
	if (Player::has_custom_resolution) {
		Player::ChangeResolution(Player::screen_width, Player::screen_height);
	} else {
		switch (DisplayUi->GetConfig().game_resolution.Get()) {
			case ConfigEnum::GameResolution::Original:
				Player::ChangeResolution(SCREEN_TARGET_WIDTH, SCREEN_TARGET_HEIGHT);
				break;
			case ConfigEnum::GameResolution::Widescreen:
				Player::ChangeResolution(416, SCREEN_TARGET_HEIGHT);
				Player::game_config.fake_resolution.Set(true);
				break;
			case ConfigEnum::GameResolution::Ultrawide:
				Player::ChangeResolution(560, SCREEN_TARGET_HEIGHT);
				Player::game_config.fake_resolution.Set(true);
				break;
		}
	}

	// Skip background image and music if not used
	if (CheckEnableTitleGraphicAndMusic()) {
		CreateTitleGraphic();
		PlayTitleMusic();
	}

	CreateCommandWindow();
}


void Scene_Title::Continue(SceneType prev_scene) {
	Main_Data::game_system->ResetSystemGraphic();

	if (restart_title_cache) {
		// Clear the cache when the game returns to the title screen
		// e.g. by pressing F12, except the Title Load menu
		Cache::ClearAll();
		AudioSeCache::Clear();

		Player::ResetGameObjects();
		if (Player::IsPatchKeyPatch()) {
			Main_Data::game_ineluki->ExecuteScriptList(FileFinder::Game().FindFile("autorun.script"));
		}

		Start();

		restart_title_cache = false;
	} else if (CheckEnableTitleGraphicAndMusic()) {
		CreateTitleGraphic();
	}

	if (prev_scene != Scene::Load && !Player::hide_title_flag) {
		command_window->SetOpenAnimation(8);
	}
}

void Scene_Title::TransitionIn(SceneType prev_scene) {
	if (Game_Battle::battle_test.enabled || !Check2k3ShowTitle() || Player::game_config.new_game.Get())
		return;

	if (prev_scene == Scene::Load || Player::hide_title_flag) {
		Scene::TransitionIn(prev_scene);
		return;
	}
	Transition::instance().InitShow(Transition::TransitionFadeIn, this);
}

void Scene_Title::Suspend(Scene::SceneType scene_type) {
	if (scene_type == Scene::Settings || scene_type == Scene::LanguageMenu) {
		restart_title_cache = true;
	}

	// Unload title graphic to save memory
	title.reset();
}

void Scene_Title::vUpdate() {
	if (Game_Battle::battle_test.enabled) {
		Player::SetupBattleTest();
		return;
	}

	if (!Check2k3ShowTitle() || Player::game_config.new_game.Get()) {
		Player::SetupNewGame();
		if (Player::debug_flag && Player::hide_title_flag) {
			Scene::Push(std::make_shared<Scene_Load>());
		}
		return;
	}

	command_window->Update();

	if (Input::IsTriggered(Input::DECISION)) {
		int index = command_window->GetIndex();
		if (index == indices.new_game) {  // New Game
			CommandNewGame();
		} else if (index == indices.continue_game) {  // Load Game
			CommandContinue();
		} else if (index == indices.import) {  // Import (multi-part games)
			CommandImport();
		} else if (index == indices.settings) {
			CommandSettings();
		} else if (index == indices.translate) { // Choose a Translation (Language)
			CommandTranslation();
		} else if (index == indices.exit) {  // Exit Game
			CommandShutdown();
		}
	} else if (Input::IsTriggered(Input::SHIFT)) {
		// For emscripten: Allow accessing the load scene for file upload with Shift
		int index = command_window->GetIndex();
		if (index == indices.continue_game) {
			CommandContinue();
		}
	}
}

void Scene_Title::Refresh() {
	// Enable load game if available
	continue_enabled = FileFinder::HasSavegame();
	if (continue_enabled) {
		command_window->SetIndex(1);
	}
	command_window->SetItemEnabled(1, continue_enabled);
}

void Scene_Title::OnTranslationChanged() {
	Start();

	command_window->SetIndex(indices.translate);

	Scene::OnTranslationChanged();
}

void Scene_Title::CreateTitleGraphic() {
	// Load Title Graphic
	if (!lcf::Data::system.title_name.empty()) {
		title.reset(new Sprite());
		FileRequestAsync* request = AsyncHandler::RequestFile("Title", lcf::Data::system.title_name);
		request->SetGraphicFile(true);
		request_id = request->Bind(&Scene_Title::OnTitleSpriteReady, this);
		request->Start();
	} else {
		title.reset(new Sprite());
		title->SetBitmap(Bitmap::Create(Player::screen_width, Player::screen_height, Color(0, 0, 0, 255)));
	}
}

void Scene_Title::RepositionWindow(Window_Command& window, bool center_vertical) {
	if (!center_vertical) {
		window.SetX(Player::screen_width / 2 - window.GetWidth() / 2);
		window.SetY(Player::screen_height * 53 / 60 - window.GetHeight());
	} else {
		window.SetX(Player::screen_width / 2 - window.GetWidth() / 2);
		window.SetY(Player::screen_height / 2 - window.GetHeight() / 2);
	}
}

void Scene_Title::CreateCommandWindow() {
	// Create Options Window
	std::vector<std::string> options;
	options.push_back(ToString(lcf::Data::terms.new_game));
	options.push_back(ToString(lcf::Data::terms.load_game));

	// Reset index to fix issues on reuse.
	indices = CommandIndices();

	// Set "Import" based on metadata
	if (Player::meta->IsImportEnabled()) {
		options.push_back(Player::meta->GetExVocabImportSaveTitleText());
		indices.import = indices.exit;
		indices.exit++;
	}

	// Set "Settings" based on the configuration
	if (Player::player_config.settings_in_title.Get()) {
		// FIXME: Translation? Not shown by default though
		options.push_back("Settings");
		indices.settings = indices.exit;
		indices.exit++;
	}

	// Set "Translate" based on metadata
	if (Player::translation.HasTranslations() && Player::player_config.lang_select_in_title.Get()) {
		options.push_back(Player::meta->GetExVocabTranslateTitleText());
		indices.translate = indices.exit;
		indices.exit++;
	}

	options.push_back(ToString(lcf::Data::terms.exit_game));

	command_window.reset(new Window_Command(options));
	RepositionWindow(*command_window, Player::hide_title_flag);

	Refresh();

	// Set the number of frames for the opening animation to last
	if (!Player::hide_title_flag) {
		command_window->SetOpenAnimation(8);
	}

	if (Player::IsRPG2k3E() && lcf::Data::battlecommands.transparency == lcf::rpg::BattleCommands::Transparency_transparent) {
		command_window->SetBackOpacity(160);
		command_window->SetBackgroundPreserveTransparentColor(true);
	}

	command_window->SetVisible(true);
}

void Scene_Title::PlayTitleMusic() {
	// Workaround Android problem: BGM doesn't start when game is started again
	Main_Data::game_system->BgmStop();
	// Play BGM
	Main_Data::game_system->BgmPlay(lcf::Data::system.title_music);
}

bool Scene_Title::CheckEnableTitleGraphicAndMusic() {
	return Check2k3ShowTitle() &&
		!Player::game_config.new_game.Get() &&
		!Game_Battle::battle_test.enabled &&
		!Player::hide_title_flag;
}

bool Scene_Title::Check2k3ShowTitle() {
	return !Player::IsRPG2k3E() || (Player::IsRPG2k3E() && lcf::Data::system.show_title);
}

bool Scene_Title::CheckValidPlayerLocation() {
	return (lcf::Data::treemap.start.party_map_id > 0);
}

void Scene_Title::CommandNewGame() {
	if (!CheckValidPlayerLocation()) {
		Output::Warning("The game has no start location set.");
	} else {
		Output::Debug("Starting new game");
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
		Player::SetupNewGame();
	}
}

void Scene_Title::CommandContinue() {
	if (continue_enabled || Input::IsTriggered(Input::SHIFT)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
	} else {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		return;
	}

	Scene::Push(std::make_shared<Scene_Load>());
}

void Scene_Title::CommandImport() {
	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));

	Scene::Push(std::make_shared<Scene_Import>());
}

void Scene_Title::CommandSettings() {
	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));

	Scene::Push(std::make_unique<Scene_Settings>());
}

void Scene_Title::CommandTranslation() {
	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));

	Scene::Push(std::make_unique<Scene_Language>());
}

void Scene_Title::CommandShutdown() {
	Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
	Transition::instance().InitErase(Transition::TransitionFadeOut, this);
	Scene::Pop();
}

void Scene_Title::OnTitleSpriteReady(FileRequestResult* result) {
	BitmapRef bitmapRef = Cache::Title(result->file);

	title->SetBitmap(bitmapRef);

	// If the title sprite doesn't fill the screen, center it to support custom resolutions
	if (bitmapRef->GetWidth() < Player::screen_width) {
		title->SetX(Player::menu_offset_x);
	}
	if (bitmapRef->GetHeight() < Player::screen_height) {
		title->SetY(Player::menu_offset_y);
	}
}

void Scene_Title::OnGameStart() {
	restart_title_cache = true;
}


/*end of file .\scene_title.cpp*/

/*start of file .\screen.cpp*/

/* ... license chunk ... */

// Headers
#include <string>
#include "bitmap.h"
#include "color.h"
#include "game_screen.h"
#include "main_data.h"
#include "screen.h"
#include "drawable_mgr.h"

Screen::Screen() : Drawable(Priority_Screen)
{
	DrawableMgr::Register(this);
}

void Screen::Draw(Bitmap& dst) {
	auto flash_color = Main_Data::game_screen->GetFlashColor();
	if (flash_color.alpha > 0) {
		if (!flash) {
			flash = Bitmap::Create(dst.GetWidth(), dst.GetHeight(), flash_color);
		} else {
			flash->Fill(flash_color);
		}
		dst.Blit(0, 0, *flash, flash->GetRect(), 255);
	}

	if (viewport != Rect()) {
		// Clear all parts of the screen that are out-of-bounds
		Rect dst_rect = dst.GetRect();
		int dx = viewport.x - dst_rect.x;
		int dy = viewport.y - dst_rect.y;

		if (dx > 0) {
			// Left and Right
			dst.ClearRect({0, 0, dx, dst.GetHeight()});
			dst.ClearRect({dst.GetWidth() - dx, 0, dx, dst.GetHeight()});
		}

		if (dy > 0) {
			// Top and Bottom
			dst.ClearRect({0, 0, dst.GetWidth(), dy});
			dst.ClearRect({0, dst.GetHeight() - dy, dst.GetWidth(), dy});
		}
	}
}


/*end of file .\screen.cpp*/

/*start of file .\sprite.cpp*/

/* ... license chunk ... */

// Headers
#include <string>
#include "sprite.h"
#include "player.h"
#include "util_macro.h"
#include "bitmap.h"
#include "cache.h"
#include "drawable_mgr.h"

// Constructor
Sprite::Sprite(Drawable::Flags flags) : Drawable(0, flags)
{
	DrawableMgr::Register(this);
}

// Draw
void Sprite::Draw(Bitmap& dst) {
	if (GetWidth() <= 0 || GetHeight() <= 0) return;

	BlitScreen(dst);
}

void Sprite::BlitScreen(Bitmap& dst) {
	if (!bitmap || (opacity_top_effect <= 0 && opacity_bottom_effect <= 0))
		return;

	BitmapRef draw_bitmap = Refresh(src_rect_effect);
	if (!draw_bitmap) {
		return;
	}

	bitmap_changed = false;

	Rect rect = src_rect_effect.GetSubRect(src_rect);
	if (draw_bitmap == bitmap_effects) {
		// When a "sprite rect" (src_rect_effect) is used bitmap_effects
		// only has the size of this subrect instead of the whole bitmap
		rect.x %= bitmap_effects->GetWidth();
		rect.y %= bitmap_effects->GetHeight();

		if (flipx_effect) {
			rect.x = bitmap_effects->GetWidth() - rect.x - rect.width;
		}

		if (flipy_effect) {
			rect.y = bitmap_effects->GetHeight() - rect.y - rect.height;
		}
	}

	BlitScreenIntern(dst, *draw_bitmap, rect);
}

void Sprite::BlitScreenIntern(Bitmap& dst, Bitmap const& draw_bitmap, Rect const& src_rect) const
{
	double zoom_x = zoom_x_effect;
	double zoom_y = zoom_y_effect;

	dst.EffectsBlit(x, y, ox - GetRenderOx(), oy - GetRenderOy(), draw_bitmap, src_rect,
		Opacity(opacity_top_effect, opacity_bottom_effect, bush_effect),
		zoom_x, zoom_y, angle_effect,
		waver_effect_depth, waver_effect_phase, static_cast<Bitmap::BlendMode>(blend_type_effect));
}

BitmapRef Sprite::Refresh(Rect& rect) {
	if (zoom_x_effect == 1.0 && zoom_y_effect == 1.0 && angle_effect == 0.0 && waver_effect_depth == 0) {
		// Prevent effect sprite creation when not in the viewport
		// TODO: Out of bounds math adjustments for zoom, angle and waver
		// but even without this will catch most of the cases
		if (Rect(x - ox, y - oy, GetWidth(), GetHeight()).IsOutOfBounds(Rect(0, 0, Player::screen_width, Player::screen_height))) {
			return BitmapRef();
		}
	}

	rect.Adjust(bitmap->GetWidth(), bitmap->GetHeight());

	bool no_tone = tone_effect == Tone();
	bool no_flash = flash_effect.alpha == 0;
	bool no_flip = !flipx_effect && !flipy_effect;
	bool no_effects = no_tone && no_flash && no_flip;
	bool effects_changed = tone_effect != current_tone ||
		flash_effect != current_flash ||
		flipx_effect != current_flip_x ||
		flipy_effect != current_flip_y;
	bool effects_rect_changed = rect != bitmap_effects_src_rect;

	if (no_effects || effects_changed || effects_rect_changed || bitmap_changed) {
		bitmap_effects.reset();
	}

	if (no_effects) {
		return bitmap;
	} else if (bitmap_effects) {
		return bitmap_effects;
	} else {
		current_tone = tone_effect;
		current_flash = flash_effect;
		current_flip_x = flipx_effect;
		current_flip_y = flipy_effect;

		bitmap_effects = Cache::SpriteEffect(bitmap, rect, flipx_effect, flipy_effect, current_tone, current_flash);
		bitmap_effects_src_rect = rect;

		return bitmap_effects;
	}
}

void Sprite::SetBitmap(BitmapRef const& nbitmap) {
	bitmap = nbitmap;
	if (!bitmap) {
		src_rect = Rect();
	} else {
		src_rect = bitmap->GetRect();
	}

	src_rect_effect = src_rect;

	bitmap_changed = true;
}

void Sprite::SetOpacity(int opacity_top, int opacity_bottom) {
	if (opacity_top_effect != opacity_top) {
		opacity_top_effect = opacity_top;
	}
	if (opacity_bottom == -1)
		opacity_bottom = (opacity_top + 1) / 2;
	if (opacity_bottom_effect != opacity_bottom) {
		opacity_bottom_effect = opacity_bottom;
	}
}



/*end of file .\sprite.cpp*/

/*start of file .\spriteset_battle.cpp*/

/* ... license chunk ... */

// Headers
#include "spriteset_battle.h"
#include "cache.h"
#include "game_actors.h"
#include "game_battle.h"
#include "game_battler.h"
#include "game_enemy.h"
#include "game_enemyparty.h"
#include "game_party.h"
#include "game_screen.h"
#include "main_data.h"
#include "player.h"
#include "sprite_battler.h"
#include "sprite_actor.h"
#include "sprite_enemy.h"

Spriteset_Battle::Spriteset_Battle(const std::string bg_name, int terrain_id)
{
	background_name = std::move(bg_name);

	// Create background
	if (!background_name.empty()) {
		background.reset(new Background(background_name));
	} else {
		// Background verifies that the Terrain ID is valid
		background.reset(new Background(terrain_id));
	}
	Game_Battle::ChangeBackground(background_name);

	// Create the sprites
	std::vector<Game_Battler*> battler;
	Main_Data::game_enemyparty->GetBattlers(battler);
	if (Player::IsRPG2k3()) {
		for (unsigned int i = 0; i < lcf::Data::actors.size(); ++i) {
			battler.push_back(Main_Data::game_actors->GetActor(i + 1));
		}
	}

	timer1.reset(new Sprite_Timer(0));
	timer2.reset(new Sprite_Timer(1));

	screen.reset(new Screen());
}

void Spriteset_Battle::Update() {
	Tone new_tone = Main_Data::game_screen->GetTone();

	// Handle background change
	const auto& current_bg = Game_Battle::GetBackground();
	if (background_name != current_bg) {
		background_name = current_bg;
		if (!background_name.empty()) {
			background.reset(new Background(background_name));
		} else {
			background.reset();
		}
	}
	background->SetTone(new_tone);
	background->Update();
}


/*end of file .\spriteset_battle.cpp*/

/*start of file .\spriteset_map.cpp*/

/* ... license chunk ... */

// Headers
#include "spriteset_map.h"
#include "cache.h"
#include "game_dynrpg.h"
#include "game_map.h"
#include "main_data.h"
#include "sprite_airshipshadow.h"
#include "sprite_character.h"
#include "game_character.h"
#include "game_player.h"
#include "game_vehicle.h"
#include "game_screen.h"
#include "bitmap.h"
#include "player.h"
#include "drawable_list.h"
#include "map_data.h"

Spriteset_Map::Spriteset_Map() {
	panorama = std::make_unique<Plane>();
	panorama->SetZ(Priority_Background);

	timer1 = std::make_unique<Sprite_Timer>(0);
	timer2 = std::make_unique<Sprite_Timer>(1);

	screen = std::make_unique<Screen>();

	if (Player::IsRPG2k3()) {
		frame = std::make_unique<Frame>();
	}

	ParallaxUpdated();

	Refresh();

	Update();
}

void Spriteset_Map::Refresh() {
	CalculateMapRenderOffset();

	tilemap = std::make_unique<Tilemap>();
	tilemap->SetWidth(Game_Map::GetTilesX());
	tilemap->SetHeight(Game_Map::GetTilesY());
	tilemap->SetRenderOx(map_render_ox);
	tilemap->SetRenderOy(map_render_oy);

	airship_shadows.clear();
	character_sprites.clear();

	ChipsetUpdated();

	need_x_clone = Game_Map::LoopHorizontal();
	need_y_clone = Game_Map::LoopVertical();

	for (Game_Event& ev : Game_Map::GetEvents()) {
		CreateSprite(&ev, need_x_clone, need_y_clone);
	}

	CreateAirshipShadowSprite(need_x_clone, need_y_clone);

	CreateSprite(Main_Data::game_player.get(), need_x_clone, need_y_clone);

	for (bool& v: vehicle_loaded) {
		v = false;
	}
}

// Update
void Spriteset_Map::Update() {
	Tone new_tone = Main_Data::game_screen->GetTone();

	tilemap->SetOx(Game_Map::GetDisplayX() / (SCREEN_TILE_SIZE / TILE_SIZE));
	tilemap->SetOy(Game_Map::GetDisplayY() / (SCREEN_TILE_SIZE / TILE_SIZE));
	tilemap->SetTone(new_tone);

	for (const auto& character_sprite : character_sprites) {
		character_sprite->Update();
		character_sprite->SetTone(new_tone);
	}

	panorama->SetOx(Game_Map::Parallax::GetX());
	panorama->SetOy(Game_Map::Parallax::GetY());
	panorama->SetTone(new_tone);

	Game_Vehicle* vehicle;
	int map_id = Game_Map::GetMapId();
	for (int i = 1; i <= 3; ++i) {
		vehicle = Game_Map::GetVehicle((Game_Vehicle::Type) i);

		if (!vehicle_loaded[i - 1] && vehicle->GetMapId() == map_id) {
			vehicle_loaded[i - 1] = true;
			CreateSprite(vehicle, need_x_clone, need_y_clone);
		}
	}

	for (auto& shadow : airship_shadows) {
		shadow->SetTone(new_tone);
		shadow->Update();
	}

	Main_Data::game_dynrpg->Update();
}

void Spriteset_Map::ChipsetUpdated() {
	if (!Game_Map::GetChipsetName().empty()) {
		FileRequestAsync* request = AsyncHandler::RequestFile("ChipSet", Game_Map::GetChipsetName());
		tilemap_request_id = request->Bind(&Spriteset_Map::OnTilemapSpriteReady, this);
		request->SetImportantFile(true);
		request->SetGraphicFile(true);
		request->Start();
	}
	else {
		OnTilemapSpriteReady(NULL);
	}

	for (auto& sprite: character_sprites) {
		sprite->ChipsetUpdated();
	}
}

void Spriteset_Map::ParallaxUpdated() {
	std::string name = Game_Map::Parallax::GetName();
	if (name != panorama_name) {
		panorama_name = name;
		if (!name.empty()) {
			FileRequestAsync* request = AsyncHandler::RequestFile("Panorama", panorama_name);
			request->SetGraphicFile(true);
			request->SetImportantFile(true);
			panorama_request_id = request->Bind(&Spriteset_Map::OnPanoramaSpriteReady, this);
			request->Start();
		}
	}

	if (name.empty()) {
		panorama->SetBitmap(BitmapRef());
		Game_Map::Parallax::Initialize(0, 0);
	}
}

void Spriteset_Map::SystemGraphicUpdated() {
	for (auto& shadow : airship_shadows) {
		shadow->RecreateShadow();
	}
}

void Spriteset_Map::SubstituteDown(int old_id, int new_id) {
	int num_subst = Game_Map::SubstituteDown(old_id, new_id);
	if (num_subst) {
		tilemap->OnSubstituteDown();
	}
}

void Spriteset_Map::SubstituteUp(int old_id, int new_id) {
	int num_subst = Game_Map::SubstituteUp(old_id, new_id);
	if (num_subst) {
		tilemap->OnSubstituteUp();
	}
}

void Spriteset_Map::ReplaceDownAt(int x, int y, int tile_index, bool disable_autotile) {
	if (tile_index >= BLOCK_F_INDEX) tile_index = BLOCK_F_INDEX - 1;

	auto tile_id = IndexToChipId(tile_index);
	tilemap->SetMapTileDataDownAt(x, y, tile_id, disable_autotile);
}

void Spriteset_Map::ReplaceUpAt(int x, int y, int tile_index) {
	tile_index += BLOCK_F_INDEX;
	if (tile_index >= NUM_UPPER_TILES + BLOCK_F_INDEX) tile_index = BLOCK_F_INDEX;

	auto tile_id = IndexToChipId(tile_index);
	tilemap->SetMapTileDataUpAt(x, y, tile_id);
}

bool Spriteset_Map::RequireClear(DrawableList& drawable_list) {
	if (drawable_list.empty()) {
		return true;
	}

	// When using a custom resolution that is not divisible by 16, clear to avoid
	// artifacts at the borders
	if (Player::screen_width % TILE_SIZE != 0 || Player::screen_height % TILE_SIZE != 0) {
		return true;
	}

	// Speed optimisation:
	// When there is nothing below the tilemap it can be drawn opaque (faster)
	tilemap->SetFastBlitDown(false);

	if (!panorama_name.empty()) {
		// Map has a panorama -> No opaque tilemap blit possible
		// but the panorama is drawn opaque -> clearing the screen is not needed
		return false;
	}

	// The list is about to be drawn, so we can just sort it now if needed.
	if (drawable_list.IsDirty()) {
		drawable_list.Sort();
	}

	// Only if there is nothing below the tileset, can we do fast blitting.
	if ((*drawable_list.begin())->GetZ() >= Priority_TilesetBelow) {
		tilemap->SetFastBlitDown(true);
	}

	return true;
}

void Spriteset_Map::CreateSprite(Game_Character* character, bool create_x_clone, bool create_y_clone) {
	auto add_sprite = [&](auto&& chara) {
		chara->SetRenderOx(map_render_ox);
		chara->SetRenderOy(map_render_oy);
		character_sprites.push_back(std::forward<decltype(chara)>(chara));
	};

	add_sprite(std::make_unique<Sprite_Character>(character));
	if (create_x_clone) {
		add_sprite(std::make_unique<Sprite_Character>(character, -map_tiles_x, 0));
		add_sprite(std::make_unique<Sprite_Character>(character, map_tiles_x, 0));
	}
	if (create_y_clone) {
		add_sprite(std::make_unique<Sprite_Character>(character, 0, -map_tiles_y));
		add_sprite(std::make_unique<Sprite_Character>(character, 0, map_tiles_y));
	}
	if (create_x_clone && create_y_clone) {
		add_sprite(std::make_unique<Sprite_Character>(character, map_tiles_x, map_tiles_y));
		add_sprite(std::make_unique<Sprite_Character>(character, -map_tiles_x, map_tiles_y));
		add_sprite(std::make_unique<Sprite_Character>(character, map_tiles_x, -map_tiles_y));
		add_sprite(std::make_unique<Sprite_Character>(character, -map_tiles_x, -map_tiles_y));
	}
}

void Spriteset_Map::CreateAirshipShadowSprite(bool create_x_clone, bool create_y_clone) {
	auto add_sprite = [&](auto&& chara) {
		chara->SetRenderOx(map_render_ox);
		chara->SetRenderOy(map_render_oy);
		airship_shadows.push_back(std::forward<decltype(chara)>(chara));
	};

	add_sprite(std::make_unique<Sprite_AirshipShadow>());
	if (create_x_clone) {
		add_sprite(std::make_unique<Sprite_AirshipShadow>(-map_tiles_x, 0));
		add_sprite(std::make_unique<Sprite_AirshipShadow>(map_tiles_x, 0));
	}
	if (create_y_clone) {
		add_sprite(std::make_unique<Sprite_AirshipShadow>(0, -map_tiles_y));
		add_sprite(std::make_unique<Sprite_AirshipShadow>(0, map_tiles_y));
	}
	if (create_x_clone && create_y_clone) {
		add_sprite(std::make_unique<Sprite_AirshipShadow>(map_tiles_x, map_tiles_y));
		add_sprite(std::make_unique<Sprite_AirshipShadow>(-map_tiles_x, map_tiles_y));
		add_sprite(std::make_unique<Sprite_AirshipShadow>(map_tiles_x, -map_tiles_y));
		add_sprite(std::make_unique<Sprite_AirshipShadow>(-map_tiles_x, -map_tiles_y));
	}
}

void Spriteset_Map::OnTilemapSpriteReady(FileRequestResult*) {
	if (!Game_Map::GetChipsetName().empty()) {
		tilemap->SetChipset(Cache::Chipset(Game_Map::GetChipsetName()));
	}
	else {
		tilemap->SetChipset(Bitmap::Create(480, 256));
	}

	tilemap->SetMapDataDown(Game_Map::GetMapDataDown());
	tilemap->SetMapDataUp(Game_Map::GetMapDataUp());
	tilemap->SetPassableDown(Game_Map::GetPassagesDown());
	tilemap->SetPassableUp(Game_Map::GetPassagesUp());
	tilemap->SetAnimationType(Game_Map::GetAnimationType());
	tilemap->SetAnimationSpeed(Game_Map::GetAnimationSpeed());
}

void Spriteset_Map::OnPanoramaSpriteReady(FileRequestResult* result) {
	BitmapRef panorama_bmp = Cache::Panorama(result->file);
	panorama->SetBitmap(panorama_bmp);
	Game_Map::Parallax::Initialize(panorama_bmp->GetWidth(), panorama_bmp->GetHeight());
	CalculatePanoramaRenderOffset();
}

void Spriteset_Map::CalculateMapRenderOffset() {
	map_render_ox = 0;
	map_render_oy = 0;

	// Smallest possible map. Smaller maps are hacked
	map_tiles_x = std::max<int>(Game_Map::GetTilesX(), 20) * TILE_SIZE;
	map_tiles_y = std::max<int>(Game_Map::GetTilesY(), 15) * TILE_SIZE;

	panorama->SetRenderOx(0);
	panorama->SetRenderOy(0);
	screen->SetViewport(Rect());

	if (Player::game_config.fake_resolution.Get()) {
		// Resolution hack for tiles and sprites
		map_tiles_x = std::max<int>(Game_Map::GetTilesX(), 20) * TILE_SIZE;
		map_tiles_y = std::max<int>(Game_Map::GetTilesY(), 15) * TILE_SIZE;

		if (map_tiles_x < Player::screen_width) {
			map_render_ox = (Player::screen_width - map_tiles_x) / 2;
		}
		if (map_tiles_y < Player::screen_height) {
			map_render_oy = (Player::screen_height - map_tiles_y) / 2;
		}

		CalculatePanoramaRenderOffset();

		screen->SetViewport({map_render_ox, map_render_oy, map_tiles_x, map_tiles_y});
	}
}

void Spriteset_Map::CalculatePanoramaRenderOffset() {
	// Resolution hack for Panorama
	if (Player::game_config.fake_resolution.Get()) {
		if (Game_Map::Parallax::FakeXPosition()) {
			panorama->SetRenderOx((Player::screen_width - SCREEN_TARGET_WIDTH) / 2);
		}
		if (Game_Map::Parallax::FakeYPosition()) {
			panorama->SetRenderOy((Player::screen_height - SCREEN_TARGET_HEIGHT) / 2);
		}
	}
}


/*end of file .\spriteset_map.cpp*/

/*start of file .\sprite_actor.cpp*/

/* ... license chunk ... */

// Headers
#include "battle_animation.h"
#include "game_enemy.h"
#include "sprite_actor.h"
#include "game_battler.h"
#include "game_actor.h"
#include "game_screen.h"
#include "bitmap.h"
#include "cache.h"
#include "main_data.h"
#include "player.h"
#include <lcf/reader_util.h>
#include "output.h"
#include "feature.h"
#include "game_battle.h"

Sprite_Actor::Sprite_Actor(Game_Actor* actor)
	: Sprite_Battler(actor, actor->GetId())
{
	CreateSprite();
	auto condition = Game_Battle::GetBattleCondition();
	if ((condition == lcf::rpg::System::BattleCondition_none || condition == lcf::rpg::System::BattleCondition_initiative) && Feature::HasFixedActorFacingDirection()) {
		fixed_facing = static_cast<FixedFacing>(lcf::Data::battlecommands.easyrpg_fixed_actor_facing_direction);
	}
}

Sprite_Actor::~Sprite_Actor() {
}

Game_Actor* Sprite_Actor::GetBattler() const {
	return static_cast<Game_Actor*>(Sprite_Battler::GetBattler());
}

void Sprite_Actor::Update() {
	auto* battler = GetBattler();

	if (!battler->IsHidden() && old_hidden != battler->IsHidden()) {
		DoIdleAnimation();
	}

	old_hidden = battler->IsHidden();

	++cycle;

	if (anim_state > 0) {
		// Animations for allies
		if (Player::IsRPG2k3()) {
			UpdatePosition();

			if (animation) {
				// Is a battle animation
				animation->SetInvert(battler->IsSpriteDirectionFlipped());
				animation->Update();

				if (animation->IsDone()) {
					if (loop_state == LoopState_DefaultAnimationAfterFinish) {
						DoIdleAnimation();
					} else if (loop_state == LoopState_LoopAnimation) {
						animation->SetFrame(0);
					} else if (loop_state == LoopState_WaitAfterFinish) {
						if (animation->GetFrames() > 0) {
							animation->SetFrame(animation->GetFrames() - 1);
						}
						idling = true;
					}
				}

				return;
			}
			// Is a battle charset animation
			static const int frames[] = {0,1,2,1,0};
			int frame = (battler->IsDefending() ? 0 : (normal_attacking ? std::min(2, cycle / 10) : frames[cycle / 10]));

			if (battler->IsDirectionFlipped()) {
				frame = 2 - frame;
			}

			if (frame == sprite_frame)
				return;

			const lcf::rpg::BattlerAnimation* anim = lcf::ReaderUtil::GetElement(lcf::Data::battleranimations, battler->GetBattleAnimationId());
			if (!anim) {
				Output::Warning("Invalid battler animation ID {}", battler->GetBattleAnimationId());
				return;
			}

			const auto* ext = lcf::ReaderUtil::GetElement(anim->poses, anim_state);
			if (!ext) {
				Output::Warning("Animation {}: Invalid battler anim-extension state {}", anim->ID, anim_state);
				return;
			}

			SetSrcRect(Rect(frame * 48, ext->battler_index * 48, 48, 48));

			if (cycle == ((idling || normal_attacking || anim_state == AnimationState_WalkingLeft || anim_state == AnimationState_WalkingRight || anim_state == AnimationState_Victory) ? 40 : 30)) {
				switch (loop_state) {
					case LoopState_DefaultAnimationAfterFinish:
						DoIdleAnimation();
						break;
					case LoopState_WaitAfterFinish:
						--cycle; // incremented to last cycle next update
						idling = true;
						break;
					case LoopState_LoopAnimation:
						cycle = 0;
						break;
					default:
						assert(false && "Bad loop state");
				}
			}
		}
	}

	if (animation) {
		animation->SetVisible(IsVisible());
	}

	SetFlipX(battler->IsDirectionFlipped());
}

void Sprite_Actor::SetAnimationState(int state, LoopState loop, int animation_id) {
	// Default value is 100 (function called with val+1)
	// 100 maps all states to "Bad state" (7)
	if (state == 101) {
		state = 7;
	}

	anim_state = state;

	loop_state = loop;

	cycle = 0;

	idling = false;

	auto* battler = GetBattler();

	if (battler->GetBattleAnimationId() > 0) {
		const lcf::rpg::BattlerAnimation* anim = lcf::ReaderUtil::GetElement(lcf::Data::battleranimations, battler->GetBattleAnimationId());
		if (!anim) {
			Output::Warning("Invalid battler animation ID {}", battler->GetBattleAnimationId());
			return;
		}

		const auto* ext = lcf::ReaderUtil::GetElement(anim->poses, anim_state);
		if (!ext) {
			Output::Warning("Animation {}: Invalid battler anim-extension state {}", anim->ID, anim_state);
			return;
		}

		std::string_view sprite_file = ext->battler_name;

		if (ext->animation_type == lcf::rpg::BattlerAnimationPose::AnimType_battle) {
			do_not_draw = false;
			SetBitmap(BitmapRef());
			if (animation_id == 0) {
				animation_id = ext->battle_animation_id;
			}
			lcf::rpg::Animation* battle_anim = lcf::ReaderUtil::GetElement(lcf::Data::animations, animation_id);
			if (!battle_anim) {
				Output::Warning("Invalid battle animation ID {}", animation_id);
				animation.reset();
			} else {
				animation.reset(new BattleAnimationBattler(*battle_anim, { battler }));
				animation->SetZ(GetZ());
			}
			animation->SetInvert(battler->IsDirectionFlipped());
		}
		else {
			do_not_draw = sprite_file.empty();
			animation.reset();
			if (!sprite_file.empty()) {
				FileRequestAsync* request = AsyncHandler::RequestFile("BattleCharSet", sprite_file);
				request->SetGraphicFile(true);
				request_id = request->Bind(&Sprite_Actor::OnBattlercharsetReady, this, ext->battler_index);
				request->Start();
			}
		}
	}
}

void Sprite_Actor::SetAnimationLoop(LoopState loop) {
	loop_state = loop;
}

void Sprite_Actor::DetectStateChange() {
	if (idling) {
		DoIdleAnimation();
	}
}

bool Sprite_Actor::IsIdling() {
	return idling;
}

int Sprite_Actor::GetWidth() const {
	if (animation) {
		return animation->GetAnimationCellWidth() / 2;
	}
	return Sprite::GetWidth();
}

int Sprite_Actor::GetHeight() const {
	if (animation) {
		return animation->GetAnimationCellHeight() / 2;
	}
	return Sprite::GetHeight();
}

void Sprite_Actor::CreateSprite() {
	auto* battler = GetBattler();

	images = {{battler->GetDisplayX(), battler->GetDisplayY()}};

	SetX(images.back().x);
	SetY(images.back().y);

	// Not animated -> Monster
	SetOx(24);
	SetOy(24);
	ResetZ();
	SetAnimationState(anim_state);
	idling = true;
}

void Sprite_Actor::DoIdleAnimation() {
	auto* battler = GetBattler();
	if (battler->IsDefending()) {
		SetAnimationState(AnimationState_Defending);
		idling = true;
		return;
	}

	const lcf::rpg::State* state = battler->GetSignificantState();
	int idling_anim;
	if (battler->GetBattleAnimationId() <= 0) {
		// Monster
		// Only visually different state is Death
		if (state && state->ID == 1) {
			idling_anim = AnimationState_Dead;
		} else {
			idling_anim = AnimationState_Idle;
		}
	} else {
		idling_anim = state ? state->battler_animation_id + 1 : AnimationState_Idle;
	}

	if (idling_anim == 101)
		idling_anim = 7;

	if (idling_anim != anim_state || loop_state == LoopState_DefaultAnimationAfterFinish)
		SetAnimationState(idling_anim, idling_anim == AnimationState_Dead ? LoopState_WaitAfterFinish : LoopState_LoopAnimation);

	idling = true;
}

void Sprite_Actor::OnBattlercharsetReady(FileRequestResult* result, int32_t battler_index) {
	SetBitmap(Cache::Battlecharset(result->file));
	SetSrcRect(Rect(0, battler_index * 48, 48, 48));
}

void Sprite_Actor::Draw(Bitmap& dst) {
	auto* battler = GetBattler();
	// "do_not_draw" is set to true if the CBA battler name is empty, this
	// makes the sprite not being drawn. This fixes issue #1708.
	if (battler->IsHidden() || do_not_draw) {
		return;
	}

	SetTone(Main_Data::game_screen->GetTone());
	SetFlashEffect(battler->GetFlashColor());

	int steps = static_cast<int>(256 / images.size());
	int opacity = steps;
	for (auto it = images.crbegin(); it != images.crend(); ++it) {
		Sprite_Battler::SetFixedFlipX();
		Sprite_Battler::SetX(it->x);
		Sprite_Battler::SetY(it->y);
		Sprite_Battler::SetOpacity(std::min(opacity, 255));
		Sprite_Battler::Draw(dst);
		opacity += steps;
	}
}

void Sprite_Actor::UpdatePosition() {
	assert(!images.empty());
	images.pop_back();
	images.insert(images.begin(), {battler->GetDisplayX(), battler->GetDisplayY()});

	if (afterimage_fade >= 0) {
		++afterimage_fade;
		if (static_cast<size_t>(afterimage_fade) >= images.size()) {
			// CBA finished, remove afterimages
			images.resize(1);
			afterimage_fade = -1;
		}
	}
}

void Sprite_Actor::ResetZ() {
	Sprite_Battler::ResetZ();
	if (animation) {
		animation->SetZ(GetZ());
	}
}

void Sprite_Actor::SetNormalAttacking(bool nnormal_attacking) {
	normal_attacking = nnormal_attacking;
}

void Sprite_Actor::SetAfterimageAmount(unsigned amount) {
	images.resize(1 + amount);
	std::fill(images.begin() + 1, images.end(), images.front());
}

void Sprite_Actor::DoAfterimageFade() {
	if (images.size() > 1) {
		afterimage_fade = 0;
	}
}


/*end of file .\sprite_actor.cpp*/

/*start of file .\sprite_airshipshadow.cpp*/

/* ... license chunk ... */

// Headers
#include "cache.h"
#include "bitmap.h"
#include "game_map.h"
#include "game_player.h"
#include "game_system.h"
#include "main_data.h"
#include "sprite_airshipshadow.h"
#include <string>

Sprite_AirshipShadow::Sprite_AirshipShadow(int x_offset, int y_offset) :
	x_offset(x_offset), y_offset(y_offset) {
	SetBitmap(Bitmap::Create(16,16));
	GetBitmap()->SetId("AirshipShadow");

	SetOx(TILE_SIZE/2);
	SetOy(TILE_SIZE);

	RecreateShadow();
}

// Draws the two shadow sprites to a single intermediate bitmap to be blit to the map
// Needs to be recalled when the System graphic changes
void Sprite_AirshipShadow::RecreateShadow() {
	GetBitmap()->Clear();

	// RPG_RT never displays shadows if there is no system graphic.
	BitmapRef system = Cache::System();
	if (!system) {
		return;
	}

	// Offset of the shadow in the System graphic as per
	// https://wiki.easyrpg.org/development/technical-details/system-graphics
	// TODO 26% opacity looks okay, but isn't accurate to RPG_RT
	Opacity opacity = Opacity(0.26 * 255);
	GetBitmap()->Blit(0, 0, *system, Rect(128,32,16,16), opacity);
	GetBitmap()->Blit(0, 0, *system, Rect(128+16,32,16,16), opacity);
}

void Sprite_AirshipShadow::Draw(Bitmap &dst) {
	Game_Vehicle* airship = Game_Map::GetVehicle(Game_Vehicle::Airship);
	const int altitude = airship->GetAltitude();
	const int max_altitude = TILE_SIZE;
	const double opacity = (double)altitude / max_altitude;
	SetOpacity(opacity * 255);

	SetX(Main_Data::game_player->GetScreenX() + x_offset);
	SetY(Main_Data::game_player->GetScreenY() + y_offset + Main_Data::game_player->GetJumpHeight());

	Sprite::Draw(dst);
}

void Sprite_AirshipShadow::Update() {
	if (!Main_Data::game_player->InAirship()) {
		SetVisible(false);
		return;
	}
	SetVisible(true);

	Game_Vehicle* airship = Game_Map::GetVehicle(Game_Vehicle::Airship);

	// Synchronized with airship priority
	SetZ(airship->GetScreenZ(x_offset, y_offset) - 1);
}


/*end of file .\sprite_airshipshadow.cpp*/

/*start of file .\sprite_battler.cpp*/

/* ... license chunk ... */

// Headers
#include "sprite_battler.h"
#include "game_battler.h"
#include "bitmap.h"
#include "cache.h"
#include "main_data.h"
#include "player.h"
#include <lcf/reader_util.h>
#include "output.h"

Sprite_Battler::Sprite_Battler(Game_Battler* battler, int index) :
	battler(battler), battle_index(index) {
}

Sprite_Battler::~Sprite_Battler() {
}

void Sprite_Battler::ResetZ() {
	static_assert(Game_Battler::Type_Ally < Game_Battler::Type_Enemy, "Game_Battler enums re-ordered! Fix Z order logic here!");

	constexpr int id_limit = 128;

	const auto& graphic = GetBitmap();
	int y = battler->GetBattlePosition().y;
	if (battler->GetType() == Game_Battler::Type_Enemy && graphic) {
		y += graphic->GetHeight() / 2;
	} else if (battler->GetType() == Game_Battler::Type_Ally) {
		y += 24;
	}

	Drawable::Z_t z = battler->GetType();
	z += y;
	z *= id_limit;
	z += id_limit - battle_index;
	z += Priority_Battler;

	SetZ(z);
}



/*end of file .\sprite_battler.cpp*/

/*start of file .\sprite_character.cpp*/

/* ... license chunk ... */

// Headers
#include "sprite_character.h"
#include "cache.h"
#include "game_map.h"
#include "bitmap.h"
#include "output.h"
#include "player.h"

Sprite_Character::Sprite_Character(Game_Character* character, int x_offset, int y_offset) :
	character(character),
	tile_id(-1),
	character_index(0),
	chara_width(0),
	chara_height(0),
	x_offset(x_offset),
	y_offset(y_offset) {

	Update();
}

void Sprite_Character::Draw(Bitmap &dst) {
	if (UsesCharset()) {
		int row = character->GetFacing();
		auto frame = character->GetAnimFrame();
		if (frame >= lcf::rpg::EventPage::Frame_middle2) frame = lcf::rpg::EventPage::Frame_middle;
		SetSrcRect({frame * chara_width, row * chara_height, chara_width, chara_height});
	}

	SetFlashEffect(character->GetFlashColor());

	SetOpacity(character->GetOpacity());

	SetX(character->GetScreenX() + x_offset);
	SetY(character->GetScreenY() + y_offset);

	int bush_split = 4 - character->GetBushDepth();
	SetBushDepth(bush_split > 3 ? 0 : GetHeight() / bush_split);

	Sprite::Draw(dst);
}

void Sprite_Character::Update() {
	if (tile_id != character->GetTileId() ||
		character_name != character->GetSpriteName() ||
		character_index != character->GetSpriteIndex() ||
		refresh_bitmap
	) {
		tile_id = character->GetTileId();
		character_name = character->GetSpriteName();
		character_index = character->GetSpriteIndex();
		refresh_bitmap = false;

		if (UsesCharset()) {
			FileRequestAsync* char_request = AsyncHandler::RequestFile("CharSet", character_name);
			char_request->SetGraphicFile(true);
			request_id = char_request->Bind(&Sprite_Character::OnCharSpriteReady, this);
			char_request->Start();
		} else {
			const auto chipset_name = Game_Map::GetChipsetName();
			if (chipset_name.empty()) {
				OnTileSpriteReady(nullptr);
			} else {
				FileRequestAsync *tile_request = AsyncHandler::RequestFile("ChipSet", Game_Map::GetChipsetName());
				tile_request->SetGraphicFile(true);
				request_id = tile_request->Bind(&Sprite_Character::OnTileSpriteReady, this);
				tile_request->Start();
			}
		}
	}

	SetVisible(character->IsVisible());
	SetZ(character->GetScreenZ(x_offset, y_offset));
}

Game_Character* Sprite_Character::GetCharacter() {
	return character;
}

void Sprite_Character::SetCharacter(Game_Character* new_character) {
	character = new_character;
}

bool Sprite_Character::UsesCharset() const {
	return !character_name.empty();
}

void Sprite_Character::OnTileSpriteReady(FileRequestResult*) {
	const auto chipset = Game_Map::GetChipsetName();

	BitmapRef tile;
	if (!chipset.empty()) {
		tile = Cache::Tile(Game_Map::GetChipsetName(), tile_id);
	}
	else {
		tile = Bitmap::Create(16, 16, true);
	}

	SetBitmap(tile);

	SetSrcRect({ 0, 0, TILE_SIZE, TILE_SIZE });
	SetOx(8);
	SetOy(16);

	Update();
}

void Sprite_Character::ChipsetUpdated() {
	if (UsesCharset()) {
		return;
	}
	refresh_bitmap = true;
}

Rect Sprite_Character::GetCharacterRect(std::string_view name, int index, const Rect bitmap_rect) {
	Rect rect;
	rect.width = 24 * (TILE_SIZE / 16) * 3;
	rect.height = 32 * (TILE_SIZE / 16) * 4;

	// Allow large 4x2 spriteset of 3x4 sprites
	// when the character name starts with a $ sign.
	// This is not exactly the VX Ace way because
	// VX Ace uses a single 1x1 spriteset of 3x4 sprites.
	if (!name.empty() && name.front() == '$') {
		if (!Player::HasEasyRpgExtensions()) {
			Output::Debug("Ignoring large charset {}. EasyRPG Extension not enabled.", name);
		} else {
			rect.width = bitmap_rect.width * (TILE_SIZE / 16) / 4;
			rect.height = bitmap_rect.height * (TILE_SIZE / 16) / 2;
		}
	}
	rect.x = (index % 4) * rect.width;
	rect.y = (index / 4) * rect.height;
	return rect;
}

void Sprite_Character::OnCharSpriteReady(FileRequestResult*) {
	SetBitmap(Cache::Charset(character_name));
	auto rect = GetCharacterRect(character_name, character_index, GetBitmap()->GetRect());
	chara_width = rect.width / 3;
	chara_height = rect.height / 4;
	SetOx(chara_width / 2);
	SetOy(chara_height);
	SetSpriteRect(rect);

	Update();
}


/*end of file .\sprite_character.cpp*/

/*start of file .\sprite_enemy.cpp*/

/* ... license chunk ... */

// Headers
#include "battle_animation.h"
#include "game_enemy.h"
#include "game_screen.h"
#include "sprite_enemy.h"
#include "bitmap.h"
#include "cache.h"
#include "main_data.h"
#include "player.h"
#include <lcf/reader_util.h>
#include "output.h"
#include "feature.h"
#include "game_battle.h"

Sprite_Enemy::Sprite_Enemy(Game_Enemy* enemy)
	: Sprite_Battler(enemy, enemy->GetTroopMemberId())
{
	CreateSprite();
	auto condition = Game_Battle::GetBattleCondition();
	if ((condition == lcf::rpg::System::BattleCondition_none || condition == lcf::rpg::System::BattleCondition_initiative) && Feature::HasFixedEnemyFacingDirection()) {
		fixed_facing = static_cast<FixedFacing>(lcf::Data::battlecommands.easyrpg_fixed_enemy_facing_direction);
	}
}

Sprite_Enemy::~Sprite_Enemy() {
}

Game_Enemy* Sprite_Enemy::GetBattler() const {
	return static_cast<Game_Enemy*>(Sprite_Battler::GetBattler());
}

void Sprite_Enemy::CreateSprite() {
	sprite_name = ToString(GetBattler()->GetSpriteName());
	hue = GetBattler()->GetHue();

	SetX(GetBattler()->GetDisplayX());
	SetY(GetBattler()->GetDisplayY());

	// Not animated -> Monster
	if (sprite_name.empty()) {
		graphic = Bitmap::Create(0, 0);
		SetOx(graphic->GetWidth() / 2);
		SetOy(graphic->GetHeight() / 2);
		SetBitmap(graphic);
		ResetZ();
	}
	else {
		FileRequestAsync* request = AsyncHandler::RequestFile("Monster", sprite_name);
		request->SetGraphicFile(true);
		request_id = request->Bind(&Sprite_Enemy::OnMonsterSpriteReady, this);
		request->Start();
	}
}

void Sprite_Enemy::OnMonsterSpriteReady(FileRequestResult* result) {
	graphic = Cache::Monster(result->file);

	SetOx(graphic->GetWidth() / 2);
	SetOy(graphic->GetHeight() / 2);

	bool hue_change = hue != 0;
	if (hue_change) {
		BitmapRef new_graphic = Bitmap::Create(graphic->GetWidth(), graphic->GetHeight());
		new_graphic->HueChangeBlit(0, 0, *graphic, graphic->GetRect(), hue);
		new_graphic->SetId(fmt::format("{},hue={}", graphic->GetId(), hue));
		graphic = new_graphic;
	}

	SetBitmap(graphic);

	ResetZ();
}

void Sprite_Enemy::Draw(Bitmap& dst) {

	auto alpha = 255;
	auto zoom = 1.0;

	auto* enemy = static_cast<Game_Enemy*>(GetBattler());

	const auto bt = enemy->GetBlinkTimer();
	const auto dt = enemy->GetDeathTimer();
	const auto et = enemy->GetExplodeTimer();

	if (!enemy->Exists() && dt == 0 && et == 0) {
		return;
	}

	if (bt % 10 >= 5) {
		return;
	}

	if (dt > 0) {
		alpha = 7 * dt;
	} else if (et > 0) {
		alpha = 12 * et;
		zoom = static_cast<double>(20 - et) / 20.0 + 1.0;
	}

	if (enemy->IsTransparent()) {
		alpha = 160 * alpha / 255;
	}

	SetOpacity(alpha);
	SetZoomX(zoom);
	SetZoomY(zoom);

	SetTone(Main_Data::game_screen->GetTone());
	SetX(enemy->GetDisplayX());
	SetY(enemy->GetDisplayY());
	SetFlashEffect(enemy->GetFlashColor());
	if (fixed_facing != Disabled) {
		SetFixedFlipX();
	} else {
		SetFlipX(enemy->IsDirectionFlipped());
	}

	Sprite_Battler::Draw(dst);
}

void Sprite_Enemy::Refresh() {
	if (sprite_name != GetBattler()->GetSpriteName() || hue != GetBattler()->GetHue()) {
		CreateSprite();
	}
}

void Sprite_Enemy::ResetZ() {
	Sprite_Battler::ResetZ();
}


/*end of file .\sprite_enemy.cpp*/

/*start of file .\sprite_picture.cpp*/

/* ... license chunk ... */
#include <cmath>

#include "sprite_picture.h"
#include "main_data.h"
#include "game_pictures.h"
#include "game_battle.h"
#include "game_screen.h"
#include "game_windows.h"
#include "player.h"
#include "bitmap.h"

Sprite_Picture::Sprite_Picture(int pic_id, Drawable::Flags flags)
	: Sprite(flags),
	pic_id(pic_id),
	feature_spritesheet(Player::IsRPG2k3ECommands()),
	feature_priority_layers(Player::IsMajorUpdatedVersion()),
	feature_bottom_trans(Player::IsRPG2k3() && !Player::IsRPG2k3E())
{
	// Initialize Z value for legacy pictures. Will be overriden in OnPictureShow if
	// priority layers feature is enabled.
	// Battle Animations are below pictures
	SetZ(Priority_PictureOld + pic_id);
}

void Sprite_Picture::OnPictureShow() {
	last_spritesheet_frame = -1;

	const bool is_battle = Game_Battle::IsBattleRunning();
	const auto& pic = Main_Data::game_pictures->GetPicture(pic_id);

	if (feature_priority_layers) {
		// Battle Animations are above pictures
		Drawable::Z_t priority;
		if (is_battle) {
			priority = Drawable::GetPriorityForBattleLayer(pic.data.battle_layer);
		} else {
			priority = Drawable::GetPriorityForMapLayer(pic.data.map_layer);
		}
		if (priority > 0) {
			// Small offset (10) to ensure there is space for graphics that are
			// drawn at the image position (e.g. DynRPG Text Plugin)
			SetZ(priority + pic_id * 10);
		}
	}
}


void Sprite_Picture::Draw(Bitmap& dst) {
	const auto& pic = Main_Data::game_pictures->GetPicture(pic_id);
	const auto& data = pic.data;

	auto& bitmap = GetBitmap();

	if (!bitmap) {
		return;
	}

	if (data.easyrpg_type == lcf::rpg::SavePicture::EasyRpgType_window) {
		// Paint the Window on the Picture
		const auto& window = Main_Data::game_windows->GetWindow(pic_id);
		window.window->Draw(*bitmap.get());
	}

	const bool is_battle = Game_Battle::IsBattleRunning();

	if (is_battle ? !pic.IsOnBattle() : !pic.IsOnMap()) {
		return;
	}

	// RPG Maker 2k3 1.12: Spritesheets
	if (feature_spritesheet
			&& pic.NumSpriteSheetFrames() > 1
			&& last_spritesheet_frame != data.spritesheet_frame)
	{
		last_spritesheet_frame = data.spritesheet_frame;

		const int sw = bitmap->GetWidth() / data.spritesheet_cols;
		const int sh = bitmap->GetHeight() / data.spritesheet_rows;
		const int sx = sw * ((data.spritesheet_frame) % data.spritesheet_cols);
		const int sy = sh * ((data.spritesheet_frame) / data.spritesheet_cols % data.spritesheet_rows);

		SetSrcRect(Rect{ sx, sy, sw, sh });
	}

	int x = data.current_x;
	int y = data.current_y;
	if (data.flags.affected_by_shake) {
		x -= Main_Data::game_screen->GetShakeOffsetX();
		y -= Main_Data::game_screen->GetShakeOffsetY();
	}

	if (Player::game_config.fake_resolution.Get()) {
		SetX(x + Player::menu_offset_x);
		SetY(y + Player::menu_offset_y);
	} else {
		SetX(x);
		SetY(y);
	}

	SetZoomX(data.current_magnify / 100.0);
	SetZoomY(data.current_magnify / 100.0);
	if (Player::IsPatchManiac()) {
		SetZoomY(data.maniac_current_magnify_height / 100.0);
	}

	auto sr = GetSrcRect();
	SetOx(sr.width / 2);
	SetOy(sr.height / 2);

	if (data.effect_mode == lcf::rpg::SavePicture::Effect_maniac_fixed_angle) {
		SetAngle(data.current_rotation * (2 * M_PI) / 360);
	} else if (data.effect_mode != lcf::rpg::SavePicture::Effect_wave) {
		SetAngle(data.current_rotation * (2 * M_PI) / 256);
	} else {
		SetAngle(0.0);
	}
	SetWaverPhase(data.effect_mode == lcf::rpg::SavePicture::Effect_wave ? data.current_waver * (2 * M_PI) / 256 : 0.0);
	SetWaverDepth(data.effect_mode == lcf::rpg::SavePicture::Effect_wave ? data.current_effect_power * 2 : 0);

	// Only older versions of RPG_RT apply the effects of current_bot_trans chunk.
	const auto top_trans = data.current_top_trans;
	const auto bottom_trans = feature_bottom_trans ? data.current_bot_trans : top_trans;

	SetOpacity(
		(int)(255 * (100 - top_trans) / 100),
		(int)(255 * (100 - bottom_trans) / 100));

	if (bottom_trans != top_trans) {
		SetBushDepth(GetHeight() / 2);
	} else {
		SetBushDepth(0);
	}

	auto tone = Tone((int) (data.current_red * 128 / 100),
			(int) (data.current_green * 128 / 100),
			(int) (data.current_blue * 128 / 100),
			(int) (data.current_sat * 128 / 100));
	if (data.flags.affected_by_tint) {
		auto screen_tone = Main_Data::game_screen->GetTone();
		tone = Blend(tone, screen_tone);
	}
	SetTone(tone);

	if (data.flags.affected_by_flash) {
		SetFlashEffect(Main_Data::game_screen->GetFlashColor());
	} else {
		SetFlashEffect(Color());
	}

	SetFlipX((data.easyrpg_flip & lcf::rpg::SavePicture::EasyRpgFlip_x) == lcf::rpg::SavePicture::EasyRpgFlip_x);
	SetFlipY((data.easyrpg_flip & lcf::rpg::SavePicture::EasyRpgFlip_y) == lcf::rpg::SavePicture::EasyRpgFlip_y);
	SetBlendType(data.easyrpg_blend_mode);

	// Don't draw anything if zoom is at zero, helps avoid a glitchy rotated sprite in the top left corner
	if (GetZoomX() <= 0.0 || GetZoomY() <= 0.0) {
		return;
	}
	Sprite::Draw(dst);
}

int Sprite_Picture::GetFrameWidth() const {
	const auto& pic = Main_Data::game_pictures->GetPicture(pic_id);
	const auto& data = pic.data;

	auto& bitmap = GetBitmap();
	assert(bitmap);

	if (feature_spritesheet && pic.NumSpriteSheetFrames() > 1) {
		return bitmap->GetWidth() / data.spritesheet_cols;
	} else {
		return bitmap->GetWidth();
	}
}

int Sprite_Picture::GetFrameHeight() const {
	const auto& pic = Main_Data::game_pictures->GetPicture(pic_id);
	const auto& data = pic.data;

	auto& bitmap = GetBitmap();
	assert(bitmap);

	if (feature_spritesheet && pic.NumSpriteSheetFrames() > 1) {
		return bitmap->GetHeight() / data.spritesheet_rows;
	} else {
		return bitmap->GetHeight();
	}
}


/*end of file .\sprite_picture.cpp*/

/*start of file .\sprite_timer.cpp*/

/* ... license chunk ... */

// Headers
#include "sprite_timer.h"
#include "cache.h"
#include "bitmap.h"
#include "game_message.h"
#include "game_party.h"
#include "game_system.h"
#include "game_battle.h"
#include <player.h>

Sprite_Timer::Sprite_Timer(int which) :
	which(which)
{
	if (which != Game_Party::Timer1 &&
		which != Game_Party::Timer2) {
		assert(false && "Invalid timer");
	}

	for (auto& d: digits) {
		d = Rect(0, 32, 8, 16);
	}
	digits[2].x = 32 + 8 * 10; // :

	SetBitmap(Bitmap::Create(40, 16));

	SetVisible(false);

	switch (which) {
		case Game_Party::Timer1:
			SetX(Player::menu_offset_x + 4);
			break;
		case Game_Party::Timer2:
			SetX(Player::screen_width - 8 * 5 - 4 - Player::menu_offset_x);
			break;
		default:
			break;
	}

	SetZ(Priority_Timer);
	SetVisible(true);
}

Sprite_Timer::~Sprite_Timer() {
}

void Sprite_Timer::Draw(Bitmap& dst) {
	if (!Main_Data::game_party->GetTimerVisible(which, Game_Battle::IsBattleRunning())) {
		return;
	}

	// RPG_RT never displays timers if there is no system graphic.
	BitmapRef system = Cache::System();
	if (!system) {
		return;
	}

	const int all_secs = Main_Data::game_party->GetTimerSeconds(which);

	int mins = all_secs / 60;
	int secs = all_secs % 60;

	int mins_1 = mins % 10;
	int mins_10 = mins / 10;

	int secs_1 = secs % 10;
	int secs_10 = secs / 10;

	digits[0].x = 32 + 8 * mins_10;
	digits[1].x = 32 + 8 * mins_1;
	digits[3].x = 32 + 8 * secs_10;
	digits[4].x = 32 + 8 * secs_1;

	if (Game_Battle::IsBattleRunning()) {
		SetY((Player::screen_height / 3 * 2) - 20);
	}
	else if (Game_Message::IsMessageActive() && Game_Message::GetRealPosition() == 0) {
		SetY(Player::screen_height - 20 - Player::menu_offset_y);
	}
	else {
		SetY(Player::menu_offset_y + 4);
	}

	GetBitmap()->Clear();
	for (int i = 0; i < 5; ++i) {
		if (i == 2) { // :
			int frames =  Main_Data::game_party->GetTimerFrames(which);
			if (frames % DEFAULT_FPS < DEFAULT_FPS / 2) {
				continue;
			}
		}
		GetBitmap()->Blit(i * 8, 0, *system, digits[i], Opacity());
	}

	Sprite::Draw(dst);
}



/*end of file .\sprite_timer.cpp*/

/*start of file .\sprite_weapon.cpp*/

/* ... license chunk ... */

// Headers
#include "sprite_weapon.h"
#include "game_battler.h"
#include "game_actor.h"
#include "game_screen.h"
#include "bitmap.h"
#include "cache.h"
#include "main_data.h"
#include "player.h"
#include <lcf/reader_util.h>
#include "output.h"

Sprite_Weapon::Sprite_Weapon(Game_Actor* actor) : Sprite() {
	battler = actor;
	CreateSprite();
}

Sprite_Weapon::~Sprite_Weapon() {
}


void Sprite_Weapon::Update() {
	++cycle;

	// Animations for allies
	// Is a battle charset animation

	int frame = std::min(2, cycle / 10);

	if (battler->IsDirectionFlipped()) {
		frame = 2 - frame;
	}

	if (frame == sprite_frame)
		return;

	const lcf::rpg::BattlerAnimation* anim = lcf::ReaderUtil::GetElement(lcf::Data::battleranimations, battler->GetBattleAnimationId());
	if (!anim) {
		Output::Warning("Invalid battler animation ID {}", battler->GetBattleAnimationId());
		return;
	}

	const auto* battler_animation_weapon = lcf::ReaderUtil::GetElement(anim->weapons, weapon_animation_id);
	if (!battler_animation_weapon) {
		return;
	}

	SetSrcRect(Rect(frame * 64, battler_animation_weapon->weapon_index * 64, 64, 64));

	SetFlipX(battler->IsDirectionFlipped());
}

void Sprite_Weapon::SetWeaponAnimation(int nweapon_animation_id) {
	weapon_animation_id = nweapon_animation_id;
}

void Sprite_Weapon::SetRanged(bool nranged) {
	ranged = nranged;
}

void Sprite_Weapon::StartAttack(bool secondary_weapon) {
	if ((secondary_weapon && !battler->IsDirectionFlipped()) || (!secondary_weapon && battler->IsDirectionFlipped())) {
		SetZ(battler->GetBattleSprite()->GetZ() + 1);
	} else {
		SetZ(battler->GetBattleSprite()->GetZ() - 1);
	}

	cycle = 0;

	attacking = true;

	if (battler->GetBattleAnimationId() > 0) {
		const lcf::rpg::BattlerAnimation* anim = lcf::ReaderUtil::GetElement(lcf::Data::battleranimations, battler->GetBattleAnimationId());
		if (!anim) {
			Output::Warning("Invalid battler animation ID {}", battler->GetBattleAnimationId());
			return;
		}

		const auto* battler_animation_weapon = lcf::ReaderUtil::GetElement(anim->weapons, weapon_animation_id);
		if (!battler_animation_weapon) {
			Output::Warning("Invalid weapon animation ID {}", weapon_animation_id);
			return;
		}

		std::string_view sprite_file = battler_animation_weapon->weapon_name;

		if (!sprite_file.empty()) {
			FileRequestAsync* request = AsyncHandler::RequestFile("BattleWeapon", sprite_file);
			request->SetGraphicFile(true);
			request_id = request->Bind(&Sprite_Weapon::OnBattleWeaponReady, this, battler_animation_weapon->weapon_index);
			request->Start();
		}
	}
}

void Sprite_Weapon::StopAttack() {
	attacking = false;
}

void Sprite_Weapon::CreateSprite() {
	SetX(battler->GetDisplayX());
	SetY(battler->GetDisplayY());

	SetOx(32);
	SetOy(32);
}

void Sprite_Weapon::OnBattleWeaponReady(FileRequestResult* result, int32_t weapon_index) {
	SetBitmap(Cache::Battleweapon(result->file));
	SetFlipX(battler->IsDirectionFlipped());
	SetSrcRect(Rect(0, weapon_index * 64, 64, 64));
}

void Sprite_Weapon::Draw(Bitmap& dst) {
	if (!attacking) {
		return;
	}

	SetTone(Main_Data::game_screen->GetTone());
	if (!ranged) {
		SetX(battler->GetDisplayX());
		SetY(battler->GetDisplayY());
	}
	SetFlashEffect(battler->GetFlashColor());

	Sprite::Draw(dst);
}


/*end of file .\sprite_weapon.cpp*/

/*start of file .\state.cpp*/

/* ... license chunk ... */

#include "state.h"
#include <lcf/reader_util.h>
#include <lcf/data.h>
#include "output.h"
#include <cassert>

namespace State {

bool Add(int state_id, StateVec& states, const PermanentStates& ps, bool allow_battle_states) {
	const lcf::rpg::State* state = lcf::ReaderUtil::GetElement(lcf::Data::states, state_id);
	if (!state) {
		Output::Warning("State::Add: Can't add state with invalid ID {}", state_id);
		return false;
	}

	if (!allow_battle_states && state->type == lcf::rpg::State::Persistence_ends) {
		return false;
	}

	if (state_id > static_cast<int>(states.size())) {
		states.resize(state_id);
	}

	states[state_id - 1] = 1;

	// Clear states that are more than 10 priority points below the
	// significant state
	const lcf::rpg::State* sig_state = GetSignificantState(states);

	for (int i = 0; i < (int)states.size(); ++i) {
		if (lcf::Data::states[i].priority <= sig_state->priority - 10 && !ps.Has(i + 1)) {
			states[i] = 0;
		}
		if (states[i]) {
			for (int j = 0; j < (int)lcf::Data::states[i].easyrpg_immune_states.size(); ++j) {
				if (lcf::Data::states[i].easyrpg_immune_states[j] && !ps.Has(j + 1)) {
					states[j] = 0;
				}
			}
		}
	}

	return states[state_id - 1] != 0;
}

bool Remove(int state_id, StateVec& states, const PermanentStates& ps) {
	const lcf::rpg::State* state = lcf::ReaderUtil::GetElement(lcf::Data::states, state_id);
	if (!state) {
		Output::Warning("State::Remove: Can't remove state with invalid ID {}", state_id);
		return false;
	}

	if (state_id - 1 >= static_cast<int>(states.size())) {
		return false;
	}

	auto& st = states[state_id - 1];

	if (!st) {
		return false;
	}

	if (ps.Has(state_id)) {
		return false;
	}

	st = 0;
	return true;
}

bool RemoveAllBattle(StateVec& states, const PermanentStates& ps) {
	bool any_removed = false;
	for (int i = 0; i < (int)states.size(); ++i) {
		auto state_id = i + 1;
		auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, state_id);
		if (state == nullptr) {
			Output::Warning("State::RemoveAllBattle: Can't remove state with invalid ID {}", state_id);
			continue;
		}
		if (state->type == lcf::rpg::State::Persistence_persists) {
			if (state->auto_release_prob == 0 || ps.Has(state_id)) {
				continue;
			}
		}
		any_removed |= Remove(state_id, states, {});
	}
	return any_removed;
}

bool RemoveAll(StateVec& states, const PermanentStates& ps) {
	bool any_removed = false;
	for (int i = 0; i < (int)states.size(); ++i) {
		auto state_id = i + 1;
		if (Has(state_id, states)) {
			any_removed |= Remove(state_id, states, ps);
		}
	}
	return any_removed;
}

lcf::rpg::State::Restriction GetSignificantRestriction(const StateVec& states) {
	// Priority is nomove > attack enemy > attack ally > normal

	lcf::rpg::State::Restriction sig_res = lcf::rpg::State::Restriction_normal;

	for (int i = 0; i < (int)states.size(); ++i) {
		auto state_id = i + 1;

		if (!Has(state_id, states)) {
			continue;
		}

		auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, state_id);
		if (state == nullptr) {
			Output::Warning("State::GetSignificantRestriction: Can't remove state with invalid ID {}", state_id);
			continue;
		}

		switch (state->restriction) {
			case lcf::rpg::State::Restriction_normal:
				break;
			case lcf::rpg::State::Restriction_do_nothing:
				return lcf::rpg::State::Restriction_do_nothing;
			case lcf::rpg::State::Restriction::Restriction_attack_enemy:
				if (sig_res == lcf::rpg::State::Restriction::Restriction_attack_ally
						|| sig_res == lcf::rpg::State::Restriction_normal) {
					sig_res = lcf::rpg::State::Restriction_attack_enemy;
				}
				break;
			case lcf::rpg::State::Restriction::Restriction_attack_ally:
				if (sig_res == lcf::rpg::State::Restriction_normal) {
					sig_res = lcf::rpg::State::Restriction_attack_ally;
				}
				break;
		}
	}

	return sig_res;

}
const lcf::rpg::State* GetSignificantState(const StateVec& states) {
	int priority = 0;
	const lcf::rpg::State* sig_state = NULL;

	for (int i = 0; i < (int)states.size(); ++i) {
		auto state_id = i + 1;

		if (!Has(state_id, states)) {
			continue;
		}

		auto* state = lcf::ReaderUtil::GetElement(lcf::Data::states, state_id);
		if (state == nullptr) {
			Output::Warning("State::GetSignificantState: Can't remove state with invalid ID {}", state_id);
			continue;
		}

		// Death has highest priority
		if (state->ID == lcf::rpg::State::kDeathID) {
			return state;
		}

		if (state->priority >= priority) {
			sig_state = state;
			priority = state->priority;
		}
	};

	return sig_state;

}

int GetStateRate(int state_id, int rate) {
	const lcf::rpg::State* state = lcf::ReaderUtil::GetElement(lcf::Data::states, state_id);

	if (!state) {
		Output::Warning("State::GetStateRate: Invalid state ID {}", state_id);
		return 0;
	}

	switch (rate) {
	case 0:
		return state->a_rate;
	case 1:
		return state->b_rate;
	case 2:
		return state->c_rate;
	case 3:
		return state->d_rate;
	case 4:
		return state->e_rate;
	default:;
	}

	assert(false && "bad rate");
	return 0;

}

const std::vector<lcf::rpg::State*> GetObjects(const StateVec& states) {
	std::vector<lcf::rpg::State*> state_list;
	for (size_t i = 0; i < states.size(); ++i) {
		if (states[i] > 0) {
			lcf::rpg::State* state = lcf::ReaderUtil::GetElement(lcf::Data::states, i + 1);
			state_list.push_back(state);
		}
	}
	return state_list;
}

const std::vector<lcf::rpg::State*> SortedByPriority(const std::vector<lcf::rpg::State*>& states) {
	std::vector<lcf::rpg::State*> state_list = states;
	std::sort(state_list.begin(), state_list.end(), [](lcf::rpg::State* lhs, lcf::rpg::State* rhs) {
		return std::tie(lhs->priority, lhs->ID) > std::tie(rhs->priority, rhs->ID);
	});
	return state_list;
}

} //namspace State


/*end of file .\state.cpp*/

/*start of file .\string_view.cpp*/

/* ... license chunk ... */

#include "string_view.h"

#if FMT_VERSION >= EP_FMT_MODERN_VERSION

#include <fmt/format.h>

auto fmt::formatter<lcf::DBString>::format(const lcf::DBString& s, format_context& ctx) const -> decltype(ctx.out()) {
	string_view sv(s.data(), s.size());
	return formatter<string_view>::format(sv, ctx);
}

#endif


/*end of file .\string_view.cpp*/

/*start of file .\text.cpp*/

/* ... license chunk ... */

// Headers
#include <lcf/data.h>
#include "cache.h"
#include "output.h"
#include "utils.h"
#include "bitmap.h"
#include "font.h"
#include "text.h"
#include "compiler.h"

#include <cctype>
#include <iterator>

Point Text::Draw(Bitmap& dest, int x, int y, const Font& font, const Bitmap& system, int color, char32_t glyph, bool is_exfont) {
	if (is_exfont) {
		if (!font.IsStyleApplied()) {
			return Font::exfont->Render(dest, x, y, system, color, glyph);
		} else {
			auto style = font.GetCurrentStyle();
			auto style_guard = Font::exfont->ApplyStyle(style);
			return Font::exfont->Render(dest, x, y, system, color, glyph);
		}
	} else {
		return font.Render(dest, x, y, system, color, glyph);
	}
}

Point Text::Draw(Bitmap& dest, int x, int y, const Font& font, Color color, char32_t glyph, bool is_exfont) {
	if (is_exfont) {
		if (!font.IsStyleApplied()) {
			return Font::exfont->Render(dest, x, y, color, glyph);
		} else {
			auto style = font.GetCurrentStyle();
			auto style_guard = Font::exfont->ApplyStyle(style);
			return Font::exfont->Render(dest, x, y, color, glyph);
		}
	} else {
		return font.Render(dest, x, y, color, glyph);
	}
}

Point Text::Draw(Bitmap& dest, const int x, const int y, const Font& font, const Bitmap& system, const int color, std::string_view text, const Text::Alignment align) {
	if (text.length() == 0) return { 0, 0 };

	Rect dst_rect = Text::GetSize(font, text);

	const int ih = dst_rect.height;

	switch (align) {
	case Text::AlignCenter:
		dst_rect.x = x - dst_rect.width / 2; break;
	case Text::AlignRight:
		dst_rect.x = x - dst_rect.width; break;
	case Text::AlignLeft:
		dst_rect.x = x; break;
	default: assert(false);
	}

	dst_rect.y = y;
	dst_rect.width += 1; dst_rect.height += 1; // Need place for shadow

	const int iy = dst_rect.y;
	const int ix = dst_rect.x;

	// Where to draw the next glyph (x pos)
	int next_glyph_pos = 0;

	// This loops always renders a single char, color blends it and then puts
	// it onto the text_surface (including the drop shadow)
	auto iter = text.data();
	const auto end = iter + text.size();

	if (font.CanShape()) {
		// Collect all glyphs until ExFont or end of string and then shape and render
		std::u32string text32;
		while (iter != end) {
			auto ret = Utils::TextNext(iter, end, 0);

			iter = ret.next;
			if (EP_UNLIKELY(!ret)) {
				continue;
			}

			if (EP_UNLIKELY(Utils::IsControlCharacter(ret.ch))) {
				next_glyph_pos += Draw(dest, ix + next_glyph_pos, iy, font, system, color, ret.ch, ret.is_exfont).x;
				continue;
			}

			if (ret.is_exfont) {
				if (!text32.empty()) {
					auto shape_ret = font.Shape(text32);
					text32.clear();

					for (const auto& ch: shape_ret) {
						next_glyph_pos += font.Render(dest, ix + next_glyph_pos, iy, system, color, ch).x;
					}
				}

				next_glyph_pos += Draw(dest, ix + next_glyph_pos, iy, font, system, color, ret.ch, true).x;
				continue;
			}

			text32 += ret.ch;
		}

		if (!text32.empty()) {
			auto shape_ret = font.Shape(text32);

			for (const auto& ch: shape_ret) {
				next_glyph_pos += font.Render(dest, ix + next_glyph_pos, iy, system, color, ch).x;
			}
		}
	} else {
		while (iter != end) {
			auto ret = Utils::TextNext(iter, end, 0);

			iter = ret.next;
			if (EP_UNLIKELY(!ret)) {
				continue;
			}
			next_glyph_pos += Text::Draw(dest, ix + next_glyph_pos, iy, font, system, color, ret.ch, ret.is_exfont).x;
		}
	}
	return { next_glyph_pos, ih };
}

Point Text::Draw(Bitmap& dest, const int x, const int y, const Font& font, const Color color, std::string_view text) {
	if (text.length() == 0) return { 0, 0 };

	int dx = x;
	int mx = x;

	int dy = y;
	int ny = 0;

	auto iter = text.data();
	const auto end = iter + text.size();
	while (iter != end) {
		auto ret = Utils::UTF8Next(iter, end);

		iter = ret.next;
		if (EP_UNLIKELY(!ret)) {
			continue;
		}

		if (ret.ch == U'\n') {
			if (ny == 0) {
				ny = font.GetSize(ret.ch).height;
			}
			dy += ny;
			mx = std::max(mx, dx);
			dx = x;
			ny = 0;
			continue;
		}

		auto rect = font.Render(dest, dx, dy, color, ret.ch);
		dx += rect.x;
		assert(ny == 0 || ny == rect.y);
		ny = rect.y;
	}
	dy += ny;
	mx = std::max(mx, dx);

	return { mx - x , dy - y };
}

Rect Text::GetSize(const Font& font, std::string_view text) {
	Rect rect;
	Rect rect_tmp;

	auto iter = text.data();
	const auto end = iter + text.size();

	if (font.CanShape()) {
		std::u32string text32;
		while (iter != end) {
			auto ret = Utils::TextNext(iter, end, 0);

			iter = ret.next;
			if (EP_UNLIKELY(!ret)) {
				continue;
			}

			if (EP_UNLIKELY(Utils::IsControlCharacter(ret.ch))) {
				rect_tmp = GetSize(font, ret.ch, ret.is_exfont);
				rect.width += rect_tmp.width;
				rect.height = std::max(rect.height, rect_tmp.height);
				continue;
			}

			if (ret.is_exfont) {
				if (!text32.empty()) {
					auto shape_ret = font.Shape(text32);
					text32.clear();

					for (const auto& ch: shape_ret) {
						Rect size = font.GetSize(ch);
						rect.width += ch.offset.x + size.width;
						rect.height = std::max(rect.height, size.height);
					}
				}

				rect_tmp = GetSize(font, ret.ch, ret.is_exfont);
				rect.width += rect_tmp.width;
				rect.height = std::max(rect.height, rect_tmp.height);
				continue;
			}

			text32 += ret.ch;
		}

		if (!text32.empty()) {
			auto shape_ret = font.Shape(text32);

			for (const auto& ch: shape_ret) {
				Rect size = font.GetSize(ch);
				rect.width += ch.offset.x + size.width;
				rect.height = std::max(rect.height, size.height);
			}
		}
	} else {
		while (iter != end) {
			auto ret = Utils::TextNext(iter, end, 0);

			iter = ret.next;
			if (EP_UNLIKELY(!ret)) {
				continue;
			}

			rect_tmp = GetSize(font, ret.ch, ret.is_exfont);
			rect.width += rect_tmp.width;
			rect.height = std::max(rect.height, rect_tmp.height);
		}
	}

	return rect;
}

Rect Text::GetSize(const Font& font, char32_t glyph, bool is_exfont) {
	if (is_exfont) {
		if (!font.IsStyleApplied()) {
			return Font::exfont->GetSize(glyph);
		} else {
			auto style = font.GetCurrentStyle();
			auto style_guard = Font::exfont->ApplyStyle(style);
			return Font::exfont->GetSize(glyph);
		}
	} else {
		return font.GetSize(glyph);
	}
}


/*end of file .\text.cpp*/

/*start of file .\tilemap.cpp*/

/* ... license chunk ... */

// Headers
#include "tilemap.h"
#include "tilemap_layer.h"
#include "bitmap.h"

// Constructor
Tilemap::Tilemap(): layer_down(0), layer_up(1) {
}

// Properties
BitmapRef const& Tilemap::GetChipset() const {
	return layer_down.GetChipset();
}
void Tilemap::SetChipset(BitmapRef const& chipset) {
	layer_down.SetChipset(chipset);
	layer_up.SetChipset(chipset);
}

bool Tilemap::IsVisible() const {
	return layer_down.IsVisible();
}
void Tilemap::SetVisible(bool nvisible) {
	layer_down.SetVisible(nvisible);
	layer_up.SetVisible(nvisible);
}
int Tilemap::GetOx() const {
	return layer_down.GetOx();
}
void Tilemap::SetOx(int nox) {
	layer_down.SetOx(nox);
	layer_up.SetOx(nox);
}
int Tilemap::GetOy() const {
	return layer_down.GetOy();
}
void Tilemap::SetOy(int noy) {
	layer_down.SetOy(noy);
	layer_up.SetOy(noy);
}
int Tilemap::GetRenderOx() const {
	return layer_down.GetRenderOx();
}
void Tilemap::SetRenderOx(int render_x) {
	layer_down.SetRenderOx(render_x);
	layer_up.SetRenderOx(render_x);
}
int Tilemap::GetRenderOy() const {
	return layer_down.GetRenderOy();
}
void Tilemap::SetRenderOy(int render_y) {
	layer_down.SetRenderOy(render_y);
	layer_up.SetRenderOy(render_y);
}
int Tilemap::GetWidth() const {
	return layer_down.GetWidth();
}
void Tilemap::SetWidth(int nwidth) {
	layer_down.SetWidth(nwidth);
	layer_up.SetWidth(nwidth);
}
int Tilemap::GetHeight() const {
	return layer_down.GetHeight();
}
void Tilemap::SetHeight(int nheight) {
	layer_down.SetHeight(nheight);
	layer_up.SetHeight(nheight);
}
int Tilemap::GetAnimationSpeed() const {
	return layer_down.GetAnimationSpeed();
}
void Tilemap::SetAnimationSpeed(int speed) {
	layer_down.SetAnimationSpeed(speed);
}
int Tilemap::GetAnimationType() const {
	return layer_down.GetAnimationType();
}
void Tilemap::SetAnimationType(int type) {
	layer_down.SetAnimationType(type);
}
void Tilemap::OnSubstituteDown() {
	layer_down.OnSubstitute();
}
void Tilemap::OnSubstituteUp() {
	layer_up.OnSubstitute();
}

void Tilemap::SetFastBlitDown(bool fast) {
	layer_down.SetFastBlit(fast);
}

void Tilemap::SetTone(Tone tone) {
	layer_down.SetTone(tone);
	layer_up.SetTone(tone);
}


/*end of file .\tilemap.cpp*/

/*start of file .\tilemap_layer.cpp*/

/* ... license chunk ... */

// Headers
#include <cstring>
#include <cmath>
#include "tilemap_layer.h"
#include "output.h"
#include "player.h"
#include "map_data.h"
#include "main_data.h"
#include "bitmap.h"
#include "compiler.h"
#include "game_map.h"
#include "game_system.h"
#include "drawable_mgr.h"
#include "baseui.h"

// Blocks subtiles IDs
// Mess with this code and you will die in 3 days...
// [tile-id][row][col]
static constexpr int8_t BlockA_Subtiles_IDS[47][2][2] = {
#define N -1
	{{N, N}, {N, N}},
	{{3, N}, {N, N}},
	{{N, 3}, {N, N}},
	{{3, 3}, {N, N}},
	{{N, N}, {N, 3}},
	{{3, N}, {N, 3}},
	{{N, 3}, {N, 3}},
	{{3, 3}, {N, 3}},
	{{N, N}, {3, N}},
	{{3, N}, {3, N}},
	{{N, 3}, {3, N}},
	{{3, 3}, {3, N}},
	{{N, N}, {3, 3}},
	{{3, N}, {3, 3}},
	{{N, 3}, {3, 3}},
	{{3, 3}, {3, 3}},
	{{1, N}, {1, N}},
	{{1, 3}, {1, N}},
	{{1, N}, {1, 3}},
	{{1, 3}, {1, 3}},
	{{2, 2}, {N, N}},
	{{2, 2}, {N, 3}},
	{{2, 2}, {3, N}},
	{{2, 2}, {3, 3}},
	{{N, 1}, {N, 1}},
	{{N, 1}, {3, 1}},
	{{3, 1}, {N, 1}},
	{{3, 1}, {3, 1}},
	{{N, N}, {2, 2}},
	{{3, N}, {2, 2}},
	{{N, 3}, {2, 2}},
	{{3, 3}, {2, 2}},
	{{1, 1}, {1, 1}},
	{{2, 2}, {2, 2}},
	{{0, 2}, {1, N}},
	{{0, 2}, {1, 3}},
	{{2, 0}, {N, 1}},
	{{2, 0}, {3, 1}},
	{{N, 1}, {2, 0}},
	{{3, 1}, {2, 0}},
	{{1, N}, {0, 2}},
	{{1, 3}, {0, 2}},
	{{0, 0}, {1, 1}},
	{{0, 2}, {0, 2}},
	{{1, 1}, {0, 0}},
	{{2, 0}, {2, 0}},
	{{0, 0}, {0, 0}}
#undef N
};

// [tile-id][row][col][x/y]
static constexpr uint8_t BlockD_Subtiles_IDS[50][2][2][2] = {
//     T-L     T-R       B-L     B-R
    {{{1, 2}, {1, 2}}, {{1, 2}, {1, 2}}},
    {{{2, 0}, {1, 2}}, {{1, 2}, {1, 2}}},
    {{{1, 2}, {2, 0}}, {{1, 2}, {1, 2}}},
    {{{2, 0}, {2, 0}}, {{1, 2}, {1, 2}}},
    {{{1, 2}, {1, 2}}, {{1, 2}, {2, 0}}},
    {{{2, 0}, {1, 2}}, {{1, 2}, {2, 0}}},
    {{{1, 2}, {2, 0}}, {{1, 2}, {2, 0}}},
    {{{2, 0}, {2, 0}}, {{1, 2}, {2, 0}}},
    {{{1, 2}, {1, 2}}, {{2, 0}, {1, 2}}},
    {{{2, 0}, {1, 2}}, {{2, 0}, {1, 2}}},
    {{{1, 2}, {2, 0}}, {{2, 0}, {1, 2}}},
    {{{2, 0}, {2, 0}}, {{2, 0}, {1, 2}}},
    {{{1, 2}, {1, 2}}, {{2, 0}, {2, 0}}},
    {{{2, 0}, {1, 2}}, {{2, 0}, {2, 0}}},
    {{{1, 2}, {2, 0}}, {{2, 0}, {2, 0}}},
    {{{2, 0}, {2, 0}}, {{2, 0}, {2, 0}}},
    {{{0, 2}, {0, 2}}, {{0, 2}, {0, 2}}},
    {{{0, 2}, {2, 0}}, {{0, 2}, {0, 2}}},
    {{{0, 2}, {0, 2}}, {{0, 2}, {2, 0}}},
    {{{0, 2}, {2, 0}}, {{0, 2}, {2, 0}}},
    {{{1, 1}, {1, 1}}, {{1, 1}, {1, 1}}},
    {{{1, 1}, {1, 1}}, {{1, 1}, {2, 0}}},
    {{{1, 1}, {1, 1}}, {{2, 0}, {1, 1}}},
    {{{1, 1}, {1, 1}}, {{2, 0}, {2, 0}}},
    {{{2, 2}, {2, 2}}, {{2, 2}, {2, 2}}},
    {{{2, 2}, {2, 2}}, {{2, 0}, {2, 2}}},
    {{{2, 0}, {2, 2}}, {{2, 2}, {2, 2}}},
    {{{2, 0}, {2, 2}}, {{2, 0}, {2, 2}}},
    {{{1, 3}, {1, 3}}, {{1, 3}, {1, 3}}},
    {{{2, 0}, {1, 3}}, {{1, 3}, {1, 3}}},
    {{{1, 3}, {2, 0}}, {{1, 3}, {1, 3}}},
    {{{2, 0}, {2, 0}}, {{1, 3}, {1, 3}}},
    {{{0, 2}, {2, 2}}, {{0, 2}, {2, 2}}},
    {{{1, 1}, {1, 1}}, {{1, 3}, {1, 3}}},
    {{{0, 1}, {0, 1}}, {{0, 1}, {0, 1}}},
    {{{0, 1}, {0, 1}}, {{0, 1}, {2, 0}}},
    {{{2, 1}, {2, 1}}, {{2, 1}, {2, 1}}},
    {{{2, 1}, {2, 1}}, {{2, 0}, {2, 1}}},
    {{{2, 3}, {2, 3}}, {{2, 3}, {2, 3}}},
    {{{2, 0}, {2, 3}}, {{2, 3}, {2, 3}}},
    {{{0, 3}, {0, 3}}, {{0, 3}, {0, 3}}},
    {{{0, 3}, {2, 0}}, {{0, 3}, {0, 3}}},
    {{{0, 1}, {2, 1}}, {{0, 1}, {2, 1}}},
    {{{0, 1}, {0, 1}}, {{0, 3}, {0, 3}}},
    {{{0, 3}, {2, 3}}, {{0, 3}, {2, 3}}},
    {{{2, 1}, {2, 1}}, {{2, 3}, {2, 3}}},
    {{{0, 1}, {2, 1}}, {{0, 3}, {2, 3}}},
    {{{1, 2}, {1, 2}}, {{1, 2}, {1, 2}}},
    {{{1, 2}, {1, 2}}, {{1, 2}, {1, 2}}},
    {{{0, 0}, {0, 0}}, {{0, 0}, {0, 0}}}
};

// Set of neighboring autotiles -> autotile variant
// Each neighbor is represented by a single bit (1 - same autotile, 0 - any other case)
// The bits are ordered as follows (from most to least significant bit): NW N NE W E SW S SE
static const std::unordered_map<uint8_t, int> AUTOTILE_D_VARIANTS_MAP = { //it also works with A
	{0b11111111, 0},
	{0b01111111, 1},
	{0b11011111, 2},
	{0b01011111, 3},
	{0b11111110, 4},
	{0b01111110, 5},
	{0b11011110, 6},
	{0b01011110, 7},
	{0b11111011, 8},
	{0b01111011, 9},
	{0b11011011, 10},
	{0b01011011, 11},
	{0b11111010, 12},
	{0b01111010, 13},
	{0b11011010, 14},
	{0b01011010, 15},
	{0b01101011, 16},
	{0b01001011, 17},
	{0b01101010, 18},
	{0b01001010, 19},
	{0b00011111, 20},
	{0b00011110, 21},
	{0b00011011, 22},
	{0b00011010, 23},
	{0b11010110, 24},
	{0b11010010, 25},
	{0b01010110, 26},
	{0b01010010, 27},
	{0b11111000, 28},
	{0b01111000, 29},
	{0b11011000, 30},
	{0b01011000, 31},
	{0b01000010, 32},
	{0b00011000, 33},
	{0b00001011, 34},
	{0b00001010, 35},
	{0b00010110, 36},
	{0b00010010, 37},
	{0b11010000, 38},
	{0b01010000, 39},
	{0b01101000, 40},
	{0b01001000, 41},
	{0b00000010, 42},
	{0b00001000, 43},
	{0b01000000, 44},
	{0b00010000, 45},
	{0b00000000, 46}
};

TilemapLayer::TilemapLayer(int ilayer) :
	substitutions(Game_Map::GetTilesLayer(ilayer)),
	layer(ilayer),
	// SubLayer for the tiles without Wall or Above passability
	// Its z-value should be under z of the events in the lower layer
	lower_layer(this, Priority_TilesetBelow + TileBelow + layer),
	// SubLayer for the tiles with Wall or Above passability
	// Its z-value should be between the z of the events in the upper layer and the hero
	upper_layer(this, Priority_TilesetAbove + TileAbove + layer)
{
}

// This setup of having an always inlined DrawTile() which dispatches to DrawTileImpl()
// was created intentionally. Inlining the transparency check was measured and shown
// to provide a performance improvement
EP_ALWAYS_INLINE
void TilemapLayer::DrawTile(Bitmap& dst, Bitmap& tileset, Bitmap& tone_tileset, int x, int y, int row, int col, uint32_t tone_hash, bool allow_fast_blit) {
	auto op = tileset.GetTileOpacity(col, row);
	if (op != ImageOpacity::Transparent) {
		DrawTileImpl(dst, tileset, tone_tileset, x, y, row, col, tone_hash, op, allow_fast_blit);
	}
}

void TilemapLayer::DrawTileImpl(Bitmap& dst, Bitmap& tileset, Bitmap& tone_tileset, int x, int y, int row, int col, uint32_t tone_hash, ImageOpacity op, bool allow_fast_blit) {

	auto rect = Rect{ col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE };

	auto* src = &tileset;

	// Create tone changed tile
	if (tone != Tone()) {
		if (chipset_tone_tiles.insert(tone_hash).second) {
			tone_tileset.ToneBlit(col * TILE_SIZE, row * TILE_SIZE, tileset, rect, tone, Opacity::Opaque());
		}
		src = &tone_tileset;
	}

	bool use_fast_blit = fast_blit && allow_fast_blit;
	if (op == ImageOpacity::Opaque || use_fast_blit) {
		dst.BlitFast(x, y, *src, rect, 255);
	} else {
		dst.Blit(x, y, *src, rect, 255);
	}
}

static uint32_t MakeFTileHash(int id) {
	return static_cast<uint32_t>(id);
}

static uint32_t MakeETileHash(int id) {
	return static_cast<uint32_t>(id | (1 << 24));
}

static uint32_t MakeDTileHash(int id) {
	return static_cast<uint32_t>(id | (2 << 24));
}

static uint32_t MakeCTileHash(int id, int anim_step) {
	return static_cast<uint32_t>((id + (anim_step << 12)) | (3 << 24));
}

static uint32_t MakeAbTileHash(int id, int anim_step) {
	return static_cast<uint32_t>((id + (anim_step << 12)) | (4 << 24));
}

void TilemapLayer::Draw(Bitmap& dst, uint8_t z_order, int render_ox, int render_oy) {
	// Get the number of tiles that can be displayed on window
	int tiles_x = (int)ceil(Player::screen_width / (float)TILE_SIZE);
	int tiles_y = (int)ceil(Player::screen_height / (float)TILE_SIZE);

	// If ox or oy are not equal to the tile size draw the next tile too
	// to prevent black (empty) tiles at the borders
	if ((ox - render_ox) % TILE_SIZE != 0) {
		++tiles_x;
	}
	if ((oy - render_oy) % TILE_SIZE != 0) {
		++tiles_y;
	}

	const bool loop_h = Game_Map::LoopHorizontal();
	const bool loop_v = Game_Map::LoopVertical();

	auto div_rounding_down = [](int n, int m) {
		if (n >= 0) return n / m;
		return (n - m + 1) / m;
	};
	auto mod = [](int n, int m) {
		int rem = n % m;
		return rem >= 0 ? rem : m + rem;
	};

	// FIXME: When Game_Map singleton is made an object we can remove this null check
	const auto frames = Main_Data::game_system ? static_cast<uint32_t>(Main_Data::game_system->GetFrameCounter()) : 0u;
	auto animation_step_c = (frames / 6) % 4;
	auto animation_step_ab = frames / animation_speed;
	if (animation_type) {
		animation_step_ab %= 3;
	} else {
		animation_step_ab %= 4;
		if (animation_step_ab == 3) {
			animation_step_ab = 1;
		}
	}

	const int div_ox = div_rounding_down(ox - render_ox, TILE_SIZE);
	const int div_oy = div_rounding_down(oy - render_oy, TILE_SIZE);

	const int mod_ox = mod(ox - render_ox, TILE_SIZE);
	const int mod_oy = mod(oy - render_oy, TILE_SIZE);

	for (int y = 0; y < tiles_y; y++) {
		for (int x = 0; x < tiles_x; x++) {

			// Get the real maps tile coordinates
			int map_x = div_ox + x;
			int map_y = div_oy + y;
			if (loop_h) map_x = mod(map_x, width);
			if (loop_v) map_y = mod(map_y, height);

			bool out_of_bounds =
				map_x < 0 || map_x >= width ||
				map_y < 0 || map_y >= height;

			if (out_of_bounds) {
				continue;
			}

			int map_draw_x = x * TILE_SIZE - mod_ox;
			int map_draw_y = y * TILE_SIZE - mod_oy;

			// Get the tile data
			TileData &tile = GetDataCache(map_x, map_y);

			// Draw the sublayer if its z is being draw now
			if (z_order == tile.z) {
				if (layer == 0) {
					// If lower layer
					bool allow_fast_blit = (tile.z == TileBelow);

					if (tile.ID >= BLOCK_E && tile.ID < BLOCK_E + BLOCK_E_TILES) {
						int id = substitutions[tile.ID - BLOCK_E];
						// If Block E

						int row, col;

						// Get the tile coordinates from chipset
						if (id < 96) {
							// If from first column of the block
							col = 12 + id % 6;
							row = id / 6;
						} else {
							// If from second column of the block
							col = 18 + (id - 96) % 6;
							row = (id - 96) / 6;
						}

						auto tone_hash = MakeETileHash(id);
						DrawTile(dst, *chipset, *chipset_effect, map_draw_x, map_draw_y, row, col, tone_hash, allow_fast_blit);
					} else if (tile.ID >= BLOCK_C && tile.ID < BLOCK_D) {
						// If Block C

						// Get the tile coordinates from chipset
						int col = 3 + (tile.ID - BLOCK_C) / 50;
						int row = 4 + animation_step_c;

						auto tone_hash = MakeCTileHash(tile.ID, animation_step_c);
						DrawTile(dst, *chipset, *chipset_effect, map_draw_x, map_draw_y, row, col, tone_hash, allow_fast_blit);
					} else if (tile.ID < BLOCK_C) {
						// If Blocks A1, A2, B

						// Draw the tile from autotile cache
						TileXY pos = GetCachedAutotileAB(tile.ID, animation_step_ab);

						int col = pos.x;
						int row = pos.y;

						// Create tone changed tile
						auto tone_hash = MakeAbTileHash(tile.ID,  animation_step_ab);
						DrawTile(dst, *autotiles_ab_screen, *autotiles_ab_screen_effect, map_draw_x, map_draw_y, row, col, tone_hash, allow_fast_blit);
					} else {
						// If blocks D1-D12

						// Draw the tile from autotile cache
						TileXY pos = GetCachedAutotileD(tile.ID);

						int col = pos.x;
						int row = pos.y;

						auto tone_hash = MakeDTileHash(tile.ID);
						DrawTile(dst, *autotiles_d_screen, *autotiles_d_screen_effect, map_draw_x, map_draw_y, row, col, tone_hash, allow_fast_blit);
					}
				} else {
					// If upper layer

					// Check that block F is being drawn
					if (tile.ID >= BLOCK_F && tile.ID < BLOCK_F + BLOCK_F_TILES) {
						int id = substitutions[tile.ID - BLOCK_F];
						int row, col;

						// Get the tile coordinates from chipset
						if (id < 48) {
							// If from first column of the block
							col = 18 + id % 6;
							row = 8 + id / 6;
						} else {
							// If from second column of the block
							col = 24 + (id - 48) % 6;
							row = (id - 48) / 6;
						}

						auto tone_hash = MakeFTileHash(id);
						DrawTile(dst, *chipset, *chipset_effect, map_draw_x, map_draw_y, row, col, tone_hash);
					}
				}
			}
		}
	}
}

TilemapLayer::TileXY TilemapLayer::GetCachedAutotileAB(short ID, short animID) {
	short block = ID / 1000;
	short b_subtile = (ID - block * 1000) / 50;
	short a_subtile = ID - block * 1000 - b_subtile * 50;
	return autotiles_ab[animID][block][b_subtile][a_subtile];
}

TilemapLayer::TileXY TilemapLayer::GetCachedAutotileD(short ID) {
	short block = (ID - 4000) / 50;
	short subtile = ID - 4000 - block * 50;
	return autotiles_d[block][subtile];
}

void TilemapLayer::CreateTileCache(const std::vector<short>& nmap_data) {
	data_cache_vec.resize(width * height);
	for (int x = 0; x < width; x++) {
		for (int y = 0; y < height; y++) {
			auto tile_id = nmap_data[x + y * width];
			CreateTileCacheAt(x, y, tile_id);
		}
	}
}

void TilemapLayer::CreateTileCacheAt(int x, int y, int tile_id) {
	TileData tile;
	tile.ID = static_cast<short>(tile_id);
	tile.z = TileBelow;

	// Calculate the tile Z
	if (!passable.empty()) {
		if (tile.ID >= BLOCK_F) { // Upper layer
			if ((passable[substitutions[tile.ID - BLOCK_F]] & Passable::Above) != 0)
				tile.z = TileAbove + 1; // Upper sublayer
			else
				tile.z = TileBelow + 1; // Lower sublayer

		} else { // Lower layer
			int chip_index =
					tile.ID >= BLOCK_E ? substitutions[tile.ID - BLOCK_E] + 18 :
					tile.ID >= BLOCK_D ? (tile.ID - BLOCK_D) / 50 + 6 :
					tile.ID >= BLOCK_C ? (tile.ID - BLOCK_C) / 50 + 3 :
					tile.ID / 1000;
			if ((passable[chip_index] & (Passable::Wall | Passable::Above)) != 0)
				tile.z = TileAbove; // Upper sublayer
			else
				tile.z = TileBelow; // Lower sublayer

		}
	}
	GetDataCache(x, y) = tile;
}

void TilemapLayer::RecreateTileDataAt(int x, int y, int tile_id) {
	map_data[x + y * width] = static_cast<short>(tile_id);
	Game_Map::ReplaceTileAt(x, y, tile_id, layer);
	CreateTileCacheAt(x, y, tile_id);
}

void TilemapLayer::GenerateAutotileAB(short ID, short animID) {
	// Calculate the block to use
	//	1: A1 + Upper B (Grass + Coast)
	//	2: A2 + Upper B (Snow + Coast)
	//	3: A1 + Lower B (Grass + Ocean/Deep water)
	short block = ID / 1000;

	// Calculate the B block combination
	short b_subtile = (ID - block * 1000) / 50;
	if (b_subtile >= TILE_SIZE) {
		Output::Warning("Invalid AB autotile ID: {} (b_subtile = {})",
						ID, b_subtile);
		return;
	}

	// Calculate the A block combination
	short a_subtile = ID - block * 1000 - b_subtile * 50;
	if (a_subtile >= 47) {
		Output::Warning("Invalid AB autotile ID: {} (a_subtile = {})",
						ID, a_subtile);
		return;
	}

	if (autotiles_ab[animID][block][b_subtile][a_subtile].valid)
		return;

	uint8_t quarters[2][2][2];

	// Determine block B subtiles
	for (int j = 0; j < 2; j++) {
		for (int i = 0; i < 2; i++) {
			// Skip the subtile if it will be used one from A block instead
			if (BlockA_Subtiles_IDS[a_subtile][j][i] != -1) continue;

			// Get the block B subtiles ids and get their coordinates on the chipset
			int t = (b_subtile >> (j * 2 + i)) & 1;
			if (block == 2) t ^= 3;

			quarters[j][i][0] = animID;
			quarters[j][i][1] = 4 + t;
		}
	}

	// Determine block A subtiles
	for (int j = 0; j < 2; j++) {
		for (int i = 0; i < 2; i++) {
			// Skip the subtile if it was used one from B block
			if (BlockA_Subtiles_IDS[a_subtile][j][i] == -1) continue;

			// Get the block A subtiles ids and get their coordinates on the chipset
			quarters[j][i][0] = animID + (block == 1 ? 3 : 0);
			quarters[j][i][1] = BlockA_Subtiles_IDS[a_subtile][j][i];
		}
	}

	// Determine block B subtiles when combining A and B
	if (b_subtile != 0 && a_subtile != 0) {
		for (int j = 0; j < 2; j++) {
			for (int i = 0; i < 2; i++) {
				// calculate tile (row 0..3)
				int t = (b_subtile >> (j * 2 + i)) & 1;
				if (block == 2) t *= 2;

				// Skip the subtile if not used
				if (t == 0) continue;

				// Get the coordinates on the chipset
				quarters[j][i][0] = animID;
				quarters[j][i][1] = 4 + t;
			}
		}
	}

	// pack the quarters data into a word
	uint32_t quarters_hash = 0;
	for (int j = 0; j < 2; j++)
		for (int i = 0; i < 2; i++)
			for (int k = 0; k < 2; k++) {
				quarters_hash <<= 4;
				quarters_hash |= quarters[j][i][k];
			}

	// check whether we have already generated this tile
	auto it = autotiles_ab_map.find(quarters_hash);
	if (it != autotiles_ab_map.end()) {
		autotiles_ab[animID][block][b_subtile][a_subtile] = it->second;
		return;
	}

	int id = autotiles_ab_next++;
	int dst_x = id % TILES_PER_ROW;
	int dst_y = id / TILES_PER_ROW;

	TileXY tile_xy(dst_x, dst_y);
	autotiles_ab_map[quarters_hash] = tile_xy;
	autotiles_ab[animID][block][b_subtile][a_subtile] = tile_xy;
}

void TilemapLayer::GenerateAutotileD(short ID) {
	// Calculate the D block id
	short block = (ID - 4000) / 50;

	// Calculate the D block combination
	short subtile = ID - 4000 - block * 50;

	if (block >= 12 || subtile >= 50 || block < 0 || subtile < 0) {
		Output::Warning("Tilemap index out of range: {} {}", block, subtile);
		return;
	}

	if (autotiles_d[block][subtile].valid)
		return;

	uint8_t quarters[2][2][2];

	// Get Block chipset coords
	short block_x, block_y;
	if (block < 4) {
		// If from first column
		block_x = (block % 2) * 3;
		block_y = 8 + (block / 2) * 4;
	} else {
		// If from second column
		block_x = 6 + (block % 2) * 3;
		block_y = ((block - 4) / 2) * 4;
	}

	// Calculate D block subtiles
	for (int j = 0; j < 2; j++) {
		for (int i = 0; i < 2; i++) {
			// Get the block D subtiles ids and get their coordinates on the chipset
			quarters[j][i][0] = block_x + BlockD_Subtiles_IDS[subtile][j][i][0];
			quarters[j][i][1] = block_y + BlockD_Subtiles_IDS[subtile][j][i][1];
		}
	}

	// pack the quarters data into a word
	uint32_t quarters_hash = 0;
	for (int j = 0; j < 2; j++)
		for (int i = 0; i < 2; i++)
			for (int k = 0; k < 2; k++) {
				quarters_hash <<= 4;//multiply 16
				quarters_hash |= quarters[j][i][k];
			}

	// check whether we have already generated this tile
	auto it = autotiles_d_map.find(quarters_hash);
	if (it != autotiles_d_map.end()) {
		autotiles_d[block][subtile] = it->second;
		return;
	}

	int id = autotiles_d_next++;
	int dst_x = id % TILES_PER_ROW;
	int dst_y = id / TILES_PER_ROW;

	TileXY tile_xy(dst_x, dst_y);
	autotiles_d_map[quarters_hash] = tile_xy;
	autotiles_d[block][subtile] = tile_xy;
}

BitmapRef TilemapLayer::GenerateAutotiles(int count, const std::unordered_map<uint32_t, TileXY>& map) {
	int rows = (count + TILES_PER_ROW - 1) / TILES_PER_ROW;
	BitmapRef tiles = Bitmap::Create(TILES_PER_ROW * TILE_SIZE, rows * TILE_SIZE);
	tiles->Clear();
	Rect rect(0, 0, TILE_SIZE/2, TILE_SIZE/2);

	for (auto& p: map) {
		uint32_t quarters_hash = p.first;
		TileXY dst = p.second;

		// unpack the quarters data
		for (int j = 0; j < 2; j++) {
			for (int i = 0; i < 2; i++) {
				constexpr int mask = ~(0xFu << 28);

				int x = quarters_hash >> 28;
				quarters_hash &= mask;
				quarters_hash <<= 4;

				int y = quarters_hash >> 28;
				quarters_hash &= mask;
				quarters_hash <<= 4;

				rect.x = (x * 2 + i) * (TILE_SIZE/2);
				rect.y = (y * 2 + j) * (TILE_SIZE/2);

				tiles->BlitFast((dst.x * 2 + i) * (TILE_SIZE / 2), (dst.y * 2 + j) * (TILE_SIZE / 2), *chipset, rect, 255);
			}
		}
	}

	if (rows > 0) {
		tiles->CheckPixels(Bitmap::Flag_Chipset | Bitmap::Flag_ReadOnly);
	}

	return tiles;
}

void TilemapLayer::SetChipset(BitmapRef const& nchipset) {
	chipset = nchipset;
	chipset_effect = Bitmap::Create(chipset->width(), chipset->height());
	chipset_tone_tiles.clear();

	if (autotiles_ab_next != 0 && autotiles_d_screen != nullptr && layer == 0) {
		autotiles_ab_screen = GenerateAutotiles(autotiles_ab_next, autotiles_ab_map);
		autotiles_d_screen = GenerateAutotiles(autotiles_d_next, autotiles_d_map);

		autotiles_ab_screen_effect = Bitmap::Create(autotiles_ab_screen->width(), autotiles_ab_screen->height());
		autotiles_d_screen_effect = Bitmap::Create(autotiles_d_screen->width(), autotiles_d_screen->height());
	}
}

void TilemapLayer::SetMapData(std::vector<short> nmap_data) {
	// Create the tiles data cache
	CreateTileCache(nmap_data);
	memset(autotiles_ab, 0, sizeof(autotiles_ab));
	memset(autotiles_d, 0, sizeof(autotiles_d));

	if (layer == 0) {
		autotiles_ab_map.clear();
		autotiles_d_map.clear();
		autotiles_ab_next = 0;
		autotiles_d_next = 0;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {

				if (GetDataCache(x, y).ID < BLOCK_C) {
					// If blocks A and B

					GenerateAutotileAB(GetDataCache(x, y).ID, 0);
					GenerateAutotileAB(GetDataCache(x, y).ID, 1);
					GenerateAutotileAB(GetDataCache(x, y).ID, 2);
				} else if (GetDataCache(x, y).ID >= BLOCK_D && GetDataCache(x, y).ID < BLOCK_E) {
					// If block D

					GenerateAutotileD(GetDataCache(x, y).ID);
				}
			}
		}
		autotiles_ab_screen = GenerateAutotiles(autotiles_ab_next, autotiles_ab_map);
		autotiles_d_screen = GenerateAutotiles(autotiles_d_next, autotiles_d_map);

		autotiles_ab_screen_effect = Bitmap::Create(autotiles_ab_screen->width(), autotiles_ab_screen->height());
		autotiles_d_screen_effect = Bitmap::Create(autotiles_d_screen->width(), autotiles_d_screen->height());

		chipset_tone_tiles.clear();
	}

	map_data = std::move(nmap_data);
}

static inline bool IsTileFromBlock(int tile_id, int block) {
	switch (block) {
	case BLOCK_A: return tile_id >= BLOCK_A && tile_id < BLOCK_A_END;
	case BLOCK_B: return tile_id >= BLOCK_B && tile_id < BLOCK_B_END;
	case BLOCK_C: return tile_id >= BLOCK_C && tile_id < BLOCK_C_END;
	case BLOCK_D: return tile_id >= BLOCK_D && tile_id < BLOCK_D_END;
	case BLOCK_E: return tile_id >= BLOCK_E && tile_id < BLOCK_E_END;
	case BLOCK_F: return tile_id >= BLOCK_F && tile_id < BLOCK_F_END;
	default: return false;
	}
}

void TilemapLayer::SetMapTileDataAt(int x, int y, int tile_id, bool disable_autotile) {
	if(!IsInMapBounds(x, y))
		return;

	substitutions = Game_Map::GetTilesLayer(layer);

	bool is_autotile = IsTileFromBlock(tile_id, BLOCK_A) || IsTileFromBlock(tile_id, BLOCK_B) || IsTileFromBlock(tile_id, BLOCK_D);

	if (disable_autotile || !is_autotile) {
		RecreateTileDataAt(x, y, tile_id);
	} else {
		// Recalculate the replaced tile itself + every neighboring tile
		static constexpr struct { int dx; int dy; } adjacent[8] = {
				{-1, -1}, { 0, -1}, { 1, -1},
				{-1,  0}, { 1,  0},
				{-1,  1}, { 0,  1}, { 1,  1}
		};

		// TODO: make it work for AB autotiles
		RecalculateAutotile(x, y, tile_id);

		for (const auto& adj : adjacent) {
			auto nx = x + adj.dx;
			auto ny = y + adj.dy;
			if (IsInMapBounds(nx, ny)) {
				RecalculateAutotile(nx, ny, GetDataCache(nx, ny).ID);
			}
		}
	}

	SetMapData(map_data);
}

static inline bool IsAutotileD(int tile_id) {
	return tile_id >= BLOCK_D && tile_id < BLOCK_E;
}

static inline bool IsSameAutotileAB(int current_tile_id, int neighbor_tile_id) {
	// Special case for water tiles - allow mixing of A and B blocks
	bool current_is_water = (IsTileFromBlock(current_tile_id, BLOCK_A) ||
		IsTileFromBlock(current_tile_id, BLOCK_B));
	bool neighbor_is_water = (IsTileFromBlock(neighbor_tile_id, BLOCK_A) ||
		IsTileFromBlock(neighbor_tile_id, BLOCK_B));

	if (current_is_water && neighbor_is_water) {
		return true;
	}

	// For non-water tiles, keep original behavior of requiring same block
	if (IsTileFromBlock(current_tile_id, BLOCK_A) && IsTileFromBlock(neighbor_tile_id, BLOCK_A)) {
		return true;
	}
	if (IsTileFromBlock(current_tile_id, BLOCK_B) && IsTileFromBlock(neighbor_tile_id, BLOCK_B)) {
		return true;
	}
	return false;
}

static inline bool IsSameAutotileD(int current_tile_id, int neighbor_tile_id) {
	return ChipIdToIndex(current_tile_id) == ChipIdToIndex(neighbor_tile_id);
}

static inline void ApplyCornerFixups(uint8_t& neighbors) {
	// Northwest corner
	if ((neighbors & NEIGHBOR_NW) && (neighbors & (NEIGHBOR_N | NEIGHBOR_W)) != (NEIGHBOR_N | NEIGHBOR_W)) {
		neighbors &= ~NEIGHBOR_NW;
	}

	// Northeast corner
	if ((neighbors & NEIGHBOR_NE) && (neighbors & (NEIGHBOR_N | NEIGHBOR_E)) != (NEIGHBOR_N | NEIGHBOR_E)) {
		neighbors &= ~NEIGHBOR_NE;
	}

	// Southwest corner
	if ((neighbors & NEIGHBOR_SW) && (neighbors & (NEIGHBOR_S | NEIGHBOR_W)) != (NEIGHBOR_S | NEIGHBOR_W)) {
		neighbors &= ~NEIGHBOR_SW;
	}

	// Southeast corner
	if ((neighbors & NEIGHBOR_SE) && (neighbors & (NEIGHBOR_S | NEIGHBOR_E)) != (NEIGHBOR_S | NEIGHBOR_E)) {
		neighbors &= ~NEIGHBOR_SE;
	}
}

void TilemapLayer::RecalculateAutotile(int x, int y, int tile_id) {
	static constexpr struct { int dx; int dy; uint8_t bit; } adjacent[8] = {
		{-1, -1, NEIGHBOR_NW}, { 0, -1, NEIGHBOR_N}, { 1, -1, NEIGHBOR_NE},
		{-1,  0, NEIGHBOR_W }, { 1,  0, NEIGHBOR_E},
		{-1,  1, NEIGHBOR_SW}, { 0,  1, NEIGHBOR_S}, { 1,  1, NEIGHBOR_SE}
	};

	auto calculateNeighbors = [&](auto isSameAutotileFn) {
		uint8_t neighbors = 0;
		for (const auto& adj : adjacent) {
			auto nx = x + adj.dx;
			auto ny = y + adj.dy;
			auto adj_tile_id = IsInMapBounds(nx, ny) ? GetDataCache(nx, ny).ID : tile_id;
			if (isSameAutotileFn(tile_id, adj_tile_id)) {
				neighbors |= adj.bit;
			}
		}
		ApplyCornerFixups(neighbors);
		return neighbors;
		};

	auto processBlock = [&](int /*blockType*/, int blockStride, int blockBase, auto isSameAutotileFn) {
		uint8_t neighbors = calculateNeighbors(isSameAutotileFn);
		int block = (tile_id - blockBase) / blockStride;
		int variant = AUTOTILE_D_VARIANTS_MAP.at(neighbors);
		int new_tile_id = blockBase + (block * blockStride) + variant;
		RecreateTileDataAt(x, y, new_tile_id);
		};

	if (IsTileFromBlock(tile_id, BLOCK_A)) {
		processBlock(BLOCK_A, BLOCK_A_STRIDE, BLOCK_A, IsSameAutotileAB);
	}
	if (IsTileFromBlock(tile_id, BLOCK_B)) {
		processBlock(BLOCK_B, BLOCK_B_STRIDE, BLOCK_B, IsSameAutotileAB);
	}
	if (IsTileFromBlock(tile_id, BLOCK_D)) {
		processBlock(BLOCK_D, BLOCK_D_STRIDE, BLOCK_D, IsSameAutotileD);
	}
}
void TilemapLayer::SetPassable(std::vector<unsigned char> npassable) {
	passable = std::move(npassable);

	// Recalculate z values of all tiles
	CreateTileCache(map_data);
}

void TilemapLayer::OnSubstitute() {
	substitutions = Game_Map::GetTilesLayer(layer);

	// Recalculate z values of all tiles
	CreateTileCache(map_data);
}

TilemapSubLayer::TilemapSubLayer(TilemapLayer* tilemap, Drawable::Z_t z) :
	Drawable(z),
	tilemap(tilemap),
	internal_z(static_cast<uint8_t>(z))
{
	DrawableMgr::Register(this);
}

void TilemapSubLayer::Draw(Bitmap& dst) {
	if (!tilemap->GetChipset()) {
		return;
	}

	tilemap->Draw(dst, internal_z, GetRenderOx(), GetRenderOy());
}

void TilemapLayer::SetTone(Tone tone) {
	if (tone == this->tone) {
		return;
	}

	this->tone = tone;

	if (autotiles_d_screen_effect) {
		autotiles_d_screen_effect->Clear();
	}
	if (autotiles_ab_screen_effect) {
		autotiles_ab_screen_effect->Clear();
	}
	if (chipset_effect) {
		chipset_effect->Clear();
	}
	chipset_tone_tiles.clear();
}


/*end of file .\tilemap_layer.cpp*/

/*start of file .\transition.cpp*/

/* ... license chunk ... */

// Headers
#include <algorithm>
#include <vector>
#include <array>
#include <cmath>

#include "player.h"
#include "transition.h"
#include "async_handler.h"
#include "bitmap.h"
#include "game_player.h"
#include "graphics.h"
#include "main_data.h"
#include "scene.h"
#include "scene_map.h"
#include "spriteset_map.h"
#include "baseui.h"
#include "drawable.h"
#include "drawable_mgr.h"
#include "output.h"
#include "rand.h"

int Transition::GetDefaultFrames(Transition::Type type)
{
	switch (type) {
		case TransitionFadeIn:
		case TransitionFadeOut:
			return 32;
		case TransitionCutIn:
		case TransitionCutOut:
		case TransitionNone:
			return 0;
		default:
			return 40;
	}
	return 0;
}

Transition::Transition() : Drawable(Priority_Transition, Drawable::Flags::Global)
{
	DrawableMgr::Register(this);
}

void Transition::PrependFlashes(int r, int g, int b, int p, int duration, int iterations) {
	flash.red = r;
	flash.green = g;
	flash.blue = b;
	flash.current_level = 0.0;
	flash.time_left = 0;

	flash_power = p;
	flash_duration = std::max(1, duration);
	flash_iterations = std::max(1, iterations);
}

void Transition::Init(Type type, Scene *linked_scene, int duration, bool next_erase) {
	// Triggering multiple transitions on a single frame is a bug.
	assert(!IsActive());

	if (duration < 0) {
		duration = GetDefaultFrames(type);
	}
	transition_type = type;
	scene = linked_scene;

	current_frame = 0;
	flash = {};
	flash_power = 0;
	flash_iterations = 0;
	flash_duration = 0;
	total_frames = 0;
	from_erase = to_erase;

	SetVisible(false);

	// Erase transitions are skipped entirely if screen already erased.
	if (type != TransitionNone && from_erase && next_erase) {
		transition_type = TransitionNone;
		return;
	}

	screen1.reset();
	screen2.reset();

	// Show Screen, the current frame is captured immediately
	if (!next_erase) {
		screen1 = DisplayUi->CaptureScreen();
	}

	// Total frames and erased have to be set *after* the above drawing code.
	// Otherwise IsActive() / IsErasedNotActive() will mess up drawing.
	total_frames = duration;

	// TransitionNone is neither a Show or Erase, it just waits and does nothing.
	// Screen state is not changed.
	if (type == TransitionNone) {
		return;
	}

	to_erase = next_erase;

	SetAttributesTransitions();
}

void Transition::SetAttributesTransitions() {
	int w, h, beg_i, mid_i, end_i, length;

	zoom_position = std::vector<int>(2);
	random_blocks = std::vector<uint32_t>(Player::screen_width * Player::screen_height / (size_random_blocks * size_random_blocks));
	mosaic_random_offset.resize(total_frames);

	for (uint32_t i = 0; i < random_blocks.size(); i++) {
		random_blocks[i] = i;
	}

	switch (transition_type) {
	case TransitionRandomBlocks:
		random_block_transition = Bitmap::Create(Player::screen_width, Player::screen_height, true);
		current_blocks_print = 0;
		std::shuffle(random_blocks.begin(), random_blocks.end(), Rand::GetRNG());
		break;
	case TransitionRandomBlocksDown:
	case TransitionRandomBlocksUp:
		random_block_transition = Bitmap::Create(Player::screen_width, Player::screen_height, true);
		current_blocks_print = 0;
		if (transition_type == TransitionRandomBlocksUp) { std::reverse(random_blocks.begin(), random_blocks.end()); }

		w = Player::screen_width / 4;
		h = Player::screen_height / 4;
		length = 10;
		for (int i = 0; i < h - 1; i++) {
			end_i = (i < length ? 2 * i + 1 : i <= h - length ? i + length : (i + h) / 2) * w;
			std::shuffle(random_blocks.begin() + i * w, random_blocks.begin() + end_i, Rand::GetRNG());

			beg_i = i * w + (i % 2 == 0 ? 0 : 2);
			mid_i = i * w + (i % 2 == 0 ? 1 : 3) + (i > h * 2 / 3 ? 3 : 0);
			if (transition_type == TransitionRandomBlocksDown) {
				std::partial_sort(random_blocks.begin() + beg_i, random_blocks.begin() + mid_i, random_blocks.begin() + end_i);
			}
			else { std::partial_sort(random_blocks.begin() + beg_i, random_blocks.begin() + mid_i, random_blocks.begin() + end_i, std::greater<uint32_t>()); }
		}
		break;
	case TransitionZoomIn:
	case TransitionZoomOut:
		if (scene != nullptr && scene->type == Scene::Map) {
			auto map = static_cast<Scene_Map*>(scene);

			zoom_position[0] = std::max(0, std::min(Main_Data::game_player->GetScreenX() + map->spriteset->GetRenderOx(), (int)Player::screen_width));
			zoom_position[1] = std::max(0, std::min(Main_Data::game_player->GetScreenY() - 8 + map->spriteset->GetRenderOy(), (int)Player::screen_height));
		}
		else {
			zoom_position[0] = Player::screen_width / 2;
			zoom_position[1] = Player::screen_height / 2;
		}
		break;
	case TransitionMosaicIn:
	case TransitionMosaicOut:
		for (int i = 0; i < total_frames; ++i) {
			const int initial_scale = 2;
			const int excl_interval = -1;
			// by default i 0..39 for scale 2..41
			mosaic_random_offset[i] = Rand::GetRandomNumber(0, i + initial_scale - excl_interval);
		}
		break;
	default:
		// do nothing, keep the compiler happy
		break;
	}
}

void Transition::Draw(Bitmap& dst) {
	if (!IsActive())
		return;

	std::vector<int> z_pos(2), z_size(2), z_length(2);
	int z_min, z_max, z_percent, z_fixed_pos, z_fixed_size;
	uint8_t m_r, m_g, m_b, m_a;
	uint32_t *m_pointer, blocks_to_print;
	int m_size;

	BitmapRef screen_pointer1, screen_pointer2;
	int w = dst.GetWidth();
	int h = dst.GetHeight();

	if (flash_iterations > 0) {
		auto color = Flash::MakeColor(flash.red, flash.green, flash.blue, flash.current_level);
		dst.BlendBlit(0, 0, *screen1, screen1->GetRect(), color, 255);
		return;
	}

	int percentage = (current_frame) * 100 / (total_frames);

	switch (transition_type) {
	case TransitionFadeIn:
	case TransitionFadeOut:
		dst.Blit(0, 0, *screen1, screen1->GetRect(), 255);
		dst.Blit(0, 0, *screen2, screen2->GetRect(), 255 * percentage / 100);
		break;
	case TransitionRandomBlocks:
	case TransitionRandomBlocksDown:
	case TransitionRandomBlocksUp:
		blocks_to_print = random_blocks.size() * percentage / 100;

		for (uint32_t i = current_blocks_print; i < blocks_to_print; i++) {
			random_block_transition->Blit(random_blocks[i] % (w / size_random_blocks) * size_random_blocks,
				random_blocks[i] / (w / size_random_blocks) * size_random_blocks, *screen2,
				Rect(random_blocks[i] % (w / size_random_blocks) * size_random_blocks, random_blocks[i] / (w / size_random_blocks) * size_random_blocks,
					size_random_blocks, size_random_blocks), Opacity::Opaque());
		}
		dst.Blit(0, 0, *screen1, screen1->GetRect(), Opacity::Opaque());
		dst.Blit(0, 0, *random_block_transition, random_block_transition->GetRect(), Opacity::Opaque());
		current_blocks_print = blocks_to_print;
		break;
	case TransitionBlindOpen:
		for (int i = 0; i < h / 8; i++) {
			dst.Blit(0, i * 8, *screen1, Rect(0, i * 8, w, 8 - 8 * percentage / 100), 255);
			dst.Blit(0, i * 8 + 8 - 8 * percentage / 100, *screen2, Rect(0, i * 8 + 8 - 8 * percentage / 100, w, 8 * percentage / 100), 255);
		}
		break;
	case TransitionBlindClose:
		for (int i = 0; i < h / 8; i++) {
			dst.Blit(0, i * 8 + 8 * percentage / 100, *screen1, Rect(0, i * 8 + 8 * percentage / 100, w, 8 - 8 * percentage / 100), 255);
			dst.Blit(0, i * 8, *screen2, Rect(0, i * 8, w, 8 * percentage / 100), 255);
		}
		break;
	case TransitionVerticalStripesIn:
	case TransitionVerticalStripesOut:
		for (int i = 0; i < h / 6 + 1 - h / 6 * percentage / 100; i++) {
			dst.Blit(0, i * 6 + 3, *screen1, Rect(0, i * 6 + 3, w, 3), 255);
			dst.Blit(0, h - i * 6, *screen1, Rect(0, h - i * 6, w, 3), 255);
		}
		for (int i = 0; i < h / 6 * percentage / 100; i++) {
			dst.Blit(0, i * 6, *screen2, Rect(0, i * 6, w, 3), 255);
			dst.Blit(0, h - 3 - i * 6, *screen2, Rect(0, h - 3 - i * 6, w, 3), 255);
		}
		break;
	case TransitionHorizontalStripesIn:
	case TransitionHorizontalStripesOut:
		for (int i = 0; i < w / 8 + 1 - w / 8 * percentage / 100; i++) {
			dst.Blit(i * 8 + 4, 0, *screen1, Rect(i * 8 + 4, 0, 4, h), 255);
			dst.Blit(w - i * 8, 0, *screen1, Rect(w - i * 8, 0, 4, h), 255);
		}
		for (int i = 0; i < w / 8 * percentage / 100; i++) {
			dst.Blit(i * 8, 0, *screen2, Rect(i * 8, 0, 4, h), 255);
			dst.Blit(w - 4 - i * 8, 0, *screen2, Rect(w - 4 - i * 8, 0, 4, h), 255);
		}
		break;
	case TransitionBorderToCenterIn:
	case TransitionBorderToCenterOut:
		dst.Blit(0, 0, *screen2, screen2->GetRect(), 255);
		dst.Blit((w / 2) * percentage / 100, (h / 2) * percentage / 100, *screen1, Rect((w / 2) * percentage / 100, (h / 2) * percentage / 100, w - w * percentage / 100, h - h * percentage / 100), 255);
		break;
	case TransitionCenterToBorderIn:
	case TransitionCenterToBorderOut:
		dst.Blit(0, 0, *screen1, screen1->GetRect(), 255);
		dst.Blit(w / 2 - (w / 2) * percentage / 100, h / 2 - (h / 2) * percentage / 100, *screen2, Rect(w / 2 - (w / 2) * percentage / 100, h / 2 - (h / 2) * percentage / 100, w * percentage / 100, h * percentage / 100), 255);
		break;
	case TransitionScrollUpIn:
	case TransitionScrollUpOut:
		dst.Blit(0, -h * percentage / 100, *screen1, screen1->GetRect(), 255);
		dst.Blit(0, h - h * percentage / 100, *screen2, screen2->GetRect(), 255);
		break;
	case TransitionScrollDownIn:
	case TransitionScrollDownOut:
		dst.Blit(0, h * percentage / 100, *screen1, screen1->GetRect(), 255);
		dst.Blit(0, -h + h * percentage / 100, *screen2, screen2->GetRect(), 255);
		break;
	case TransitionScrollLeftIn:
	case TransitionScrollLeftOut:
		dst.Blit(-w * percentage / 100, 0, *screen1, screen1->GetRect(), 255);
		dst.Blit(w - w * percentage / 100, 0, *screen2, screen2->GetRect(), 255);
		break;
	case TransitionScrollRightIn:
	case TransitionScrollRightOut:
		dst.Blit(w * percentage / 100, 0, *screen1, screen1->GetRect(), 255);
		dst.Blit(-w + w * percentage / 100, 0, *screen2, screen2->GetRect(), 255);
		break;
	case TransitionVerticalCombine:
	case TransitionVerticalDivision:
		// If TransitionVerticalCombine, invert percentage and screen:
		if (transition_type == TransitionVerticalCombine) { percentage = 100 - percentage; }
		screen_pointer1 = transition_type == TransitionVerticalCombine ? screen2 : screen1;
		screen_pointer2 = transition_type == TransitionVerticalCombine ? screen1 : screen2;

		dst.Blit(0, -(h / 2) * percentage / 100, *screen_pointer1, Rect(0, 0, w, h / 2), 255);
		dst.Blit(0, h / 2 + (h / 2) * percentage / 100, *screen_pointer1, Rect(0, h / 2, w, h / 2), 255);
		dst.Blit(0, h / 2 - (h / 2) * percentage / 100, *screen_pointer2, Rect(0, h / 2 - (h / 2) * percentage / 100, w, h * percentage / 100), 255);
		break;
	case TransitionHorizontalCombine:
	case TransitionHorizontalDivision:
		// If TransitionHorizontalCombine, invert percentage and screen:
		if (transition_type == TransitionHorizontalCombine) { percentage = 100 - percentage; }
		screen_pointer1 = transition_type == TransitionHorizontalCombine ? screen2 : screen1;
		screen_pointer2 = transition_type == TransitionHorizontalCombine ? screen1 : screen2;

		dst.Blit(-(w / 2) * percentage / 100, 0, *screen_pointer1, Rect(0, 0, w / 2, h), 255);
		dst.Blit(w / 2 + (w / 2) * percentage / 100, 0, *screen_pointer1, Rect(w / 2, 0, w / 2, h), 255);
		dst.Blit(w / 2 - (w / 2) * percentage / 100, 0, *screen_pointer2, Rect(w / 2 - (w / 2) * percentage / 100, 0, w * percentage / 100, h), 255);
		break;
	case TransitionCrossCombine:
	case TransitionCrossDivision:
		// If TransitionCrossCombine, invert percentage and screen:
		if (transition_type == TransitionCrossCombine) { percentage = 100 - percentage; }
		screen_pointer1 = transition_type == TransitionCrossCombine ? screen2 : screen1;
		screen_pointer2 = transition_type == TransitionCrossCombine ? screen1 : screen2;

		dst.Blit(-(w / 2) * percentage / 100, -(h / 2) * percentage / 100, *screen_pointer1, Rect(0, 0, w / 2, h / 2), 255);
		dst.Blit(w / 2 + (w / 2) * percentage / 100, -(h / 2) * percentage / 100, *screen_pointer1, Rect(w / 2, 0, w / 2, h / 2), 255);
		dst.Blit(w / 2 + (w / 2) * percentage / 100, h / 2 + (h / 2) * percentage / 100, *screen_pointer1, Rect(w / 2, h / 2, w / 2, h / 2), 255);
		dst.Blit(-(w / 2) * percentage / 100, h / 2 + (h / 2) * percentage / 100, *screen_pointer1, Rect(0, h / 2, w / 2, h / 2), 255);
		dst.Blit(w / 2 - (w / 2) * percentage / 100, 0, *screen_pointer2, Rect(w / 2 - (w / 2) * percentage / 100, 0, w * percentage / 100, h / 2 - (h / 2) * percentage / 100), 255);
		dst.Blit(w / 2 - (w / 2) * percentage / 100, h / 2 + (h / 2) * percentage / 100, *screen_pointer2, Rect(w / 2 - (w / 2) * percentage / 100, h / 2 + (h / 2) * percentage / 100, w * percentage / 100, h / 2 + (h / 2) * percentage / 100), 255);
		dst.Blit(0, h / 2 - (h / 2) * percentage / 100, *screen_pointer2, Rect(0, h / 2 - (h / 2) * percentage / 100, w, h * percentage / 100), 255);
		break;
	case TransitionZoomIn:
	case TransitionZoomOut:
		// If TransitionZoomOut, invert percentage and screen:
		if (transition_type == TransitionZoomOut) { percentage = 100 - percentage; }
		screen_pointer1 = transition_type == TransitionZoomOut ? screen2 : screen1;

		// X Coordinate: [0]   Y Coordinate: [1]
		z_length[0] = w;
		z_length[1] = h;
		percentage = percentage <= 97 ? percentage : 97;

		for (int i = 0; i < 2; i++) {
			z_min = z_length[i] / 4;
			z_max = z_length[i] * 3 / 4;
			z_pos[i] = std::max(z_min, std::min((int)zoom_position[i], z_max)) * percentage / 100;
			z_size[i] = z_length[i] * (100 - percentage) / 100;

			z_percent = (zoom_position[i] < z_min) ? (100 * zoom_position[i] / z_min - 100) :
				(zoom_position[i] > z_max) ? (100 * (zoom_position[i] - z_max) / (z_length[i] - z_max)) : 0;

			if (z_percent != 0 && percentage > 0) {
				z_fixed_pos = z_pos[i] * std::abs(z_percent) / percentage;
				z_fixed_size = z_length[i] * (100 - std::abs(z_percent)) / 100;
				z_pos[i] += percentage < std::abs(z_percent) ? (z_percent > 0 ? 1 : 0) * (z_length[i] - z_size[i]) - z_pos[i] :
					(z_percent > 0 ? z_length[i] - z_fixed_pos - z_fixed_size : -z_fixed_pos);
			}
		}

		dst.StretchBlit(Rect(0, 0, w, h), *screen_pointer1, Rect(z_pos[0], z_pos[1], z_size[0], z_size[1]), 255);
		break;
	case TransitionMosaicIn:
	case TransitionMosaicOut: {
		// Goes from scale 2 to 41 (current_frame is 0 - 39)
		// FIXME: current_frame starts at 1 (off-by-one error?)
		// If TransitionMosaicIn, invert scale and screen:
		int32_t rand;
		if (transition_type == TransitionMosaicIn) {
			m_size = total_frames + 1 - current_frame;
			screen_pointer1 = screen2;
			rand = mosaic_random_offset[total_frames - current_frame - 1];
		} else {
			// remove when off-by-one error is fixed
			const int off_one_fix = -1;
			m_size = current_frame + 2 + off_one_fix;
			screen_pointer1 = screen1;
			rand = mosaic_random_offset[current_frame + off_one_fix];
		}

		// The offset defines where at (X,Y) the pixel is picked for scaling (nearest neighbour)
		// The pixel is usually initially out of bounds
		// in this case the nearest pixel of the image is choosen (edge handling = extend)
		int off = (m_size / 2);

		for (int row = 0; row < h + rand; ++row) {
			int src_row = std::clamp(((row + off) / m_size) * m_size - off, 0, h - 1);

			for (int col = 0; col < w + rand; ++col) {
				int src_col = std::clamp(((col + off) / m_size) * m_size - off, 0, w - 1);
				m_pointer = static_cast<uint32_t*>(screen_pointer1->pixels()) + src_row * w + src_col;
				dst.pixel_format.uint32_to_rgba(*m_pointer, m_r, m_g, m_b, m_a);

				Rect r(col - rand, row - rand, 1, 1);
				dst.FillRect(r, Color(m_r, m_g, m_b, 255));
			}
		}
		break;
	}
	case TransitionWaveIn:
	case TransitionWaveOut:
		{
			// If TransitionWaveIn, invert percentage and screen:
			auto p = (transition_type == TransitionWaveIn) ? 100 - percentage : percentage;
			auto& screen = (transition_type == TransitionWaveIn) ? *screen2 : *screen1;
			auto depth = p * 40 / 100;
			auto phase = p * 5 * M_PI / 100.0 + M_PI;
			dst.WaverBlit(0, 0, 1, 1, screen, screen.GetRect(), depth, phase, Opacity::Opaque());
		}
		break;
	case TransitionCutIn:
		dst.Blit(0, 0, *screen2, screen2->GetRect(), Opacity::Opaque());
		break;
	case TransitionCutOut:
		dst.Blit(0, 0, *screen1, screen1->GetRect(), Opacity::Opaque());
		break;
	case TransitionNone:
		break;
	}
}

void Transition::Update() {
	if (!IsActive()) {
		return;
	}

	// FIXME: Break this dependency on DisplayUI
	if (transition_type != TransitionNone && !screen2) {
		// Wait for all graphics to load before drawing screens.
		if (FromErase() && AsyncHandler::IsGraphicFilePending()) {
			return;
		}

		if (scene) {
			scene->UpdateGraphics();
		}

		if (!screen1) {
			// erase -> erase is ingored
			// any -> erase - screen1 was drawn in init.
			assert(ToErase() && !FromErase());
			screen1 =  Bitmap::Create(Player::screen_width, Player::screen_height, false);
			Graphics::LocalDraw(*screen1, std::numeric_limits<Drawable::Z_t>::min(), GetZ() - 1);
		}
		if (ToErase()) {
			screen2 = Bitmap::Create(Player::screen_width, Player::screen_height, Color(0, 0, 0, 255));
		} else {
			screen2 =  Bitmap::Create(Player::screen_width, Player::screen_height, false);
			Graphics::LocalDraw(*screen2, std::numeric_limits<Drawable::Z_t>::min(), GetZ() - 1);
		}
	}

	SetVisible(true);

	if (flash_iterations > 0) {
		if (flash.time_left > 0) {
			Flash::Update(flash.current_level, flash.time_left);
			if (flash.time_left > 0) {
				return;
			}
			--flash_iterations;
		}
		if (flash_iterations > 0) {
			flash.current_level = flash_power;
			flash.time_left = flash_duration;
			return;
		}
	}
	//Update current_frame:
	current_frame++;
}



/*end of file .\transition.cpp*/

/*start of file .\translation.cpp*/

/* ... license chunk ... */

#include "translation.h"

// Headers
#include <fstream>
#include <iomanip>
#include <memory>
#include <lcf/data.h>
#include <lcf/rpg/terms.h>
#include <lcf/rpg/map.h>
#include "lcf/rpg/mapinfo.h"

#include "baseui.h"
#include "cache.h"
#include "font.h"
#include "main_data.h"
#include "game_actors.h"
#include "game_map.h"
#include "player.h"
#include "output.h"
#include "utils.h"
#include "scene.h"

// Name of the translate directory
#define TRDIR_NAME "language"

// Name of expected files
#define TRFILE_RPG_RT_LDB    "rpg_rt.ldb.po"
#define TRFILE_RPG_RT_COMMON "rpg_rt.ldb.common.po"
#define TRFILE_RPG_RT_BATTLE "rpg_rt.ldb.battle.po"
#define TRFILE_RPG_RT_LMT    "rpg_rt.lmt.po"
#define TRFILE_META_INI      "meta.ini"

// Message box commands to remove a message box or add one in place.
// These commands are added by translators in the .po files to manipulate
//   text boxes at runtime. They are magic strings that will not otherwise
//   appear in the source of EasyRPG, but they should not be deleted.
#define TRCUST_REMOVEMSG        "<easyrpg:delete_page>"
#define TRCUST_ADDMSG           "<easyrpg:new_page>"


FilesystemView Tr::GetTranslationFilesystem() {
	return Player::translation.GetRootTree();
}

bool Tr::HasActiveTranslation() {
	return !GetCurrentTranslationId().empty();
}

std::string Tr::GetCurrentTranslationId() {
	return Player::translation.GetCurrentLanguage().lang_dir;
}

std::string Tr::GetCurrentLanguageCode() {
	return Player::translation.GetCurrentLanguage().lang_code;
}

FilesystemView Tr::GetCurrentTranslationFilesystem() {
	return Player::translation.GetRootTree().Subtree(GetCurrentTranslationId());
}

void Translation::Reset()
{
	ClearTranslationLookups();

	translation_root_fs = FilesystemView();
	languages.clear();
	current_language = {};
	default_language = {};
}

void Translation::InitTranslations()
{
	// Reset
	Reset();

	// Determine if the "languages" directory exists, and convert its case.
	auto fs = FileFinder::Game();
	auto game_tree = fs.ListDirectory();
	for (const auto& tr_name : *game_tree) {
		if (tr_name.first == TRDIR_NAME) {
			translation_root_fs = fs.Subtree(tr_name.second.name);
			break;
		}
	}
	if (translation_root_fs) {
		// Now list all directories within the translate dir
		auto translation_tree = translation_root_fs.ListDirectory();

		// Now iterate over every subdirectory.
		for (const auto& tr_name : *translation_tree) {
			Language item;
			item.lang_dir = tr_name.second.name;
			item.lang_name = tr_name.second.name;

			// If there's a manifest file, read the language name and help text from that
			auto meta_file = translation_root_fs.OpenFile(item.lang_dir, TRFILE_META_INI);
			if (meta_file) {
				lcf::INIReader ini(meta_file);
				item.lang_name = ini.GetString("Language", "Name", item.lang_name);
				item.lang_desc = ini.GetString("Language", "Description", "");
				item.lang_code = ini.GetString("Language", "Code", "");
				item.lang_term = ini.GetString("Language", "Term", "Language");
				item.game_title = ini.GetString("Language", "GameTitle", "");
				item.use_builtin_font = Utils::LowerCase(ini.GetString("Language", "Font", "")) == "builtin";

				if (item.lang_dir == "default") {
					// Metadata for the normal game language
					default_language = item;
					continue;
				}
			}

			languages.push_back(item);
		}
	}
}

const Language& Translation::GetCurrentLanguage() const
{
	return current_language;
}

const Language& Translation::GetDefaultLanguage() const
{
	return default_language;
}

FilesystemView Translation::GetRootTree() const
{
	return translation_root_fs;
}

bool Translation::HasTranslations() const
{
	return !languages.empty();
}

const std::vector<Language>& Translation::GetLanguages() const
{
	return languages;
}


void Translation::SelectLanguage(std::string_view lang_id)
{
	// Try to read in our language files.
	Output::Debug("Changing language to: '{}'", (!lang_id.empty() ? lang_id : "<Default>"));

	AsyncHandler::ClearRequests();

	if (!lang_id.empty()) {
		auto root = GetRootTree();
		if (!root) {
			Output::Warning("Cannot load translation. 'Language' folder does not exist");
			return;
		}

		FilesystemView language_tree = root.Subtree(lang_id);
		if (language_tree) {
			auto files = Utils::MakeSvArray(TRFILE_RPG_RT_LDB, TRFILE_RPG_RT_BATTLE, TRFILE_RPG_RT_COMMON, TRFILE_RPG_RT_LMT, "Font/Font", "Font/Font2");
			request_counter = static_cast<int>(files.size());
			for (auto s: files) {
				FileRequestAsync* request = AsyncHandler::RequestFile(language_tree.GetFullPath(), s);
				request->SetImportantFile(true);
				requests.emplace_back(request->Bind(&Translation::SelectLanguageAsync, this, lang_id));
				request->Start();
			}
		} else {
			Output::Warning("Translation for '{}' does not appear to exist", lang_id);
		}
	} else {
		// Default language, no request needed
		request_counter = 1;
		SelectLanguageAsync(nullptr, lang_id);
	}
}

void Translation::SelectLanguageAsync(FileRequestResult*, std::string_view lang_id) {
	--request_counter;
	if (request_counter == 0) {
		requests.clear();
	} else {
		// Waiting for remaining callbacks
		return;
	}

	if (!ParseLanguageFiles(lang_id)) {
		return;
	}

	// We reload the entire database as a precaution.
	Player::LoadDatabase();

	// Translation could provide custom fonts
	if (current_language.use_builtin_font) {
		Font::ResetDefault();
	} else {
		Player::LoadFonts();
	}

	// Rewrite our database+messages (unless we are on the Default language).
	// Note that map Message boxes are changed on map load, to avoid slowdown here.
	if (!current_language.lang_dir.empty()) {
		RewriteDatabase();
		RewriteTreemapNames();
		RewriteBattleEventMessages();
		RewriteCommonEventMessages();
	}

	if (!current_language.game_title.empty()) {
		Player::UpdateTitle(current_language.game_title);
	} else if (!Player::game_title_original.empty()) {
		Player::UpdateTitle(Player::game_title_original);
	}

	// Reset the cache, so that all images load fresh.
	Cache::Clear();

	Scene::instance->OnTranslationChanged();
}

void Translation::RequestAndAddMap(int map_id) {
	if (current_language.lang_dir.empty()) {
		return;
	}

	std::stringstream ss;
	ss << "Map" << std::setfill('0') << std::setw(4) << map_id << ".po";
	std::string map_name = ss.str();

	if (maps.find(Utils::LowerCase(map_name)) != maps.end()) {
		// Already loaded
		return;
	}

	FileRequestAsync* request = AsyncHandler::RequestFile(Tr::GetCurrentTranslationFilesystem().GetFullPath(), map_name);
	request->SetImportantFile(true);
	map_request = request->Bind([this, map_name](FileRequestResult*) {
		std::unique_ptr<Dictionary> dict = std::make_unique<Dictionary>();
		auto is = Tr::GetCurrentTranslationFilesystem().OpenInputStream(map_name);
		if (is) {
			ParsePoFile(std::move(is), *dict);
			maps[Utils::LowerCase(map_name)] = std::move(dict);
			Output::Debug("Loaded {} map .po file ({} map files loaded)", map_name, maps.size());
		}
	});
	request->Start();
}

bool Translation::ParseLanguageFiles(std::string_view lang_id)
{
	FilesystemView language_tree;

	// Create the directory tree (for lookups).
	if (!lang_id.empty()) {
		language_tree = GetRootTree().Subtree(lang_id);
		if (!language_tree) {
			Output::Warning("Translation for '{}' does not appear to exist", lang_id);
			return false;
		}
	}

	// Clear the old translation
	ClearTranslationLookups();

	// For default, this is all we need.
	if (!language_tree) {
		current_language = {};
		return true;
	}

	// Scan for files in the directory and parse them.
	for (const auto& tr_name : *language_tree.ListDirectory()) {
		if (tr_name.second.type != DirectoryTree::FileType::Regular) {
			continue;
		}

		if (tr_name.first == TRFILE_RPG_RT_LDB) {
			sys = std::make_unique<Dictionary>();
			auto is = language_tree.OpenInputStream(tr_name.second.name);
			if (is) {
				ParsePoFile(std::move(is), *sys);
			}
		} else if (tr_name.first == TRFILE_RPG_RT_BATTLE) {
			battle = std::make_unique<Dictionary>();
			auto is = language_tree.OpenInputStream(tr_name.second.name);
			if (is) {
				ParsePoFile(std::move(is), *battle);
			}
		} else if (tr_name.first == TRFILE_RPG_RT_COMMON) {
			common = std::make_unique<Dictionary>();
			auto is = language_tree.OpenInputStream(tr_name.second.name);
			if (is) {
				ParsePoFile(std::move(is), *common);
			}
		} else if (tr_name.first == TRFILE_RPG_RT_LMT) {
			mapnames = std::make_unique<Dictionary>();
			auto is = language_tree.OpenInputStream(tr_name.second.name);
			if (is) {
				ParsePoFile(std::move(is), *mapnames);
			}
		} else if (EndsWith(tr_name.first, ".po")) {
			// This will fail in the web player but is intentional
			// The fetching happens on map load instead
			// Still parsing all files locally to get syntax errors early
			auto is = language_tree.OpenInputStream(tr_name.second.name);
			if (is) {
				std::unique_ptr<Dictionary> dict = std::make_unique<Dictionary>();
				ParsePoFile(std::move(is), *dict);
				maps[tr_name.first] = std::move(dict);
			}
		}
	}

	auto it = std::find_if(languages.begin(), languages.end(), [&lang_id](const auto& lang) {
		return lang_id == lang.lang_dir;
	});
	assert(it != languages.end());
	current_language = *it;

	// Log
	Output::Debug("Translation loaded {} sys, {} common, {} battle, and {} map .po files", (sys==nullptr?0:1), (battle==nullptr?0:1), (common==nullptr?0:1), maps.size());

	return true;
}


void Translation::RewriteDatabase()
{
	if (!sys) {
		return;
	}

	lcf::rpg::ForEachString(lcf::Data::data, [this](lcf::DBString& value, auto& ctxt) {
		// When we re-write the database, we only care about translations that are exactly one level deep.
		if (ctxt.parent==nullptr || ctxt.parent->parent!=nullptr) {
			return;
		}

		// Look up the indexed form first; e.g., "actors.1.name", starting from 1 instead of 0
		if (ctxt.index >= 0) {
			if (sys->TranslateString<lcf::DBString>(fmt::format("{}.{}.{}", ctxt.parent->name, ctxt.parent->index+1, ctxt.name), value)) {
				return;
			}
		}

		// Look up the non-indexed form second; e.g., "actors.name"
		if (sys->TranslateString<lcf::DBString>(fmt::format("{}.{}", ctxt.parent->name, ctxt.name), value)) {
			return;
		}

		// Finally, look up a context-free form (just by value).
		if (sys->TranslateString<lcf::DBString>("", value)) {
			return;
		}
	});
}

void Translation::RewriteTreemapNames()
{
	if (mapnames) {
		for (lcf::rpg::MapInfo& map : lcf::Data::treemap.maps) {
			mapnames->TranslateString<lcf::DBString>("", map.name);
		}
	}
}

void Translation::RewriteBattleEventMessages()
{
	// Rewrite all event commands on all pages.
	if (battle) {
		for (lcf::rpg::Troop& troop : lcf::Data::troops) {
			for (lcf::rpg::TroopPage& page : troop.pages) {
				RewriteEventCommandMessage(*battle, page.event_commands);
			}
		}
	}
}


void Translation::RewriteCommonEventMessages()
{
	// Rewrite all event commands on all pages.
	if (common) {
		for (lcf::rpg::CommonEvent& ev : lcf::Data::commonevents) {
			RewriteEventCommandMessage(*common, ev.event_commands);
		}
	}
}


namespace {
	/**
	 * Helper class for iterating over and rewriting event commands.
	 * Starts at index 0.
	 */
	class CommandIterator {
	public:
		CommandIterator(std::vector<lcf::rpg::EventCommand>& commands) : commands(commands) {}

		/** Returns true if the index is past the end of the command list */
		bool Done() const {
			return index >= commands.size();
		}

		/** Advance the index through the command list by 1 */
		void Advance() {
			index += 1;
		}

		/** Retrieve the code of the EventCommand at the index */
		lcf::rpg::EventCommand::Code CurrentCmdCode() const {
			return static_cast<lcf::rpg::EventCommand::Code>(commands[index].code);
		}

		/** Retrieve the string of the EventCommand at the index */
		lcf::DBString& CurrentCmdString() const {
			return commands[index].string;
		}

		/** Retrieve the indent level of the EventCommand at the index */
		int CurrentCmdIndent() const {
			return commands[index].indent;
		}

		/** Retrieve parameter at position 'pos' of the EventCommand at the current index, or the devValue if no such parameter exists. */
		int CurrentCmdParam(size_t pos, int defVal = 0) const {
			if (pos < commands[index].parameters.size()) {
				return commands[index].parameters[pos];
			}
			return defVal;
		}

		/** Returns true if the current Event Command is ShowMessage */
		bool CurrentIsShowMessage() const {
			return CurrentCmdCode() == lcf::rpg::EventCommand::Code::ShowMessage;
		}

		/** Returns true if the current Event Command is ShowMessage_2 */
		bool CurrentIsShowMessage2() const {
			return CurrentCmdCode() == lcf::rpg::EventCommand::Code::ShowMessage_2;
		}

		/** Returns true if the current Event Command is ShowChoice */
		bool CurrentIsShowChoice() const {
			return CurrentCmdCode() == lcf::rpg::EventCommand::Code::ShowChoice;
		}

		/** Returns true if the current Event Command is ShowChoiceOption */
		bool CurrentIsShowChoiceOption() const {
			return CurrentCmdCode() == lcf::rpg::EventCommand::Code::ShowChoiceOption;
		}

		/** Returns true if the current Event Command is ShowChoiceEnd */
		bool CurrentIsShowChoiceEnd() const {
			return CurrentCmdCode() == lcf::rpg::EventCommand::Code::ShowChoiceEnd;
		}

		/** Returns true if the current Event Command is ChangeHeroName */
		bool CurrentIsChangeHeroName() const {
			return CurrentCmdCode() == lcf::rpg::EventCommand::Code::ChangeHeroName;
		}

		/** Returns true if the current Event Command is ChangeHeroTitle */
		bool CurrentIsChangeHeroTitle() const {
			return CurrentCmdCode() == lcf::rpg::EventCommand::Code::ChangeHeroTitle;
		}

		/** Returns true if the current Event Command is ChangeHeroTitle */
		bool CurrentIsConditionActorName() const {
			return CurrentCmdCode() == lcf::rpg::EventCommand::Code::ConditionalBranch &&
				CurrentCmdParam(0) == 5 && CurrentCmdParam(2) == 1;
		}

		/** Returns true if the current Event Command is ShowStringPicture */
		bool CurrentIsShowStringPicture() const {
			return CurrentCmdCode() == lcf::rpg::EventCommand::Code::Maniac_ShowStringPicture;
		}

		/**
		 * Add each line of a [ShowMessage,ShowMessage_2,...] chain to "msg_str" (followed by a newline)
		 * and save to "indexes" the index of each ShowMessage(2) command that was used to populate this
		 * (for rewriting later).
		 * Advances the index until after the last ShowMessage(2) command
		 */
		void BuildMessageString(std::stringstream& msg_str, std::vector<size_t>& indexes) {
			// No change if we're not on the right command.
			if (Done() || !CurrentIsShowMessage()) {
				return;
			}

			// Add the first line
			msg_str << CurrentCmdString() <<"\n";
			indexes.push_back(index);
			Advance();

			// Build lines 2 through 4
			while (!Done() && CurrentIsShowMessage2()) {
				msg_str << CurrentCmdString() <<"\n";
				indexes.push_back(index);
				Advance();
			}
		}

		/**
		 * Add each line of a [ShowChoice,ShowChoiceOption,...,ShowChoiceEnd] chain to "msg_str" (followed by a newline)
		 * and save to "indexes" the index of each ShowChoiceOption command that was used to populate this
		 * (for rewriting later).
		 * Advances the index until after the (first) ShowChoice command (but it will likely still be on a ShowChoiceOption/End)
		 */
		void BuildChoiceString(std::stringstream& msg_str, std::vector<size_t>& indexes) {
			// No change if we're not on the right command.
			if (Done() || !CurrentIsShowChoice()) {
				return;
			}

			// Advance to ChoiceOptions
			Advance();
			if(Done()) {
				return;
			}

			// Choices must be on the same indent level.
			// We have to save/restore the index, though, in the rare case that we skip something that can be translated.
			int indent = CurrentCmdIndent();
			size_t savedIndex = index;
			while (!Done()) {
				if (indent == CurrentCmdIndent()) {
					// Handle a new index
					if (CurrentIsShowChoiceOption() && CurrentCmdParam(0,0) < 4) {
						msg_str << CurrentCmdString() <<"\n";
						indexes.push_back(index);
					}

					// Done?
					if (CurrentIsShowChoiceEnd()) {
						break;
					}
				}
				Advance();
			}
			index = savedIndex;
		}

		/** Change the string value of the EventCommand at position "idx" to "newStr" */
		void ReWriteString(size_t idx, std::string_view newStr) {
			if (idx < commands.size()) {
				commands[idx].string = lcf::DBString(newStr);
			}
		}

		/**
		 * Puts a "ShowMessage" or "ShowMessage_2" command into the command stack before position "idx".
		 * Sets the string value to "line". Note that ShowMessage_2 is chosen if baseMsgBox is false.
		 * This also updates the index if relevant, but it does not update external index caches.
		 */
		void PutShowMessageBeforeIndex(std::string_view line, size_t idx, bool baseMsgBox) {
			// We need a reference index for the indent.
			size_t refIndent = 0;
			if (idx < commands.size()) {
				refIndent = commands[idx].indent;
			} else if (idx == commands.size() && commands.size()>0) {
				refIndent = commands[idx-1].indent;
			}

			if (idx <= commands.size()) {
				lcf::rpg::EventCommand newCmd;
				newCmd.code = static_cast<int>(baseMsgBox ? lcf::rpg::EventCommand::Code::ShowMessage : lcf::rpg::EventCommand::Code::ShowMessage_2);
				newCmd.indent = refIndent;
				newCmd.string = lcf::DBString(line);
				commands.insert(commands.begin()+idx, newCmd);

				// Update our index
				if (index >= idx) {
					index += 1;
				}
			}
		}

		/**
		 * Remove the EventCommand at position "idx" from the command stack.
		 * Also updates our index, if relevant.
		 */
		void RemoveByIndex(size_t idx) {
			if (idx < commands.size()) {
				commands.erase(commands.begin() + idx);

				// Update our index
				if (index > idx) {
					index -= 1;
				}
			}
		}

		/**
		 * Add multiple message boxes to the command stack before "idx".
		 * The "msgs" each represent lines in new, independent message boxes (so they will have both ShowMessage and ShowMessage_2)
		 * Also updates our index, if relevant.
		 */
		void InsertMultiMessageBefore(std::vector<std::vector<std::string>>& msgs, size_t idx) {
			for (std::vector<std::string>& lines : msgs) {
				while (!lines.empty()) {
					PutShowMessageBeforeIndex(lines.back(), idx, lines.size()==1);
					lines.pop_back();
				}
			}
		}

	private:
		std::vector<lcf::rpg::EventCommand>& commands;
		size_t index = 0;
	};
}



std::vector<std::vector<std::string>> Translation::TranslateMessageStream(const Dictionary& dict, const std::stringstream& msg, char trimChar) {
	// Prepare source string
	std::string msgStr = msg.str();
	if (msgStr.size()>0 && msgStr.back() == trimChar) {
		msgStr.pop_back();
	}

	// Translation exists?
	std::vector<std::vector<std::string>> res;
	if (dict.TranslateString<std::string>("", msgStr)) {
		// First, get all lines.
		std::vector<std::string> lines = Utils::Tokenize(msgStr, [](char32_t c) { return c=='\n'; });

		// Now, break into message boxes based on the ADDMSG string
		res.push_back(std::vector<std::string>());
		for (const auto& line : lines) {
			if (line == TRCUST_ADDMSG) {
				res.push_back(std::vector<std::string>());
			} else {
				res.back().push_back(line);
			}

			// Special case: stop once you've found a REMMSG (to avoid the case where both add/rem are present)
			if (line == TRCUST_REMOVEMSG) {
				break;
			}
		}

		// Ensure we never get an empty vector (force using the REMMSG command)
		for (std::vector<std::string>& msgbox : res) {
			if (msgbox.empty()) {
				msgbox.push_back("");
			}
		}
	}

	return res;
}


void Translation::RewriteEventCommandMessage(const Dictionary& dict, std::vector<lcf::rpg::EventCommand>& commandsOrig) {
	// A note on this function: it is (I feel) necessarily complicated, given what it's actually doing.
	// I've tried to abstract most of this complexity away behind an "iterator" interface, so that we do not
	// have to track the current index directly in this function.
	CommandIterator commands(commandsOrig);
	while (!commands.Done()) {
		// We only need to deal with either Message or Choice commands
		if (commands.CurrentIsShowMessage()) {
			// Build up the lines of Message texts
			std::stringstream msg_str;
			std::vector<size_t> msg_indexes;
			commands.BuildMessageString(msg_str, msg_indexes);

			// Go through messages first, including possible choices
			if (msg_indexes.size()>0) {
				// Get our lines, possibly including "combined"
				std::vector<std::vector<std::string>> msgs = TranslateMessageStream(dict, msg_str, '\n');
				if (msgs.size()>0) {
					// The complex replacement logic is based on the last message box, then all remaining things are simply left back in.
					std::vector<std::string>& lines = msgs.back();

					// There is a special case here: if we are asked to remove a message box, we should do nothing further
					// This command is *only* respected as the first line of a message box.
					if (lines[0]==TRCUST_REMOVEMSG) {
						// Clear all message boxes in reverse order.
						while (!msg_indexes.empty()) {
							commands.RemoveByIndex(msg_indexes.back());
							msg_indexes.pop_back();
						}
					} else {
						// Trim lines down to allowed remaining (with choices).
						const size_t maxLines = 4;
						while (lines.size() > maxLines) {
							lines.pop_back();
						}

						// First, pop extra entries from the back of msg_cmd; this preserves the remaining entries' indexes
						while (msg_indexes.size() > lines.size()) {
							commands.RemoveByIndex(msg_indexes.back());
							msg_indexes.pop_back();
						}

						// Next, push extra entries from the back of lines to msg_cmd
						while (lines.size() > msg_indexes.size()) {
							commands.PutShowMessageBeforeIndex("", msg_indexes.back()+1, false);
							msg_indexes.push_back(msg_indexes.back()+1);
						}

						// Now simply go through each entry and update it.
						for (size_t num=0; num<msg_indexes.size(); num++) {
							commands.ReWriteString(msg_indexes[num], lines[num]);
						}
					}
					msgs.pop_back();

					// Now add remianing messages, if any
					commands.InsertMultiMessageBefore(msgs, msg_indexes[0]);
				}
			}

			// Note that commands.Advance() has already happened within the above code.
		} else if (commands.CurrentIsShowChoice()) {
			// Build up the lines of Choice elements
			std::stringstream choice_str;
			std::vector<size_t> choice_indexes; // Number of entries == number of choices
			commands.BuildChoiceString(choice_str, choice_indexes);

			// Go through choices.
			if (choice_indexes.size() > 0) {
				// Translate, break back into lines.
				std::vector<std::vector<std::string>> msgs = TranslateMessageStream(dict, choice_str, '\n');
				if (msgs.size() > 0) {
					// Logic here is also based on the last message box.
					std::vector<std::string> &lines = msgs.back();

					// We only pick the first X entries from the translation, since we can't change the Choice count.
					for (size_t num = 0; num < choice_indexes.size() && num < lines.size(); num++) {
						commands.ReWriteString(choice_indexes[num], lines[num]);
					}

					msgs.pop_back();

					// Now add remianing messages, if any
					commands.InsertMultiMessageBefore(msgs, choice_indexes[0]);
				}
			}

			// Note that commands.Advance() has already happened within the above code.
		} else if (commands.CurrentIsChangeHeroName() || commands.CurrentIsConditionActorName()) {
			dict.TranslateString("actors.name", commands.CurrentCmdString());
			commands.Advance();
		} else if (commands.CurrentIsChangeHeroTitle()) {
			dict.TranslateString("actors.title", commands.CurrentCmdString());
			commands.Advance();
		} else if (commands.CurrentIsShowStringPicture()) {
			std::string_view cmdstr = commands.CurrentCmdString();
			if (!cmdstr.empty() && cmdstr[0] == '\x01') {
				size_t escape_idx = 1;
				for (escape_idx = 1; escape_idx < cmdstr.size(); ++escape_idx) {
					char c = cmdstr[escape_idx];
					if (c == '\x01' || c == '\x02' || c == '\x03') {
						break;
					}
				}

				// String Picture use \r\n linebreaks
				// Rewrite them to \n
				std::string term = Utils::ReplaceAll(ToString(cmdstr.substr(1, escape_idx - 1)), "\r\n", "\n");
				dict.TranslateString("strpic", term);
				// Reintegrate the term
				commands.CurrentCmdString() = lcf::DBString("\x01" + term + ToString(cmdstr.substr(escape_idx)));
			}

			commands.Advance();
		} else {
			commands.Advance();
		}
	}
}

void Translation::RewriteMapMessages(std::string_view map_name, lcf::rpg::Map& map) {
	// Retrieve lookup for this map.
	auto mapIt = maps.find(ToString(map_name));
	if (mapIt==maps.end()) { return; }

	// Rewrite all event commands on all pages.
	for (lcf::rpg::Event& ev : map.events) {
		for (lcf::rpg::EventPage& pg : ev.pages) {
			RewriteEventCommandMessage(*mapIt->second, pg.event_commands);
		}
	}
}

void Translation::ParsePoFile(Filesystem_Stream::InputStream is, Dictionary& out)
{
	if (is) {
		Dictionary::FromPo(out, is);
	}
}

void Translation::ClearTranslationLookups()
{
	sys.reset();
	common.reset();
	battle.reset();
	mapnames.reset();
	maps.clear();
}

//////////////////////////////////////////////////////////
// NOTE: The code from here on out is duplicated in LcfTrans.
//       At some point it should be merged to a common location.
//////////////////////////////////////////////////////////


void Dictionary::addEntry(const Entry& entry)
{
	// Space-saving measure: If the translation string is empty, there's no need to save it (since we will just show the original).
	if (!entry.translation.empty()) {
		entries[entry.context][entry.original] = entry.translation;
	}
}

// Returns success
void Dictionary::FromPo(Dictionary& res, Filesystem_Stream::InputStream& in) {
	std::string line;
	std::string_view line_view;
	bool found_header = false;
	bool parse_item = false;
	int line_number = 0;

	Entry e;

	auto extract_string = [&](size_t offset) -> std::string {
		if (offset >= line_view.size()) {
			Output::Error("{}\n\nParse error (Line {}) is empty", FileFinder::GetPathInsideGamePath(in.GetName()), line_number);
			return "";
		}

		std::stringstream out;
		bool slash = false;
		bool first_quote = false;

		for (char c : line_view.substr(offset)) {
			if (!first_quote) {
				if (c == ' ') {
					continue;
				} else if (c == '"') {
					first_quote = true;
					continue;
				}
				Output::Error("{}\n\nParse error (Line {}): Expected \", got \"{}\":\n{}", FileFinder::GetPathInsideGamePath(in.GetName()), line_number, c, line);
				return "";
			}

			if (!slash && c == '\\') {
				slash = true;
			} else if (slash) {
				slash = false;
				switch (c) {
					case '\\':
						out << c;
						break;
					case 'n':
						out << '\n';
						break;
					case '"':
						out << '"';
						break;
					default: {
						Output::Error("{}\n\nParse error (Line {}): Expected \\, \\n or \", got \"{}\":\n{}", FileFinder::GetPathInsideGamePath(in.GetName()), line_number, c, line);
						break;
					}
				}
			} else {
				// no-slash
				if (c == '"') {
					// done
					return out.str();
				}
				out << c;
			}
		}

		Output::Error("{}\n\nParse error (Line {}): Unterminated line:\n{}", FileFinder::GetPathInsideGamePath(in.GetName()), line_number, line);
		return out.str();
	};

	auto read_msgstr = [&]() {
		// Parse multiply lines until empty line or comment
		e.translation = extract_string(6);

		while (Utils::ReadLine(in, line)) {
			line_view = Utils::TrimWhitespace(line);
			++line_number;
			if (line_view.empty() || StartsWith(line_view, "#")) {
				break;
			}
			e.translation += extract_string(0);
		}

		parse_item = false;
		res.addEntry(e);
		e = Entry();
	};

	auto read_msgid = [&]() {
		// Parse multiply lines until empty line or msgstr is encountered
		e.original = extract_string(5);

		while (Utils::ReadLine(in, line)) {
			line_view = Utils::TrimWhitespace(line);
			++line_number;
			if (line_view.empty() || StartsWith(line_view, "msgstr")) {
				read_msgstr();
				return;
			}
			e.original += extract_string(0);
		}
	};

	while (Utils::ReadLine(in, line)) {
		line_view = Utils::TrimWhitespace(line);
		++line_number;
		if (!found_header) {
			if (StartsWith(line_view, "msgstr")) {
				found_header = true;
			}
			continue;
		}

		if (!parse_item) {
			if (StartsWith(line_view, "msgctxt")) {
				e.context = extract_string(7);

				parse_item = true;
			} else if (StartsWith(line_view, "msgid")) {
				parse_item = true;
				read_msgid();
			}
		} else {
			if (StartsWith(line_view, "msgid")) {
				read_msgid();
			} else if (StartsWith(line_view, "msgstr")) {
				read_msgstr();
			}
		}
	}
}


/*end of file .\translation.cpp*/

/*start of file .\utils.cpp*/

/* ... license chunk ... */

// Headers
#include "utils.h"
#include "compiler.h"
#include <cassert>
#include <cstdint>
#include <cinttypes>
#include <cstdio>
#include <algorithm>
#include <cctype>
#include <istream>
#include <zlib.h>

namespace {
	char Lower(char c) {
		if (c >= 'A' && c <= 'Z') {
			return c + 'a' - 'A';
		} else {
			return c;
		}
	}

	char Upper(char c) {
		if (c >= 'a' && c <= 'z') {
			return c + 'A' - 'a';
		} else {
			return c;
		}
	};

}

std::string Utils::LowerCase(std::string_view str) {
	auto result = std::string(str);
	LowerCaseInPlace(result);
	return result;
}

std::string& Utils::LowerCaseInPlace(std::string& str) {
	std::transform(str.begin(), str.end(), str.begin(), Lower);
	return str;
}

std::string Utils::UpperCase(std::string_view str) {
	auto result = std::string(str);
	UpperCaseInPlace(result);
	return result;
}

std::string& Utils::UpperCaseInPlace(std::string& str) {
	std::transform(str.begin(), str.end(), str.begin(), Upper);
	return str;
}

int Utils::StrICmp(const char* l, const char* r) {
	assert(l != nullptr);
	assert(r != nullptr);
	while (*l != '\0' && *r != '\0') {
		auto d = Lower(*l) - Lower(*r);
		if (d != 0) {
			return d;
		}
		++l;
		++r;
	}
	return *l - *r;
}

int Utils::StrICmp(std::string_view l, std::string_view r) {
	for (size_t i = 0; i < std::min(l.size(), r.size()); ++i) {
		auto d = Lower(l[i]) - Lower(r[i]);
		if (d != 0) {
			return d;
		}
	}
	return l.size() - r.size();
}

std::u16string Utils::DecodeUTF16(std::string_view str) {
	std::u16string result;
	for (auto it = str.begin(), str_end = str.end(); it < str_end; ++it) {
		uint8_t c1 = static_cast<uint8_t>(*it);
		if (c1 < 0x80) {
			result.push_back(static_cast<uint16_t>(c1));
		}
		else if (c1 < 0xC2) {
			continue;
		}
		else if (c1 < 0xE0) {
			if (str_end-it < 2)
				break;
			uint8_t c2 = static_cast<uint8_t>(*(++it));
			if ((c2 & 0xC0) != 0x80)
				continue;
			result.push_back(static_cast<uint16_t>(((c1 & 0x1F) << 6) | (c2 & 0x3F)));
		}
		else if (c1 < 0xF0) {
			if (str_end-it < 3)
				break;
			uint8_t c2 = static_cast<uint8_t>(*(++it));
			uint8_t c3 = static_cast<uint8_t>(*(++it));
			if (c1 == 0xE0) {
				if ((c2 & 0xE0) != 0xA0)
					continue;
			} else if (c1 == 0xED) {
				if ((c2 & 0xE0) != 0x80)
					continue;
			} else {
				if ((c2 & 0xC0) != 0x80)
					continue;
			}
			if ((c3 & 0xC0) != 0x80)
				continue;
			result.push_back(static_cast<uint16_t>(((c1 & 0x0F) << 12)
												 | ((c2 & 0x3F) << 6)
												 |  (c3 & 0x3F)));
		}
		else if (c1 < 0xF5) {
			if (str_end-it < 4)
				break;
			uint8_t c2 = static_cast<uint8_t>(*(++it));
			uint8_t c3 = static_cast<uint8_t>(*(++it));
			uint8_t c4 = static_cast<uint8_t>(*(++it));
			if (c1 == 0xF0) {
				if (!(0x90 <= c2 && c2 <= 0xBF))
					continue;
			} else if (c1 == 0xF4) {
				if ((c2 & 0xF0) != 0x80)
					continue;
			} else {
				if ((c2 & 0xC0) != 0x80)
					continue;
			}
			if ((c3 & 0xC0) != 0x80 || (c4 & 0xC0) != 0x80)
				continue;
			if ((((c1 & 7UL) << 18) +
				((c2 & 0x3FUL) << 12) +
				((c3 & 0x3FUL) << 6) + (c4 & 0x3F)) > 0x10FFFF)
				continue;
			result.push_back(static_cast<uint16_t>(
					0xD800
				  | (((((c1 & 0x07) << 2) | ((c2 & 0x30) >> 4)) - 1) << 6)
				  | ((c2 & 0x0F) << 2)
				  | ((c3 & 0x30) >> 4)));
			result.push_back(static_cast<uint16_t>(
					0xDC00
				  | ((c3 & 0x0F) << 6)
				  |  (c4 & 0x3F)));
		}
	}
	return result;
}

std::u32string Utils::DecodeUTF32(std::string_view str) {
	std::u32string result;
	for (auto it = str.begin(), str_end = str.end(); it < str_end; ++it) {
		uint8_t c1 = static_cast<uint8_t>(*it);
		if (c1 < 0x80) {
			result.push_back(static_cast<uint32_t>(c1));
		}
		else if (c1 < 0xC2) {
			continue;
		}
		else if (c1 < 0xE0) {
			if (str_end-it < 2)
				break;
			uint8_t c2 = it[1];
			if ((c2 & 0xC0) != 0x80)
				continue;
			result.push_back(static_cast<uint32_t>(((c1 & 0x1F) << 6)
												  | (c2 & 0x3F)));
		}
		else if (c1 < 0xF0) {
			if (str_end-it < 3)
				break;
			uint8_t c2 = static_cast<uint8_t>(*(++it));
			uint8_t c3 = static_cast<uint8_t>(*(++it));
			if (c1 == 0xE0) {
				if ((c2 & 0xE0) != 0xA0)
					continue;
			} else if (c1 == 0xED) {
				if ((c2 & 0xE0) != 0x80)
					continue;
			} else {
				if ((c2 & 0xC0) != 0x80)
					continue;
			}
			if ((c3 & 0xC0) != 0x80)
				continue;
			result.push_back(static_cast<uint32_t>(((c1 & 0x0F) << 12)
												 | ((c2 & 0x3F) << 6)
												 |  (c3 & 0x3F)));
		}
		else if (c1 < 0xF5) {
			if (str_end-it < 4)
				break;
			uint8_t c2 = static_cast<uint8_t>(*(++it));
			uint8_t c3 = static_cast<uint8_t>(*(++it));
			uint8_t c4 = static_cast<uint8_t>(*(++it));
			if (c1 == 0xF0) {
				if (!(0x90 <= c2 && c2 <= 0xBF))
					continue;
			} else if (c1 == 0xF4) {
				if ((c2 & 0xF0) != 0x80)
					continue;
			} else {
				if ((c2 & 0xC0) != 0x80)
					continue;
			}
			if ((c3 & 0xC0) != 0x80 || (c4 & 0xC0) != 0x80)
				continue;
			result.push_back(static_cast<uint32_t>(((c1 & 0x07) << 18)
												 | ((c2 & 0x3F) << 12)
												 | ((c3 & 0x3F) << 6)
												 |  (c4 & 0x3F)));
		}
	}
	return result;
}

std::string Utils::EncodeUTF(const std::u16string& str) {
	std::string result;
	for (auto it = str.begin(), str_end = str.end(); it < str_end; ++it) {
		uint16_t wc1 = *it;
		if (wc1 < 0x0080) {
			result.push_back(static_cast<char>(wc1));
		}
		else if (wc1 < 0x0800) {
			result.push_back(static_cast<char>(0xC0 | (wc1 >> 6)));
			result.push_back(static_cast<char>(0x80 | (wc1 & 0x03F)));
		}
		else if (wc1 < 0xD800) {
			result.push_back(static_cast<char>(0xE0 |  (wc1 >> 12)));
			result.push_back(static_cast<char>(0x80 | ((wc1 & 0x0FC0) >> 6)));
			result.push_back(static_cast<char>(0x80 |  (wc1 & 0x003F)));
		}
		else if (wc1 < 0xDC00) {
			if (str_end-it < 2)
				break;
			uint16_t wc2 = *(++it);
			if ((wc2 & 0xFC00) != 0xDC00)
				continue;
			if (((((wc1 & 0x03C0UL) >> 6) + 1) << 16) +
				((wc1 & 0x003FUL) << 10) + (wc2 & 0x03FF) > 0x10FFFF)
				continue;
			uint8_t z = ((wc1 & 0x03C0) >> 6) + 1;
			result.push_back(static_cast<char>(0xF0 | (z >> 2)));
			result.push_back(static_cast<char>(0x80 | ((z & 0x03) << 4)     | ((wc1 & 0x003C) >> 2)));
			result.push_back(static_cast<char>(0x80 | ((wc1 & 0x0003) << 4) | ((wc2 & 0x03C0) >> 6)));
			result.push_back(static_cast<char>(0x80 |  (wc2 & 0x003F)));
		}
		else if (wc1 < 0xE000) {
			continue;
		}
		else {
			result.push_back(static_cast<char>(0xE0 |  (wc1 >> 12)));
			result.push_back(static_cast<char>(0x80 | ((wc1 & 0x0FC0) >> 6)));
			result.push_back(static_cast<char>(0x80 |  (wc1 & 0x003F)));
		}
	}
	return result;
}

std::string Utils::EncodeUTF(const std::u32string& str) {
	std::string result;
	for (const char32_t& wc : str) {
		if ((wc & 0xFFFFF800) == 0x00D800 || wc > 0x10FFFF)
			break;
		if (wc < 0x000080) {
			result.push_back(static_cast<char>(wc));
		}
		else if (wc < 0x000800) {
			result.push_back(static_cast<char>(0xC0 | (wc >> 6)));
			result.push_back(static_cast<char>(0x80 | (wc & 0x03F)));
		}
		else if (wc < 0x010000) {
			result.push_back(static_cast<char>(0xE0 |  (wc >> 12)));
			result.push_back(static_cast<char>(0x80 | ((wc & 0x0FC0) >> 6)));
			result.push_back(static_cast<char>(0x80 |  (wc & 0x003F)));
		}
		else {
			result.push_back(static_cast<char>(0xF0 |  (wc >> 18)));
			result.push_back(static_cast<char>(0x80 | ((wc & 0x03F000) >> 12)));
			result.push_back(static_cast<char>(0x80 | ((wc & 0x000FC0) >> 6)));
			result.push_back(static_cast<char>(0x80 |  (wc & 0x00003F)));
		}
	}
	return result;
}

Utils::UtfNextResult Utils::UTF8Next(const char* iter, const char* const end) {
	while (iter != end) {
		uint8_t c1 = static_cast<uint8_t>(*iter);
		++iter;
		if (c1 < 0x80) {
			return { iter, static_cast<uint32_t>(c1) };
		}
		if (c1 < 0xC2) {
			continue;
		}
		if (iter == end) {
			break;
		}
		uint8_t c2 = static_cast<uint8_t>(*iter);
		++iter;
		if (c1 < 0xE0) {
			if ((c2 & 0xC0) != 0x80)
				continue;
			auto ch = (static_cast<uint32_t>(((c1 & 0x1F) << 6) | (c2 & 0x3F)));
			return { iter, ch };
		}
		if (iter == end) {
			break;
		}
		uint8_t c3 = static_cast<uint8_t>(*iter);
		++iter;
		if (c1 < 0xF0) {
			if (c1 == 0xE0) {
				if ((c2 & 0xE0) != 0xA0)
					continue;
			} else if (c1 == 0xED) {
				if ((c2 & 0xE0) != 0x80)
					continue;
			} else {
				if ((c2 & 0xC0) != 0x80)
					continue;
			}
			if ((c3 & 0xC0) != 0x80)
				continue;
			auto ch = (static_cast<uint32_t>(((c1 & 0x0F) << 12)
						| ((c2 & 0x3F) << 6)
						|  (c3 & 0x3F)));
			return { iter, ch };
		}
		if (iter == end) {
			break;
		}
		uint8_t c4 = static_cast<uint8_t>(*iter);
		++iter;
		if (c1 < 0xF5) {
			if (c1 == 0xF0) {
				if (!(0x90 <= c2 && c2 <= 0xBF))
					continue;
			} else if (c1 == 0xF4) {
				if ((c2 & 0xF0) != 0x80)
					continue;
			} else {
				if ((c2 & 0xC0) != 0x80)
					continue;
			}
			if ((c3 & 0xC0) != 0x80 || (c4 & 0xC0) != 0x80)
				continue;
		auto ch = static_cast<uint32_t>(((c1 & 0x07) << 18)
				| ((c2 & 0x3F) << 12)
				| ((c3 & 0x3F) << 6)
				|  (c4 & 0x3F));
		return { iter, ch };
		}
	}
	return { iter, 0 };
}

Utils::UtfNextResult Utils::UTF8Skip(const char* iter, const char* end, int skip) {
	UtfNextResult ret;

	if (skip == 0) {
		ret = UTF8Next(iter, end);
		return { iter, ret.ch };
	}

	for (; iter < end && skip > 0; --skip) {
		ret = UTF8Next(iter, end);
		iter = ret.next;
	}

	return ret;
}

int Utils::UTF8Length(std::string_view str) {
	size_t len = 0;

	const char* iter = str.data();
	const char* const e = str.data() + str.size();
	while (iter < e) {
		auto ret = Utils::UTF8Next(iter, e);
		iter = ret.next;
		++len;
	}

	return len;
}

Utils::ExFontRet Utils::ExFontNext(const char* iter, const char* end) {
	ExFontRet ret;
	if (end - iter >= 2 && *iter == '$') {
		auto next_ch = *(iter + 1);
		// Don't use std::isalpha, because it's indirects based on locale.
		bool is_lower = (next_ch >= 'a' && next_ch <= 'z');
		bool is_upper = (next_ch >= 'A' && next_ch <= 'Z');
		if (is_lower || is_upper) {
			ret.next = iter + 2;
			ret.value = next_ch;
			ret.is_valid = true;
		}
	}
	return ret;
}

Utils::TextRet Utils::TextNext(const char* iter, const char* end, char32_t escape) {
	TextRet ret;

	if (EP_UNLIKELY(iter == end)) {
		ret.next = iter;
		return ret;
	}

	auto ex_ret = ExFontNext(iter, end);
	if (ex_ret) {
		ret.next = ex_ret.next;
		ret.ch = ex_ret.value;
		ret.is_exfont = true;
		return ret;
	}

	auto utf8_ret = UTF8Next(iter, end);
	ret.next = utf8_ret.next;
	ret.ch = utf8_ret.ch;

	if (escape != 0 && ret.ch == escape && ret.next != end) {
		auto eret = UTF8Next(ret.next, end);
		ret.next = eret.next;
		ret.ch = eret.ch;
		ret.is_escape = true;
	}
	ret.is_exfont = false;

	return ret;
}

// Please report an issue when you get a compile error here because your toolchain is broken and lacks wchar_t
template<size_t WideSize>
static std::wstring ToWideStringImpl(std::string_view);
#if __SIZEOF_WCHAR_T__ == 4 || __WCHAR_MAX__ > 0x10000
template<> // utf32
std::wstring ToWideStringImpl<4>(std::string_view str) {
	const auto tmp = Utils::DecodeUTF32(str);
	return std::wstring(tmp.begin(), tmp.end());
}
#else
template<> // utf16
std::wstring ToWideStringImpl<2>(std::string_view str) {
	const auto tmp = Utils::DecodeUTF16(str);
	return std::wstring(tmp.begin(), tmp.end());
}
#endif

std::wstring Utils::ToWideString(std::string_view str) {
	return ToWideStringImpl<sizeof(wchar_t)>(str);
}

template<size_t WideSize>
static std::string FromWideStringImpl(const std::wstring&);
#if __SIZEOF_WCHAR_T__ == 4 || __WCHAR_MAX__ > 0x10000
template<> // utf32
std::string FromWideStringImpl<4>(const std::wstring& str) {
	return Utils::EncodeUTF(std::u32string(str.begin(), str.end()));
}
#else
template<> // utf16
std::string FromWideStringImpl<2>(const std::wstring& str) {
	return Utils::EncodeUTF(std::u16string(str.begin(), str.end()));
}
#endif

std::string Utils::FromWideString(const std::wstring& str) {
	return FromWideStringImpl<sizeof(wchar_t)>(str);
}

int Utils::PositiveModulo(int i, int m) {
	return (i % m + m) % m;
}

void Utils::SwapByteOrder(uint16_t& us) {
#ifdef WORDS_BIGENDIAN
	us =	(us >> 8) |
			(us << 8);
#else
	(void)us;
#endif
}

void Utils::SwapByteOrder(uint32_t& ui) {
#ifdef WORDS_BIGENDIAN
	ui =	(ui >> 24) |
			((ui<<8) & 0x00FF0000) |
			((ui>>8) & 0x0000FF00) |
			(ui << 24);
#else
	(void)ui;
#endif
}

void Utils::SwapByteOrder(double& d) {
#ifdef WORDS_BIGENDIAN
	uint32_t *p = reinterpret_cast<uint32_t *>(&d);
	SwapByteOrder(p[0]);
	SwapByteOrder(p[1]);
	uint32_t tmp = p[0];
	p[0] = p[1];
	p[1] = tmp;
#else
	(void)d;
#endif
}

// based on https://stackoverflow.com/questions/6089231/
bool Utils::ReadLine(std::istream& is, std::string& line_out) {
	std::istream::sentry se(is, true);
	std::streambuf* sb = is.rdbuf();

	if (!is) {
		return false;
	}

	line_out.clear();

	for(;;) {
		int c = sb->sbumpc();
		switch (c) {
		case '\n':
			return true;
		case '\r':
			if (sb->sgetc() == '\n') {
				sb->sbumpc();
			}
			return true;
		case EOF:
			// Also handle the case when the last line has no line ending
			if (line_out.empty()) {
				is.setstate(std::ios::eofbit);
				return false;
			}
			return true;
		default:
			line_out += (char)c;
		}
	}
}

std::vector<std::string> Utils::Tokenize(std::string_view str_to_tokenize, const std::function<bool(char32_t)> predicate) {
	std::u32string text = DecodeUTF32(str_to_tokenize);
	std::vector<std::string> tokens;
	std::u32string cur_token;

	for (char32_t& c : text) {
		if (predicate(c)) {
			tokens.push_back(EncodeUTF(cur_token));
			cur_token.clear();
			continue;
		}

		cur_token.push_back(c);
	}

	tokens.push_back(EncodeUTF(cur_token));

	return tokens;
}

std::vector<uint8_t> Utils::ReadStream(std::istream& stream) {
	constexpr int buffer_incr = 8192;
	std::vector<uint8_t> outbuf;

	do {
		outbuf.resize(outbuf.size() + buffer_incr);
		stream.read(reinterpret_cast<char*>(outbuf.data() + outbuf.size() - buffer_incr), buffer_incr);
	} while (stream.gcount() == buffer_incr);

	outbuf.resize(outbuf.size() - buffer_incr + stream.gcount());

	return outbuf;
}

uint32_t Utils::CRC32(std::istream& stream) {
	uLong crc = crc32(0L, Z_NULL, 0);
	std::array<uint8_t, 8192> buffer = {};
	do {
		stream.read(reinterpret_cast<char*>(buffer.data()), buffer.size());
		crc = crc32(crc, buffer.data(), stream.gcount());
	} while (stream.gcount() == static_cast<std::streamsize>(buffer.size()));
	return crc;
}

// via https://stackoverflow.com/q/3418231/
std::string Utils::ReplaceAll(std::string str, const std::string& search, const std::string& replace) {
	if (search.empty()) {
		return str;
	}

	size_t start_pos = 0;
	while((start_pos = str.find(search, start_pos)) != std::string::npos) {
		str.replace(start_pos, search.length(), replace);
		start_pos += replace.length(); // Handles case where 'replace' is a substring of 'search'
	}
	return str;
}

std::string Utils::ReplacePlaceholders(std::string_view text_template, Span<const char> types, Span<const std::string_view> values) {
	auto str = std::string(text_template);
	size_t index = str.find("%");
	while (index != std::string::npos) {
		if (index + 1 < str.length()) {
			char type = str[index + 1];
			if (type != '%') {
				auto v_it = values.begin();
				for (auto t_it = types.begin();
					t_it != types.end() && v_it != values.end();
					++t_it, ++v_it) {
					if (std::toupper(type) == *t_it) {
						str.replace(index, 2, v_it->data(), v_it->size());
						index += (*v_it).length() - 2;
						break;
					}
				}
			}
		}

		index = str.find("%", index + 1);
	}

	return str;
}

std::string_view Utils::TrimWhitespace(std::string_view s) {
	size_t left = 0;
	for (auto& c: s) {
		if (std::isspace(static_cast<int>(c))) {
			++left;
		} else {
			break;
		}
	}
	s.remove_prefix(left);

	size_t right = 0;
	for (auto it = s.crbegin(); it != s.crend(); ++it) {
		if (std::isspace(static_cast<int>(*it))) {
			++right;
		} else {
			break;
		}
	}
	s.remove_suffix(right);

	return s;
}

std::string Utils::FormatDate(const std::tm *tm, std::string_view format) {
	constexpr int buf_size = 128;
	char buffer[buf_size];

	auto res = strftime(buffer, buf_size, ToString(format).c_str(), tm);

	return std::string(buffer, res);
}


/*end of file .\utils.cpp*/

/*start of file .\version.cpp*/

/* ... license chunk ... */

#include "version.h"

// Fallback if buildsystem has not provided a version
#ifndef EP_VERSION
	#warning "No version specified by build system, using defaults."

	// Helper Macros
	#define STRINGIFY(x) #x
	#define TO_STRING(x) STRINGIFY(x)

	// Set by release-helper.sh
	#define EP_VERSION_MAJOR 0
	#define EP_VERSION_MINOR 8
	#define EP_VERSION_PATCH 1
	#define EP_VERSION_TWEAK 0

	// concatenate short version string
	#define _VER1 TO_STRING(EP_VERSION_MAJOR) "." TO_STRING(EP_VERSION_MINOR)
	#if EP_VERSION_TWEAK > 0
		#define _VER2 TO_STRING(EP_VERSION_PATCH) "." TO_STRING(EP_VERSION_TWEAK)
	#elif EP_VERSION_PATCH > 0
		#define _VER2 TO_STRING(EP_VERSION_PATCH)
	#endif
	#ifdef _VER2
		#define EP_VERSION _VER1 "." _VER2
	#else
		#define EP_VERSION _VER1
	#endif
#endif

// These can be undefined
#ifndef EP_VERSION_GIT
	#define EP_VERSION_GIT ""
#endif
#ifndef EP_VERSION_APPEND
	#define EP_VERSION_APPEND ""
#endif

namespace Version {

	const char STRING[] = EP_VERSION;
	const int MAJOR = EP_VERSION_MAJOR;
	const int MINOR = EP_VERSION_MINOR;
	const int PATCH = EP_VERSION_PATCH;
	const int TWEAK = EP_VERSION_TWEAK;
	const char GIT[] = EP_VERSION_GIT;
	const char APPEND[] = EP_VERSION_APPEND;

	std::string GetVersionString(bool with_git, bool with_append) {
		std::string ver = Version::STRING;
		if (with_git && std::strlen(GIT) > 0) {
			ver += std::string(" ") + GIT;
		}
		if (with_append && std::strlen(APPEND) > 0) {
			ver += std::string(" ") + APPEND;
		}
		return ver;
	}
}


/*end of file .\version.cpp*/

/*start of file .\weather.cpp*/

/* ... license chunk ... */

// Headers
#include <cstdint>
#include <string>
#include <vector>
#include "bitmap.h"
#include "color.h"
#include "game_screen.h"
#include "main_data.h"
#include "weather.h"
#include "drawable_mgr.h"
#include "player.h"
#include "output.h"
#include "rand.h"

Weather::Weather() :
	Drawable(Priority_Weather, Drawable::Flags::Shared)
{
	DrawableMgr::Register(this);

	auto rect = Main_Data::game_screen->GetScreenEffectsRect();
	weather_surface = Bitmap::Create(rect.width, rect.height, true);
}

void Weather::Update() {
}

void Weather::Draw(Bitmap& dst) {
	SetTone(Main_Data::game_screen->GetTone());

	switch (Main_Data::game_screen->GetWeatherType()) {
		case Game_Screen::Weather_None:
			break;
		case Game_Screen::Weather_Rain:
			DrawRain(dst);
			break;
		case Game_Screen::Weather_Snow:
			DrawSnow(dst);
			break;
		case Game_Screen::Weather_Fog:
			DrawFog(dst);
			break;
		case Game_Screen::Weather_Sandstorm:
			DrawSandstorm(dst);
			break;
	}
}

static constexpr int num_strength = 3;
static constexpr int num_rain_or_snow_particles[] = { 20, 60, 100 };
static constexpr auto rain_bitmap_rect = Rect{ 0, 0, 6, 24 };
static constexpr auto snow_bitmap_rect = Rect{ 0, 0, 2, 2 };
static constexpr auto overlay_bitmap_rect = Rect{ 0, 0, TILE_SIZE, TILE_SIZE };

static constexpr auto num_fog_particles = 2;

static constexpr int num_sand_particles[] = { 128, 191, 255 };
static constexpr int num_sand_colors = 4;
static constexpr auto sand_particle_rect = Rect{ 0, 0, 1, 2 };

static constexpr auto sand_particle_bitmap_rect = Rect{
	0, 0,
	sand_particle_rect.width,
	sand_particle_rect.height * num_sand_colors,
};

static constexpr Rect MakeMaxBitmapRect(std::initializer_list<Rect> list) {
	int max_w = 0;
	int max_h = 0;
	for (auto& rect: list) {
		max_w = std::max(rect.width, max_w);
		max_h = std::max(rect.height, max_h);
	}
	return Rect{ 0, 0, max_w, max_h };
}

static constexpr auto tone_bitmap_rect = MakeMaxBitmapRect({ rain_bitmap_rect, snow_bitmap_rect, overlay_bitmap_rect, sand_particle_bitmap_rect });

static constexpr int num_overlay_colors = 3;

static constexpr Color fog_overlay_colors[num_overlay_colors] = {
	{ 230, 230, 230, 255 },
	{ 240, 240, 240, 255 },
	{ 255, 255, 255, 255 },
};

static constexpr Color sand_overlay_colors[num_overlay_colors] = {
	{ 220, 220, 160, 255 },
	{ 230, 230, 170, 255 },
	{ 240, 240, 180, 255 },
};

// RPG_RT only allows strength 0, 1, and 2. If you hack strength 3,
// it will show the upper layer as fully opaque and the lower layer
// with opacity 64. We set lower layer to 0 and don't render it
// since it can't be seen anyway.
// If you hack strength 4 or higher, RPG_RT will exhibit buggy
// wraparound behavior. In Player, we clamp at 3.
static constexpr int num_opacities = 4;
static constexpr int fog_opacity[2][4] = {
	{ 32, 64, 96, 0 },
	{ 64, 80, 160, 255 },
};


int Weather::GetMaxNumParticles(int weather_type) {
	switch (weather_type) {
		case Game_Screen::Weather_None:
			return 0;
		case Game_Screen::Weather_Rain:
		case Game_Screen::Weather_Snow:
			return num_rain_or_snow_particles[num_strength - 1];
		case Game_Screen::Weather_Fog:
			return num_fog_particles;
		case Game_Screen::Weather_Sandstorm:
			return num_sand_particles[num_strength - 1];
	}
	return 0;
}

const Bitmap* Weather::ApplyToneEffect(const Bitmap& bitmap, Rect rect) {
	if (tone_effect == Tone()) {
		return &bitmap;
	}

	if (!tone_bitmap) {
		assert(tone_dirty && "Tone Bitmap Created but tone was not marked dirty!");
		tone_bitmap = Bitmap::Create(tone_bitmap_rect.width, tone_bitmap_rect.height, true);
	}

	if (tone_dirty) {
		tone_bitmap->ToneBlit(0, 0, bitmap, rect, tone_effect, Opacity::Opaque());
	}
	return tone_bitmap.get();
}

void Weather::CreateRainParticle() {
	constexpr int w = rain_bitmap_rect.width;
	constexpr int h = rain_bitmap_rect.height;
	rain_bitmap = Bitmap::Create(w, h, true);

	const auto pixel = Bitmap::pixel_format.rgba_to_uint32_t(255,255,255,255);

	auto* img = reinterpret_cast<uint32_t*>(rain_bitmap->pixels());

	for (int y = 0; y < h; ++y) {
		int x = w - (y / 4) - 1;

		img[y * w + x] = pixel;
	}
}

void Weather::DrawRain(Bitmap& dst) {
	if (!rain_bitmap) {
		CreateRainParticle();
	}
	DrawParticles(dst, *rain_bitmap, rain_bitmap_rect, 5, 12);
}


void Weather::CreateSnowParticle() {
	constexpr auto w = snow_bitmap_rect.width;
	constexpr auto h = snow_bitmap_rect.height;
	snow_bitmap = Bitmap::Create(w, h, true);

	const auto pixel = Bitmap::pixel_format.rgba_to_uint32_t(255,255,255,255);

	auto* img = reinterpret_cast<uint32_t*>(snow_bitmap->pixels());

	for (int i = 0; i < w * h; ++i) {
		img[i] = pixel;
	}
}

void Weather::DrawSnow(Bitmap& dst) {
	if (!snow_bitmap) {
		CreateSnowParticle();
	}
	DrawParticles(dst, *snow_bitmap, snow_bitmap_rect, 7, 30);
}

void Weather::DrawParticles(Bitmap& dst, const Bitmap& particle, const Rect rect, int abase, int tmax) {
	auto* bitmap = ApplyToneEffect(particle, rect);

	const auto strength = Main_Data::game_screen->GetWeatherStrength();
	const auto& particles = Main_Data::game_screen->GetParticles();

	const int num_particles = num_rain_or_snow_particles[Utils::Clamp(strength, 0, num_strength - 1)];
	const auto ainc = abase + strength;

	auto surface_rect = weather_surface->GetRect();
	weather_surface->Clear();

	assert(num_particles <= static_cast<int>(particles.size()));

	for (int i = 0; i < num_particles; ++i) {
		auto& p = particles[i];
		if (p.t > tmax) {
			continue;
		}

		auto alpha = std::min(ainc * p.t, 255);

		weather_surface->EdgeMirrorBlit(p.x, p.y, *bitmap, rect, true, true, alpha);
	}

	const auto shake_x = Main_Data::game_screen->GetShakeOffsetX();
	const auto shake_y = Main_Data::game_screen->GetShakeOffsetY();
	auto pan_rect = Main_Data::game_screen->GetScreenEffectsRect();
	dst.TiledBlit(-pan_rect.x + shake_x, -pan_rect.y + shake_y, surface_rect, *weather_surface, dst.GetRect(), Opacity::Opaque());
}

void Weather::DrawFog(Bitmap& dst) {
	if (!fog_bitmap) {
		CreateFogOverlay();
	}

	DrawFogOverlay(dst, *fog_bitmap);
}

void Weather::DrawSandstorm(Bitmap& dst) {
	if (!sand_bitmap) {
		CreateFogOverlay();
	}
	if (!sand_particle_bitmap) {
		CreateSandParticle();
	}

	DrawFogOverlay(dst, *sand_bitmap);
	DrawSandParticles(dst, *sand_particle_bitmap);
}

void Weather::CreateSandParticle() {
	constexpr int w = sand_particle_bitmap_rect.width;
	constexpr int h = sand_particle_bitmap_rect.height;

	sand_particle_bitmap = Bitmap::Create(w, h, true);

	const std::array<uint32_t,num_sand_colors> pixels = {{
		Bitmap::pixel_format.rgba_to_uint32_t(255,255,32,255), // Yellow
		Bitmap::pixel_format.rgba_to_uint32_t(255,180,32,255), // Orange
		Bitmap::pixel_format.rgba_to_uint32_t(255,32,32,255), // Red
		Bitmap::pixel_format.rgba_to_uint32_t(255,255,240,255), // White
	}};

	auto* img = reinterpret_cast<uint32_t*>(sand_particle_bitmap->pixels());

	for (int i = 0; i < w * h; ++i) {
		img[i] = pixels[i / 2];
	}
}

void Weather::DrawSandParticles(Bitmap& dst, const Bitmap& particle_bitmap) {
	const auto strength = Main_Data::game_screen->GetWeatherStrength();
	const auto& particles = Main_Data::game_screen->GetParticles();

	auto* bitmap = ApplyToneEffect(particle_bitmap, particle_bitmap.GetRect());

	const int num_particles = num_sand_particles[Utils::Clamp(strength, 0, num_strength - 1)];

	assert(num_particles <= static_cast<int>(particles.size()));

	for (int i = 0; i < num_particles; ++i) {
		auto& p = particles[i];
		const int color = (i % num_sand_colors);

		auto rect = Rect{
			0,
			color * sand_particle_rect.height,
			sand_particle_rect.width,
			sand_particle_rect.height
		};

		dst.Blit(p.x, p.y, *bitmap, rect, p.alpha);
	}
}

void Weather::CreateFogOverlay() {
	uint32_t fog_pixels[num_overlay_colors];
	uint32_t sand_pixels[num_overlay_colors];

	for (int i = 0; i < num_overlay_colors; ++i) {
		auto fc = fog_overlay_colors[i];
		auto sc = sand_overlay_colors[i];
		fog_pixels[i] = Bitmap::pixel_format.rgba_to_uint32_t(fc.red, fc.green, fc.blue, fc.alpha);
		sand_pixels[i] = Bitmap::pixel_format.rgba_to_uint32_t(sc.red, sc.green, sc.blue, sc.alpha);
	}

	constexpr auto w = overlay_bitmap_rect.width;
	constexpr auto h = overlay_bitmap_rect.height;

	fog_bitmap = Bitmap::Create(w, h);
	sand_bitmap = Bitmap::Create(w, h);

	auto* fog_img = reinterpret_cast<uint32_t*>(fog_bitmap->pixels());
	auto* sand_img = reinterpret_cast<uint32_t*>(sand_bitmap->pixels());

	for (int i = 0; i < w * h; ++i) {
		int px = Rand::GetRandomNumber(0, num_overlay_colors - 1);
		// FIXME: This only works for 32bit pixel formats
		fog_img[i] = fog_pixels[px];
		sand_img[i] = sand_pixels[px];
	}
}

void Weather::DrawFogOverlay(Bitmap& dst, const Bitmap& overlay) {
	const auto dr = dst.GetRect();
	constexpr auto sr = overlay_bitmap_rect;

	auto* src = ApplyToneEffect(overlay, sr);

	auto strength = Utils::Clamp(Main_Data::game_screen->GetWeatherStrength(), 0, num_opacities - 1);
	int back_opacity = fog_opacity[0][strength];
	int front_opacity = fog_opacity[1][strength];

	const auto shake_x = Main_Data::game_screen->GetShakeOffsetX();
	const auto shake_y = Main_Data::game_screen->GetShakeOffsetY();

	// RPG_RT uses the first 2 particles for fog layer graphics
	const auto& particles = Main_Data::game_screen->GetParticles();
	assert(particles.size() >= num_fog_particles);
	const auto fog_bg_frames = particles[0].x;
	const auto fog_fg_frames = particles[1].x;

	// Front layer moves left one pixel every 8 frames.
	const int fx = shake_x + (fog_fg_frames / 8) % sr.width;
	// Back layer moves left one pixel every 4 frames.
	const int bx = shake_x - (fog_bg_frames / 4) % sr.width;
	// Front layer moves vertically up and down using this algorithm. And it uses the background frame counter!
	// Confirmed to be matching RPG_RT
	const int fy = shake_y - Utils::RoundTo<int>(std::sin(fog_bg_frames * M_PI / 4096.0) * (sr.height / 2)) - (sr.height / 4);
	// Back layer never moves vertically
	const int by = shake_y;

	dst.TiledBlit(bx, by, sr, *src, dr, back_opacity);
	dst.TiledBlit(fx, fy, sr, *src, dr, front_opacity);
}

void Weather::SetTone(Tone tone) {
	if (tone != tone_effect) {
		tone_effect = tone;
		tone_dirty = true;
	}
}

void Weather::OnWeatherChanged() {
	tone_dirty = true;
	if (tone_bitmap) {
		tone_bitmap->Clear();
	}
}


/*end of file .\weather.cpp*/

/*start of file .\window.cpp*/

/* ... license chunk ... */

// Headers
#include <cmath>
#include "system.h"
#include "player.h"
#include "rect.h"
#include "util_macro.h"
#include "window.h"
#include "bitmap.h"
#include "drawable_mgr.h"

constexpr int arrow_animation_frames = 20;

Window::Window(Drawable::Flags flags): Drawable(Priority_Window, flags)
{
	DrawableMgr::Register(this);
}

void Window::SetOpenAnimation(int frames) {
	closing = false;
	SetVisible(true);

	if (frames > 0) {
		animation_frames = frames;
		animation_count = 0.0;
		animation_increment = (height / 2.0) / frames;
	}
	else {
		animation_frames = 0;
	}
}

void Window::SetCloseAnimation(int frames) {
	if (frames > 0) {
		closing = true;
		animation_frames = frames;
		animation_count = (height / 2.0);
		animation_increment = - animation_count / frames;
	} else {
		SetVisible(false);
	}
}

void Window::SetBackgroundAlpha(bool alpha) {
	if (alpha == background_alpha) {
		return;
	}

	background_needs_refresh = true;
	background_alpha = alpha;
}

void Window::SetBackgroundPreserveTransparentColor(bool preserve) {
	if (preserve == bg_preserve_transparent_color) {
		return;
	}

	bg_preserve_transparent_color = preserve;
}

void Window::Draw(Bitmap& dst) {
	if (width <= 0 || height <= 0) return;
	if (x < -width || x > dst.GetWidth() || y < -height || y > dst.GetHeight()) return;

	if (windowskin) {
		if (width > 4 && height > 4 && (back_opacity * opacity / 255 > 0)) {
			if (background_needs_refresh) RefreshBackground();

			if (animation_frames > 0) {
				int ianimation_count = (int)animation_count;

				Rect src_rect(0, height / 2 - ianimation_count, width, ianimation_count * 2);

				dst.Blit(x, y + src_rect.y, *background, src_rect, back_opacity * opacity / 255);
			} else {
				dst.Blit(x, y, *background, background->GetRect(), back_opacity * opacity / 255);
			}
		}

		if (width > 0 && height > 0 && opacity > 0) {
			if (frame_needs_refresh) RefreshFrame();

			int fopacity = frame_opacity * opacity / 255;

			if (animation_frames > 0) {
				int ianimation_count = (int)animation_count;

				if (ianimation_count > 8) {
					Rect src_rect(0, height / 2 - ianimation_count, 8, ianimation_count * 2 - 16);

					if (frame_left) {
						dst.Blit(x, y + 8 + src_rect.y, *frame_left, src_rect, fopacity);
					}

					if (frame_right) {
						dst.Blit(x + width - 8, y + 8 + src_rect.y, *frame_right, src_rect, fopacity);
					}

					dst.Blit(x, y + height / 2 - ianimation_count, *frame_up, frame_up->GetRect(), fopacity);
					dst.Blit(x, y + height / 2 + ianimation_count - 8, *frame_down, frame_down->GetRect(), fopacity);
				} else {
					dst.Blit(x, y + height / 2 - ianimation_count, *frame_up, Rect(0, 0, width, ianimation_count), fopacity);
					dst.Blit(x, y + height / 2 , *frame_down, Rect(0, 8 - ianimation_count, width, ianimation_count), fopacity);
				}
			} else {
				dst.Blit(x, y, *frame_up, frame_up->GetRect(), fopacity);
				dst.Blit(x, y + height - 8, *frame_down, frame_down->GetRect(), fopacity);

				if (frame_left) {
					dst.Blit(x, y + 8, *frame_left, frame_left->GetRect(), fopacity);
				}

				if (frame_right) {
					dst.Blit(x + width - 8, y + 8, *frame_right, frame_right->GetRect(), fopacity);
				}
			}
		}

		if (width >= 16 && height > 16 && cursor_rect.width > 4 && cursor_rect.height > 4 && animation_frames == 0) {
			if (cursor_needs_refresh) RefreshCursor();

			Rect src_rect(
				-min(cursor_rect.x + border_x, 0),
				-min(cursor_rect.y + border_y, 0),
				min(cursor_rect.width, width - cursor_rect.x + border_x),
				min(cursor_rect.height, height - cursor_rect.y + border_y)
			);

			if (cursor_frame <= 10)
				dst.Blit(x + cursor_rect.x + border_x, y + cursor_rect.y + border_y, *cursor1, src_rect, 255);
			else
				dst.Blit(x + cursor_rect.x + border_x, y + cursor_rect.y + border_y, *cursor2, src_rect, 255);
		}
	}

	if (contents) {
		if (width > 2 * border_x && height > 2 * border_y &&
			-ox < width - 2 * border_x && -oy < height - 2 * border_y &&
			contents_opacity > 0 && animation_frames == 0) {
			Rect src_rect(-min(-ox, 0), -min(-oy, 0),
						  min(width - 2 * border_x, width - 2 * border_x + ox),
						  min(height - 2 * border_y, height - 2 * border_y + oy));

			dst.Blit(max(x + border_x, x + border_x - ox),
					  max(y + border_y, y + border_y - oy),
					  *contents, src_rect, contents_opacity);
		}
	}

	auto show_arrow = [&](bool which) {
		if (!which || !animate_arrows) {
			return which;
		}

		return (arrow_animation_frame < arrow_animation_frames) && animation_frames <= 0;
	};

	if ((pause && arrow_animation_frame < arrow_animation_frames && animation_frames <= 0) || show_arrow(down_arrow)) {
		Rect src_rect(40, 16, 16, 8);
		dst.Blit(x + width / 2 - 8, y + height - 8, *windowskin, src_rect, 255);
	}

	if (show_arrow(up_arrow)) {
		Rect src_rect(40, 8, 16, 8);
		dst.Blit(x + width / 2 - 8, y, *windowskin, src_rect, 255);
	}

	if (show_arrow(right_arrow)) {
		Rect src_rect(40, 16, 16, 8);
		dst.RotateZoomOpacityBlit(x + width - 8, y + height / 2 - 8, 16, 0, *windowskin, src_rect, -M_PI / 2, 1.0, 1.0, 255);
	}

	if (show_arrow(left_arrow)) {
		Rect src_rect(40, 8, 16, 8);
		dst.RotateZoomOpacityBlit(x, y + height / 2 - 8, 16, 0, *windowskin, src_rect, -M_PI / 2, 1.0, 1.0, 255);
	}
}

void Window::RefreshBackground() {
	background_needs_refresh = false;

	BitmapRef bitmap = Bitmap::Create(width, height, background_alpha);

	if (stretch) {
		bitmap->StretchBlit(*windowskin, Rect(0, 0, 32, 32), 255);
	} else {
		bitmap->TiledBlit(Rect(0, 0, 32, 32), *windowskin, bitmap->GetRect(), 255);
	}

	background = bitmap;
}

void Window::RefreshFrame() {
	frame_needs_refresh = false;

	BitmapRef up_bitmap = Bitmap::Create(width, 8);
	BitmapRef down_bitmap = Bitmap::Create(width, 8);

	up_bitmap->Clear();
	down_bitmap->Clear();

	Rect src_rect, dst_rect;

	// Border Up
	src_rect = { 32 + 8, 0, 16, 8 };
	dst_rect = { 8, 0, max(width - 16, 1), 8 };
	up_bitmap->TiledBlit(8, 0, src_rect, *windowskin, dst_rect, 255);

	// Border Down
	src_rect = { 32 + 8, 32 - 8, 16, 8 };
	dst_rect = { 8, 0, max(width - 16, 1), 8 };
	down_bitmap->TiledBlit(8, 0, src_rect, *windowskin, dst_rect, 255);

	// Upper left corner
	up_bitmap->Blit(0, 0, *windowskin, Rect(32, 0, 8, 8), 255);

	// Upper right corner
	up_bitmap->Blit(width - 8, 0, *windowskin, Rect(64 - 8, 0, 8, 8), 255);

	// Lower left corner
	down_bitmap->Blit(0, 0, *windowskin, Rect(32, 32 - 8, 8, 8), 255);

	// Lower right corner
	down_bitmap->Blit(width - 8, 0, *windowskin, Rect(64 - 8, 32 - 8, 8, 8), 255);

	frame_up = up_bitmap;
	frame_down = down_bitmap;

	if (height > 16) {
		BitmapRef left_bitmap = Bitmap::Create(8, height - 16);
		BitmapRef right_bitmap = Bitmap::Create(8, height - 16);

		// Border Left
		src_rect = { 32, 8, 8, 16 };
		dst_rect = { 0, 0, 8, height - 16 };
		left_bitmap->TiledBlit(0, 8, src_rect, *windowskin, dst_rect, 255);

		// Border Right
		src_rect = { 64 - 8, 8, 8, 16 };
		dst_rect = { 0, 0, 8, height - 16 };
		right_bitmap->TiledBlit(0, 8, src_rect, *windowskin, dst_rect, 255);

		frame_left = left_bitmap;
		frame_right = right_bitmap;
	} else {
		frame_left = BitmapRef();
		frame_right = BitmapRef();
	}
}

void Window::RefreshCursor() {
	cursor_needs_refresh = false;

	int cw = cursor_rect.width;
	int ch = cursor_rect.height;

	BitmapRef cursor1_bitmap = Bitmap::Create(cw, ch);
	BitmapRef cursor2_bitmap = Bitmap::Create(cw, ch);

	cursor1_bitmap->Clear();
	cursor2_bitmap->Clear();

	Rect dst_rect;

	// Border Up
	dst_rect = { 8, 0, cw - 16, 8 };
	cursor1_bitmap->TiledBlit(8, 0, Rect(64 + 8, 0, 16, 8), *windowskin, dst_rect, 255);
	cursor2_bitmap->TiledBlit(8, 0, Rect(96 + 8, 0, 16, 8), *windowskin, dst_rect, 255);

	// Border Down
	dst_rect = { 8, ch - 8, cw - 16, 8 };
	cursor1_bitmap->TiledBlit(8, 0, Rect(64 + 8, 32 - 8, 16, 8), *windowskin, dst_rect, 255);
	cursor2_bitmap->TiledBlit(8, 0, Rect(96 + 8, 32 - 8, 16, 8), *windowskin, dst_rect, 255);

	// Border Left
	dst_rect = { 0, 8, 8, ch - 16 };
	cursor1_bitmap->TiledBlit(0, 8, Rect(64, 8, 8, 16), *windowskin, dst_rect, 255);
	cursor2_bitmap->TiledBlit(0, 8, Rect(96, 8, 8, 16), *windowskin, dst_rect, 255);

	// Border Right
	dst_rect = { cw - 8, 8, 8, ch - 16 };
	cursor1_bitmap->TiledBlit(0, 8, Rect(96 - 8, 8, 8, 16), *windowskin, dst_rect, 255);
	cursor2_bitmap->TiledBlit(0, 8, Rect(128 - 8, 8, 8, 16), *windowskin, dst_rect, 255);

	// Upper left corner
	cursor1_bitmap->Blit(0, 0, *windowskin, Rect(64, 0, 8, 8), 255);
	cursor2_bitmap->Blit(0, 0, *windowskin, Rect(96, 0, 8, 8), 255);

	// Upper right corner
	cursor1_bitmap->Blit(cw - 8, 0, *windowskin, Rect(96 - 8, 0, 8, 8), 255);
	cursor2_bitmap->Blit(cw - 8, 0, *windowskin, Rect(128 - 8, 0, 8, 8), 255);

	// Lower left corner
	cursor1_bitmap->Blit(0, ch - 8, *windowskin, Rect(64, 32 - 8, 8, 8), 255);
	cursor2_bitmap->Blit(0, ch - 8, *windowskin, Rect(96, 32 - 8, 8, 8), 255);

	// Lower right corner
	cursor1_bitmap->Blit(cw - 8, ch - 8, *windowskin, Rect(96 - 8, 32 - 8, 8, 8), 255);
	cursor2_bitmap->Blit(cw - 8, ch - 8, *windowskin, Rect(128 - 8, 32 - 8, 8, 8), 255);

	// Background
	dst_rect = { 8, 8, cw - 16, ch - 16 };
	cursor1_bitmap->TiledBlit(8, 8, Rect(64 + 8, 8, 16, 16), *windowskin, dst_rect, 255);
	cursor2_bitmap->TiledBlit(8, 8, Rect(96 + 8, 8, 16, 16), *windowskin, dst_rect, 255);

	cursor1 = cursor1_bitmap;
	cursor2 = cursor2_bitmap;
}

void Window::Update() {
	if (active) {
		cursor_frame += 1;
		if (cursor_frame > 20) cursor_frame = 0;
		if (pause || animate_arrows) {
			arrow_animation_frame = (arrow_animation_frame + 1) % (arrow_animation_frames * 2);
		}
	}

	if (animation_frames > 0) {
		// Open/Close Animation
		animation_frames -= 1;
		animation_count += animation_increment;
		if (closing && animation_frames <= 0) {
			SetVisible(false);
			closing = false;
		}
	}
}

void Window::SetWindowskin(BitmapRef const& nwindowskin) {
	if (windowskin == nwindowskin) {
		return;
	}

	background_needs_refresh = true;
	frame_needs_refresh = true;
	cursor_needs_refresh = true;
	windowskin = nwindowskin;
}

void Window::SetStretch(bool nstretch) {
	if (stretch != nstretch) background_needs_refresh = true;
	stretch = nstretch;
}

void Window::SetCursorRect(Rect const& ncursor_rect) {
	if (cursor_rect.width != ncursor_rect.width || cursor_rect.height != ncursor_rect.height) cursor_needs_refresh = true;
	cursor_rect = ncursor_rect;
}

void Window::SetWidth(int nwidth) {
	if (width != nwidth) {
		background_needs_refresh = true;
		frame_needs_refresh = true;
	}
	width = nwidth;
}

void Window::SetHeight(int nheight) {
	if (height != nheight) {
		background_needs_refresh = true;
		frame_needs_refresh = true;
	}
	height = nheight;
}




/*end of file .\window.cpp*/

/*start of file .\window_about.cpp*/

/* ... license chunk ... */

// Headers
#include <iomanip>
#include <sstream>
#include "window_about.h"
#include "game_party.h"
#include "bitmap.h"
#include "font.h"
#include "version.h"

Window_About::Window_About(int ix, int iy, int iwidth, int iheight) :
	Window_Base(ix, iy, iwidth, iheight) {

	SetContents(Bitmap::Create(width - 16, height - 16));
}

void Window_About::Refresh() {
	std::vector<std::string> about_msg = {
		"EasyRPG Player is a RPG Maker 2000/2003",
		"interpreter.",
		"Licensed under the GPLv3.",
		"",
		"v" + Version::GetVersionString(true, true),
		"",
		"Website: easyrpg.org",
		"Contact us: easyrpg.org/contact",
		"",
		"Bugs: github.com/EasyRPG/Player/issues",
		"Contribute: easyrpg.org/contribute",
	};

	for (size_t i = 0; i < about_msg.size(); ++i) {
		contents->TextDraw(0, 2 + 14 * i, Font::ColorDefault, about_msg[i]);
	}
}


/*end of file .\window_about.cpp*/

/*start of file .\window_actorinfo.cpp*/

/* ... license chunk ... */

// Headers
#include <iomanip>
#include <sstream>
#include "window_actorinfo.h"
#include "game_actors.h"
#include "game_party.h"
#include "bitmap.h"
#include "font.h"
#include "feature.h"

Window_ActorInfo::Window_ActorInfo(int ix, int iy, int iwidth, int iheight, const Game_Actor& actor) :
	Window_Base(ix, iy, iwidth, iheight),
	actor(actor) {

	SetContents(Bitmap::Create(width - 16, height - 16));

	Refresh();
}

void Window_ActorInfo::Refresh() {
	contents->Clear();

	DrawInfo();
}

void Window_ActorInfo::DrawInfo() {
	if (Feature::HasRow()) {
		// Draw Row formation.
		std::string battle_row = actor.GetBattleRow() == Game_Actor::RowType::RowType_back ? lcf::rpg::Terms::TermOrDefault(lcf::Data::terms.easyrpg_status_scene_back, "Back") : lcf::rpg::Terms::TermOrDefault(lcf::Data::terms.easyrpg_status_scene_front, "Front");
		contents->TextDraw(contents->GetWidth(), 2, Font::ColorDefault, battle_row, Text::AlignRight);
	}

	// Draw Face
	DrawActorFace(actor, 0, 0);

	// Draw Name
	contents->TextDraw(0, 50, 1, lcf::rpg::Terms::TermOrDefault(lcf::Data::terms.easyrpg_status_scene_name, "Name"));
	DrawActorName(actor, 36, 66);

	// Draw Profession
	contents->TextDraw(0, 82, 1, lcf::rpg::Terms::TermOrDefault(lcf::Data::terms.easyrpg_status_scene_class, "Class"));
	DrawActorClass(actor, 36, 98);

	// Draw Rank
	contents->TextDraw(0, 114, 1, lcf::rpg::Terms::TermOrDefault(lcf::Data::terms.easyrpg_status_scene_title, "Title"));
	DrawActorTitle(actor, 36, 130);

	// Draw Status
	contents->TextDraw(0, 146, 1, lcf::rpg::Terms::TermOrDefault(lcf::Data::terms.easyrpg_status_scene_condition, "State"));
	DrawActorState(actor, 36, 162);

	//Draw Level
	contents->TextDraw(0, 178, 1, lcf::Data::terms.level);
	contents->TextDraw(78, 178, Font::ColorDefault, std::to_string(actor.GetLevel()), Text::AlignRight);
}


/*end of file .\window_actorinfo.cpp*/

/*start of file .\window_actorsp.cpp*/

/* ... license chunk ... */

// Headers
#include "window_actorsp.h"
#include "bitmap.h"
#include "font.h"

Window_ActorSp::Window_ActorSp(int ix, int iy, int iwidth, int iheight) :
	Window_Base(ix, iy, iwidth, iheight) {

	SetContents(Bitmap::Create(width - 16, height - 16));

	contents->Clear();
}

void Window_ActorSp::SetBattler(const Game_Battler& battler) {
	int cx = 0;

	int digits = (battler.MaxSpValue() >= 1000) ? 4 : 3;

	int color = Font::ColorDefault;
	if (battler.GetMaxSp() != 0 && battler.GetSp() <= battler.GetMaxSp() / 4) {
		color = Font::ColorCritical;
	}

	contents->Clear();

	// Draw current Sp
	contents->TextDraw(cx + digits * 6, 2, color, std::to_string(battler.GetSp()), Text::AlignRight);

	// Draw /
	cx += digits * 6;
	contents->TextDraw(cx, 2, Font::ColorDefault, "/");

	// Draw Max Sp
	cx += 6;
	contents->TextDraw(cx + digits * 6, 2, Font::ColorDefault, std::to_string(battler.GetMaxSp()), Text::AlignRight);
}


/*end of file .\window_actorsp.cpp*/

/*start of file .\window_actorstatus.cpp*/

/* ... license chunk ... */

// Headers
#include <iomanip>
#include <sstream>
#include "window_actorstatus.h"
#include "game_actors.h"
#include "game_party.h"
#include "bitmap.h"
#include "font.h"

Window_ActorStatus::Window_ActorStatus(int ix, int iy, int iwidth, int iheight, const Game_Actor& actor) :
	Window_Base(ix, iy, iwidth, iheight),
	actor(actor) {

	SetContents(Bitmap::Create(width - 16, height - 16));

	Refresh();
}

void Window_ActorStatus::Refresh() {
	contents->Clear();

	DrawStatus();
}

void Window_ActorStatus::DrawStatus() {
	int have, max;
	auto fontcolor = [&have, &max](bool can_knockout) {
		if (can_knockout && have == 0) return Font::ColorKnockout;
		if (max > 0 && (have <= max / 4)) return Font::ColorCritical;
		return Font::ColorDefault;
	};

	// Draw Hp
	contents->TextDraw(1, 2, 1, lcf::Data::terms.health_points);
	have = actor.GetHp();
	max = actor.GetMaxHp();
	DrawMinMax(90, 2, have, max, fontcolor(true));

	// Draw Sp
	contents->TextDraw(1, 18, 1, lcf::Data::terms.spirit_points);
	have = actor.GetSp();
	max = actor.GetMaxSp();
	DrawMinMax(90, 18, have, max, fontcolor(false));

	// Draw Exp
	contents->TextDraw(1, 34, 1, lcf::Data::terms.exp_short);
	DrawMinMax(90, 34, -1, -1);
}

void Window_ActorStatus::DrawMinMax(int cx, int cy, int min, int max, int color) {
	std::stringstream ss;
	if (max >= 0) {
		ss << min;
	} else {
		ss << actor.GetExpString(true);
	}
	contents->TextDraw(cx, cy, color, ss.str(), Text::AlignRight);
	contents->TextDraw(cx, cy, Font::ColorDefault, "/");
	ss.str("");
	if (max >= 0) {
		ss << max;
	} else {
		ss << actor.GetNextExpString(true);
	}
	contents->TextDraw(cx + 48, cy, Font::ColorDefault, ss.str(), Text::AlignRight);
}


/*end of file .\window_actorstatus.cpp*/

/*start of file .\window_actortarget.cpp*/

/* ... license chunk ... */

// Headers
#include "window_actortarget.h"
#include "game_actor.h"
#include "game_party.h"
#include "bitmap.h"
#include "player.h"

Window_ActorTarget::Window_ActorTarget(int ix, int iy, int iwidth, int iheight) :
	Window_Selectable(ix, iy, iwidth, iheight) {

	SetContents(Bitmap::Create(width - 16, height - 16));

	Refresh();
}

void Window_ActorTarget::Refresh() {
	contents->Clear();

	item_max = Main_Data::game_party->GetActors().size();

	int y = 0;
	for (int i = 0; i < item_max; ++i) {
		const Game_Actor& actor = *(Main_Data::game_party->GetActors()[i]);

		DrawActorFace(actor, 0, i * 48 + y);
		DrawActorName(actor, 48 + 8, i * 48 + 2 + y);
		DrawActorLevel(actor, 48 + 8, i * 48 + 2 + 16 + y);
		DrawActorState(actor, 48 + 8, i * 48 + 2 + 16 + 16 + y);
		int digits = (actor.MaxHpValue() >= 1000 || actor.MaxSpValue() >= 1000) ? 4 : 3;
		int x_offset = 48 + 8 + 46 + (digits == 3 ? 12 : 0);
		DrawActorHp(actor, x_offset, i * 48 + 2 + 16 + y, digits);
		DrawActorSp(actor, x_offset, i * 48 + 2 + 16 + 16 + y, digits);

		y += 10;
	}
}

void Window_ActorTarget::UpdateCursorRect() {
	if (index < -10) { // Entire Party
		cursor_rect = { 48 + 4, 0, 120, item_max * (48 + 10) - 10 };
	} else if (index < 0) { // Fixed to one
		cursor_rect = { 48 + 4, (-index - 1) * (48 + 10), 120, 48 };
	} else {
		cursor_rect = { 48 + 4, index * (48 + 10), 120, 48 };
	}
}

Game_Actor* Window_ActorTarget::GetActor() {
	int ind = GetIndex();
	if (ind >= -10 && ind < 0) {
		ind = -ind - 1;
	}
	else if (ind == -100) {
		return nullptr;
	}

	return &(*Main_Data::game_party)[ind];
}


/*end of file .\window_actortarget.cpp*/

/*start of file .\window_base.cpp*/

/* ... license chunk ... */

// Headers
#include <iomanip>
#include <sstream>
#include "window_base.h"
#include "cache.h"
#include <lcf/data.h>
#include "game_system.h"
#include "bitmap.h"
#include "font.h"
#include "player.h"

Window_Base::Window_Base(int x, int y, int width, int height, Drawable::Flags flags)
	: Window(flags)
{
	SetWindowskin(Cache::SystemOrBlack());

	SetX(x);
	SetY(y);
	SetWidth(width);
	SetHeight(height);
	SetStretch(Main_Data::game_system->GetMessageStretch() == lcf::rpg::System::Stretch_stretch);
	SetZ(Priority_Window);

	if (Player::IsRPG2k()) {
		SetBackgroundPreserveTransparentColor(true);
	}
}

bool Window_Base::InitMovement(int old_x, int old_y, int new_x, int new_y, int duration) {
	current_frame = 0;
	old_position[0] = old_x;
	old_position[1] = old_y;
	new_position[0] = new_x;
	new_position[1] = new_y;
	SetX(old_position[0]);
	SetY(old_position[1]);
	total_frames = 0;
	if (old_x != new_x || old_y != new_y) {
		total_frames = duration;
		return true;
	}
	return false;
}

bool Window_Base::IsMovementActive() {
	return total_frames > 0 && current_frame <= total_frames;
}

void Window_Base::Update() {
	Window::Update();
	if (IsSystemGraphicUpdateAllowed()) {
		SetWindowskin(Cache::SystemOrBlack(GetBackgroundPreserveTransparentColor()));
		SetStretch(Main_Data::game_system->GetMessageStretch() == lcf::rpg::System::Stretch_stretch);
	}
	UpdateMovement();
}

void Window_Base::UpdateMovement() {
	if (!IsMovementActive()) {
		return;
	}
	current_frame++;
	if (IsMovementActive()) {
		SetX(old_position[0] + (new_position[0] - old_position[0]) * current_frame / total_frames);
		SetY(old_position[1] + (new_position[1] - old_position[1]) * current_frame / total_frames);
	} else {
		SetX(new_position[0]);
		SetY(new_position[1]);
	}
}

void Window_Base::OnFaceReady(FileRequestResult* result, int face_index, int cx, int cy, bool flip) {
	BitmapRef faceset = Cache::Faceset(result->file);

	Rect src_rect(
		(face_index % 4) * 48,
		face_index / 4 * 48,
		48,
		48
		);

	if (flip) {
		contents->FlipBlit(cx, cy, *faceset, src_rect, true, false, Opacity::Opaque());
	}
	else {
		contents->Blit(cx, cy, *faceset, src_rect, 255);
	}
}

// All these functions assume that the input is valid

void Window_Base::DrawFace(std::string_view face_name, int face_index, int cx, int cy, bool flip) {
	if (face_name.empty()) { return; }

	FileRequestAsync* request = AsyncHandler::RequestFile("FaceSet", face_name);
	request->SetGraphicFile(true);
	face_request_ids.push_back(request->Bind(&Window_Base::OnFaceReady, this, face_index, cx, cy, flip));
	request->Start();
}

void Window_Base::DrawActorFace(const Game_Actor& actor, int cx, int cy) {
	DrawFace(actor.GetFaceName(), actor.GetFaceIndex(), cx, cy);
}

void Window_Base::DrawActorName(const Game_Battler& actor, int cx, int cy) const {
	contents->TextDraw(cx, cy, Font::ColorDefault, actor.GetName());
}

void Window_Base::DrawActorTitle(const Game_Actor& actor, int cx, int cy) const {
	contents->TextDraw(cx, cy, Font::ColorDefault, actor.GetTitle());
}

void Window_Base::DrawActorClass(const Game_Actor& actor, int cx, int cy) const {
	contents->TextDraw(cx, cy, Font::ColorDefault, actor.GetClassName());
}

void Window_Base::DrawActorLevel(const Game_Actor& actor, int cx, int cy) const {
	// Draw LV-String
	contents->TextDraw(cx, cy, 1, lcf::Data::terms.lvl_short);

	// Draw Level of the Actor
	contents->TextDraw(cx + (lcf::Data::system.easyrpg_max_level >= 100 ? 30 : 24), cy, Font::ColorDefault, std::to_string(actor.GetLevel()), Text::AlignRight);
}

void Window_Base::DrawActorState(const Game_Battler& actor, int cx, int cy) const {
	// Unit has Normal state if no state is set
	const lcf::rpg::State* state = actor.GetSignificantState();
	if (!state) {
		contents->TextDraw(cx, cy, Font::ColorDefault, lcf::Data::terms.normal_status);
	} else {
		contents->TextDraw(cx, cy, state->color, state->name);
	}
}

void Window_Base::DrawActorExp(const Game_Actor& actor, int cx, int cy) const {
	// Draw EXP-String
	int width = 7;
	if (actor.MaxExpValue() < 1000000) {
		width = 6;
		contents->TextDraw(cx, cy, 1, lcf::Data::terms.exp_short);
	}

	// Current Exp of the Actor
	// ------/------
	std::stringstream ss;
	ss << std::setfill(' ') << std::setw(width) << actor.GetExpString();

	// Delimiter
	ss << '/';

	// Exp for Level up
	ss << std::setfill(' ') << std::setw(width) << actor.GetNextExpString();
	contents->TextDraw(cx + (width == 6 ? 12 : 0), cy, Font::ColorDefault, ss.str(), Text::AlignLeft);
}

void Window_Base::DrawActorHp(const Game_Battler& actor, int cx, int cy, int digits, bool draw_max) const {
	// Draw HP-String
	contents->TextDraw(cx, cy, 1, lcf::Data::terms.hp_short);

	// Draw Current HP of the Actor
	cx += 12;
	// Color: 0 okay, 4 critical, 5 dead
	int color = GetValueFontColor(actor.GetHp(), actor.GetMaxHp(), true);
	auto dx = digits * 6;
	contents->TextDraw(cx + dx, cy, color, std::to_string(actor.GetHp()), Text::AlignRight);

	if (!draw_max)
		return;

	// Draw the /
	cx += dx;
	contents->TextDraw(cx, cy, Font::ColorDefault, "/");

	// Draw Max Hp
	cx += 6;
	contents->TextDraw(cx + dx, cy, Font::ColorDefault, std::to_string(actor.GetMaxHp()), Text::AlignRight);
}

void Window_Base::DrawActorSp(const Game_Battler& actor, int cx, int cy, int digits, bool draw_max) const {
	// Draw SP-String
	contents->TextDraw(cx, cy, 1, lcf::Data::terms.sp_short);

	// Draw Current SP of the Actor
	cx += 12;
	// Color: 0 okay, 4 critical/empty
	int color = GetValueFontColor(actor.GetSp(), actor.GetMaxSp(), false);
	auto dx = digits * 6;
	contents->TextDraw(cx + dx, cy, color, std::to_string(actor.GetSp()), Text::AlignRight);

	if (!draw_max)
		return;

	// Draw the /
	cx += dx;
	contents->TextDraw(cx, cy, Font::ColorDefault, "/");

	// Draw Max Sp
	cx += 6;
	contents->TextDraw(cx + dx, cy, Font::ColorDefault, std::to_string(actor.GetMaxSp()), Text::AlignRight);
}

void Window_Base::DrawActorParameter(const Game_Battler& actor, int cx, int cy, int type) const {
	std::string_view name;
	int value;

	switch (type) {
	case 0:
		name = lcf::Data::terms.attack;
		value = actor.GetAtk();
		break;
	case 1:
		name = lcf::Data::terms.defense;
		value = actor.GetDef();
		break;
	case 2:
		name = lcf::Data::terms.spirit;
		value = actor.GetSpi();
		break;
	case 3:
		name = lcf::Data::terms.agility;
		value = actor.GetAgi();
		break;
	default:
		return;
	}

	// Draw Term
	contents->TextDraw(cx, cy, 1, name);

	// Draw Value
	contents->TextDraw(cx + 78, cy, Font::ColorDefault, std::to_string(value), Text::AlignRight);
}

void Window_Base::DrawEquipmentType(const Game_Actor& actor, int cx, int cy, int type) const {
	std::string_view name;

	switch (type) {
	case 0:
		name = lcf::Data::terms.weapon;
		break;
	case 1:
		if (actor.HasTwoWeapons()) {
			name = lcf::Data::terms.weapon;
		} else {
			name = lcf::Data::terms.shield;
		}
		break;
	case 2:
		name = lcf::Data::terms.armor;
		break;
	case 3:
		name = lcf::Data::terms.helmet;
		break;
	case 4:
		name = lcf::Data::terms.accessory;
		break;
	default:
		return;
	}

	contents->TextDraw(cx, cy, 1, name);
}

void Window_Base::DrawItemName(const lcf::rpg::Item& item, int cx, int cy, bool enabled) const {
	int color = enabled ? Font::ColorDefault : Font::ColorDisabled;

	contents->TextDraw(cx, cy, color, item.name);
}

void Window_Base::DrawSkillName(const lcf::rpg::Skill& skill, int cx, int cy, bool enabled) const {
	int color = enabled ? Font::ColorDefault : Font::ColorDisabled;

	contents->TextDraw(cx, cy, color, skill.name);
}

void Window_Base::DrawCurrencyValue(int money, int cx, int cy) const {
	// This function draws right aligned because of the dynamic with of the
	// gold output (cx and cy define the right border)
	std::stringstream gold;
	gold << money;

	Rect gold_text_size = Text::GetSize(*Font::Default(), lcf::Data::terms.gold);
	contents->TextDraw(cx, cy, 1, lcf::Data::terms.gold, Text::AlignRight);

	contents->TextDraw(cx - gold_text_size.width, cy, Font::ColorDefault, gold.str(), Text::AlignRight);
}

void Window_Base::DrawGauge(const Game_Battler& actor, int cx, int cy, int alpha) const {
	BitmapRef system2 = Cache::System2();
	if (!system2) {
		return;
	}

	bool full = actor.IsAtbGaugeFull();

	// Which gauge (0 - 2)
	int gauge_y = 32 + 2 * 16;

	// Three components of the gauge
	Rect gauge_left(0, gauge_y, 16, 16);
	Rect gauge_center(16, gauge_y, 16, 16);
	Rect gauge_right(32, gauge_y, 16, 16);

	Rect dst_rect(cx + 16, cy, 25, 16);

	contents->Blit(cx + 0, cy, *system2, gauge_left, alpha);
	contents->Blit(cx + 16 + 25, cy, *system2, gauge_right, alpha);
	contents->StretchBlit(dst_rect, *system2, gauge_center, alpha);

	const auto atb = actor.GetAtbGauge();
	const auto gauge_w = 25 * atb / actor.GetMaxAtbGauge();
	if (gauge_w > 0) {
		// Full or not full bar
		Rect gauge_bar(full ? 64 : 48, gauge_y, 16, 16);
		Rect bar_rect(cx + 16, cy, gauge_w, 16);
		contents->StretchBlit(bar_rect, *system2, gauge_bar, alpha);
	}
}

void Window_Base::DrawActorHpValue(const Game_Battler& actor, int cx, int cy) const {
	contents->TextDraw(cx, cy, GetValueFontColor(actor.GetHp(), actor.GetMaxHp(), true), std::to_string(actor.GetHp()), Text::AlignRight);
}

void Window_Base::DrawActorSpValue(const Game_Battler& actor, int cx, int cy) const {
	contents->TextDraw(cx, cy, GetValueFontColor(actor.GetSp(), actor.GetMaxSp(), false), std::to_string(actor.GetSp()), Text::AlignRight);
}

int Window_Base::GetValueFontColor(int have, int max, bool can_knockout) const {
	if (can_knockout && have == 0) return Font::ColorKnockout;
	if (max > 0 && (have <= max / 4)) return Font::ColorCritical;
	return Font::ColorDefault;
}


/*end of file .\window_base.cpp*/

/*start of file .\window_battlemessage.cpp*/

/* ... license chunk ... */

// Headers
#include <sstream>
#include "game_message.h"
#include "player.h"
#include "window_battlemessage.h"
#include "bitmap.h"
#include "font.h"
#include "utils.h"
#include "output.h"
#include "feature.h"

Window_BattleMessage::Window_BattleMessage(int ix, int iy, int iwidth, int iheight) :
	Window_Base(ix, iy, iwidth, iheight)
{
	SetContents(Bitmap::Create(width - 20, height - 16));

	SetVisible(false);
	// Above other windows but below the messagebox
	SetZ(Priority_Window + 50);
}

void Window_BattleMessage::Push(std::string_view message) {
#ifdef EP_DEBUG_BATTLE2K_MESSAGE
	Output::Debug("Battle2k Message Push \"{}\"", message);
#endif
	Utils::ForEachLine(message, [this](std::string_view line)
			{ PushLine(line); });
}

void Window_BattleMessage::PushLine(std::string_view line) {
	if (Feature::HasPlaceholders()) {
		Game_Message::WordWrap(
				line,
				GetWidth() - 20,
				[this](std::string_view wrap_line) {
					lines.push_back(std::string(wrap_line));
				}
				);
	}
	else {
		lines.push_back(std::string(line));
	}

	needs_refresh = true;
}

void Window_BattleMessage::PushWithSubject(std::string_view message, std::string_view subject) {
	if (Feature::HasPlaceholders()) {
		Push(Utils::ReplacePlaceholders(
			message,
			Utils::MakeArray('S'),
			Utils::MakeSvArray(subject)
		));
	}
	else {
		Push(std::string(subject) + std::string(message));
	}
	needs_refresh = true;
}

void Window_BattleMessage::Pop() {
#ifdef EP_DEBUG_BATTLE2K_MESSAGE
	Output::Debug("Battle2k Message Pop");
#endif
	lines.pop_back();
	needs_refresh = true;
	if (GetIndex() > (int)lines.size()) {
		SetIndex(lines.size());
	}
}

void Window_BattleMessage::PopUntil(int line_number) {
#ifdef EP_DEBUG_BATTLE2K_MESSAGE
	Output::Debug("Battle2k Message PopUntil {}", line_number);
#endif
	while (static_cast<int>(lines.size()) > line_number) {
		lines.pop_back();
	}
	needs_refresh = true;
}

void Window_BattleMessage::Clear() {
#ifdef EP_DEBUG_BATTLE2K_MESSAGE
	Output::Debug("Battle2k Message Clear");
#endif
	lines.clear();
	SetIndex(0);
	needs_refresh = true;
}

void Window_BattleMessage::ScrollToEnd() {
	const auto old_index = index;
	if (lines.size() > linesPerPage) {
		index = lines.size() - linesPerPage;
	} else {
		index = 0;
	}
	needs_refresh |= (index != old_index);
}

void Window_BattleMessage::Refresh() {
	contents->Clear();

	int i = GetIndex();
	const auto ed = std::min(i + linesPerPage, (int)lines.size());
	int y = 2;
	for (; i < ed; ++i) {
		contents->TextDraw(0, y, Font::ColorDefault, lines[i]);
		y+= 16;
	}
	needs_refresh = false;
}

void Window_BattleMessage::Update() {
	Window_Base::Update();
	if (needs_refresh) {
		Refresh();
	}
}

int Window_BattleMessage::GetLineCount() {
	return (int)lines.size();
}

bool Window_BattleMessage::IsPageFilled() {
	return (lines.size() - GetIndex()) >= linesPerPage;
}


/*end of file .\window_battlemessage.cpp*/

/*start of file .\window_battlestatus.cpp*/

/* ... license chunk ... */

// Headers
#include <algorithm>
#include "bitmap.h"
#include "cache.h"
#include "input.h"
#include "game_enemyparty.h"
#include "game_party.h"
#include "game_actor.h"
#include "game_system.h"
#include "game_battle.h"
#include "player.h"
#include "font.h"
#include "output.h"
#include "window_battlestatus.h"
#include "feature.h"

Window_BattleStatus::Window_BattleStatus(int ix, int iy, int iwidth, int iheight, bool enemy) :
	Window_Selectable(ix, iy, iwidth, iheight), mode(ChoiceMode_All), enemy(enemy) {

	SetBorderX(4);

	SetContents(Bitmap::Create(width - 8, height - 16));

	if (Player::IsRPG2k3() && lcf::Data::battlecommands.window_size == lcf::rpg::BattleCommands::WindowSize_small) {
		height = 68;
		menu_item_height = 14;
		actor_face_height = 17;
		SetBorderY(5);
		SetContents(Bitmap::Create(width - 8, height - 10));
	}

	index = -1;

	if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_gauge) {
		// Simulate a borderless window
		// Doing it this way for gauge style makes the implementation on
		// scene-side easier
		border_x = 0;
		border_y = 0;
		SetContents(Bitmap::Create(width, height));
		SetOpacity(0);
	}

	Refresh();
}

void Window_BattleStatus::Refresh() {
	contents->Clear();

	if (enemy) {
		item_max = Main_Data::game_enemyparty->GetBattlerCount();
	}
	else {
		item_max = Main_Data::game_party->GetBattlerCount();
	}

	item_max = std::min(item_max, 4);

	for (int i = 0; i < item_max; i++) {
		// The party only contains valid battlers
		const Game_Battler* actor;
		if (enemy) {
			actor = &(*Main_Data::game_enemyparty)[i];
		}
		else {
			actor = &(*Main_Data::game_party)[i];
		}

		if (!enemy && lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_gauge) {
			DrawActorFace(*static_cast<const Game_Actor*>(actor), 80 * i, actor_face_height);
		}
		else {
			int y = menu_item_height / 8 + i * menu_item_height;

			DrawActorName(*actor, 4, y);
			if (Feature::HasRpg2kBattleSystem()) {
				int hpdigits = (actor->MaxHpValue() >= 1000) ? 4 : 3;
				int spdigits = (actor->MaxSpValue() >= 1000) ? 4 : 3;
				DrawActorState(*actor, (hpdigits < 4 && spdigits < 4) ? 86 : 80, y);
				DrawActorHp(*actor, 178 - hpdigits * 6 - spdigits * 6, y, hpdigits, true);
				DrawActorSp(*actor, 220 - spdigits * 6, y, spdigits, false);
			} else {
				if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_traditional) {
					DrawActorState(*actor, 84, y);
					DrawActorHpValue(*actor, 136 + 4 * 6, y);
				} else {
					DrawActorState(*actor, 80, y);
				}
			}
		}
	}

	RefreshGauge();
}

void Window_BattleStatus::RefreshGauge() {
	if (Feature::HasRpg2k3BattleSystem()) {
		if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_alternative) {
			if (lcf::Data::battlecommands.window_size == lcf::rpg::BattleCommands::WindowSize_small) {
				contents->ClearRect(Rect(192, 0, 45, 58));
			} else {
				contents->ClearRect(Rect(192, 0, 45, 64));
			}
		}

		for (int i = 0; i < item_max; ++i) {
			// The party always contains valid battlers
			Game_Battler* actor;
			if (enemy) {
				actor = &(*Main_Data::game_enemyparty)[i];
			}
			else {
				actor = &(*Main_Data::game_party)[i];
			}

			if (!enemy && lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_gauge) {
				BitmapRef system2 = Cache::System2();
				if (system2) {
					// Clear number and gauge drawing area
					contents->ClearRect(Rect(40 + 80 * i, actor_face_height, 8 * 4, 48));

					// Number clearing removed part of the face, but both, clear and redraw
					// are needed because some games don't have face graphics that are huge enough
					// to clear the number area (e.g. Ara Fell)
					DrawActorFace(*static_cast<const Game_Actor*>(actor), 80 * i, actor_face_height);

					int x = 32 + i * 80;
					int y = actor_face_height;

					// Left Gauge
					contents->Blit(x, y, *system2, Rect(0, 32, 16, 48), Opacity::Opaque());
					x += 16;

					// Center
					const auto fill_x = x;
					contents->StretchBlit(Rect(x, y, 25, 48), *system2, Rect(16, 32, 16, 48), Opacity::Opaque());
					x += 25;

					// Right
					contents->Blit(x, y, *system2, Rect(32, 32, 16, 48), Opacity::Opaque());

					// HP
					DrawGaugeSystem2(fill_x, y, actor->GetHp(), actor->GetMaxHp(), 0);
					// SP
					DrawGaugeSystem2(fill_x, y + 16, actor->GetSp(), actor->GetMaxSp(), 1);
					// Gauge
					DrawGaugeSystem2(fill_x, y + 16 * 2, actor->GetAtbGauge(), actor->GetMaxAtbGauge(), 2);

					// Numbers
					x = 40 + 80 * i;
					DrawNumberSystem2(x, y, actor->GetHp());
					DrawNumberSystem2(x, y + 12 + 4, actor->GetSp());
				}
			}
			else {
				int y = menu_item_height / 8 + i * menu_item_height;

				if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_alternative) {
					// RPG_RT Bug (?): Gauge hidden when selected due to transparency (wrong color when rendering)
					if (lcf::Data::battlecommands.transparency == lcf::rpg::BattleCommands::Transparency_opaque || (menu_item_height / 8 + index * menu_item_height != y)) {
						DrawGauge(*actor, 202 - 10, y - 2, lcf::Data::battlecommands.transparency == lcf::rpg::BattleCommands::Transparency_opaque ? 96 : 255);
					}
					int hpdigits = (actor->MaxHpValue() >= 1000) ? 4 : 3;
					int spdigits = (actor->MaxSpValue() >= 1000) ? 4 : 3;
					DrawActorHp(*actor, 178 - hpdigits * 6 - spdigits * 6, y, hpdigits, true);
					DrawActorSp(*actor, 220 - spdigits * 6, y, spdigits, false);
				} else {
					DrawGauge(*actor, 156, y - 2);
				}
			}
		}
	}
}

void Window_BattleStatus::DrawGaugeSystem2(int x, int y, int cur_value, int max_value, int which) {
	BitmapRef system2 = Cache::System2();
	assert(system2);

	if (max_value == 0) {
		return;
	}

	int gauge_x;
	if (cur_value == max_value) {
		gauge_x = 16;
	}
	else {
		gauge_x = 0;
	}

	int gauge_width = 25;

	if (max_value > 0) {
		gauge_width = 25 * cur_value / max_value;
	}

	contents->StretchBlit(Rect(x, y, gauge_width, 16), *system2, Rect(48 + gauge_x, 32 + 16 * which, 16, 16), Opacity::Opaque());
}

void Window_BattleStatus::DrawNumberSystem2(int x, int y, int value) {
	BitmapRef system2 = Cache::System2();
	assert(system2);

	bool handle_zero = false;

	if (value >= 1000) {
		contents->Blit(x, y, *system2, Rect((value / 1000) * 8, 80, 8, 16), Opacity::Opaque());
		value %= 1000;
		if (value < 100) {
			handle_zero = true;
		}
	}
	if (handle_zero || value >= 100) {
		handle_zero = false;
		contents->Blit(x + 8, y, *system2, Rect((value / 100) * 8, 80, 8, 16), Opacity::Opaque());
		value %= 100;
		if (value < 10) {
			handle_zero = true;
		}
	}
	if (handle_zero || value >= 10) {
		contents->Blit(x + 8 * 2, y, *system2, Rect((value / 10) * 8, 80, 8, 16), Opacity::Opaque());
		value %= 10;
	}

	contents->Blit(x + 8 * 3, y, *system2, Rect(value * 8, 80, 8, 16), Opacity::Opaque());
}

int Window_BattleStatus::ChooseActiveCharacter() {
	int old_index = index < 0 ? 0 : index;
	index = -1;
	for (int i = 0; i < item_max; i++) {
		int new_index = (old_index + i) % item_max;
		if ((*Main_Data::game_party)[new_index].IsAtbGaugeFull()) {
			index = new_index;
			return index;
		}
	}

	if (index != old_index)
		UpdateCursorRect();

	return index;
}

void Window_BattleStatus::SetChoiceMode(ChoiceMode new_mode) {
	mode = new_mode;
}

void Window_BattleStatus::Update() {
	// Window Selectable update logic skipped on purpose
	// (breaks up/down-logic)
	Window_Base::Update();

	int old_item_max = item_max;
	if (enemy) {
		item_max = Main_Data::game_enemyparty->GetBattlerCount();
	} else {
		item_max = Main_Data::game_party->GetBattlerCount();
	}

	if (item_max != old_item_max) {
		Refresh();
	} else if (Feature::HasRpg2k3BattleSystem()) {
		RefreshGauge();
	}

	if (active && index >= 0) {
		if (Input::IsRepeated(Input::DOWN) || Input::IsRepeated(Input::RIGHT) || Input::IsTriggered(Input::SCROLL_DOWN)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
			for (int i = 1; i < item_max; i++) {
				int new_index = (index + i) % item_max;
				if (IsChoiceValid((*Main_Data::game_party)[new_index])) {
					index = new_index;
					break;
				}
			}
		}
		if (Input::IsRepeated(Input::UP) || Input::IsRepeated(Input::LEFT) || Input::IsTriggered(Input::SCROLL_UP)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
			for (int i = item_max - 1; i > 0; i--) {
				int new_index = (index + i) % item_max;
				if (IsChoiceValid((*Main_Data::game_party)[new_index])) {
					index = new_index;
					break;
				}
			}
		}
	}

	UpdateCursorRect();
}

void Window_BattleStatus::UpdateCursorRect() {
	if (lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_gauge) {
		SetCursorRect(Rect());
		return;
	}

	if (index < 0)
		SetCursorRect(Rect());
	else
		SetCursorRect(Rect(0, index * menu_item_height, contents->GetWidth(), menu_item_height));
}

bool Window_BattleStatus::IsChoiceValid(const Game_Battler& battler) const {
	switch (mode) {
		case ChoiceMode_All:
			return true;
		case ChoiceMode_Alive:
			return !battler.IsDead();
		case ChoiceMode_Dead:
			return battler.IsDead();
		case ChoiceMode_Ready:
			return battler.IsAtbGaugeFull();
		case ChoiceMode_None:
			return false;
		default:
			assert(false && "Invalid Choice");
			return false;
	}
}

void Window_BattleStatus::RefreshActiveFromValid() {
	std::vector<Game_Battler*> battlers;
	if (enemy) {
		Main_Data::game_enemyparty->GetBattlers(battlers);
	} else {
		Main_Data::game_party->GetBattlers(battlers);
	}

	for (size_t i = 0; i < battlers.size(); ++i) {
		auto* battler = battlers[i];
		if (IsChoiceValid(*battler)) {
			if (!GetActive() || GetIndex() < 0) {
				SetIndex(i);
				SetActive(true);
			}
			return;
		}
		SetIndex(-1);
		SetActive(false);
	}
	UpdateCursorRect();
}


/*end of file .\window_battlestatus.cpp*/

/*start of file .\window_command.cpp*/

/* ... license chunk ... */

// Headers
#include "window_command.h"
#include "color.h"
#include "bitmap.h"
#include "util_macro.h"

static int CalculateWidth(const std::vector<std::string>& commands, int width) {
	if (width < 0) {
		int max = 0;
		for (size_t i = 0; i < commands.size(); ++i) {
			max = std::max(max, Text::GetSize(*Font::Default(), commands[i]).width);
		}
		return max + 16;
	} else {
		return width;
	}
}

Window_Command::Window_Command(std::vector<std::string> in_commands, int width, int max_item) :
	Window_Selectable(0, 0, CalculateWidth(in_commands, width), (max_item < 0 ? in_commands.size() : max_item) * 16 + 16)
{
	ReplaceCommands(std::move(in_commands));
}

void Window_Command::Refresh() {
	contents->Clear();
	for (int i = 0; i < item_max; i++) {
		DrawItem(i, IsItemEnabled(i) ? Font::ColorDefault : Font::ColorDisabled);
	}
}

void Window_Command::DrawItem(int index, Font::SystemColor color) {
	contents->ClearRect(Rect(0, menu_item_height * index, contents->GetWidth() - 0, menu_item_height));
	contents->TextDraw(0, menu_item_height * index + menu_item_height / 8, color, commands[index]);
}

void Window_Command::DisableItem(int i) {
	SetItemEnabled(i, false);
}

void Window_Command::EnableItem(int i) {
	SetItemEnabled(i, true);
}

void Window_Command::SetItemEnabled(int index, bool enabled) {
	DrawItem(index, enabled ? Font::ColorDefault : Font::ColorDisabled);
	commands_enabled[index] = enabled;
}

bool Window_Command::IsItemEnabled(int index) {
	if (index < 0 || index >= static_cast<int>(commands_enabled.size())) {
		return false;
	}

	return commands_enabled[index];
}

void Window_Command::SetItemText(unsigned index, std::string_view text) {
	if (index < commands.size()) {
		commands[index] = ToString(text);
		DrawItem(index, IsItemEnabled(index) ? Font::ColorDefault : Font::ColorDisabled);
	}
}

void Window_Command::ReplaceCommands(std::vector<std::string> in_commands) {
	commands = std::move(in_commands);
	commands_enabled.clear();
	commands_enabled.resize(commands.size(), true);
	index = 0;
	item_max = commands.size();
	const int num_contents = item_max > 0 ? item_max : 1;
	SetContents(Bitmap::Create(this->width - 16, num_contents * menu_item_height));
	SetTopRow(0);

	Refresh();
}


/*end of file .\window_command.cpp*/

/*start of file .\window_command_horizontal.cpp*/

/* ... license chunk ... */

// Headers
#include "window_command_horizontal.h"
#include "color.h"
#include "bitmap.h"
#include "util_macro.h"

static int CalculateWidth(const std::vector<std::string>& commands, int width) {
	if (width < 0) {
		width = 0;
		for (size_t i = 0; i < commands.size(); ++i) {
			width += std::max(width, Text::GetSize(*Font::Default(), commands[i]).width) + 16;
		}
	}
	return width;
}

Window_Command_Horizontal::Window_Command_Horizontal(std::vector<std::string> in_commands, int width) :
	Window_Command(in_commands, -1)
{
	SetWidth(CalculateWidth(in_commands, width));
	SetHeight(32);
	ReplaceCommands(std::move(in_commands));
}

void Window_Command_Horizontal::DrawItem(int index, Font::SystemColor color) {
	Rect rect = GetItemRect(index);

	contents->ClearRect(rect);
	contents->TextDraw(rect.x, rect.y, color, commands[index]);
}

void Window_Command_Horizontal::ReplaceCommands(std::vector<std::string> in_commands) {
	commands = std::move(in_commands);
	index = 0;
	SetItemMax(commands.size());
	const int num_contents = item_max > 0 ? item_max : 1;
	SetContents(Bitmap::Create(this->width - 16, num_contents * menu_item_height));
	SetTopRow(0);
	SetColumnMax(commands.size());

	Refresh();
}


/*end of file .\window_command_horizontal.cpp*/

/*start of file .\window_equip.cpp*/

/* ... license chunk ... */

// Headers
#include "window_equip.h"
#include "game_actors.h"
#include "bitmap.h"
#include <lcf/reader_util.h>
#include "output.h"

Window_Equip::Window_Equip(int ix, int iy, int iwidth, int iheight, const Game_Actor& actor) :
	Window_Selectable(ix, iy, iwidth, iheight),
	actor(actor) {

	SetContents(Bitmap::Create(width - 16, height - 16));

	index = 0;

	Refresh();
}

int Window_Equip::GetItemId() {
	return index < 0 ? 0 : data[index];
}

void Window_Equip::Refresh() {
	contents->Clear();

	// Add the equipment of the actor to data
	data.clear();
	for (int i = 1; i <= 5; ++i) {
		const lcf::rpg::Item* item = actor.GetEquipment(i);
		data.push_back(item ? item->ID : 0);
	}
	item_max = data.size();

	// Draw equipment text
	for (int i = 0; i < 5; ++i) {
		DrawEquipmentType(actor, 0, (12 + 4) * i + 2, i);
		if (data[i] > 0) {
			// Equipment and items are guaranteed to be valid
			DrawItemName(*lcf::ReaderUtil::GetElement(lcf::Data::items, data[i]), 60, (12 + 4) * i + 2);
		}
	}
}

void Window_Equip::UpdateHelp() {
	help_window->SetText(GetItemId() == 0 ? "" :
		ToString(lcf::ReaderUtil::GetElement(lcf::Data::items, GetItemId())->description));
}


/*end of file .\window_equip.cpp*/

/*start of file .\window_equipitem.cpp*/

/* ... license chunk ... */

// Headers
#include "window_equipitem.h"
#include "game_actors.h"
#include "game_party.h"
#include <lcf/reader_util.h>
#include "output.h"

Window_EquipItem::Window_EquipItem(int ix, int iy, int iwidth, int iheight, const Game_Actor& actor, int equip_type) :
	Window_Item(ix, iy, iwidth, iheight),
	actor(actor) {
	this->equip_type = equip_type;
	if (equip_type > 4 || equip_type < 0) {
		this->equip_type = Window_EquipItem::other;
	}

	if (this->equip_type == Window_EquipItem::shield &&
		actor.HasTwoWeapons()) {

		this->equip_type = Window_EquipItem::weapon;
	}
}

bool Window_EquipItem::CheckInclude(int item_id) {
	// Do not show equippable items if the actor has its equipment fixed
	if (actor.IsEquipmentFixed(false)) {
		return false;
	}

	// Add the empty element
	if (item_id == 0) {
		return true;
	}

	bool result = false;

	// Equipment and items are guaranteed to be valid
	lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);

	switch (equip_type) {
	case Window_EquipItem::weapon:
		result = item->type == lcf::rpg::Item::Type_weapon;
		break;
	case Window_EquipItem::shield:
		result = item->type == lcf::rpg::Item::Type_shield;
		break;
	case Window_EquipItem::armor:
		result = item->type == lcf::rpg::Item::Type_armor;
		break;
	case Window_EquipItem::helmet:
		result = item->type == lcf::rpg::Item::Type_helmet;
		break;
	case Window_EquipItem::other:
		result = item->type == lcf::rpg::Item::Type_accessory;
		break;
	default:
		return false;
	}

	if (result) {
		// Check if the party has the item at least once
		if (Main_Data::game_party->GetItemCount(item_id) == 0) {
			return false;
		} else {
			return actor.IsEquippable(item_id);
		}
	} else {
		return false;
	}
}

bool Window_EquipItem::CheckEnable(int item_id) {
	(void)item_id;
	return true;
}


/*end of file .\window_equipitem.cpp*/

/*start of file .\window_equipstatus.cpp*/

/* ... license chunk ... */

// Headers
#include <iomanip>
#include <sstream>
#include "game_actors.h"
#include "window_equipstatus.h"
#include "bitmap.h"
#include "font.h"
#include "player.h"

Window_EquipStatus::Window_EquipStatus(int ix, int iy, int iwidth, int iheight, const Game_Actor& actor) :
	Window_Base(ix, iy, iwidth, iheight),
	actor(actor),
	draw_params(false),
	dirty(true) {

	SetContents(Bitmap::Create(width - 16, height - 16));

	Refresh();
}

void Window_EquipStatus::Refresh() {
	if (dirty) {
		contents->Clear();

		int y_offset;

		y_offset = 18;
		// Actor data is guaranteed to be valid
		DrawActorName(actor, 0, 2);

		for (int i = 0; i < 4; ++i) {
			DrawParameter(0, y_offset + ((12 + 4) * i), i);
		}

		dirty = false;
	}
}

void Window_EquipStatus::SetNewParameters(
	int new_atk, int new_def, int new_spi, int new_agi) {
	draw_params = true;

	dirty = true;

	atk = new_atk;
	def = new_def;
	spi = new_spi;
	agi = new_agi;
}

void Window_EquipStatus::ClearParameters() {
	if (draw_params != false) {
		draw_params = false;
		dirty = true;
		Refresh();
	}
}

int Window_EquipStatus::GetNewParameterColor(int old_value, int new_value) {
	if (old_value == new_value) {
		return 0;
	} else if (old_value < new_value) {
		return 2;
	} else {
		return 3;
	}
}

void Window_EquipStatus::DrawParameter(int cx, int cy, int type) {
	std::string_view name;
	int value;
	int new_value;

	switch (type) {
	case 0:
		name = lcf::Data::terms.attack;
		value = actor.GetAtk();
		new_value = atk;
		break;
	case 1:
		name = lcf::Data::terms.defense;
		value = actor.GetDef();
		new_value = def;
		break;
	case 2:
		name = lcf::Data::terms.spirit;
		value = actor.GetSpi();
		new_value = spi;
		break;
	case 3:
		name = lcf::Data::terms.agility;
		value = actor.GetAgi();
		new_value = agi;
		break;
	default:
		return;
	}

	// Check if 4 digits are needed instead of 3
	int limit = actor.MaxStatBaseValue();
	bool more_space_needed = (Player::IsRPG2k3() && limit >= 500) || limit >= 1000;

	// Draw Term
	contents->TextDraw(cx, cy, 1, name);

	// Draw Value
	cx += (more_space_needed ? (8 * 6 + 6 * 4) : (10 * 6 + 6 * 3));
	contents->TextDraw(cx, cy, Font::ColorDefault, std::to_string(value), Text::AlignRight);

	if (draw_params) {
		if (lcf::Data::terms.easyrpg_equipment_arrow == lcf::Data::terms.kDefaultTerm) {
			if (Player::IsCP932()) {
				// Draw fullwidth arrow
				contents->TextDraw(cx, cy, 1, "→");
			} else {
				// Draw arrow (+3 for center between the two numbers)
				contents->TextDraw(cx + 3, cy, 1, ">");
			}
		} else {
			// Draw arrow
			int offset = (12 - Text::GetSize(*Font::Default(), lcf::Data::terms.easyrpg_equipment_arrow).width) / 2;
			contents->TextDraw(cx + offset, cy, 1, lcf::Data::terms.easyrpg_equipment_arrow);
		}

		// Draw New Value
		cx += 6 * 2 + (more_space_needed ? (6 * 4) : (6 * 3));
		int color = GetNewParameterColor(value, new_value);
		contents->TextDraw(cx, cy, color, std::to_string(new_value), Text::AlignRight);
	}
}


/*end of file .\window_equipstatus.cpp*/

/*start of file .\window_face.cpp*/

/* ... license chunk ... */

// Headers
#include "bitmap.h"
#include "game_actors.h"
#include "window_face.h"

Window_Face::Window_Face(int ix, int iy, int iwidth, int iheight) :
	Window_Base(ix, iy, iwidth, iheight) {

	SetContents(Bitmap::Create(width - 16, height - 16));
}

void Window_Face::Refresh() {
	contents->Clear();
	// Actor data is guaranteed to be valid
	DrawActorFace(*actor, 0, 0);
}

void Window_Face::Set(const Game_Actor& actor) {
	this->actor = &actor;
	Refresh();
}


/*end of file .\window_face.cpp*/

/*start of file .\window_gamelist.cpp*/

/* ... license chunk ... */

// Headers
#include "window_gamelist.h"
#include "filefinder.h"
#include "bitmap.h"
#include "font.h"
#include "system.h"

Window_GameList::Window_GameList(int ix, int iy, int iwidth, int iheight) :
	Window_Selectable(ix, iy, iwidth, iheight) {
	column_max = 1;
}

bool Window_GameList::Refresh(FilesystemView filesystem_base, bool show_dotdot) {
	base_fs = filesystem_base;
	if (!base_fs) {
		return false;
	}

	game_entries.clear();

	this->show_dotdot = show_dotdot;

#ifndef USE_CUSTOM_FILEBUF
	// Calling "Create" while iterating over the directory list appears to corrupt
	// the file entries probably because of a reallocation due to caching new entries.
	// Create a copy of the entries instead to workaround this issue.
	DirectoryTree::DirectoryListType files = *base_fs.ListDirectory();
#else
	DirectoryTree::DirectoryListType* files = base_fs.ListDirectory();
#endif

	// Find valid game diectories
#ifndef USE_CUSTOM_FILEBUF
	for (auto& dir : files) {
#else
	for (auto& dir : *files) {
#endif
		assert(!dir.second.name.empty() && "VFS BUG: Empty filename in the folder");

#ifdef EMSCRIPTEN
		if (dir.second.name == "Save") {
			continue;
		}
#endif

		if (EndsWith(dir.second.name, ".save")) {
			continue;
		}
		if (dir.second.type == DirectoryTree::FileType::Regular) {
			if (FileFinder::IsSupportedArchiveExtension(dir.second.name)) {
				// The type is only determined on platforms with fast file IO (Windows and UNIX systems)
				// A platform is considered "fast" when it does not require our custom IO buffer
#ifndef USE_CUSTOM_FILEBUF
				auto fs = base_fs.Create(dir.second.name);
				game_entries.push_back({ dir.second.name, FileFinder::GetProjectType(fs) });
#else
				game_entries.push_back({ dir.second.name, FileFinder::ProjectType::Unknown });
#endif
			}
		} else if (dir.second.type == DirectoryTree::FileType::Directory) {
#ifndef USE_CUSTOM_FILEBUF
			auto fs = base_fs.Create(dir.second.name);
			game_entries.push_back({ dir.second.name, FileFinder::GetProjectType(fs) });
#else
			game_entries.push_back({ dir.second.name, FileFinder::ProjectType::Unknown });
#endif
		}
	}

	// Sort game list in place
	std::sort(game_entries.begin(), game_entries.end(),
			  [](const FileFinder::GameEntry &ge1, const FileFinder::GameEntry &ge2) {
				  return strcmp(Utils::LowerCase(ge1.dir_name).c_str(),
								Utils::LowerCase(ge2.dir_name).c_str()) <= 0;
			  });

	if (show_dotdot) {
		game_entries.insert(game_entries.begin(), { "..", FileFinder::ProjectType::Unknown });
	}

	if (HasValidEntry()) {
		item_max = game_entries.size();

		CreateContents();

		contents->Clear();

		for (int i = 0; i < item_max; ++i) {
			DrawItem(i);
		}
	}
	else {
		item_max = 1;

		SetContents(Bitmap::Create(width - 16, height - 16));

		if (show_dotdot) {
			DrawItem(0);
		}

		DrawErrorText(show_dotdot);
	}

	return true;
}

void Window_GameList::DrawItem(int index) {
	Rect rect = GetItemRect(index);
	contents->ClearRect(rect);

	auto& ge = game_entries[index];

#ifndef USE_CUSTOM_FILEBUF
	auto color = Font::ColorDefault;
	if (ge.type == FileFinder::ProjectType::Unknown) {
		color = Font::ColorHeal;
	} else if (ge.type > FileFinder::ProjectType::Supported) {
		color = Font::ColorKnockout;
	}
#else
	auto color = Font::ColorDefault;
#endif

	contents->TextDraw(rect.x, rect.y, color, ge.dir_name);

	if (ge.type > FileFinder::ProjectType::Supported) {
		auto notice = fmt::format("{}", FileFinder::kProjectType.tag(ge.type));
		contents->TextDraw(rect.width, rect.y, color, notice, Text::AlignRight);
	}
}

void Window_GameList::DrawErrorText(bool show_dotdot) {
	std::vector<std::string> error_msg = {
#ifdef EMSCRIPTEN
		"Did you type in a wrong URL?",
		"",
		"If you think this is an error, contact the owner",
		"of this website.",
		"",
		"Technical information: index.json was not found.",
		"",
		"Ensure through the dev tools of your browser that",
		"the file is at the correct location.",
#else
		"With EasyRPG Player you can play games created",
		"with RPG Maker 2000 and RPG Maker 2003.",
		"",
		"These games have an RPG_RT.ldb and they can be",
		"extracted or in ZIP archives.",
		"",
		"Newer engines such as RPG Maker XP, VX, MV and MZ",
		"are not supported."
#endif
	};

	int y = (show_dotdot ? 4 + 14 : 0);

#ifdef EMSCRIPTEN
	contents->TextDraw(0, y, Font::ColorKnockout, "The game was not found.");
#else
	contents->TextDraw(0, y, Font::ColorKnockout, "No games found in the current directory.");
#endif

	y += 14 * 2;
	for (size_t i = 0; i < error_msg.size(); ++i) {
		contents->TextDraw(0, y + 14 * i, Font::ColorCritical, error_msg[i]);
	}
}

bool Window_GameList::HasValidEntry() {
	size_t minval = show_dotdot ? 1 : 0;
	return game_entries.size() > minval;
}

FileFinder::FsEntry Window_GameList::GetFilesystemEntry() const {
	const auto& entry = game_entries[GetIndex()];
	return { base_fs.Create(entry.dir_name), entry.type };
}


/*end of file .\window_gamelist.cpp*/

/*start of file .\window_gold.cpp*/

/* ... license chunk ... */

// Headers
#include <iomanip>
#include <sstream>
#include "window_gold.h"
#include "game_party.h"
#include "main_data.h"
#include "bitmap.h"

Window_Gold::Window_Gold(int ix, int iy, int iwidth, int iheight) :
	Window_Base(ix, iy, iwidth, iheight) {

	SetContents(Bitmap::Create(width - 16, height - 16));

	Refresh();
}

void Window_Gold::Refresh() {
	contents->Clear();
	DrawCurrencyValue(Main_Data::game_party->GetGold(), contents->GetWidth(), 2);
}


/*end of file .\window_gold.cpp*/

/*start of file .\window_help.cpp*/

/* ... license chunk ... */

// Headers
#include "window_help.h"
#include "bitmap.h"
#include "font.h"

Window_Help::Window_Help(int ix, int iy, int iwidth, int iheight, Drawable::Flags flags) :
	Window_Base(ix, iy, iwidth, iheight, flags),
	align(Text::AlignLeft) {

	SetContents(Bitmap::Create(width - 16, height - 16));

	contents->Clear();
}

void Window_Help::SetText(std::string text, int color, Text::Alignment align, bool halfwidthspace) {
	if (this->text != text || this->color != color || this->align != align) {
		contents->Clear();

		text_x_offset = 0;
		AddText(text, color, align, halfwidthspace);

		this->text = std::move(text);
		this->align = align;
		this->color = color;
		this->text_x_scroll = 0;
		this->text_x_scroll_dir = false;
		this->text_x_width = text_x_offset;
	}
}

void Window_Help::Clear() {
	this->text = "";
	this->color = Font::ColorDefault;
	this->align = Text::AlignLeft;
	text_x_offset = 0;
	contents->Clear();
}

void Window_Help::AddText(std::string text, int color, Text::Alignment align, bool halfwidthspace) {
	std::string::size_type pos = 0;
	std::string::size_type nextpos = 0;
	while (nextpos != std::string::npos) {
		nextpos = text.find(' ', pos);
		auto segment = std::string_view(text).substr(pos, nextpos - pos);
		auto offset = contents->TextDraw(text_x_offset, 2, color, segment, align);
		text_x_offset += offset.x;

		// Special handling for proportional fonts: If the "normal" space is already small do not half it again
		if (nextpos != decltype(text)::npos) {
			int space_width = Text::GetSize(*(font ? font : Font::Default()), " ").width;

			if (halfwidthspace && space_width >= 6) {
				text_x_offset += space_width / 2;
			} else {
				text_x_offset += space_width;
			}
			pos = nextpos + 1;
		}
	}
}

void Window_Help::SetAnimation(Window_Help::Animation animation) {
	text_x_scroll = 0;
	this->animation = animation;
}

void Window_Help::UpdateScroll() {
	if (animation == Animation::None) {
		return;
	}

	if (text_x_width <= contents->GetWidth()) {
		// no need to scroll
		return;
	}

	if (animation == Animation::BackAndForth) {
		text_x_scroll += text_x_scroll_dir ? 1 : -1;

		if ((!text_x_scroll_dir && (text_x_width + text_x_scroll) == contents->GetWidth()) ||
				(text_x_scroll_dir && text_x_scroll == 0)) {
			text_x_scroll_dir = !text_x_scroll_dir;
		}

		contents->Clear();
		text_x_offset = text_x_scroll;
		AddText(text, color, align, true);
	} else if (animation == Animation::Loop) {
		--text_x_scroll;

		const int gap_size = 18;

		if (text_x_scroll == -text_x_width - gap_size) {
			text_x_scroll = 0;
		}

		contents->Clear();
		text_x_offset = text_x_scroll;
		AddText(text, color, align, true);
		text_x_offset += gap_size;
		AddText(text, color, align, true);
	}
}

void Window_Help::Update() {
	Window_Base::Update();
	UpdateScroll();
}


/*end of file .\window_help.cpp*/

/*start of file .\window_import_progress.cpp*/

/* ... license chunk ... */

// Headers
#include "window_import_progress.h"
#include "bitmap.h"
#include "color.h"
#include "font.h"

Window_ImportProgress::Window_ImportProgress(int ix, int iy, int iwidth, int iheight) :
	Window_Base(ix, iy, iwidth, iheight) {

	SetContents(Bitmap::Create(width - 16, height - 16));
	Refresh();
}

void Window_ImportProgress::SetProgress(int pct, const std::string& path) {
	percent = pct;
	curr_path = path;
	Refresh();
}

void Window_ImportProgress::Refresh() {
	contents->Clear();

	contents->TextDraw(0, 2, Font::ColorDefault, "Searching for files...", Text::AlignLeft);

	Rect inner(1, 16+3, 142, 16-6);
	Rect outer(inner.x-1, inner.y-1, inner.width+2, inner.height+2);

	contents->FillRect(outer, Color(0x00, 0x00, 0x00, 0xFF));
	contents->FillRect(inner, Color(0x66, 0x66, 0x66, 0xFF));
	inner.width = (inner.width*percent) / 100;
	contents->FillRect(inner, Color(0xFF, 0x00, 0x00, 0xFF));

	contents->TextDraw(0, 2 + 32, Font::ColorDefault, std::string("Folder: ") + curr_path, Text::AlignLeft);
}


/*end of file .\window_import_progress.cpp*/

/*start of file .\window_input_settings.cpp*/

/* ... license chunk ... */

// Headers
#include "window_input_settings.h"
#include "bitmap.h"
#include "input_buttons.h"
#include "window_selectable.h"
#include <sstream>

Window_InputSettings::Window_InputSettings(int ix, int iy, int iwidth, int iheight) :
	Window_Selectable(ix, iy, iwidth, iheight) {
	column_max = 2;

	SetContents(Bitmap::Create(width - 16, height - 16));
}

Input::InputButton Window_InputSettings::GetInputButton() const {
	return button;
}

void Window_InputSettings::SetInputButton(Input::InputButton button) {
	this->button = button;
	Refresh();
}

bool Window_InputSettings::RemoveMapping() {
	int index = GetIndex();

	int i = 0;
	auto& mappings = Input::GetInputSource()->GetButtonMappings();
	for (auto ki = mappings.LowerBound(button); ki != mappings.end() && ki->first == button; ++ki) {
		if (i == index) {
			auto key = static_cast<Input::Keys::InputKey>(ki->second);

			mappings.Remove({button, key});
			Refresh();
			break;
		}

		++i;
	}

	return true;
}

void Window_InputSettings::ResetMapping() {
	Input::ResetDefaultMapping(button);
	Refresh();
}

void Window_InputSettings::Refresh() {
	contents->Clear();

	auto& mappings = Input::GetInputSource()->GetButtonMappings();
	auto custom_names = Input::GetInputKeyNames();

	std::vector<std::string> items;

	std::stringstream ss;
	for (auto ki = mappings.LowerBound(button); ki != mappings.end() && ki->first == button;++ki) {
		auto key = static_cast<Input::Keys::InputKey>(ki->second);

		auto custom_name = std::find_if(custom_names.begin(), custom_names.end(), [&](auto& key_pair) {
			return key_pair.first == key;
		});

		if (custom_name != custom_names.end()) {
			items.push_back(custom_name->second);
		} else {
			items.push_back(Input::Keys::kInputKeyNames.tag(key));
		}
	}

	if (items.size() > mapping_limit) {
		items.resize(mapping_limit);
	}

	item_max = static_cast<int>(items.size());

	for (int i = 0; i < item_max; ++i) {
		Rect rect = GetItemRect(i);
		contents->ClearRect(rect);

		const std::string& text = items[i];

		bool enabled = true;

		Font::SystemColor color = enabled ? Font::ColorDefault : Font::ColorDisabled;
		contents->TextDraw(rect.x, rect.y, color, text);
	}
}


/*end of file .\window_input_settings.cpp*/

/*start of file .\window_interpreter.cpp*/

/* ... license chunk ... */

 // Headers
#include <vector>
#include "window_interpreter.h"
#include "bitmap.h"
#include "game_map.h"
#include "game_message.h"
#include "game_system.h"
#include "game_variables.h"
#include "input.h"
#include "player.h"
#include "lcf/reader_util.h"
#include <cache.h>
#include "feature.h"

#ifdef ENABLE_DYNAMIC_INTERPRETER_CONFIG
namespace {
	bool GlobalIsRPG2k3Commands() { return Player::game_config.patch_rpg2k3_commands.Get(); }
	bool GlobalIsPatchDynRpg() { return Player::game_config.patch_dynrpg.Get(); }
	bool GlobalIsPatchManiac() { return Player::game_config.patch_maniac.Get(); }
	bool GlobalIsPatchKeyPatch() { return Player::game_config.patch_key_patch.Get(); }
	bool GlobalIsPatchDestiny() { return Player::game_config.patch_destiny.Get(); }
	bool GlobalIsPatchCommonThisEvent() { return Player::game_config.patch_common_this_event.Get(); }
	bool GlobalIsPatchUnlockPics() { return Player::game_config.patch_unlock_pics.Get(); }
	bool GlobalHasRpg2kBattleSystem() { return lcf::Data::system.easyrpg_use_rpg2k_battle_system; }
}

struct RuntimeFlagInfo {
	bool (*config_fn)();
	Game_Interpreter_Shared::StateRuntimeFlagRef field_on, field_off;
	std::string_view name;
};

using StateFlags = lcf::rpg::SaveEventExecState::EasyRpgStateRuntime_Flags;
constexpr std::array <RuntimeFlagInfo, 8> runtime_flags = { {
	{ &GlobalIsRPG2k3Commands, &StateFlags::patch_rpg2k3_cmds_on, &StateFlags::patch_rpg2k3_cmds_off, "rpg2k3_cmds"},
	{ &GlobalIsPatchDynRpg, &StateFlags::patch_dynrpg_on, &StateFlags::patch_dynrpg_off, "dynrpg" },
	{ &GlobalIsPatchManiac, &StateFlags::patch_maniac_on, &StateFlags::patch_maniac_off, "maniac" },
	{ &GlobalIsPatchKeyPatch, &StateFlags::patch_keypatch_on, &StateFlags::patch_keypatch_off, "keypatch" },
	{ &GlobalIsPatchDestiny, &StateFlags::patch_destiny_on, &StateFlags::patch_destiny_off, "destiny" },
	{ &GlobalIsPatchCommonThisEvent, &StateFlags::patch_common_this_event_on, &StateFlags::patch_common_this_event_off, "common_this_event" },
	{ &GlobalIsPatchUnlockPics, &StateFlags::patch_unlock_pics_on, &StateFlags::patch_unlock_pics_off, "unlock_pics" },
	{ &GlobalHasRpg2kBattleSystem, &StateFlags::use_rpg2k_battle_system_on, &StateFlags::use_rpg2k_battle_system_off, "rpg2k_battle_system" }
} };
#endif

Window_Interpreter::Window_Interpreter(int ix, int iy, int iwidth, int iheight) :
	Window_Selectable(ix, iy, iwidth, iheight) {
	column_max = 1;

	sub_actions = UiSubActionLine(
		{ UiAction::ShowRuntimeFlags,		UiAction::ShowMovementInfo },
		{ "[Flags]",						"WAITING for EV movement" },
		{ Font::SystemColor::ColorHeal,		Font::SystemColor::ColorCritical },
		{ [&] { return (this->state.easyrpg_runtime_flags.conf_override_active); }, [&] { return this->state.wait_movement; } }
	);

	sub_window_flags.reset(new Window_Selectable(Player::menu_offset_x + 15, Player::menu_offset_y + 16, 288, 208));
	sub_window_flags->SetVisible(false);
	sub_window_flags->SetActive(false);
	sub_window_flags->SetIndex(-1);
}

Window_Interpreter::~Window_Interpreter() {

}

void Window_Interpreter::SetStackState(std::string interpreter_desc, lcf::rpg::SaveEventExecState state) {
	this->display_item = { interpreter_desc };
	this->state = state;
}

void Window_Interpreter::Refresh() {

	if (sub_window_flags->GetActive()) {
#ifdef ENABLE_DYNAMIC_INTERPRETER_CONFIG
		DrawRuntimeFlagsWindow();
#endif
		return;
	}

	stack_display_items.clear();

	int max_cmd_count = 0, max_evt_id = 10, max_page_id = 0;

	stack_display_items = Debug::CreateCallStack(state);

	for (auto it = stack_display_items.begin(); it < stack_display_items.end(); ++it) {
		auto& item = *it;

		if (item.evt_id > max_evt_id)
			max_evt_id = item.evt_id;
		if (item.page_id > max_page_id)
			max_page_id = item.page_id;
		if (static_cast<int>(item.cmd_count) > max_cmd_count)
			max_cmd_count = item.cmd_count;
	}

	item_max = stack_display_items.size() + lines_without_stack;
	lines_without_stack = lines_without_stack_fixed;

	if (sub_actions.IsVisible()) {
		item_max++;
		lines_without_stack++;
	}

	digits_stackitemno = std::log10(stack_display_items.size()) + 1;
	digits_evt_id = max_evt_id == 0 ? 2 : std::log10(max_evt_id) + 1;
	digits_page_id = max_page_id == 0 ? 0 : std::log10(max_page_id) + 1;
	digits_cmdcount = std::log10(max_cmd_count) + 1;

	digits_evt_combined_id = digits_evt_id + 3;
	if (digits_page_id > 0)
		digits_evt_combined_id += digits_page_id + 2;

	CreateContents();
	contents->Clear();

	if (!IsValid())
		return;

	DrawDescriptionLines();

	for (int i = 0; i < static_cast<int>(stack_display_items.size()); ++i) {
		DrawStackLine(i);
	}
}

bool Window_Interpreter::IsValid() {
	return !display_item.desc.empty();
}

void Window_Interpreter::Update() {
	if (sub_window_flags->GetActive()) {
		if (Input::IsTriggered(Input::InputButton::CANCEL)) {
			sub_window_flags->SetActive(false);
			sub_window_flags->SetVisible(false);
			sub_window_flags->SetIndex(-1);
		} else {
			sub_window_flags->Update();
		}
		return;
	}
	Window_Selectable::Update();

	if (IsHoveringSubActionLine()) {
		sub_actions.Update(*this);

		if (Input::IsTriggered(Input::InputButton::DECISION)) {
			if (GetSelectedAction() == UiAction::ShowRuntimeFlags) {
				sub_window_flags->SetActive(true);
				sub_window_flags->SetVisible(true);
				this->Refresh();

				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
			} else if (GetSelectedAction() == UiAction::ShowMovementInfo) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
			}
		}
	} else {
		sub_actions.ClearIndex();
	}
}

bool Window_Interpreter::IsHoveringSubActionLine() const {
	return GetIndex() == 1 && sub_actions.IsVisible();
}

void Window_Interpreter::DrawDescriptionLines() {
	int i = 0;
	Rect rect = GetItemRect(i++);
	contents->ClearRect(rect);

	contents->TextDraw(rect.x, rect.y, Font::ColorDefault, display_item.desc);

	rect = GetItemRect(i++);
	contents->ClearRect(rect);

	if (sub_actions.IsVisible()) {
		sub_actions.Draw(contents, rect);
	}

	rect = GetItemRect(i++);
	contents->ClearRect(rect);


	if (stack_display_items.size() > 0) {
		auto str_ex_type = std::string(Game_Interpreter_Shared::kExecutionType.tag(static_cast<int>(stack_display_items[0].type_ex)));
		contents->TextDraw(rect.x, rect.y, Font::ColorDefault, "(");
		contents->TextDraw(rect.x + 6, rect.y, Font::ColorHeal, str_ex_type);
		contents->TextDraw(rect.x + 6 * (str_ex_type.length() + 1), rect.y, Font::ColorDefault, ")");
	}
	contents->TextDraw(rect.x + rect.width / 2, rect.y, Font::ColorDefault, "Stack Size: ");
	contents->TextDraw(GetWidth() - 16, rect.y, Font::ColorCritical, std::to_string(state.stack.size()), Text::AlignRight);
}

void Window_Interpreter::DrawStackLine(int index) {

	Rect rect = GetItemRect(index + lines_without_stack);
	contents->ClearRect(rect);

	Debug::CallStackItem& item = stack_display_items[index];

	contents->TextDraw(rect.x, rect.y, Font::ColorDisabled, fmt::format("[{:0" + std::to_string(digits_stackitemno) + "d}]", state.stack.size() - index));

	std::string formatted_id;
	Font::SystemColor color = Font::ColorDefault;

	switch (item.type_ev) {
		case InterpreterEventType::MapEvent:
			if (item.page_id > 0) {
				formatted_id = fmt::format("EV{:0" + std::to_string(digits_evt_id) + "d}[{:0" + std::to_string(digits_page_id) + "d}]", item.evt_id, item.page_id);
			} else {
				formatted_id = fmt::format("EV{:0" + std::to_string(digits_evt_id) + "d}", item.evt_id);
			}
			if (item.map_has_changed) {
				color = Font::ColorKnockout;
			}
			break;
		case InterpreterEventType::CommonEvent:
			formatted_id = fmt::format("CE{:0" + std::to_string(digits_evt_id) + "d}", item.evt_id);
			break;
		case InterpreterEventType::BattleEvent:
			formatted_id = fmt::format("BE{:0" + std::to_string(digits_evt_id) + "d}", item.evt_id);
			break;
		default:
			formatted_id = fmt::format("{:0" + std::to_string(digits_evt_id + 2) + "d}", 0);
			color = Font::ColorKnockout;
			break;
	}
	contents->TextDraw(rect.x + (digits_stackitemno * 6) + 16, rect.y, color, formatted_id);

	std::string name = item.name;
	int max_length = 28;
	max_length -= digits_stackitemno;
	max_length -= digits_evt_combined_id;
	max_length -= digits_cmdcount * 2;
	if (static_cast<int>(name.length()) > max_length) {
		name = name.substr(0, max_length - 3) + "...";
	}
	contents->TextDraw(rect.x + ((digits_stackitemno + digits_evt_combined_id) * 6) + 16, rect.y, Font::ColorDefault, name, Text::AlignLeft);
	contents->TextDraw(GetWidth() - 16, rect.y, Font::ColorDefault, fmt::format("{:0" + std::to_string(digits_cmdcount) + "d}/{:0" + std::to_string(digits_cmdcount) + "d}", item.cmd_current, item.cmd_count), Text::AlignRight);
}

Window_Interpreter::UiAction Window_Interpreter::GetSelectedAction() const {
	if (GetIndex() >= lines_without_stack) {
		return UiAction::ShowStackItem;
	}
	if (GetIndex() == 1 && sub_actions.IsVisible()) {
		return sub_actions.GetSelectedAction();
	}
	return UiAction::None;
}

int Window_Interpreter::GetSelectedStackFrameLine() const {
	if (GetIndex() < lines_without_stack) {
		return -1;
	}
	return state.stack.size() - (GetIndex() - lines_without_stack) - 1;
}

bool Window_Interpreter::UiSubActionLine::IsVisible() const {
	for (auto v : this->visibility_delegates) {
		if (v())
			return true;
	}
	return false;
}

void Window_Interpreter::UiSubActionLine::Update(Window_Selectable& parent) {
	if (actions.size() == 0 || !visibility_delegates[this->index]())
		return;

	int i = this->index;

	if (Input::IsRepeated(Input::RIGHT)) {
		i++;

		while (i != this->index) {
			if (i >= static_cast<int>(actions.size()))
				i = 0;
			if (visibility_delegates[i]())
				break;
			i++;
		}
	}
	if (Input::IsRepeated(Input::LEFT)) {
		i--;
		while (i != this->index) {
			if (i < 0)
				i = actions.size() - 1;
			if (visibility_delegates[i]())
				break;
			i--;
		}
	}

	if (i != this->index) {
		this->index = i;
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
	}
	int offset_x = 0;
	for (i = 0; i < this->index; i++) {
		offset_x += (this->texts[i].length() + 1) * 6;
	}
	auto cursor_rect = parent.GetCursorRect();
	parent.SetCursorRect(Rect(cursor_rect.x + offset_x, cursor_rect.y, (this->texts[this->index].length() + 1) * 6 + 2, cursor_rect.height));
}

namespace {
	void TextDrawUnderlined(BitmapRef contents, int x, int y, int color, std::string_view text) {
		auto sys = Cache::SystemOrBlack();
		auto rect = Rect(x, y + 12, text.length() * 6, 1);
		// Draw shadow first
		contents->FillRect(Rect(rect.x + 1, rect.y + 1, rect.width, rect.height), sys->GetColorAt(18, 34));

		//Draw the actual text
		contents->TextDraw(x, y, color, text);

		// Draw underline
		contents->FillRect(rect, sys->GetColorAt(color % 10 * 16 + 2, color / 10 * 16 + 48 + 15));
	}
}

void Window_Interpreter::UiSubActionLine::Draw(BitmapRef contents, Rect rect) const {
	int offset_x = 0;

	for (int i = 0; i < static_cast<int>(this->actions.size()); i++) {
		if (!visibility_delegates[i]())
			continue;
		TextDrawUnderlined(contents, rect.x + offset_x, rect.y, colors[i], texts[i]);
		offset_x += (texts[i].length() + 1) * 6;
	}
}

void Window_Interpreter::UiSubActionLine::ClearIndex() {
	this->index = 0;
}

Window_Interpreter::UiAction Window_Interpreter::UiSubActionLine::GetSelectedAction() const {
	return this->actions[this->index];
}

#ifdef ENABLE_DYNAMIC_INTERPRETER_CONFIG
void Window_Interpreter::DrawRuntimeFlagsWindow() const {
	sub_window_flags->CreateContents();
	auto contents = sub_window_flags->GetContents();
	Rect rect = sub_window_flags->GetItemRect(0);


	contents->TextDraw(rect.x, rect.y, Font::ColorHeal, "Interpreter Flags:");
	contents->TextDraw(rect.x + 19 * 6, rect.y, Font::ColorDefault, display_item.desc);

	int i = 0;
	for (auto info : runtime_flags) {
		auto flag = Game_Interpreter_Shared::GetRuntimeFlag(state, info.field_on, info.field_off);;
		if (!flag) {
			continue;
		}

		rect = sub_window_flags->GetItemRect(i + 1);
		contents->ClearRect(rect);

		bool is_active = info.config_fn();
		bool is_overridden = *flag;
		contents->TextDraw(rect.x, rect.y, Font::ColorDefault, fmt::format("{}:", info.name));

		int r = 16;
		contents->TextDraw(sub_window_flags->GetWidth() - r, rect.y, Font::ColorCritical, is_overridden ? "[ON]" : "[OFF]", Text::AlignRight);
		r += 3 * 8;
		if (!is_overridden)
			r += 8;
		contents->TextDraw(sub_window_flags->GetWidth() - r, rect.y, Font::ColorDefault, "->", Text::AlignRight);
		r += 16;
		contents->TextDraw(sub_window_flags->GetWidth() - r, rect.y, Font::ColorDisabled, is_active ? "[ON]" : "[OFF]", Text::AlignRight);

		++i;
	}
}
#endif


/*end of file .\window_interpreter.cpp*/

/*start of file .\window_item.cpp*/

/* ... license chunk ... */

// Headers
#include <iomanip>
#include <sstream>
#include "window_item.h"
#include "game_party.h"
#include "bitmap.h"
#include "font.h"
#include <lcf/reader_util.h>
#include "game_battle.h"
#include "output.h"

Window_Item::Window_Item(int ix, int iy, int iwidth, int iheight) :
	Window_Selectable(ix, iy, iwidth, iheight) {
	column_max = 2;
}

const lcf::rpg::Item* Window_Item::GetItem() const {
	if (index < 0) {
		return nullptr;
	}

	return lcf::ReaderUtil::GetElement(lcf::Data::items, data[index]);
}

bool Window_Item::CheckInclude(int item_id) {
	if (data.size() == 0 && item_id == 0) {
		return true;
	} else {
		return (item_id > 0);
	}
}

bool Window_Item::CheckEnable(int item_id) {
	auto* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
	if (!item) {
		return false;
	}
	if (item->type == lcf::rpg::Item::Type_medicine
			&& (!Game_Battle::IsBattleRunning() || !item->occasion_field1)) {
		return true;
	}
	return Main_Data::game_party->IsItemUsable(item_id, actor);
}

void Window_Item::Refresh() {
	std::vector<int> party_items;

	data.clear();
	Main_Data::game_party->GetItems(party_items);

	for (size_t i = 0; i < party_items.size(); ++i) {
		if (this->CheckInclude(party_items[i])) {
			data.push_back(party_items[i]);
		}
	}

	if (Game_Battle::IsBattleRunning()) {
		// Include equipped accessories that invoke skills in sorted order.
		if (actor) {
			for (int i = 1; i <= 5; ++i) {
				const lcf::rpg::Item* item = actor->GetEquipment(i);
				if (item && item->use_skill && item->skill_id > 0) {
					auto iter = std::lower_bound(data.begin(), data.end(), item->ID);
					if (iter == data.end() || *iter != item->ID) {
						data.insert(iter, item->ID);
					}
				}
			}
		}
	}

	if (CheckInclude(0)) {
		data.push_back(0);
	}

	item_max = data.size();

	CreateContents();

	SetIndex(index);

	contents->Clear();

	for (int i = 0; i < item_max; ++i) {
		DrawItem(i);
	}
}

void Window_Item::DrawItem(int index) {
	Rect rect = GetItemRect(index);
	contents->ClearRect(rect);

	int item_id = data[index];

	if (item_id > 0) {
		int number = Main_Data::game_party->GetItemCount(item_id);

		// Items are guaranteed to be valid
		const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
		if (actor) {
			if (item->use_skill) {
				number += actor->GetItemCount(item_id);
			}
		}

		bool enabled = CheckEnable(item_id);
		DrawItemName(*item, rect.x, rect.y, enabled);

		Font::SystemColor color = enabled ? Font::ColorDefault : Font::ColorDisabled;
		contents->TextDraw(rect.x + rect.width - 24, rect.y, color, fmt::format("{}{:3d}", lcf::rpg::Terms::TermOrDefault(lcf::Data::terms.easyrpg_item_number_separator, ":"), number));
	}
}

void Window_Item::UpdateHelp() {
	help_window->SetText(GetItem() == nullptr ? "" : ToString(GetItem()->description));
}

void Window_Item::SetActor(Game_Actor * actor) {
	this->actor = actor;
}


/*end of file .\window_item.cpp*/

/*start of file .\window_keyboard.cpp*/

/* ... license chunk ... */

#include <string>
#include <algorithm>

#include "window_keyboard.h"
#include "game_system.h"
#include "input.h"
#include "bitmap.h"
#include "font.h"

const char* const Window_Keyboard::DONE = "<Done>";
const char* const Window_Keyboard::SPACE = "SPACE";
const char* const Window_Keyboard::NEXT_PAGE = "<Page>";
const char* const Window_Keyboard::DONE_JP = "<決定>";
const char* const Window_Keyboard::DONE_RU = "<OK>";
const char* const Window_Keyboard::DONE_KO = "<결정>";
const char* const Window_Keyboard::DONE_ZH_CN = "<确定>";
const char* const Window_Keyboard::DONE_ZH_TW = "<確定>";

/*
 * Hiragana <-> Katakana; Hangul 1 <-> Hangul 2; Simp. Chinese 1 <-> Simp. Chinese 2;
 * Trad. Chinese 1 <-> Trad. Chinese 2; Rus.Cyrillic <-> Rus.Latin; letter <-> symbol
 */

Keyboard_Layout Window_Keyboard::layouts[Window_Keyboard::MODE_END] = {
	{
		"<かな>",
		{ // Hiragana
			{"あ", "い", "う", "え", "お", "が", "ぎ", "ぐ", "げ", "ご"},
			{"か", "き", "く", "け", "こ", "ざ", "じ", "ず", "ぜ", "ぞ"},
			{"さ", "し", "す", "せ", "そ", "だ", "ぢ", "づ", "で", "ど"},
			{"た", "ち", "つ", "て", "と", "ば", "び", "ぶ", "べ", "ぼ"},
			{"な", "に", "ぬ", "ね", "の", "ぱ", "ぴ", "ぷ", "ぺ", "ぽ"},
			{"は", "ひ", "ふ", "へ", "ほ", "ぁ", "ぃ", "ぅ", "ぇ", "ぉ"},
			{"ま", "み", "む", "め", "も", "っ", "ゃ", "ゅ", "ょ", "ゎ"},
			{"や", "ゆ", "よ", "わ", "ん", "ー", "～", "・", "＝", "☆"},
			{"ら", "り", "る", "れ", "ろ", "ヴ", NEXT_PAGE, "", DONE}
		}
	},
	{
		"<カナ>",
		{ // Katakana
			{"ア", "イ", "ウ", "エ", "オ", "ガ", "ギ", "グ", "ゲ", "ゴ"},
			{"カ", "キ", "ク", "ケ", "コ", "ザ", "ジ", "ズ", "ゼ", "ゾ"},
			{"サ", "シ", "ス", "セ", "ソ", "ダ", "ヂ", "ヅ", "デ", "ド"},
			{"タ", "チ", "ツ", "テ", "ト", "バ", "ビ", "ブ", "ベ", "ボ"},
			{"ナ", "ニ", "ヌ", "ネ", "ノ", "パ", "ピ", "プ", "ペ", "ポ"},
			{"ハ", "ヒ", "フ", "ヘ", "ホ", "ァ", "ィ", "ゥ", "ェ", "ォ"},
			{"マ", "ミ", "ム", "メ", "モ", "ッ", "ャ", "ュ", "ョ", "ヮ"},
			{"ヤ", "ユ", "ヨ", "ワ", "ン", "ー", "～", "・", "＝", "☆"},
			{"ラ", "リ", "ル", "レ", "ロ", "ヴ", NEXT_PAGE, "", DONE}
		}
	},
	{
		"<앞P>",
		{ // Hangul 1
			{"가", "갸", "거", "겨", "고", "교", "구", "계", "그", "기"},
			{"나", "냐", "너", "녀", "노", "뇨", "누", "뉴", "느", "녹"},
			{"다", "댜", "더", "뎌", "도", "됴", "두", "듀", "드", "디"},
			{"라", "랴", "러", "려", "로", "료", "루", "류", "르", "리"},
			{"마", "먀", "머", "며", "모", "묘", "무", "물", "므", "미"},
			{"바", "뱌", "버", "벼", "보", "뵤", "부", "뷰", "비", "밤"},
			{"사", "색", "서", "세", "소", "쇼", "수", "슈", "신", "심"},
			{"아", "야", "어", "여", "오", "요", "우", "유", "으", "이"},
			{"〜", "·", ".", "☆", SPACE, "", NEXT_PAGE, "", DONE}
		}

	},
	{
		"<뒤P>",
		{ // Hangul 2
			{"자", "쟈", "저", "져", "조", "죠", "주", "쥬", "즈", "지"},
			{"차", "챠", "처", "쳐", "초", "쵸", "추", "츄", "츠", "치"},
			{"카", "캬", "커", "켜", "코", "쿄", "쿠", "큐", "크", "키"},
			{"타", "탸", "터", "텨", "토", "툐", "투", "튜", "트", "티"},
			{"파", "퍄", "퍼", "펴", "포", "표", "푸", "퓨", "프", "피"},
			{"하", "햐", "허", "혀", "호", "효", "후", "휴", "흐", "해"},
			{"1", "2", "3", "4", "5", "6", "7", "8", "9", "0"},
			{"진", "녘", "의", "민", "예", "건", "현", "운", "걔", "임"},
			{"영", "은", "성", "준", SPACE, "", NEXT_PAGE, "", DONE}
		},
	},
	{
		"<翻页>",
		{ // Simp. Chinese 1
			{"阿", "艾", "安", "奥", "巴", "拜", "班", "邦", "贝", "本"},
			{"比", "宾", "波", "伯", "布", "查", "达", "丹", "当", "道"},
			{"德", "登", "迪", "蒂", "丁", "度", "杜", "顿", "多", "厄"},
			{"尔", "恩", "法", "凡", "菲", "费", "芬", "佛", "弗", "夫"},
			{"盖", "格", "戈", "冈", "古", "哈", "海", "汉", "豪", "赫"},
			{"华", "霍", "基", "吉", "加", "杰", "捷", "金", "卡", "凯"},
			{"科", "克", "肯", "拉", "莱", "兰", "朗", "劳", "勒", "雷"},
			{"里", "利", "立", "丽", "莉", "林", "琳", "留", "隆", "鲁"},
			{"路", "伦", "罗", "洛", "律", "", NEXT_PAGE, "", DONE}
		}
	},
	{
		"<前页>",
		{ // Simp. Chinese 2
			{"玛", "迈", "曼", "梅", "美", "门", "米", "密", "明", "缪"},
			{"摩", "莫", "姆", "穆", "那", "娜", "纳", "奈", "南", "尼"},
			{"宁", "纽", "奴", "诺", "欧", "帕", "派", "佩", "皮", "普"},
			{"奇", "琪", "琼", "丘", "萨", "撒", "赛", "桑", "瑟", "森"},
			{"沙", "山", "珊", "史", "世", "斯", "丝", "司", "苏", "所"},
			{"索", "塔", "泰", "坦", "汤", "特", "提", "汀", "统", "瓦"},
			{"威", "维", "韦", "卫", "温", "沃", "乌", "西", "希", "夏"},
			{"辛", "修", "休", "雅", "亚", "林", "琳", "留", "隆", "鲁"},
			{"伊", "英", "尤", "则", "扎", "", NEXT_PAGE, "", DONE}
		}
	},
	{
		"<翻頁>",
		{ // Trad. Chinese 1
			{"泉", "聲", "咽", "危", "石", "日", "色", "冷", "青", "松"},
			{"薄", "暮", "空", "潭", "曲", "安", "禪", "制", "毒", "龍"},
			{"海", "內", "存", "知", "己", "天", "涯", "若", "比", "鄰"},
			{"滿", "階", "芳", "草", "綠", "一", "片", "杏", "花", "香"},
			{"恨", "無", "千", "日", "酒", "空", "斷", "九", "迴", "腸"},
			{"當", "路", "誰", "相", "假", "知", "音", "世", "所", "稀"},
			{"只", "應", "守", "寂", "寞", "還", "掩", "故", "園", "扉"},
			{"坐", "觀", "垂", "釣", "者", "－", "～", "’", "＝", "☆"},
			{"徒", "有", "羨", "魚", "情", "的", NEXT_PAGE, "", DONE}
		}
	},
	{
		"<前頁>",
		{ // Trad. Chinese 2
			{"幾", "行", "歸", "塞", "盡", "念", "爾", "獨", "何", "之"},
			{"暮", "雨", "相", "呼", "失", "寒", "塘", "欲", "下", "遲"},
			{"霞", "光", "連", "碧", "彩", "湖", "岸", "水", "連", "灘"},
			{"天", "地", "丹", "青", "繪", "人", "間", "錦", "秀", "看"},
			{"返", "景", "入", "深", "林", "復", "照", "青", "苔", "上"},
			{"中", "歲", "頗", "好", "道", "晚", "家", "南", "山", "睡"},
			{"興", "來", "每", "獨", "往", "勝", "事", "空", "自", "知"},
			{"遙", "夜", "泛", "清", "瑟", "－", "～", "’", "＝", "☆"},
			{"西", "風", "生", "翠", "蘿", "的", NEXT_PAGE, "", DONE}
		}
	},
	{
		"<Абвг>",
		{ // Cp1251 Russian Cyrillic (+ Bel. and Ukr. letters in the last row)
			{"А", "Б", "В", "Г", "Д", "а", "б", "в", "г", "д"},
			{"Е", "Ё", "Ж", "З", "И", "е", "ё", "ж", "з", "и"},
			{"Й", "К", "Л", "М", "Н", "й", "к", "л", "м", "н"},
			{"О", "П", "Р", "С", "Т", "о", "п", "р", "с", "т"},
			{"У", "Ф", "Х", "Ц", "Ч", "у", "ф", "х", "ц", "ч"},
			{"Ш", "Щ", "Ъ", "Ы", "Ь", "ш", "щ", "ъ", "ы", "ь"},
			{"Э", "Ю", "Я",  "",  "", "э", "ю", "я",  "",  ""},
			{"Ґ", "Є", "І", "Ї", "Ў", "ґ", "є", "і", "ї", "ў"},
			{"ʼ",  "",  "",  "",  "",  "", NEXT_PAGE, "", DONE}
		}
	},
	{
		"<Abcd>",
		{ // Letter
			{"A", "B", "C", "D", "E", "a", "b", "c", "d", "e"},
			{"F", "G", "H", "I", "J", "f", "g", "h", "i", "j"},
			{"K", "L", "M", "N", "O", "k", "l", "m", "n", "o"},
			{"P", "Q", "R", "S", "T", "p", "q", "r", "s", "t"},
			{"U", "V", "W", "X", "Y", "u", "v", "w", "x", "y"},
			{"Z", "" , "" , "" , "" , "z"},
			{"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"},
			{SPACE},
			{"" , "" , "" , "" , "" , "" , NEXT_PAGE, "", DONE}
		}
	},
	{
		"<$A$B>",
		{ // Symbol
			{"$A", "$B", "$C", "$D", "$E", "$a", "$b", "$c", "$d", "$e"},
			{"$F", "$G", "$H", "$I", "$J", "$f", "$g", "$h", "$i", "$j"},
			{"$K", "$L", "$M", "$N", "$O", "$k", "$l", "$m", "$n", "$o"},
			{"$P", "$Q", "$R", "$S", "$T", "$p", "$q", "$r", "$s", "$t"},
			{"$U", "$V", "$W", "$X", "$Y", "$u", "$v", "$w", "$x", "$y"},
			{"$Z",  "" ,  "" ,  "" ,  "" , "$z"},
			{},
			{},
			{ "" ,  "" ,  "" ,  "" ,  "" ,  "" , NEXT_PAGE, "", DONE}
		}
	}
};

Window_Keyboard::Window_Keyboard(int ix, int iy, int iwidth, int iheight, const char* ndone_text)
		: Window_Base(ix, iy, iwidth, iheight)
		, done_text(ndone_text)
		, play_cursor(false)
{
	row = 0;
	col = 0;

	SetContents(Bitmap::Create(width - 16, height - 16));

	row_spacing = 16;
	col_spacing = (contents->GetWidth() - 2 * border_x) / col_max;

	mode = Letter;
	next_mode = Symbol;

	Refresh();
	UpdateCursorRect();
}

void Window_Keyboard::SetMode(Window_Keyboard::Mode nmode, Window_Keyboard::Mode nnext_mode) {
	mode = nmode;
	next_mode = nnext_mode;
	Refresh();
	UpdateCursorRect();
}

std::string const& Window_Keyboard::GetKey(int row, int col) const {
	std::string const& str = layouts[mode].items[row][col];
	if (str == NEXT_PAGE) {
		return layouts[next_mode].key_text;
	}
	else if (str == DONE) {
		return done_text;
	}
	else {
		return str;
	}
}

std::string const& Window_Keyboard::GetSelected() const {
	return layouts[mode].items[row][col];
}

Rect Window_Keyboard::GetItemRect(int row, int col) const {
	return Rect(col * col_spacing + border_x,
				row * row_spacing + border_y,
				Text::GetSize(*Font::Default(), GetKey(row, col)).width + 8,
				row_spacing);
}

void Window_Keyboard::UpdateCursorRect() {
	Rect r = GetItemRect(row, col);
	r.y -= 2;
	SetCursorRect(r);
}

void Window_Keyboard::Refresh() {
	contents->Clear();

	for (int j = 0; j < row_max; j++) {
		for (int i = 0; i < col_max; i++) {
			Rect r = GetItemRect(j, i);
			contents->TextDraw(r.x + 4, r.y, Font::ColorDefault, GetKey(j, i));
		}
	}
}

void Window_Keyboard::Update() {
	Window_Base::Update();

	// move left on wide fields
	int skip_dir = -1;

	if (active) {
		if (Input::IsRepeated(Input::DOWN)) {
			play_cursor = true;
			row = (row + 1) % row_max;
		}
		if (Input::IsRepeated(Input::UP)) {
			play_cursor = true;
			row = (row + row_max - 1) % row_max;
		}
		if (Input::IsRepeated(Input::RIGHT)) {
			play_cursor = true;
			col = (col + 1) % col_max;
			skip_dir = 1;
		}
		if (Input::IsRepeated(Input::LEFT)) {
			play_cursor = true;
			col = (col + col_max - 1) % col_max;
		}
	}

	// Special handling for wide fields
	if (col > 0) {
		// page switch and done are always in the bottom right corner
		if ((row == row_max - 1 && (col == col_max - 3 || col == col_max - 1))
			|| GetKey(row, col - 1) == SPACE)
			col = std::min(col + skip_dir, col_max - 1);
	}

	// Skip empty cells
	if (GetSelected().empty()) {
		Update();
		return;
	}

	if (play_cursor) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
		play_cursor = false;
	}
	UpdateCursorRect();
}


/*end of file .\window_keyboard.cpp*/

/*start of file .\window_menustatus.cpp*/

/* ... license chunk ... */

// Headers
#include "window_menustatus.h"
#include "cache.h"
#include "game_party.h"
#include "player.h"
#include "bitmap.h"
#include "feature.h"

Window_MenuStatus::Window_MenuStatus(int ix, int iy, int iwidth, int iheight) :
	Window_Selectable(ix, iy, iwidth, iheight) {

	if (Player::IsRPG2k3()) {
		SetContents(Bitmap::Create(width - 12, height - 16));
		SetBorderX(4);
		text_offset = 4;
	} else {
		SetContents(Bitmap::Create(width - 16, height - 16));
	}

	Refresh();
}

void Window_MenuStatus::Refresh() {
	contents->Clear();

	item_max = Main_Data::game_party->GetActors().size();

	int y = 0;
	for (int i = 0; i < item_max; ++i) {
		// The party always contains valid battlers
		const Game_Actor& actor = *(Main_Data::game_party->GetActors()[i]);

		int face_x = 0;
		if (Player::IsRPG2k3()) {
			if (!Feature::HasRow()) {
				face_x = 4;
			} else {
				face_x = actor.GetBattleRow() == Game_Actor::RowType::RowType_back ? 8 : 0;
			}
		}
		DrawActorFace(actor, face_x, i*48 + y);

		DrawActorName(actor, 48 + 8 + text_offset, i*48 + 2 + y);
		DrawActorTitle(actor, 48 + 8 + 88 + text_offset, i*48 + 2 + y);
		DrawActorLevel(actor, 48 + 8 + text_offset, i*48 + 2 + 16 + y);
		DrawActorState(actor, 48 + 8 + 42 + text_offset, i*48 + 2 + 16 + y);
		DrawActorExp(actor, 48 + 8 + text_offset, i*48 + 2 + 16 + 16 + y);
		int digits = (actor.MaxHpValue() >= 1000 || actor.MaxSpValue() >= 1000) ? 4 : 3;
		DrawActorHp(actor, 48 + 8 + 106 + text_offset - (digits == 3 ? 0 : 12), i * 48 + 2 + 16 + y, digits);
		DrawActorSp(actor, 48 + 8 + 106 + text_offset - (digits == 3 ? 0 : 12), i * 48 + 2 + 16 + 16 + y, digits);

		y += 10;
	}
}

void Window_MenuStatus::UpdateCursorRect()
{
	if (index < 0) {
		cursor_rect = { 0, 0, 0, 0 };
	} else {
		cursor_rect = { 48 + 4 + text_offset, index * (48 + 10), 168, 48 };
	}
}

Game_Actor* Window_MenuStatus::GetActor() const {
	return &(*Main_Data::game_party)[GetIndex()];
}


/*end of file .\window_menustatus.cpp*/

/*start of file .\window_message.cpp*/

/* ... license chunk ... */

// Headers
#include <cctype>
#include <sstream>
#include <iterator>

#include "compiler.h"
#include "utils.h"
#include "window_message.h"
#include "game_actors.h"
#include "game_map.h"
#include "game_message.h"
#include "game_party.h"
#include "game_system.h"
#include "game_variables.h"
#include "input.h"
#include "output.h"
#include "player.h"
#include "util_macro.h"
#include "game_battle.h"
#include "bitmap.h"
#include "font.h"
#include "cache.h"
#include "text.h"

// FIXME: Off by 1 bug in window base class
constexpr int message_animation_frames = 7;
constexpr int gold_window_width = 88;
constexpr int gold_window_height = 32;

//#define EP_DEBUG_MESSAGE
//#define EP_DEBUG_MESSAGE_TEXT

namespace {
#if defined(EP_DEBUG_MESSAGE) || defined(EP_DEBUG_MESSAGE_TEXT)
static int frame_offset = 0;

void DebugLogResetFrameCounter() {
	frame_offset = Main_Data::game_system->GetFrameCounter();
}
#else
void DebugLogResetFrameCounter() { }
#endif

#ifdef EP_DEBUG_MESSAGE
template <typename... Args>
void DebugLog(const char* fmt, Args&&... args) {
	int frames = Main_Data::game_system->GetFrameCounter() - frame_offset;
	Output::Debug(fmt, frames, std::forward<Args>(args)...);
}
#else

template <typename... Args>
void DebugLog(const char*, Args&&...) { }
#endif

#ifdef EP_DEBUG_MESSAGE_TEXT
template <typename... Args>
void DebugLogText(const char* fmt, Args&&... args) {
	int frames = Main_Data::game_system->GetFrameCounter() - frame_offset;
	Output::Debug(fmt, frames, std::forward<Args>(args)...);
}
#else

template <typename... Args>
void DebugLogText(const char*, Args&&...) { }
#endif
} //namespace

// C4428 is nonsense
#ifdef _MSC_VER
#pragma warning (disable : 4428)
#endif

Window_Message::Window_Message(int ix, int iy, int iwidth, int iheight) :
	Window_Selectable(ix, iy, iwidth, iheight),
	number_input_window(new Window_NumberInput(0, 0)),
	gold_window(new Window_Gold(Player::screen_width - Player::menu_offset_x - gold_window_width, Player::menu_offset_y, gold_window_width, gold_window_height)),
	pending_message(Game_Message::CommandCodeInserter)
{
	SetContents(Bitmap::Create(width - 16, height - 16));

	// 2k3 transparent message boxes
	bool msg_transparent = Player::IsRPG2k3()
		// if the flag is set ..
		&& (lcf::Data::battlecommands.transparency == lcf::rpg::BattleCommands::Transparency_transparent)
		// if we're not in battle, or if we are in battle but not using mode A
		&& (!Game_Battle::IsBattleRunning() || lcf::Data::battlecommands.battle_type != lcf::rpg::BattleCommands::BattleType_traditional)
		// RPG_RT < 1.11 bug, map messages were not transparent if the battle type was mode A.
		&& (Player::IsRPG2k3E() || lcf::Data::battlecommands.battle_type != lcf::rpg::BattleCommands::BattleType_traditional);
	if (msg_transparent) {
		SetBackOpacity(160);
		SetBackgroundPreserveTransparentColor(true);
	}
	gold_window->SetBackOpacity(GetBackOpacity());

	SetVisible(false);
	// Above other windows
	SetZ(Priority_Window + 100);

	active = true;
	SetIndex(-1);
	text_color = Font::ColorDefault;

	number_input_window->SetVisible(false);

	gold_window->SetVisible(false);

	Main_Data::game_system->ClearMessageFace();
	Game_Message::SetWindow(this);
}

Window_Message::~Window_Message() {
	if (Game_Message::GetWindow() == this) {
		Game_Message::SetWindow(nullptr);
	}
}

void Window_Message::StartMessageProcessing(PendingMessage pm) {
	text.clear();
	pending_message = std::move(pm);

	if (!IsVisible()) {
		DebugLogResetFrameCounter();
	}
	DebugLog("{}: MSG START");

	if (!pending_message.IsActive()) {
		return;
	}

	const auto& lines = pending_message.GetLines();

	int num_lines = 0;
	auto append = [&](const std::string& line) {
		bool force_page_break = (!line.empty() && line.back() == '\f');

		text.append(line, 0, line.size() - force_page_break);
		if (line.empty() || text.back() != '\n') {
			text.push_back('\n');
		}
		++num_lines;

		if (num_lines == GetMaxLinesPerPage() || force_page_break) {
			text.push_back('\f');
			num_lines = 0;
		}
	};

	if (pending_message.IsWordWrapped()) {
		for (const std::string& line : lines) {
			/* TODO: don't take commands like \> \< into account when word-wrapping */
			Game_Message::WordWrap(
					line,
					width - 24,
					[&](std::string_view wrapped_line) {
						append(std::string(wrapped_line));
					}
			);
		}
	} else {
		for (const std::string& line : lines) {
			append(line);
		}
	}

	if (text.empty() || text.back() != '\f') {
		text.push_back('\f');
	}

	item_max = min(4, pending_message.GetNumChoices());

	text_index = text.data();

	DebugLog("{}: MSG TEXT \n{}", text);

	auto open_frames = (!IsVisible() && !Game_Battle::IsBattleRunning()) ? message_animation_frames : 0;
	SetOpenAnimation(open_frames);
	DebugLog("{}: MSG START OPEN {}", open_frames);

	InsertNewPage();
}

void Window_Message::OnFinishPage() {
	DebugLog("{}: FINISH PAGE");

	if (pending_message.GetNumChoices() > 0) {
		StartChoiceProcessing();
	} else if (pending_message.HasNumberInput()) {
		StartNumberInputProcessing();
	} else if (!kill_page) {
		DebugLog("{}: SET PAUSE");
		SetPause(true);
	}

	line_count = 0;
	kill_page = false;
	line_char_counter = 0;
}

void Window_Message::StartChoiceProcessing() {
	SetIndex(0);
}

void Window_Message::StartNumberInputProcessing() {
	number_input_window->SetMaxDigits(pending_message.GetNumberInputDigits());
	if (IsFaceEnabled() && !Main_Data::game_system->IsMessageFaceRightPosition()) {
		number_input_window->SetX(Player::message_box_offset_x + LeftMargin + FaceSize + RightFaceMargin);
	} else {
		number_input_window->SetX(x);
	}
	number_input_window->SetY(y + contents_y - 2);
	number_input_window->SetActive(true);
	if (IsVisible() && !IsOpeningOrClosing()) {
		number_input_window->SetVisible(true);
	}
	number_input_window->Update();
}

void Window_Message::ShowGoldWindow() {
	if (Game_Battle::IsBattleRunning()) {
		return;
	}
	if (!gold_window->IsVisible()) {
		gold_window->SetY(y == 0 ? Player::screen_height - Player::menu_offset_y - 32 : Player::menu_offset_y);
		gold_window->SetOpenAnimation(message_animation_frames);
	} else if (gold_window->IsClosing()) {
		gold_window->SetOpenAnimation(0);
	}
	gold_window->Refresh();
}

void Window_Message::InsertNewPage() {
	DebugLog("{}: MSG NEW PAGE");
	// Cancel pending face requests for async
	// Otherwise they render on the wrong page
	face_request_ids.clear();

	contents->Clear();
	SetIndex(-1);
	SetPause(false);
	number_input_window->SetActive(false);
	number_input_window->SetVisible(false);
	kill_page = false;
	line_count = 0;
	text_color = Font::ColorDefault;
	speed = 1;
	kill_page = false;
	instant_speed = false;
	prev_char_printable = false;
	prev_char_waited = true;

	if (GetFont()) {
		page_font = GetFont();
	} else {
		page_font = Font::Default();
	}

	// Position the message box vertically
	// Game_Message::GetRealPosition() specify top/middle/bottom
	if (Game_Message::GetRealPosition() == 0) {
		y = Player::menu_offset_y;
	}
	else if (Game_Message::GetRealPosition() == 1) {
		y = static_cast<int>((Player::screen_height - MESSAGE_BOX_HEIGHT) / 2.f);
	}
	else if (Game_Message::GetRealPosition() == 2) {
		y = Player::screen_height - Player::menu_offset_y - MESSAGE_BOX_HEIGHT ;
	}

	if (Main_Data::game_system->IsMessageTransparent()) {
		SetOpacity(0);
		gold_window->SetBackOpacity(0);
	} else {
		SetOpacity(255);
		gold_window->SetBackOpacity(GetBackOpacity());
	}

	// In some cases the gold window is always opaque
	bool gold_window_opaque =
		// 2k does not support system graphic transparency setting
		Player::IsRPG2k() ||
		// system graphic set to opaque
		lcf::Data::battlecommands.transparency == lcf::rpg::BattleCommands::Transparency_opaque ||
		// RPG2k3 < 1.10 and traditional battle (mode A)
		(!Player::IsRPG2k3E() && lcf::Data::battlecommands.battle_type == lcf::rpg::BattleCommands::BattleType_traditional);

	if (gold_window_opaque) {
		gold_window->SetBackOpacity(255);
	}

	// 2k3 applies transparent color to gold window
	if (Player::IsRPG2k3()) {
		gold_window->SetBackgroundAlpha(Main_Data::game_system->IsMessageTransparent());
		gold_window->SetBackgroundPreserveTransparentColor(GetBackgroundPreserveTransparentColor() && !gold_window->GetBackgroundAlpha());
	}

	if (IsFaceEnabled()) {
		if (!Main_Data::game_system->IsMessageFaceRightPosition()) {
			contents_x = LeftMargin + FaceSize + RightFaceMargin;
			DrawFace(Main_Data::game_system->GetMessageFaceName(), Main_Data::game_system->GetMessageFaceIndex(), LeftMargin, TopMargin, Main_Data::game_system->IsMessageFaceFlipped());
		} else {
			contents_x = 0;
			DrawFace(Main_Data::game_system->GetMessageFaceName(), Main_Data::game_system->GetMessageFaceIndex(), 248, TopMargin, Main_Data::game_system->IsMessageFaceFlipped());
		}
	} else {
		contents_x = 0;
	}

	if (pending_message.GetChoiceStartLine() == 0 && pending_message.HasChoices()) {
		contents_x += 12;
	}

	contents_y = 2;

	if (pending_message.GetNumberInputStartLine() == 0 && pending_message.HasNumberInput()) {
		// If there is an input window on the first line
		StartNumberInputProcessing();
	}
	line_char_counter = 0;

	if (pending_message.ShowGoldWindow()) {
		ShowGoldWindow();
	} else {
		// If first character is gold, the gold window appears immediately and animates open with the main window.
		auto tret = Utils::TextNext(text_index, (text.data() + text.size()), Player::escape_char);
		if (tret && tret.is_escape && tret.ch == '$') {
			ShowGoldWindow();
		}
	}
}

void Window_Message::InsertNewLine() {
	DebugLog("{}: MSG NEW LINE");
	if (IsFaceEnabled() && !Main_Data::game_system->IsMessageFaceRightPosition()) {
		contents_x = LeftMargin + FaceSize + RightFaceMargin;
	} else {
		contents_x = 0;
	}

	contents_y += 16;
	++line_count;

	if (pending_message.HasChoices() && line_count >= pending_message.GetChoiceStartLine()) {
		unsigned choice_index = line_count - pending_message.GetChoiceStartLine();
		if (pending_message.GetChoiceResetColor()) {
			// Check for disabled choices
			if (!pending_message.IsChoiceEnabled(choice_index)) {
				text_color = Font::ColorDisabled;
			} else {
				text_color = Font::ColorDefault;
			}
		}

		contents_x += 12;
	}
	line_char_counter = 0;
	prev_char_printable = false;
	prev_char_waited = true;
}

void Window_Message::FinishMessageProcessing() {
	DebugLog("{}: FINISH MSG");
	text.clear();
	text_index = text.data();

	SetPause(false);
	kill_page = false;
	line_char_counter = 0;
	SetIndex(-1);

	pending_message = PendingMessage(Game_Message::CommandCodeInserter);

	auto close_frames = Game_Battle::IsBattleRunning() ? 0 : message_animation_frames;

	if (number_input_window->IsVisible()) {
		number_input_window->SetActive(false);
		number_input_window->SetVisible(false);
	}

	SetCloseAnimation(close_frames);
	close_started_this_frame = true;
	DebugLog("{}: MSG START CLOSE {}", close_frames);

	// RPG_RT updates window open/close at the end of the main loop.
	// To simulate this timing, we run base class Update() again once
	// to animate the closing by 1 frame.
	Window::Update();

	if (gold_window->IsVisible()) {
		gold_window->SetCloseAnimation(close_frames);
		gold_window->Update();
	}
}

void Window_Message::ResetWindow() {

}

void Window_Message::Update() {
	aop = {};
	if (IsOpening()) { DebugLog("{}: MSG OPENING"); }
	if (IsClosing()) { DebugLog("{}: MSG CLOSING"); }

	close_started_this_frame = false;
	close_finished_this_frame = false;

	const bool was_closing = IsClosing();

	Window_Selectable::Update();
	number_input_window->Update();
	gold_window->Update();

	if (was_closing && !IsClosing()) {
		close_finished_this_frame = true;
	}

	if (!IsVisible()) {
		return;
	}

	if (IsOpeningOrClosing()) {
		return;
	}

	if (wait_count > 0) {
		DebugLog("{}: MSG WAIT {}", wait_count);
		--wait_count;
		return;
	}

	if (GetPause()) {
		DebugLog("{}: MSG PAUSE");
		WaitForInput();

		if (GetPause()) {
			return;
		}
	}

	if (GetIndex() >= 0) {
		DebugLog("{}: MSG CHOICE");
		InputChoice();
		if (GetIndex() >= 0) {
			return;
		}
	}

	if (number_input_window->GetActive()) {
		DebugLog("{}: MSG NUMBER");
		InputNumber();
		if (number_input_window->GetActive()) {
			return;
		}
	}

	DebugLog("{}: MSG UPD");
	UpdateMessage();
}

void Window_Message::UpdateMessage() {
	// Message Box Show Message rendering loop
	bool instant_speed_forced = false;

	if (Player::debug_flag && Input::IsPressed(Input::SHIFT)) {
		instant_speed = true;
		instant_speed_forced = true;
	}

	auto system = Cache::SystemOrBlack();

	while (true) {
		const auto* end = text.data() + text.size();

		if (wait_count > 0) {
			DebugLog("{}: MSG WAIT LOOP {}", wait_count);
			--wait_count;
			break;
		}

		if (!shape_ret.empty()) {
			if (!DrawGlyph(*page_font, *system, shape_ret[0])) {
				continue;
			}

			shape_ret.erase(shape_ret.begin());
			continue;
		}

		if (GetPause() || GetIndex() >= 0 || number_input_window->GetActive()) {
			break;
		}

		if (text_index == end) {
			FinishMessageProcessing();
			break;
		}

		auto tret = Utils::TextNext(text_index, end, Player::escape_char);
		auto text_prev = text_index;
		text_index = tret.next;

		if (EP_UNLIKELY(!tret)) {
			continue;
		}

		const auto ch = tret.ch;
		if (tret.is_exfont) {
			if (!DrawGlyph(*page_font, *system, ch, true)) {
				text_index = text_prev;
			}
			continue;
		}

		if (ch == '\f') {
			if (text_index != end) {
				InsertNewPage();
				SetWait(1);
			}
			continue;
		}

		if (ch == '\n') {
			int wait_frames = 0;
			bool end_page = (*text_index == '\f');

			if (!instant_speed) {
				if (!prev_char_printable) {
					wait_frames += 1 + end_page;
				}
			} else if (end_page) {
				// When the page ends and speed is instant, RPG_RT always waits 2 frames.
				wait_frames += 2;
			}

			InsertNewLine();

			if (end_page) {
				OnFinishPage();
			}
			SetWait(wait_frames);

			if (instant_speed && !instant_speed_forced) {
				// instant_speed stops at the end of the line
				// unless it was triggered by the shift key.
				instant_speed = false;
			}
			continue;
		}

		if (Utils::IsControlCharacter(ch)) {
			// control characters not handled
			continue;
		}

		if (tret.is_escape && ch != Player::escape_char) {
			// Special message codes
			switch (ch) {
			case 'c':
			case 'C':
				{
					// Color
					auto pres = Game_Message::ParseColor(text_index, end, Player::escape_char, true);
					auto value = pres.value;
					text_index = pres.next;
					DebugLogText("{}: MSG Color \\c[{}]", value);
					SetWaitForNonPrintable(0);
					text_color = value > 19 ? 0 : value;
				}
				break;
			case 's':
			case 'S':
				{
					// Speed modifier
					auto pres = Game_Message::ParseSpeed(text_index, end, Player::escape_char, true);
					text_index = pres.next;
					DebugLogText("{}: MSG Speed \\s[{}]", pres.value);
					SetWaitForNonPrintable(0);
					speed = Utils::Clamp(pres.value, 1, 20);
				}
				break;
			case '_':
				// Insert half size space
				contents_x += Text::GetSize(*page_font, " ").width / 2;
				DebugLogText("{}: MSG HalfWait \\_");
				SetWaitForCharacter(1);
				break;
			case '$':
				// Show Gold Window
				ShowGoldWindow();
				DebugLogText("{}: MSG Gold \\$");
				SetWaitForNonPrintable(speed);
				break;
			case '!':
				// Text pause
				DebugLogText("{}: MSG Pause \\!");
				SetWaitForNonPrintable(0);
				SetPause(true);
				break;
			case '^':
				// Force message close
				// The close happens at the end of the message, not where
				// the ^ is encountered
				DebugLogText("{}: MSG Kill Page \\^");
				kill_page = true;
				SetWaitForNonPrintable(speed);
				break;
			case '>':
				// Instant speed start
				DebugLogText("{}: MSG Instant Speed Start \\>");
				SetWaitForNonPrintable(0);
				instant_speed = true;
				break;
			case '<':
				// Instant speed stop - also cancels shift key and forces a delay.
				instant_speed = false;
				instant_speed_forced = false;
				DebugLogText("{}: MSG Instant Speed Stop \\<");
				SetWaitForNonPrintable(speed);
				break;
			case '.':
				// 1/4 second sleep
				// Despite documentation saying 1/4 second, RPG_RT waits for 16 frames.
				// RPG_RT also has a bug(??) where speeds >= 17 slow this down by 1 more frame per speed.
				SetWaitForNonPrintable(16 + Utils::Clamp(speed - 16, 0, 4));
				DebugLogText("{}: MSG Quick Sleep \\.");
				break;
			case '|':
				// Second sleep
				// Despite documentation saying 1 second, RPG_RT waits for 61 frames.
				SetWaitForNonPrintable(61);
				DebugLogText("{}: MSG Sleep \\|");
				break;
			default:
				// Unknown characters will not display anything but do wait.
				SetWaitForNonPrintable(speed);
				break;
			}
			continue;
		}

		if (page_font->CanShape()) {
			assert(shape_ret.empty());

			auto text_index_shape = text_index;
			std::u32string text32;
			text32 += ch;

			while (true) {
				tret = Utils::TextNext(text_index_shape, end, Player::escape_char);

				if (EP_UNLIKELY(!tret)) {
					break;
				}

				auto text_prev_shape = text_index_shape;
				text_index_shape = tret.next;
				auto chs = tret.ch;

				if (text_index_shape == end || tret.is_exfont || tret.is_escape || Utils::IsControlCharacter(chs)) {
					text_index = text_prev_shape;
					break;
				}

				text32 += tret.ch;
			}

			shape_ret = page_font->Shape(text32);
			continue;
		} else {
			if (!DrawGlyph(*page_font, *system, ch, false)) {
				text_index = text_prev;
				continue;
			}
		}
	}
}

bool Window_Message::DrawGlyph(Font& font, const Bitmap& system, char32_t glyph, bool is_exfont) {
	if (is_exfont) {
		DebugLogText("{}: MSG DrawGlyph Exfont {}", static_cast<uint32_t>(glyph));
	} else {
		if (glyph < 128) {
			DebugLogText("{}: MSG DrawGlyph ASCII {}", static_cast<char>(glyph));
		} else {
			DebugLogText("{}: MSG DrawGlyph UTF32 {#:X}", static_cast<uint32_t>(glyph));
		}
	}

	// RPG_RT compatible for half-width (6) and full-width (12)
	// generalizes the algo for even bigger glyphs
	// FIXME: When using Freetype this can cause slow rendering speeds due to dynamic width
	auto get_width = [](int w) {
		return (w > 0) ? (w - 1) / 6 + 1 : 0;
	};

	// Wide characters cause an extra wait if the last printed character did not wait.
	if (prev_char_printable && !prev_char_waited) {
		auto& wide_font = is_exfont ? *Font::exfont : font;
		auto rect = wide_font.GetSize(glyph);
		auto width = get_width(rect.width);
		if (width >= 2) {
			prev_char_waited = true;
			++line_char_counter;
			SetWait(1);
			return false;
		}
	}

	auto rect = Text::Draw(*contents, contents_x, contents_y, font, system, text_color, glyph, is_exfont);

	int glyph_width = rect.x;
	contents_x += glyph_width;
	int width = get_width(glyph_width);
	SetWaitForCharacter(width);

	return true;
}

bool Window_Message::DrawGlyph(Font& font, const Bitmap& system, const Font::ShapeRet& shape) {
	// RPG_RT compatible for half-width (6) and full-width (12)
	// generalizes the algo for even bigger glyphs
	// FIXME: This can cause slow rendering speeds for complex shapes
	auto get_width = [](int w) {
		return (w > 0) ? (w - 1) / 6 + 1 : 0;
	};

	DebugLogText("{}: MSG DrawGlyph Shape {}, {}", static_cast<uint32_t>(shape.code), get_width(shape.advance.x));

	// Wide characters cause an extra wait if the last printed character did not wait.
	if (prev_char_printable && !prev_char_waited) {
		auto width = get_width(shape.advance.x);
		if (width >= 2) {
			prev_char_waited = true;
			++line_char_counter;
			SetWait(1);
			return false;
		}
	}

	auto rect = font.Render(*contents, contents_x, contents_y, system, text_color, shape);

	int glyph_width = rect.x;
	contents_x += glyph_width;
	int width = get_width(glyph_width);
	SetWaitForCharacter(width);

	return true;
}

void Window_Message::IncrementLineCharCounter(int width) {
	// For speed 1, RPG_RT prints 2 half width chars every frame. This
	// resets anytime we print a full width character or another
	// character with a different speed.
	// To emulate this, we increment by 2 and clear the low bit anytime
	// we're not a speed 1 half width char.
	if (width == 1 && speed <= 1) {
		line_char_counter++;
	} else {
		line_char_counter = (line_char_counter & ~1) + 2;
	}
}

void Window_Message::UpdateCursorRect() {
	if (index >= 0) {
		int x_pos = 2;
		int y_pos = (pending_message.GetChoiceStartLine() + index) * 16;
		int width = contents->GetWidth() - 4;

		if (IsFaceEnabled()) {
			if (!Main_Data::game_system->IsMessageFaceRightPosition()) {
				x_pos += LeftMargin + FaceSize + RightFaceMargin;
			}
			width = width - LeftMargin - FaceSize - RightFaceMargin;
		}

		SetCursorRect(Rect(x_pos, y_pos, width, 16));
	} else {
		SetCursorRect(Rect());
	}
}

void Window_Message::WaitForInput() {
	if (Input::IsTriggered(Input::DECISION) ||
			Input::IsTriggered(Input::CANCEL)) {
		SetPause(false);
	}
}

void Window_Message::InputChoice() {
	int choice_result = -1;

	if (Input::IsTriggered(Input::CANCEL)) {
		if (pending_message.GetChoiceCancelType() > 0) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cancel));
			choice_result = pending_message.GetChoiceCancelType() - 1; // Cancel
		}
	} else if (Input::IsTriggered(Input::DECISION)) {
		if (!pending_message.IsChoiceEnabled(index)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
			return;
		}

		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
		choice_result = index;
	}

	if (choice_result >= 0) {
		auto& continuation = pending_message.GetChoiceContinuation();
		if (continuation) {
			aop = continuation(choice_result);
		}
		// This disables choices
		index = -1;
	}
}

void Window_Message::InputNumber() {
	number_input_window->SetVisible(true);
	if (Input::IsTriggered(Input::DECISION)) {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
		Main_Data::game_variables->Set(pending_message.GetNumberInputVariable(), number_input_window->GetNumber());
		Game_Map::SetNeedRefresh(true);
		number_input_window->SetNumber(0);
		number_input_window->SetActive(false);
	}
}

void Window_Message::SetWaitForNonPrintable(int frames) {
	if (!instant_speed) {
		if (speed <= 1) {
			frames += (line_char_counter & 1);
		}
		SetWait(frames);
	}
	prev_char_waited = (instant_speed || frames > 0);
	prev_char_printable = false;
	// Non printables only contribute to character count after the first printable..
	if (line_char_counter > 0) {
		IncrementLineCharCounter(1);
	}
}

void Window_Message::SetWaitForCharacter(int width) {
	int frames = 0;
	if (!instant_speed && width > 0) {
		bool is_last_for_page;
		if (!shape_ret.empty()) {
			is_last_for_page = (shape_ret.size() == 1) && (
				(text.data() + text.size() - text_index) <= 1 || (*text_index == '\n' && *(text_index + 1) == '\f'));
		} else {
			is_last_for_page = (text.data() + text.size() - text_index) <= 1 || (*text_index == '\n' && *(text_index + 1) == '\f');
		}

		if (is_last_for_page) {
			// RPG_RT always waits 2 frames for last character on the page.
			// FIXME: Exfonts / wide last on page?
			DebugLogText("{}: is_last_for_page");
			frames = 2;
		} else {
			if (speed > 1) {
				frames = speed * width / 2 + 1;
			} else {
				frames = width / 2;
				if (width & 1) {
					bool is_last_for_line;
					if (!shape_ret.empty()) {
						is_last_for_line = shape_ret.size() == 1 && (*text_index == '\n');
					} else {
						is_last_for_line = (*text_index == '\n');
					}
					if (is_last_for_line) {
						DebugLogText("{}: is_last_for_line");
					}

					// RPG_RT waits for every even character. Also always waits
					// for the last character.
					frames += (line_char_counter & 1) || is_last_for_line;
				}
			}
		}
	}
	prev_char_waited = (instant_speed || frames > 0);
	prev_char_printable = true;
	SetWait(frames);
	IncrementLineCharCounter(width);
}

void Window_Message::SetWait(int frames) {
	assert(speed >= 1 && speed <= 20);
	DebugLogText("{}: MSG SetWait {}", frames);
	wait_count = frames;
}

bool Window_Message::IsFaceEnabled() const {
	return pending_message.IsFaceEnabled() && !Main_Data::game_system->GetMessageFaceName().empty();
}



/*end of file .\window_message.cpp*/

/*start of file .\window_name.cpp*/

/* ... license chunk ... */

// Headers
#include <string>
#include "window_name.h"
#include "bitmap.h"
#include "font.h"
#include <lcf/data.h>
#include "game_system.h"

Window_Name::Window_Name(int ix, int iy, int iwidth, int iheight) :
	Window_Base(ix, iy, iwidth, iheight) {

	SetContents(Bitmap::Create(width - 16, height - 16));

	name.clear();

	Refresh();
}

void Window_Name::Refresh() {
	contents->Clear();
	contents->TextDraw(2, 2, Font::ColorDefault, name);
}

void Window_Name::Set(std::string text) {
	name = std::move(text);
	Refresh();
}

void Window_Name::Append(std::string_view text) {
	// Avoid string copies by reusing the buffer in name
	name.append(text.begin(), text.end());
	if (Text::GetSize(*Font::Default(), name).width <= (12 * 6)) {
		Refresh();
	} else {
		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Buzzer));
		name.resize(name.size() - text.size());
	}
}

void Window_Name::Update() {
	Rect const name_size = Text::GetSize(*Font::Default(), name);
	SetCursorRect(Rect(name_size.width + 2, 0, 16, 16));
}

void Window_Name::Erase() {
	if (name.empty())
		return;

	auto u32name = Utils::DecodeUTF32(name);
	u32name.pop_back();
	name = Utils::EncodeUTF(u32name);

	Refresh();
}



/*end of file .\window_name.cpp*/

/*start of file .\window_numberinput.cpp*/

/* ... license chunk ... */

// Headers
#include "window_numberinput.h"
#include "game_variables.h"
#include "game_system.h"
#include "input.h"
#include "main_data.h"
#include "util_macro.h"
#include "bitmap.h"
#include "font.h"
#include "player.h"

#include <cstdio>
#include <fmt/format.h>

Window_NumberInput::Window_NumberInput(int ix, int iy, int iwidth, int iheight) :
	Window_Selectable(ix, iy, iwidth, iheight),
	digits_max(10) {
	number = 0;
	plus = true;

	SetContents(Bitmap::Create(width - 16, height - 16));
	cursor_width = 14;
	// Above the message window
	SetZ(Priority_Window + 150);
	opacity = 0;
	active = false;
	show_operator = false;

	ResetIndex();
	Refresh();
	UpdateCursorRect();
}

void Window_NumberInput::Refresh() {
	contents->Clear();

	auto s = fmt::format("{0}{1:0{2}d}",
			show_operator ? (plus ? "+" : "-") : "",
			number, digits_max);

	for (int i = 0; i < digits_max + (int)show_operator; ++i) {
		char c[2] = {s[i], '\0'};
		int x = i * (cursor_width - 2) + (show_operator ? 2 : 12);
		contents->TextDraw(x, 2, Font::ColorDefault, c);
	}
}

int Window_NumberInput::GetNumber() const {
	if (plus) {
		if (number > std::numeric_limits<int>::max()) {
			return std::numeric_limits<int>::max();
		} else {
			return static_cast<int>(number);
		}
	} else {
		if (number * -1 < std::numeric_limits<int>::min()) {
			return std::numeric_limits<int>::min();
		} else {
			return static_cast<int>(-number);
		}
	}
}

void Window_NumberInput::SetNumber(int inumber) {
	int64_t num = 1;
	for (int i = 0; i < digits_max; ++i) {
		num *= 10;
	}
	number = Utils::Clamp<int64_t>(std::llabs(inumber), 0, num - 1);
	ResetIndex();

	plus = inumber >= 0;

	UpdateCursorRect();
	Refresh();
}

int Window_NumberInput::GetMaxDigits() const {
	return digits_max;
}

void Window_NumberInput::SetMaxDigits(int idigits_max) {
	// Up to 10 digits (highest 32 bit number)
	int top = std::max(10, idigits_max);
	digits_max =
		(idigits_max > top) ? top :
		(idigits_max <= 0) ? 1 :
		idigits_max;
	ResetIndex();
	UpdateCursorRect();
	Refresh();
}

bool Window_NumberInput::GetShowOperator() const {
	return show_operator;
}

void Window_NumberInput::SetShowOperator(bool show) {
	show_operator = show;
}

void Window_NumberInput::UpdateCursorRect() {
	cursor_rect = { index * (cursor_width - 2) + (show_operator ? -2 : 8), 0, cursor_width, 16 };
}

void Window_NumberInput::Update() {
	Window_Selectable::Update();
	if (active) {
		if (Input::IsRepeated(Input::DOWN) || Input::IsRepeated(Input::UP)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));

			if (show_operator && index == 0) {
				plus = !plus;
			} else {
				int place = 1;
				for (int i = 0; i < (digits_max - 1 - (int)index + (int)show_operator); ++i) {
					place *= 10;
				}
				int64_t n = number / place % 10;
				number -= n * place;
				if (Input::IsRepeated(Input::UP)) {
					n = (n + 1) % 10;
				}
				if (Input::IsRepeated(Input::DOWN)) {
					n = (n + 9) % 10;
				}
				number += n * place;
			}
			if (number == 0) {
				plus = true;
			}
			Refresh();
		}

		if (Input::IsRepeated(Input::RIGHT)) {
			if (digits_max >= 2) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
				index = (index + 1) % (digits_max + (int)show_operator);
			}
		}

		if (Input::IsRepeated(Input::LEFT)) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
			index = (index + digits_max - 1 + (int)show_operator) % (digits_max + (int)show_operator);
		}

		// Extension: Allow number input through numpad
		if (!show_operator || index > 0) {
			for (int btn = static_cast<int>(Input::N0); btn <= static_cast<int>(Input::N9); ++btn) {
				if (Input::IsTriggered(static_cast<Input::InputButton>(btn))) {
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));

					int place = 1;
					for (int i = 0; i < (digits_max - 1 - (int)index + (int)show_operator); ++i) {
						place *= 10;
					}
					int64_t n = number / place % 10;
					number -= n * place;
					number += (btn - static_cast<int>(Input::N0)) * static_cast<int64_t>(place);
					index = (index + 1) % (digits_max + (int)show_operator);
					Refresh();
					break;
				}
			}
		}

		UpdateCursorRect();
	}
}

void Window_NumberInput::ResetIndex() {
	index = digits_max - 1 + int(show_operator);
}


/*end of file .\window_numberinput.cpp*/

/*start of file .\window_paramstatus.cpp*/

/* ... license chunk ... */

// Headers
#include <iomanip>
#include <sstream>
#include "game_actors.h"
#include "window_paramstatus.h"
#include "bitmap.h"
#include "font.h"

Window_ParamStatus::Window_ParamStatus(int ix, int iy, int iwidth, int iheight, const Game_Actor& actor) :
	Window_Base(ix, iy, iwidth, iheight),
	actor(actor)
{

	SetContents(Bitmap::Create(width - 16, height - 16));

	Refresh();
}

void Window_ParamStatus::Refresh() {
	contents->Clear();

	auto draw = [this](int y, std::string_view name, int value) {
		// Draw Term
		contents->TextDraw(0, y, 1, name);

		// Draw Value
		contents->TextDraw(90, y, Font::ColorDefault, std::to_string(value), Text::AlignRight);
		return y + 16;
	};

	int y = 2;
	y = draw(y, lcf::Data::terms.attack, actor.GetAtk());
	y = draw(y, lcf::Data::terms.defense, actor.GetDef());
	y = draw(y, lcf::Data::terms.spirit, actor.GetSpi());
	y = draw(y, lcf::Data::terms.agility, actor.GetAgi());
}



/*end of file .\window_paramstatus.cpp*/

/*start of file .\window_savefile.cpp*/

/* ... license chunk ... */

// Headers
#include <string>
#include <iomanip>
#include <sstream>
#include "window_savefile.h"
#include "game_system.h"
#include "input.h"
#include "bitmap.h"
#include "font.h"
#include "player.h"

Window_SaveFile::Window_SaveFile(int ix, int iy, int iwidth, int iheight) :
	Window_Base(ix, iy, iwidth, iheight) {

	SetBorderX(4);
	SetContents(Bitmap::Create(width - 8, height - 16));

	Refresh();
	UpdateCursorRect();
}

void Window_SaveFile::UpdateCursorRect() {
	Rect rect = Rect();

	if (GetActive()) {
		if (override_index > 0) {
			rect = Rect(0, 0, Text::GetSize(*Font::Default(), GetSaveFileName()).width + 6, 16);
		} else {
			rect = Rect(0, 0, Text::GetSize(*Font::Default(), GetSaveFileName()).width + Text::GetSize(*Font::Default(), " ").width * 5 / 2 + 8, 16);
		}
	}

	SetCursorRect(rect);
}

std::string Window_SaveFile::GetSaveFileName() const {
	std::ostringstream out;
	if (!override_name.empty()) {
		if (override_name.size() > 14 && has_party) {
			out << override_name.substr(0, 11) << "...";
		} else {
			out << override_name;
		}
	} else {
		out << lcf::Data::terms.file;
	}
	return out.str();
}

void Window_SaveFile::SetIndex(int id) {
	index = id;
}

void Window_SaveFile::SetDisplayOverride(const std::string& name, int index) {
	override_name = name;
	override_index = index;
}

void Window_SaveFile::SetParty(lcf::rpg::SaveTitle title) {
	data = std::move(title);
	has_party = true;
}

void Window_SaveFile::SetCorrupted(bool corrupted) {
	this->corrupted = corrupted;
}

bool Window_SaveFile::IsValid() const {
	return has_save && !corrupted;
}

bool Window_SaveFile::HasParty() const {
	return has_party;
}

void Window_SaveFile::SetHasSave(bool valid) {
	this->has_save = valid;
}

void Window_SaveFile::Refresh() {
	contents->Clear();

	Font::SystemColor fc = has_save ? Font::ColorDefault : Font::ColorDisabled;

	contents->TextDraw(4, 2, fc, GetSaveFileName());
	contents->TextDraw(4 + Text::GetSize(*Font::Default(), GetSaveFileName()).width, 2, fc, " ");

	std::stringstream out;
	out << std::setw(2) << std::setfill(' ') << index + 1;
	contents->TextDraw(4 + Text::GetSize(*Font::Default(), GetSaveFileName()).width + Text::GetSize(*Font::Default(), " ").width / 2, 2, fc, out.str());

	if (corrupted) {
		contents->TextDraw(4, 16 + 2, Font::ColorKnockout, "Savegame corrupted");
		return;
	}

	if (!has_party) {
		return;
	}

	out.str("");
	if (override_index > 0) {
		out << lcf::Data::terms.file << std::setw(3) << std::setfill(' ') << override_index;
		contents->TextDraw(4, 16+2, fc, out.str());
	} else {
		contents->TextDraw(4, 16 + 2, fc, data.hero_name);
	}

	auto lvl_short = ToString(lcf::Data::terms.lvl_short);
	if (lvl_short.size() != 2) {
		lvl_short.resize(2, ' ');
	}

	contents->TextDraw(4, 32 + 2, 1, lvl_short);

	int lx = Text::GetSize(*Font::Default(), lvl_short).width;
	out.str("");
	out << std::setw(2) << std::setfill(' ') << data.hero_level;
	contents->TextDraw(4 + lx, 32 + 2, fc, out.str());

	auto hp_short = ToString(lcf::Data::terms.hp_short);
	if (hp_short.size() != 2) {
		hp_short.resize(2, ' ');
	}

	contents->TextDraw(46, 32 + 2, 1, hp_short);

	int hx = Text::GetSize(*Font::Default(), hp_short).width;
	out.str("");
	out << std::setw(Player::IsRPG2k3() ? 4 : 3) << std::setfill(' ') << data.hero_hp;
	contents->TextDraw(46 + hx, 32 + 2, fc, out.str());

	int i = 0;
	DrawFace(data.face1_name, data.face1_id, 92 + i++ * 56, 0, false);
	DrawFace(data.face2_name, data.face2_id, 92 + i++ * 56, 0, false);
	DrawFace(data.face3_name, data.face3_id, 92 + i++ * 56, 0, false);
	DrawFace(data.face4_name, data.face4_id, 92 + i++ * 56, 0, false);
}

void Window_SaveFile::Update() {
	Window_Base::Update();
	UpdateCursorRect();
}


/*end of file .\window_savefile.cpp*/

/*start of file .\window_selectable.cpp*/

/* ... license chunk ... */

// Headers
#include "window_selectable.h"
#include "game_system.h"
#include "input.h"
#include "util_macro.h"
#include "bitmap.h"

constexpr int arrow_animation_frames = 20;

// Constructor
Window_Selectable::Window_Selectable(int ix, int iy, int iwidth, int iheight) :
	Window_Base(ix, iy, iwidth, iheight) { }

void Window_Selectable::CreateContents() {
	int w = std::max(0, width - border_x * 2);
	int h = std::max(0, std::max(height - border_y * 2, GetRowMax() * menu_item_height));

	SetContents(Bitmap::Create(w, h));
}

// Properties

int Window_Selectable::GetIndex() const {
	return index;
}
void Window_Selectable::SetIndex(int nindex) {
	index = min(nindex, item_max - 1);
	if (active && help_window != NULL) {
		UpdateHelp();
	}
	UpdateCursorRect();
}
int Window_Selectable::GetColumnMax() const {
	return column_max;
}
void Window_Selectable::SetColumnMax(int ncolmax) {
	column_max = ncolmax;
}
int Window_Selectable::GetRowMax() const {
	return (item_max + column_max - 1) / column_max;
}
int Window_Selectable::GetTopRow() const {
	return oy / menu_item_height;
}
void Window_Selectable::SetTopRow(int row) {
	if (row < 0) row = 0;
	if (row > GetRowMax() - 1) row = GetRowMax() - 1;
	SetOy(row * menu_item_height);
}
int Window_Selectable::GetPageRowMax() const {
	return (height - border_y * 2) / menu_item_height;
}
int Window_Selectable::GetPageItemMax() {
	return GetPageRowMax() * column_max;
}

Rect Window_Selectable::GetItemRect(int index) {
	Rect rect = Rect();
	rect.width = (width / column_max - 16);
	rect.x = (index % column_max * (rect.width + 16));
	rect.height = menu_item_height - 4;
	rect.y = index / column_max * menu_item_height + menu_item_height / 8;
	return rect;
}

Window_Help* Window_Selectable::GetHelpWindow() {
	return help_window;
}

void Window_Selectable::SetHelpWindow(Window_Help* nhelp_window) {
	help_window = nhelp_window;
	if (active && help_window != NULL) {
		UpdateHelp();
	}
}

void Window_Selectable::UpdateHelp() {
	if (UpdateHelpFn && help_window != nullptr) {
		UpdateHelpFn(*help_window, index);
	}
}

// Update Cursor Rect
void Window_Selectable::UpdateCursorRect() {
	int cursor_width = 0;
	int x = 0;
	if (index < 0) {
		SetCursorRect(Rect());
		return;
	}
	int row = index / column_max;
	if (row < GetTopRow()) {
		SetTopRow(row);
	} else if (row > GetTopRow() + (GetPageRowMax() - 1)) {
		SetTopRow(row - (GetPageRowMax() - 1));
	}

	cursor_width = (width / column_max - 16) + 8;
	x = (index % column_max * (cursor_width + 8)) - 4;

	int y = index / column_max * menu_item_height - oy;
	SetCursorRect(Rect(x, y, cursor_width, menu_item_height));
}

void Window_Selectable::UpdateArrows() {
	bool show_up_arrow = (GetTopRow() > 0);
	bool show_down_arrow = (GetTopRow() < (GetRowMax() - GetPageRowMax()));

	if (show_up_arrow || show_down_arrow) {
		arrow_frame = (arrow_frame + 1) % (arrow_animation_frames * 2);
	}
	bool arrow_visible = (arrow_frame < arrow_animation_frames);
	SetUpArrow(show_up_arrow && arrow_visible);
	SetDownArrow(show_down_arrow && arrow_visible);
}

// Update
void Window_Selectable::Update() {
	Window_Base::Update();
	if (active && item_max > 0 && index >= 0) {
		if (scroll_dir != 0) {
			scroll_progress++;
			SetOy(GetOy() + (menu_item_height * scroll_progress / 4 - menu_item_height * (scroll_progress - 1) / 4) * scroll_dir);
			UpdateArrows();
			if (scroll_progress < 4) {
				return;
			} else {
				scroll_dir = 0;
				scroll_progress = 0;
				if (active && help_window != NULL) {
					UpdateHelp();
				}
				UpdateCursorRect();
			}
		}

		int old_index = index;

		auto move_down = [&]() {
			if (index < item_max - column_max || column_max == 1 ) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
				index = (index + column_max) % item_max;
			}
		};
		if (Input::IsTriggered(Input::DOWN) || Input::IsTriggered(Input::SCROLL_DOWN)) {
			move_down();
		} else if (Input::IsRepeated(Input::DOWN)) {
			if (endless_scrolling || (index + column_max) % item_max > index) {
				move_down();
			}
		}

		auto move_up = [&]() {
			if (index >= column_max || column_max == 1) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
				index = (index - column_max + item_max) % item_max;
			}
		};
		if (Input::IsTriggered(Input::UP) || Input::IsTriggered(Input::SCROLL_UP)) {
			move_up();
		} else if (Input::IsRepeated(Input::UP)) {
			if (endless_scrolling || (index - column_max + item_max) % item_max < index) {
				move_up();
			}
		}

		// page up/down is limited to selectables with one column
		if (column_max == 1) {
			if (Input::IsRepeated(Input::PAGE_DOWN) && index < item_max - 1) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
				int new_pos = index + GetPageRowMax();
				index = (new_pos <= item_max - 1) ? new_pos : item_max - 1;
			}
			if (Input::IsRepeated(Input::PAGE_UP) && index > 0) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
				int new_pos = index - GetPageRowMax();
				index = (new_pos >= 0) ? new_pos : 0;
			}
		}
		if (Input::IsRepeated(Input::RIGHT)) {
			if (column_max >= wrap_limit && index < item_max - 1) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
				index += 1;
			}
		}
		if (Input::IsRepeated(Input::LEFT)) {
			if (column_max >= wrap_limit && index > 0) {
				Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
				index -= 1;
			}
		}

		if (std::abs(index - old_index) <= column_max) {
			int row = index / column_max;
			if (row < GetTopRow() && old_index < item_max - 1) {
				scroll_dir = -1;
				return;
			} else if (row > GetTopRow() + (GetPageRowMax() - 1) && old_index > 0) {
				scroll_dir = 1;
				return;
			}
		}
	}
	if (active && help_window != NULL) {
		UpdateHelp();
	}
	UpdateCursorRect();
	UpdateArrows();
}

// Set endless scrolling state
void Window_Selectable::SetEndlessScrolling(bool state) {
	endless_scrolling = state;
}

// Set menu item height
void Window_Selectable::SetMenuItemHeight(int height) {
	menu_item_height = height;
}

void Window_Selectable::SetSingleColumnWrapping(bool wrap) {
	wrap_limit = wrap ? 1 : 2;
}


/*end of file .\window_selectable.cpp*/

/*start of file .\window_settings.cpp*/

/* ... license chunk ... */

// Headers
#include <sstream>
#include <utility>
#include "game_map.h"
#include "input.h"
#include "text.h"
#include "window_settings.h"
#include "game_config.h"
#include "game_system.h"
#include "input_buttons.h"
#include "keys.h"
#include "output.h"
#include "baseui.h"
#include "bitmap.h"
#include "player.h"
#include "system.h"
#include "audio.h"
#include "audio_midi.h"
#include "audio_generic_midiout.h"

#ifdef EMSCRIPTEN
#  include "platform/emscripten/interface.h"
#endif

class MenuItem final : public ConfigParam<std::string_view> {
public:
	explicit MenuItem(std::string_view name, std::string_view description, std::string_view value) :
		ConfigParam<std::string_view>(name, description, "", "", value) {
	}
};

Window_Settings::Window_Settings(int ix, int iy, int iwidth, int iheight) :
	Window_Selectable(ix, iy, iwidth, iheight) {
	column_max = 1;
}

void Window_Settings::DrawOption(int index) {
	Rect rect = GetItemRect(index);
	contents->ClearRect(rect);

	auto& option = GetFrame().options[index];

	bool enabled = bool(option.action);
	Font::SystemColor color = enabled ? option.color : Font::ColorDisabled;

	contents->TextDraw(rect, color, option.text);
	contents->TextDraw(rect, color, option.value_text, Text::AlignRight);
}

Window_Settings::StackFrame& Window_Settings::GetFrame(int n) {
	auto i = stack_index - n;
	assert(i >= 0 && i < static_cast<int>(stack.size()));
	return stack[i];
}

const Window_Settings::StackFrame& Window_Settings::GetFrame(int n) const {
	auto i = stack_index - n;
	assert(i >= 0 && i < static_cast<int>(stack.size()));
	return stack[i];
}

void Window_Settings::Push(UiMode ui, int arg) {
	SavePosition();

	++stack_index;
	assert(stack_index < static_cast<int>(stack.size()));
	stack[stack_index] = { ui, arg, 0, 0, {}};

	Refresh();
	RestorePosition();
}

void Window_Settings::Pop() {
	SavePosition();
	--stack_index;
	assert(stack_index >= 0);

	Refresh();
	RestorePosition();
}

void Window_Settings::SavePosition() {
	auto mode = GetFrame().uimode;
	if (mode != eNone) {
		auto& mem = memory[mode - 1];
		mem.index = index;
		mem.top_row = GetTopRow();
	}
}

void Window_Settings::RestorePosition() {
	auto mode = GetFrame().uimode;
	if (mode != eNone) {
		auto& mem = memory[mode - 1];
		index = mem.index;
		SetTopRow(mem.top_row);
	}
}

Window_Settings::UiMode Window_Settings::GetMode() const {
	return GetFrame().uimode;
}

void Window_Settings::Refresh() {
	GetFrame().options.clear();

	switch (GetFrame().uimode) {
		case eNone:
		case eMain:
			break;
		case eInput:
			RefreshInput();
			break;
		case eVideo:
			RefreshVideo();
			break;
		case eAudio:
			RefreshAudio();
			break;
		case eAudioMidi:
			RefreshAudioMidi();
			break;
		case eAudioSoundfont:
			RefreshAudioSoundfont();
			break;
		case eEngine:
			RefreshEngine();
			break;
		case eEngineFont1:
			RefreshEngineFont(false);
			break;
		case eEngineFont2:
			RefreshEngineFont(true);
			break;
		case eLicense:
			RefreshLicense();
			break;
		case eInputButtonCategory:
			RefreshButtonCategory();
			break;
		case eInputListButtonsGame:
		case eInputListButtonsEngine:
		case eInputListButtonsDeveloper:
			RefreshButtonList();
			break;
		default:
			break;
	}

	SetItemMax(GetFrame().options.size());

	if (GetFrame().uimode == eNone || GetFrame().options.empty()) {
		SetIndex(-1);
	}

	CreateContents();

	contents->Clear();

	for (int i = 0; i < item_max; ++i) {
		DrawOption(i);
	}
}

void Window_Settings::UpdateHelp() {
	if (index >= 0 && index < static_cast<int>(GetFrame().options.size())) {
		help_window->SetText(GetFrame().options[index].help);
		if (help_window2) {
			help_window2->SetText(GetFrame().options[index].help2);
			help_window2->SetVisible(!GetFrame().options[index].help2.empty());
		}
	} else {
		help_window->SetText("");
		if (help_window2) {
			help_window2->SetVisible(false);
		}
	}
}

template <typename Param, typename Action>
void Window_Settings::AddOption(const Param& param,
	Action&& action)
{
	if (!param.IsOptionVisible()) {
		return;
	}
	Option opt;
	opt.text = ToString(param.GetName());
	opt.help = ToString(param.GetDescription());
	opt.value_text = param.ValueToString();
	opt.mode = eOptionNone;
	if (!param.IsLocked()) {
		opt.action = std::forward<Action>(action);
	}
	GetFrame().options.push_back(std::move(opt));
}

template <typename T, typename Action>
void Window_Settings::AddOption(const RangeConfigParam<T>& param,
		Action&& action
	) {
	if (!param.IsOptionVisible()) {
		return;
	}
	Option opt;
	opt.text = ToString(param.GetName());
	opt.help = ToString(param.GetDescription());
	opt.value_text = param.ValueToString();
	opt.mode = eOptionRangeInput;
	opt.current_value = static_cast<int>(param.Get());
	opt.original_value = opt.current_value;
	opt.min_value = param.GetMin();
	opt.max_value = param.GetMax();
	if (!param.IsLocked()) {
		opt.action = std::forward<Action>(action);
	}
	GetFrame().options.push_back(std::move(opt));
}

template <typename T, typename Action, size_t S>
void Window_Settings::AddOption(const EnumConfigParam<T, S>& param,
			Action&& action
	) {
	if (!param.IsOptionVisible()) {
		return;
	}
	Option opt;
	opt.text = ToString(param.GetName());
	opt.help = ToString(param.GetDescription());
	opt.value_text = param.ValueToString();
	opt.mode = eOptionPicker;
	opt.current_value = static_cast<int>(param.Get());
	opt.original_value = opt.current_value;
	int idx = 0;
	for (auto& s: param.GetValues()) {
		if (param.IsValid(static_cast<T>(idx))) {
			opt.options_text.push_back(ToString(s));
			opt.options_index.push_back(idx);
		}
		++idx;
	}

	idx = 0;
	for (auto& s: param.GetDescriptions()) {
		if (param.IsValid(static_cast<T>(idx))) {
			opt.options_help.push_back(ToString(s));
		}
		++idx;
	}
	if (!param.IsLocked()) {
		opt.action = std::forward<Action>(action);
	}
	GetFrame().options.push_back(std::move(opt));
}

void Window_Settings::RefreshVideo() {
	auto cfg = DisplayUi->GetConfig();

	AddOption(cfg.renderer,	[](){});
	AddOption(cfg.fullscreen, [](){ DisplayUi->ToggleFullscreen(); });
	AddOption(cfg.window_zoom, [](){ DisplayUi->ToggleZoom(); });
	AddOption(cfg.fps, [this](){ DisplayUi->SetShowFps(static_cast<ConfigEnum::ShowFps>(GetCurrentOption().current_value)); });
	AddOption(cfg.vsync, [](){ DisplayUi->ToggleVsync(); });
	AddOption(cfg.fps_limit, [this](){ DisplayUi->SetFrameLimit(GetCurrentOption().current_value); });
	AddOption(cfg.stretch, []() { DisplayUi->ToggleStretch(); });
	AddOption(cfg.scaling_mode, [this](){ DisplayUi->SetScalingMode(static_cast<ConfigEnum::ScalingMode>(GetCurrentOption().current_value)); });
	AddOption(cfg.pause_when_focus_lost, [cfg]() mutable { DisplayUi->SetPauseWhenFocusLost(cfg.pause_when_focus_lost.Toggle()); });
	AddOption(cfg.touch_ui, [](){ DisplayUi->ToggleTouchUi(); });
	AddOption(cfg.game_resolution, [this]() { DisplayUi->SetGameResolution(static_cast<ConfigEnum::GameResolution>(GetCurrentOption().current_value)); });
	AddOption(cfg.screen_scale, [this](){ DisplayUi->SetScreenScale(GetCurrentOption().current_value); });
}

void Window_Settings::RefreshAudio() {
	auto cfg = Audio().GetConfig();

	AddOption(cfg.music_volume, [this](){ Audio().BGM_SetGlobalVolume(GetCurrentOption().current_value); });
	AddOption(cfg.sound_volume, [this](){ Audio().SE_SetGlobalVolume(GetCurrentOption().current_value); });
	if (cfg.fluidsynth_midi.IsOptionVisible() || cfg.wildmidi_midi.IsOptionVisible() || cfg.native_midi.IsOptionVisible() || cfg.fmmidi_midi.IsOptionVisible()) {
		AddOption(MenuItem("MIDI drivers", "Configure MIDI playback", ""), [this]() { Push(eAudioMidi); });
	}
	AddOption(cfg.soundfont, [this](){ Push(eAudioSoundfont); });
}

void Window_Settings::RefreshAudioMidi() {
	auto cfg = Audio().GetConfig();

	bool used = false;

	if (cfg.fluidsynth_midi.IsOptionVisible()) {
		AddOption(cfg.fluidsynth_midi, []() { Audio().SetFluidsynthEnabled(Audio().GetConfig().fluidsynth_midi.Toggle()); });
		if (!MidiDecoder::CheckFluidsynth(GetFrame().options.back().help2)) {
			GetFrame().options.back().text += " [Not working]";
			GetFrame().options.back().color = Font::ColorKnockout;
		} else if (cfg.fluidsynth_midi.Get()) {
			GetFrame().options.back().text += " [In use]";
			used = true;
		}
	}

	if (cfg.wildmidi_midi.IsOptionVisible()) {
		AddOption(cfg.wildmidi_midi, []() { Audio().SetWildMidiEnabled(Audio().GetConfig().wildmidi_midi.Toggle()); });
		if (!MidiDecoder::CheckWildMidi(GetFrame().options.back().help2)) {
			GetFrame().options.back().text += " [Not working]";
			GetFrame().options.back().color = Font::ColorKnockout;
		} else if (cfg.wildmidi_midi.Get() && !used) {
			GetFrame().options.back().text += " [In use]";
			used = true;
		}
	}

	if (cfg.native_midi.IsOptionVisible()) {
		AddOption(cfg.native_midi, []() { Audio().SetNativeMidiEnabled(Audio().GetConfig().native_midi.Toggle()); });
		auto midi_out = Audio().CreateAndGetMidiOut();
		if (!midi_out || !midi_out->IsInitialized(GetFrame().options.back().help2)) {
			GetFrame().options.back().text += " [Not working]";
			GetFrame().options.back().color = Font::ColorKnockout;
		} else if (cfg.native_midi.Get() && !used) {
			GetFrame().options.back().text += " [In use]";
			used = true;
		}
	}

	if (cfg.fmmidi_midi.IsOptionVisible()) {
		AddOption(cfg.fmmidi_midi, []() {});
		if (!used) {
			GetFrame().options.back().text += " [In use]";
		}
	}

	AddOption(MenuItem("> Information <", "The first active and working option is used for MIDI", ""), [](){});
	GetFrame().options.back().help2 = "Changes take effect when a new MIDI file is played";
}

void Window_Settings::RefreshAudioSoundfont() {
	auto fs = Game_Config::GetSoundfontFilesystem();

	if (!fs) {
		Pop();
	}

	fs.ClearCache();

	auto acfg = Audio().GetConfig();
	AddOption(MenuItem("<Autodetect>", "Attempt to find a suitable soundfont automatically", acfg.soundfont.Get().empty() ? "[x]" : ""), [this]() {
		Audio().SetFluidsynthSoundfont({});
		Pop();
	});

	auto list = fs.ListDirectory();
	assert(list);

	std::string sf_lower = Utils::LowerCase(Audio().GetFluidsynthSoundfont());
	for (const auto& item: *list) {
		if (item.second.type == DirectoryTree::FileType::Regular && (EndsWith(item.first, ".sf2") || EndsWith(item.first, ".soundfont"))) {
			AddOption(MenuItem(item.second.name, "Use this custom soundfont", EndsWith(sf_lower, item.first) ? "[x]" : ""), [this, fs, item]() {
				Audio().SetFluidsynthSoundfont(FileFinder::MakePath(fs.GetFullPath(), item.second.name));
				Pop();
			});
		}
	}

	for (auto& opt: GetFrame().options) {
		opt.help2 = "Changes take effect when a new MIDI file is played";
	}

#ifdef EMSCRIPTEN
	AddOption(MenuItem("<Upload Soundfont>", "Provide a soundfont from your system", ""), [fs]() { Emscripten_Interface::UploadSoundfont(); });
#elif defined(SUPPORT_FILE_BROWSER)
	AddOption(MenuItem("<Open Soundfont directory>", "Open the soundfont directory in a file browser", ""), [fs]() { DisplayUi->OpenURL(fs.GetFullPath()); });
#endif
}

#ifdef __clang__
// FIXME: Binding &cfg in the lambdas below is not needed and generates a warning in clang but MSVC requires it
#pragma clang diagnostic ignored "-Wunused-lambda-capture"
#endif

void Window_Settings::RefreshEngine() {
	auto& cfg = Player::player_config;
	cfg.Hide();

	AddOption(cfg.font1, [this, &cfg]() {
		font_size.Set(cfg.font1_size.Get());
		Push(eEngineFont1);
		GetFrame().scratch = -1;
	});
	if (cfg.font1.IsOptionVisible()) {
		if (cfg.font1.IsLocked()) {
			GetFrame().options.back().help = "This game uses a custom font";
		}
		if (Main_Data::game_system->GetFontId() == lcf::rpg::System::Font_gothic) {
			GetFrame().options.back().text += " [In use]";
		}
	}

	AddOption(cfg.font2, [this, &cfg]() {
		font_size.Set(cfg.font2_size.Get());
		Push(eEngineFont2);
		GetFrame().scratch = -1;
	});
	if (cfg.font2.IsOptionVisible()) {
		if (cfg.font2.IsLocked()) {
			GetFrame().options.back().help = "This game uses a custom font";
		}
		if (Main_Data::game_system->GetFontId() == lcf::rpg::System::Font_mincho) {
			GetFrame().options.back().text += " [In use]";
		}
	}

	AddOption(cfg.show_startup_logos, [this, &cfg](){ cfg.show_startup_logos.Set(static_cast<ConfigEnum::StartupLogos>(GetCurrentOption().current_value)); });
	AddOption(cfg.settings_autosave, [&cfg](){ cfg.settings_autosave.Toggle(); });
	AddOption(cfg.settings_in_title, [&cfg](){ cfg.settings_in_title.Toggle(); });
	AddOption(cfg.settings_in_menu, [&cfg](){ cfg.settings_in_menu.Toggle(); });
	AddOption(cfg.lang_select_on_start, [this, &cfg]() { cfg.lang_select_on_start.Set(static_cast<ConfigEnum::StartupLangSelect>(GetCurrentOption().current_value)); });
	AddOption(cfg.lang_select_in_title, [&cfg](){ cfg.lang_select_in_title.Toggle(); });
	AddOption(cfg.log_enabled, [&cfg]() { cfg.log_enabled.Toggle(); });
	AddOption(cfg.screenshot_scale, [this, &cfg](){ cfg.screenshot_scale.Set(GetCurrentOption().current_value); });

	GetFrame().options.back().help2 = fmt::format("Screenshot size: {}x{}",
		Player::screen_width * cfg.screenshot_scale.Get(), Player::screen_height * cfg.screenshot_scale.Get());

	auto fmt_sample_name = [](bool is_auto_screenshot) {
		auto name = Output::GetScreenshotName(is_auto_screenshot);
		if (Player::player_config.screenshot_timestamp.Get()) {
			return name + ".png";
		}
		return name + "_0.png";
	};

	AddOption(cfg.screenshot_timestamp, [this, &cfg]() { cfg.screenshot_timestamp.Toggle(); });
	GetFrame().options.back().help2 = fmt::format("Sample name: {}", fmt_sample_name(false));

	AddOption(cfg.automatic_screenshots, [&cfg]() { cfg.automatic_screenshots.Toggle(); });
	if (Player::player_config.automatic_screenshots.Get()) {
		GetFrame().options.back().help2 = fmt::format("Sample name: {}", fmt_sample_name(true));
	}
	AddOption(cfg.automatic_screenshots_interval, [this, &cfg]() { cfg.automatic_screenshots_interval.Set(GetCurrentOption().current_value); });
}

void Window_Settings::RefreshEngineFont(bool mincho) {
	auto fs = Game_Config::GetFontFilesystem();

	if (!fs) {
		Pop();
	}

	fs.ClearCache();

	auto& cfg = Player::player_config;

	auto& setting = mincho ? cfg.font2 : cfg.font1;

	auto set_help2 = [this]() {
		GetFrame().options.back().help2 = ToString(sample_text.GetDescriptions()[static_cast<int>(sample_text.Get())]);
	};

	AddOption(MenuItem("<Built-in Font>", "Use the built-in pixel font", setting.Get().empty() ? "[x]" : ""), [this, &setting, mincho]() {
		Font::SetDefault(nullptr, mincho);
		setting.Set("");
		Pop();
	});
	set_help2();

	std::string font_lower = Utils::LowerCase(Font::Default(mincho)->GetName());

	auto list = fs.ListDirectory();
	assert(list);
	for (const auto& item: *list) {
		bool is_font = std::any_of(FileFinder::FONTS_TYPES.begin(), FileFinder::FONTS_TYPES.end(), [&item](const auto& ext) {
			return EndsWith(item.first, ext);
		});

		if (item.second.type == DirectoryTree::FileType::Regular && is_font) {
			AddOption(MenuItem(item.second.name, "Use this font", EndsWith(font_lower, item.first) ? "[x]" : ""), [=, &cfg, &setting]() mutable {
				if (Input::IsTriggered(Input::LEFT) || Input::IsRepeated(Input::LEFT)) {
					if (font_size.Get() == font_size.GetMin()) {
						font_size.Set(font_size.GetMax());
					} else {
						font_size.Set(font_size.Get() - 1);
					}
					return;
				} else if (Input::IsTriggered(Input::RIGHT) || Input::IsRepeated(Input::RIGHT)) {
					if (font_size.Get() == font_size.GetMax()) {
						font_size.Set(font_size.GetMin());
					} else {
						font_size.Set(font_size.Get() + 1);
					}
					return;
				}

				auto is = fs.OpenInputStream(item.second.name);
				if (is) {
					auto font = Font::CreateFtFont(std::move(is), font_size.Get(), false, false);
					if (font) {
						setting.Set(FileFinder::MakePath(fs.GetFullPath(), item.second.name));
						auto& setting_size = mincho ? cfg.font2_size : cfg.font1_size;
						setting_size.Set(font->GetCurrentStyle().size);
						Font::SetDefault(font, mincho);
						Pop();
					}
				}
			});
			set_help2();
		}
	}

	/*AddOption(font_size, [this]() mutable {
		font_size.Set(GetCurrentOption().current_value);
	});*/

	AddOption(sample_text, [this]() {
		sample_text.Set(static_cast<SampleText>(GetCurrentOption().current_value));
	});
	set_help2();

#ifdef EMSCRIPTEN
	AddOption(MenuItem("<Upload Font>", "Provide a font from your system", ""), [fs]() { Emscripten_Interface::UploadFont(); });
#elif defined(SUPPORT_FILE_BROWSER)
	AddOption(MenuItem("<Open Font directory>", "Open the font directory in a file browser", ""), [fs]() { DisplayUi->OpenURL(fs.GetFullPath()); });
#endif
}

void Window_Settings::RefreshLicense() {
	AddOption(MenuItem("EasyRPG Player", "The engine you are using :)", "GPLv3+"), [this](){
		Push(eAbout);
	});
	AddOption(MenuItem("liblcf", "Handles RPG Maker 2000/2003 and EasyRPG projects", "MIT"), [](){});
	AddOption(MenuItem("libpng", "For reading and writing PNG image files", "zlib"), [](){});
	AddOption(MenuItem("zlib", "Implements deflate used in ZIP archives and PNG images", "zlib"), [](){});
	AddOption(MenuItem("Pixman", "Pixel-manipulation library", "MIT"), [](){});
	AddOption(MenuItem("fmtlib", "Text formatting library", "BSD"), [](){});
	// No way to detect them - Used by liblcf
	AddOption(MenuItem("expat", "XML parser", "MIT"), [](){});
	AddOption(MenuItem("ICU", "Unicode library", "ICU"), [](){});
#if USE_SDL == 1
	AddOption(MenuItem("SDL1", "Abstraction layer for graphic, audio, input and more", "LGPLv2.1+"), [](){});
#elif USE_SDL == 2
	AddOption(MenuItem("SDL2", "Abstraction layer for graphic, audio, input and more", "zlib"), [](){});
#elif USE_SDL == 3
	AddOption(MenuItem("SDL3", "Abstraction layer for graphic, audio, input and more", "zlib"), [](){});
#endif
#ifdef HAVE_FREETYPE
	AddOption(MenuItem("Freetype", "Font parsing and rasterization library", "Freetype"), [](){});
#endif
#ifdef HAVE_HARFBUZZ
	AddOption(MenuItem("Harfbuzz", "Text shaping engine", "MIT"), [](){});
#endif
#ifdef SUPPORT_AUDIO
	// Always shown because the Midi synth is compiled in
	AddOption(MenuItem("FmMidi", "MIDI file parser and Yamaha YM2608 FM synthesizer", "BSD"), [](){});
#ifdef HAVE_LIBMPG123
	AddOption(MenuItem("mpg123", "Decodes MPEG Audio Layer 1, 2 and 3", "LGPLv2.1+"), [](){});
#endif
#ifdef HAVE_LIBSNDFILE
	AddOption(MenuItem("libsndfile", "Decodes sampled audio data (WAV)", "LGPLv2.1+"), [](){});
#endif
#ifdef HAVE_OGGVORBIS
	AddOption(MenuItem("ogg", "Ogg container format library", "BSD"), [](){});
	AddOption(MenuItem("vorbis", "Decodes the free Ogg Vorbis audio codec", "BSD"), [](){});
#endif
#ifdef HAVE_TREMOR
	AddOption(MenuItem("tremor", "Decodes the free Ogg Vorbis audio format", "BSD"), [](){});
#endif
#ifdef HAVE_OPUS
	AddOption(MenuItem("opus", "Decodes the free OPUS audio codec", "BSD"), [](){});
#endif
#ifdef HAVE_LIBWILDMIDI
	AddOption(MenuItem("WildMidi", "MIDI synthesizer", "LGPLv3+"), [](){});
#endif
#ifdef HAVE_FLUIDSYNTH
	AddOption(MenuItem("FluidSynth", "MIDI synthesizer supporting SoundFont 2", "LGPLv2.1+"), [](){});
#endif
#ifdef HAVE_FLUIDLITE
	AddOption(MenuItem("FluidLite", "MIDI synthesizer supporting SoundFont 2 (lite version)", "LGPLv2.1+"), [](){});
#endif
#ifdef HAVE_XMP
	AddOption(MenuItem("xmp-lite", "Module (MOD, S3M, XM and IT) synthesizer", "MIT"), [](){});
#endif
#ifdef HAVE_LIBSPEEXDSP
	AddOption(MenuItem("speexdsp", "Audio resampler", "BSD"), [](){});
#endif
#ifdef HAVE_LIBSAMPLERATE
	AddOption(MenuItem("samplerate", "Audio resampler", "BSD"), [](){});
#endif
#ifdef WANT_DRWAV
	AddOption(MenuItem("dr_wav", "Decodes sampled audio data (WAV)", "MIT-0"), [](){});
#endif
#ifdef HAVE_ALSA
	AddOption(MenuItem("ALSA", "Linux sound support (used for MIDI playback)", "LGPL2.1+"), [](){});
#endif
#endif
#ifdef HAVE_LHASA
	AddOption(MenuItem("lhasa", "For parsing LHA (.lzh) archives", "ISC"), [](){});
#endif
#ifdef HAVE_NLOHMANN_JSON
	AddOption(MenuItem("nlohmann_json", "Processing of JSON files", "MIT"), [](){});
#endif
#ifdef WANT_FONT_BAEKMUK
	AddOption(MenuItem("Baekmuk", "Korean font family", "Baekmuk"), [](){});
#endif
	AddOption(MenuItem("Shinonome", "Japanese font family", "Public Domain"), [](){});
	AddOption(MenuItem("ttyp0", "ttyp0 font family", "ttyp0"), [](){});
#ifdef WANT_FONT_WQY
	AddOption(MenuItem("WenQuanYi", "WenQuanYi font family (CJK)", "GPLv2+ with FE"), [](){});
#endif
#ifdef EMSCRIPTEN
	AddOption(MenuItem("Teenyicons", "Tiny minimal 1px icons", "MIT"), [](){});
#endif
}

void Window_Settings::RefreshInput() {
	Game_ConfigInput& cfg = Input::GetInputSource()->GetConfig();

	AddOption(MenuItem("Key/Button mapping", "Change the keybindings", ""),
		[this]() { Push(eInputButtonCategory); });
	AddOption(cfg.gamepad_swap_ab_and_xy, [&cfg](){ cfg.gamepad_swap_ab_and_xy.Toggle(); Input::ResetTriggerKeys(); });
	AddOption(cfg.gamepad_swap_analog, [&cfg](){ cfg.gamepad_swap_analog.Toggle(); Input::ResetTriggerKeys(); });
	AddOption(cfg.gamepad_swap_dpad_with_buttons, [&cfg](){ cfg.gamepad_swap_dpad_with_buttons.Toggle(); Input::ResetTriggerKeys(); });
	AddOption(cfg.speed_modifier_a, [this, &cfg](){ cfg.speed_modifier_a.Set(GetCurrentOption().current_value); });
	AddOption(cfg.speed_modifier_b, [this, &cfg](){ cfg.speed_modifier_b.Set(GetCurrentOption().current_value); });
}

void Window_Settings::RefreshButtonCategory() {
	AddOption(MenuItem("Game", "Buttons used by games", ""),
		[this]() { Push(eInputListButtonsGame, 0); });
	AddOption(MenuItem("Engine", "Buttons to access engine features", ""),
		[this]() { Push(eInputListButtonsEngine, 1); });
	AddOption(MenuItem("Developer", "Buttons useful for developers", ""),
		[this]() { Push(eInputListButtonsDeveloper, 2); });
}

void Window_Settings::RefreshButtonList() {
	auto& mappings = Input::GetInputSource()->GetButtonMappings();
	auto custom_names = Input::GetInputKeyNames();

	std::vector<Input::InputButton> buttons;
	switch (GetFrame().arg) {
		case 0:
			buttons = {	Input::UP, Input::DOWN, Input::LEFT, Input::RIGHT, Input::DECISION, Input::CANCEL, Input::SHIFT,
				Input::N0, Input::N1, Input::N2, Input::N3, Input::N4, Input::N5, Input::N6, Input::N7, Input::N8, Input::N9,
				Input::PLUS, Input::MINUS, Input::MULTIPLY, Input::DIVIDE, Input::PERIOD, Input::MOUSE_LEFT,
				Input::MOUSE_MIDDLE, Input::MOUSE_RIGHT, Input::SCROLL_UP, Input::SCROLL_DOWN };
			break;
		case 1:
			buttons = {Input::SETTINGS_MENU, Input::TOGGLE_FPS, Input::TOGGLE_FULLSCREEN, Input::TOGGLE_ZOOM,
				Input::TAKE_SCREENSHOT, Input::RESET, Input::FAST_FORWARD_A, Input::FAST_FORWARD_B,
				Input::PAGE_UP, Input::PAGE_DOWN };
			break;
		case 2:
			buttons = {	Input::DEBUG_MENU, Input::DEBUG_THROUGH, Input::DEBUG_SAVE, Input::DEBUG_ABORT_EVENT,
				Input::SHOW_LOG };
			break;
	}

	for (auto b: buttons) {
		auto button = static_cast<Input::InputButton>(b);

		std::string name = Input::kInputButtonNames.tag(button);

		// Improve readability of the names
		bool first_letter = true;
		for (size_t i = 0; i < name.size(); ++i) {
			auto& ch = name[i];
			if (ch >= 'A' && ch <= 'Z') {
				if (!first_letter) {
					ch += 32;
				}
				first_letter = false;
			} else if (ch == '_') {
				ch = ' ';
				first_letter = true;
			}
		}

		std::string help = Input::kInputButtonHelp.tag(button);
		std::string value;

		// Append as many buttons as fit on the screen, then add ...
		int contents_w = GetContents()->width();
		int name_size = Text::GetSize(*Font::Default(), name).width;
		int value_size = 0;

		for (auto ki = mappings.LowerBound(button); ki != mappings.end() && ki->first == button; ++ki) {
			auto custom_name = std::find_if(custom_names.begin(), custom_names.end(), [&](auto& key_pair) {
				return key_pair.first == ki->second;
			});

			std::string cur_value;
			if (custom_name != custom_names.end()) {
				cur_value = custom_name->second;
			} else {
				cur_value = Input::Keys::kInputKeyNames.tag(ki->second);
			}

			int cur_value_size = Text::GetSize(*Font::Default(), cur_value + ",").width;

			if (value.empty()) {
				value = cur_value;
			} else if (name_size + value_size + cur_value_size + 24 > contents_w) {
				value += ",…";
				break;
			} else {
				value += "," + cur_value;
			}

			value_size += cur_value_size;
		}

		switch (button) {
			case Input::FAST_FORWARD_A: {
				Game_ConfigInput& cfg = Input::GetInputSource()->GetConfig();
				help = fmt::format(help, cfg.speed_modifier_a.Get());
				break;
			}
			case Input::FAST_FORWARD_B: {
				Game_ConfigInput& cfg = Input::GetInputSource()->GetConfig();
				help = fmt::format(help, cfg.speed_modifier_b.Get());
				break;
			}
			default:
				break;
		}

		auto param = MenuItem(name, help, value);
		AddOption(param,
				[this, button](){
				Push(eInputButtonOption, static_cast<int>(button));
			});
	}
}


/*end of file .\window_settings.cpp*/

/*start of file .\window_shop.cpp*/

/* ... license chunk ... */

// Headers
#include <string>
#include "input.h"
#include "scene.h"
#include "scene_shop.h"
#include "game_system.h"
#include "game_message.h"
#include "window_shop.h"
#include "bitmap.h"
#include "font.h"

Window_Shop::Window_Shop(int shop_type, int ix, int iy, int iwidth, int iheight) :
	Window_Base(ix, iy, iwidth, iheight) {

	SetContents(Bitmap::Create(width - 16, height - 16));

	switch (shop_type) {
		case 0:
			greeting = lcf::Data::terms.shop_greeting1;
			regreeting = lcf::Data::terms.shop_regreeting1;
			buy_msg = lcf::Data::terms.shop_buy1;
			sell_msg = lcf::Data::terms.shop_sell1;
			leave_msg = lcf::Data::terms.shop_leave1;
			buy_select = lcf::Data::terms.shop_buy_select1;
			buy_number = lcf::Data::terms.shop_buy_number1;
			purchased = lcf::Data::terms.shop_purchased1;
			sell_select = lcf::Data::terms.shop_sell_select1;
			sell_number = lcf::Data::terms.shop_sell_number1;
			sold_msg = lcf::Data::terms.shop_sold1;
			break;
		case 1:
			greeting = lcf::Data::terms.shop_greeting2;
			regreeting = lcf::Data::terms.shop_regreeting2;
			buy_msg = lcf::Data::terms.shop_buy2;
			sell_msg = lcf::Data::terms.shop_sell2;
			leave_msg = lcf::Data::terms.shop_leave2;
			buy_select = lcf::Data::terms.shop_buy_select2;
			buy_number = lcf::Data::terms.shop_buy_number2;
			purchased = lcf::Data::terms.shop_purchased2;
			sell_select = lcf::Data::terms.shop_sell_select2;
			sell_number = lcf::Data::terms.shop_sell_number2;
			sold_msg = lcf::Data::terms.shop_sold2;
			break;
		case 2:
			greeting = lcf::Data::terms.shop_greeting3;
			regreeting = lcf::Data::terms.shop_regreeting3;
			buy_msg = lcf::Data::terms.shop_buy3;
			sell_msg = lcf::Data::terms.shop_sell3;
			leave_msg = lcf::Data::terms.shop_leave3;
			buy_select = lcf::Data::terms.shop_buy_select3;
			buy_number = lcf::Data::terms.shop_buy_number3;
			purchased = lcf::Data::terms.shop_purchased3;
			sell_select = lcf::Data::terms.shop_sell_select3;
			sell_number = lcf::Data::terms.shop_sell_number3;
			sold_msg = lcf::Data::terms.shop_sold3;
			break;
	}

	mode = Scene_Shop::BuySellLeave;
	index = 1;

	Refresh();
}

void Window_Shop::UpdateCursorRect() {
	int x = 4;
	int width = contents->GetWidth() - 8;
	if (!Main_Data::game_system->GetMessageFaceName().empty()) {
		if (!Main_Data::game_system->IsMessageFaceRightPosition()) {
			x += LeftMargin + FaceSize + RightFaceMargin;
		}
		width -= LeftMargin + FaceSize + RightFaceMargin;
	}

	Rect rect;
	switch (mode) {
		case Scene_Shop::BuySellLeave:
		case Scene_Shop::BuySellLeave2:
			rect = Rect(x, index * 16, width, 16);
			break;
		default:
			rect = Rect();
			break;
	}

	SetCursorRect(rect);
}

void Window_Shop::Refresh() {
	contents->Clear();

	int x = 0;
	if (!Main_Data::game_system->GetMessageFaceName().empty()) {
		if (!Main_Data::game_system->IsMessageFaceRightPosition()) {
			x += LeftMargin + FaceSize + RightFaceMargin;
			DrawFace(Main_Data::game_system->GetMessageFaceName(), Main_Data::game_system->GetMessageFaceIndex(), LeftMargin, TopMargin, Main_Data::game_system->IsMessageFaceFlipped());
		}
		else {
			DrawFace(Main_Data::game_system->GetMessageFaceName(), Main_Data::game_system->GetMessageFaceIndex(), 248, TopMargin, Main_Data::game_system->IsMessageFaceFlipped());
		}
	}

	int idx = 0;
	switch (mode) {
		case Scene_Shop::BuySellLeave:
		case Scene_Shop::BuySellLeave2:
			contents->TextDraw(x, 2, Font::ColorDefault,
							   mode == Scene_Shop::BuySellLeave2
							   ? regreeting
							   : greeting);
			idx++;

			contents->TextDraw(x + 12, 2 + idx * 16, Font::ColorDefault, buy_msg);
			buy_index = idx++;

			contents->TextDraw(x + 12, 2 + idx * 16, Font::ColorDefault, sell_msg);
			sell_index = idx++;

			contents->TextDraw(x + 12, 2 + idx * 16, Font::ColorDefault, leave_msg);
			leave_index = idx++;
			break;
		case Scene_Shop::Buy:
			contents->TextDraw(x, 2, Font::ColorDefault, buy_select);
			break;
		case Scene_Shop::BuyHowMany:
			contents->TextDraw(x, 2, Font::ColorDefault, buy_number);
			break;
		case Scene_Shop::Bought:
			contents->TextDraw(x, 2, Font::ColorDefault, purchased);
			break;
		case Scene_Shop::Sell:
			contents->TextDraw(x, 2, Font::ColorDefault, sell_select);
			break;
		case Scene_Shop::SellHowMany:
			contents->TextDraw(x, 2, Font::ColorDefault, sell_number);
			break;
		case Scene_Shop::Sold:
			contents->TextDraw(x, 2, Font::ColorDefault, sold_msg);
			break;
	}

	UpdateCursorRect();
}

void Window_Shop::SetMode(int nmode) {
	mode = nmode;
	Refresh();
}

int Window_Shop::GetChoice() const {
	return choice;
}

void Window_Shop::SetChoice(int nchoice) {
	choice = nchoice;
}

void Window_Shop::Update() {
	Window_Base::Update();

	if (active) {
		switch (mode) {
			case Scene_Shop::BuySellLeave:
			case Scene_Shop::BuySellLeave2:
				if (Input::IsRepeated(Input::DOWN) || Input::IsTriggered(Input::SCROLL_DOWN)) {
					if (index < leave_index) {
						index++;
					}
					else {
						index = 1;
					}
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
				}
				if (Input::IsRepeated(Input::UP) || Input::IsTriggered(Input::SCROLL_UP)) {
					if (index > 1) {
						index--;
					}
					else {
						index = leave_index;
					}
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
				}
				if (Input::IsTriggered(Input::DECISION)) {
					Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
					if (index == buy_index)
						choice = Scene_Shop::Buy;
					if (index == sell_index)
						choice = Scene_Shop::Sell;
					if (index == leave_index)
						choice = Scene_Shop::Leave;
				}
				break;
		}
	}

	UpdateCursorRect();
}


/*end of file .\window_shop.cpp*/

/*start of file .\window_shopbuy.cpp*/

/* ... license chunk ... */

// Headers
#include <sstream>
#include <string>
#include "window_base.h"
#include "window_shopbuy.h"
#include "game_system.h"
#include "game_party.h"
#include "bitmap.h"
#include "font.h"
#include "output.h"
#include <lcf/reader_util.h>

Window_ShopBuy::Window_ShopBuy(const std::vector<int>& goods,
		int ix, int iy, int iwidth, int iheight)
	: Window_Selectable(ix, iy, iwidth, iheight)
	  , data(goods)
{
	index = 0;
	item_max = data.size();
}

int Window_ShopBuy::GetItemId() {
	if (index < 0 || index >= (int)data.size()) {
		return 0;
	} else {
		return data[index];
	}
}

void Window_ShopBuy::Refresh() {
	CreateContents();

	contents->Clear();
	Rect rect(0, 0, contents->GetWidth(), contents->GetHeight());
	contents->Clear();

	for (size_t i = 0; i < data.size(); ++i) {
		DrawItem(i);
	}
}

void Window_ShopBuy::DrawItem(int index) {
	int item_id = data[index];

	// (Shop) items are guaranteed to be valid
	const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);

	int price = 0;
	bool enabled = false;

	if (!item) {
		Output::Warning("Window ShopBuy: Invalid item ID {}", item_id);
	} else {
		enabled = item->price <= Main_Data::game_party->GetGold() && Main_Data::game_party->GetItemCount(item_id) < Main_Data::game_party->GetMaxItemCount(item_id);
		price = item->price;
	}

	Rect rect = GetItemRect(index);
	contents->ClearRect(rect);
	DrawItemName(*item, rect.x, rect.y, enabled);

	std::string str = std::to_string(price);
	contents->TextDraw(rect.width, rect.y, enabled ? Font::ColorDefault : Font::ColorDisabled, str, Text::AlignRight);
}

void Window_ShopBuy::UpdateHelp() {
	std::string help_text = "";
	if (!data.empty()) {
		const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, data[index]);
		if (item) {
			help_text = ToString(item->description);
		} else {
			help_text = "??? BAD ITEM ???";
		}
	}

	help_window->SetText(std::move(help_text));
}

bool Window_ShopBuy::CheckEnable(int item_id) {
	const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
	if (!item) {
		return false;
	}

	return (item->price <= Main_Data::game_party->GetGold() &&
		Main_Data::game_party->GetItemCount(item_id) < Main_Data::game_party->GetMaxItemCount(item_id));
}


/*end of file .\window_shopbuy.cpp*/

/*start of file .\window_shopnumber.cpp*/

/* ... license chunk ... */

// Headers
#include <sstream>
#include "game_system.h"
#include "input.h"
#include "util_macro.h"
#include "window_shopnumber.h"
#include "bitmap.h"
#include "font.h"
#include <lcf/reader_util.h>

Window_ShopNumber::Window_ShopNumber(int ix, int iy, int iwidth, int iheight) :
	Window_Base(ix, iy, iwidth, iheight),
	item_max(1), price(0), number(1), item_id(0) {

	SetContents(Bitmap::Create(width - 16, height - 16));
	contents->Clear();
}

void Window_ShopNumber::SetData(int item_id, int item_max, int price) {
	this->item_id = item_id;
	this->item_max = item_max;
	this->price = price;
	number = 1;
}

void Window_ShopNumber::Refresh() {
	contents->Clear();

	int y = 34;
	// (Shop) items are guaranteed to be valid
	DrawItemName(*lcf::ReaderUtil::GetElement(lcf::Data::items, item_id), 0, y);

	std::stringstream ss;
	ss << number;

	contents->TextDraw(132, y, Font::ColorDefault, "x");
	contents->TextDraw(132 + 30, y, Font::ColorDefault, ss.str(), Text::AlignRight);
	if (item_max >= 100) {
		SetCursorRect(Rect(132 + 8, y - 2, 26, 16));
	} else {
		SetCursorRect(Rect(132 + 14, y - 2, 20, 16));
	}

	DrawCurrencyValue(GetTotal(), contents->GetWidth(), y + 32);
}

int Window_ShopNumber::GetNumber() const {
	return number;
}

void Window_ShopNumber::Update() {
	Window_Base::Update();

	if (active) {
		int last_number = number;
		if (Input::IsRepeated(Input::RIGHT) && number < item_max) {
			number++;
		} else if (Input::IsRepeated(Input::LEFT) && number > 1) {
			number--;
		} else if ((Input::IsRepeated(Input::UP) || Input::IsTriggered(Input::SCROLL_UP))
			&& number < item_max) {
			number = min(number + 10, item_max);
		} else if ((Input::IsRepeated(Input::DOWN) || Input::IsTriggered(Input::SCROLL_DOWN))
			&& number > 1) {
			number = max(number - 10, 1);
		}

		if (last_number != number) {
			Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Cursor));
			Refresh();
		}
	}
}

int Window_ShopNumber::GetTotal() const {
	return price * number;
}


/*end of file .\window_shopnumber.cpp*/

/*start of file .\window_shopparty.cpp*/

/* ... license chunk ... */

// Headers
#include "bitmap.h"
#include "cache.h"
#include "game_party.h"
#include "game_actor.h"
#include "window_shopparty.h"
#include "output.h"
#include <lcf/reader_util.h>
#include "sprite_character.h"

Window_ShopParty::Window_ShopParty(int ix, int iy, int iwidth, int iheight) :
	Window_Base(ix, iy, iwidth, iheight) {

	SetBorderX(4);
	SetBorderY(4);
	SetContents(Bitmap::Create(width - GetBorderX() * 2, height - 16));

	cycle = 0;
	item_id = 0;

	const std::vector<Game_Actor*>& actors = Main_Data::game_party->GetActors();
	for (size_t i = 0; i < actors.size() && i < 4; i++) {
		const auto& sprite_name = actors[i]->GetSpriteName();
		FileRequestAsync* request = AsyncHandler::RequestFile("CharSet", sprite_name);
		request->SetGraphicFile(true);
		request_ids.push_back(request->Bind(&Window_ShopParty::OnCharsetSpriteReady, this, (int)i));
		request->Start();
	}

	Refresh();
}

static int CmpEquip(const Game_Actor* actor, const lcf::rpg::Item* new_item) {
	auto atk = actor->GetBaseAtk(Game_Battler::WeaponAll, true, false);
	auto def = actor->GetBaseDef(Game_Battler::WeaponAll, true, false);
	auto spi = actor->GetBaseSpi(Game_Battler::WeaponAll, true, false);
	auto agi = actor->GetBaseAgi(Game_Battler::WeaponAll, true, false);

	auto add_item = [&](const lcf::rpg::Item* item, int mod = 1) {
		if (item) {
			atk += item->atk_points1 * mod;
			def += item->def_points1 * mod;
			spi += item->spi_points1 * mod;
			agi += item->agi_points1 * mod;
		}
	};

	for (int i = 1; i <= 5; i++) {
		auto* count_item = actor->GetEquipment(i);
		add_item(count_item, 1);
	}

	atk = Utils::Clamp(atk, 1, 999);
	def = Utils::Clamp(def, 1, 999);
	spi = Utils::Clamp(spi, 1, 999);
	agi = Utils::Clamp(agi, 1, 999);

	int old_score = atk + def + spi + agi;

	atk = actor->GetBaseAtk(Game_Battler::WeaponAll, true, false);
	def = actor->GetBaseDef(Game_Battler::WeaponAll, true, false);
	spi = actor->GetBaseSpi(Game_Battler::WeaponAll, true, false);
	agi = actor->GetBaseAgi(Game_Battler::WeaponAll, true, false);

	for (int i = 1; i <= 5; i++) {
		auto* count_item = actor->GetEquipment(i);
		add_item(count_item, 1);
	}

	auto* old_item = actor->GetEquipment(new_item->type);
	// If its a weapon or shield, get the other hand
	const lcf::rpg::Item* other_old_item = nullptr;
	if (new_item->type == lcf::rpg::Item::Type_weapon) {
		other_old_item = actor->GetEquipment(lcf::rpg::Item::Type_shield);
	} else if (new_item->type == lcf::rpg::Item::Type_shield) {
		other_old_item = actor->GetEquipment(lcf::rpg::Item::Type_weapon);
	}

	add_item(old_item, -1);
	// If other hand had a two handed weapon, or we considering a 2 handed weapon, remove the other hand.
	if (new_item && other_old_item &&
			((other_old_item->type == lcf::rpg::Item::Type_weapon && other_old_item->two_handed) || (new_item->type == lcf::rpg::Item::Type_weapon && new_item->two_handed))) {
		add_item(other_old_item, -1);
	}
	add_item(new_item, 1);

	int limit = actor->MaxStatBaseValue();

	atk = Utils::Clamp(atk, 1, limit);
	def = Utils::Clamp(def, 1, limit);
	spi = Utils::Clamp(spi, 1, limit);
	agi = Utils::Clamp(agi, 1, limit);

	int new_score = atk + def + spi + agi;

	return new_score - old_score;
}

static bool IsEquipment(const lcf::rpg::Item* item) {
	return item->type == lcf::rpg::Item::Type_weapon
		|| item->type == lcf::rpg::Item::Type_shield
		|| item->type == lcf::rpg::Item::Type_helmet
		|| item->type == lcf::rpg::Item::Type_armor
		|| item->type == lcf::rpg::Item::Type_accessory;
}

void Window_ShopParty::Refresh() {
	contents->Clear();

	BitmapRef system = Cache::SystemOrBlack();

	if (item_id < 0 || item_id > static_cast<int>(lcf::Data::items.size()))
		return;

	const std::vector<Game_Actor*>& actors = Main_Data::game_party->GetActors();
	for (int i = 0; i < static_cast<int>(actors.size()) && i < 4; i++) {
		Game_Actor *actor = actors[i];
		int phase = (cycle / anim_rate) % 4;
		int phasecmp = phase;
		if (phase == 3) {
			phase = 1;
		}
		// RPG_RT displays the actors in an empty shop.
		bool usable = item_id == 0 || actor->IsEquippable(item_id);
		BitmapRef bm = bitmaps[i][usable ? phase : 1][usable ? 1 : 0];

		if (bm) {
			contents->Blit(i * 32, 0, *bm, bm->GetRect(), 255);
		}

		const auto* new_item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);
		if (new_item == nullptr) {
			// Can be null for an empty shop, in which case there is only 1 item 0.
			return;
		}

		bool equippable = usable && IsEquipment(new_item);

		if (equippable) {
			// check if item is equipped by each member
			bool is_equipped = false;
			for (int j = 1; j <= 5; ++j) {
				const lcf::rpg::Item* item = actor->GetEquipment(j);
				if (item) {
					is_equipped |= (item->ID == item_id);
				}
			}
			if (is_equipped)
				contents->Blit(i * 32 + 20, 24, *system, Rect(128 + 8 * phase, 24, 8, 8), 255);
			else {
				int cmp = CmpEquip(actor, new_item);
				if (cmp > 0) {
					contents->Blit(i * 32 + 20, 24, *system, Rect(128 + 8 * phasecmp, 0, 8, 8), 255);
				}
				else if (cmp < 0) {
					contents->Blit(i * 32 + 20, 24, *system, Rect(128 + 8 * phasecmp, 16, 8, 8), 255);
				}
				else {
					contents->Blit(i * 32 + 20, 24, *system, Rect(128 + 8 * phasecmp, 8, 8, 8), 255);
				}
			}
		}
	}
}

void Window_ShopParty::SetItemId(int nitem_id) {
	if (nitem_id != item_id) {
		item_id = nitem_id;
		Refresh();
	}
}

void Window_ShopParty::Update() {
	cycle++;
	if (cycle % anim_rate == 0)
		Refresh();
}

void Window_ShopParty::OnCharsetSpriteReady(FileRequestResult* /* result */, int party_index) {
	Game_Actor *actor = Main_Data::game_party->GetActors()[party_index];
	std::string_view sprite_name = actor->GetSpriteName();
	int sprite_id = actor->GetSpriteIndex();
	BitmapRef bm = Cache::Charset(sprite_name);
	auto rect = Sprite_Character::GetCharacterRect(sprite_name, sprite_id, bm->GetRect());
	int width = rect.width / 3;
	int height = rect.height / 4;
	for (int j = 0; j < 3; j++) {
		int sx = ((sprite_id % 4) * 3 + j) * width;
		int sy = ((sprite_id / 4) * 4 + 2) * height;
		Rect src(sx, sy, width, height);
		for (int k = 0; k < 2; k++) {
			BitmapRef bm2 = Bitmap::Create(width, height, true);
			bm2->Clear();
			bm2->Blit(0, 0, *bm, src, 255);
			if (k == 0)
				bm2->ToneBlit(0, 0, *bm2, bm2->GetRect(), Tone(128, 128, 128, 0), Opacity::Opaque());
			bitmaps[party_index][j][k] = bm2;
		}
	}
}


/*end of file .\window_shopparty.cpp*/

/*start of file .\window_shopsell.cpp*/

/* ... license chunk ... */

// Headers
#include <iomanip>
#include <sstream>
#include "window_shopsell.h"
#include "game_party.h"
#include "output.h"
#include <lcf/reader_util.h>

Window_ShopSell::Window_ShopSell(int ix, int iy, int iwidth, int iheight) :
	Window_Item(ix, iy, iwidth, iheight) {}

bool Window_ShopSell::CheckEnable(int item_id) {
	// Items are guaranteed to be valid

	const lcf::rpg::Item* item = lcf::ReaderUtil::GetElement(lcf::Data::items, item_id);

	return item->price > 0;
}


/*end of file .\window_shopsell.cpp*/

/*start of file .\window_shopstatus.cpp*/

/* ... license chunk ... */

// Headers
#include <string>
#include <sstream>
#include "game_party.h"
#include "window_shopstatus.h"
#include "bitmap.h"
#include "font.h"

Window_ShopStatus::Window_ShopStatus(int ix, int iy, int iwidth, int iheight) :
	Window_Base(ix, iy, iwidth, iheight), item_id(0) {

	SetContents(Bitmap::Create(width - 16, height - 16));

	Refresh();
}

void Window_ShopStatus::Refresh() {
	contents->Clear();

	int number = 0;
	int equipped = 0;

	if (item_id != 0) {
		number = Main_Data::game_party->GetItemCount(item_id);
		equipped = Main_Data::game_party->GetEquippedItemCount(item_id);
	}

	contents->TextDraw(0, 2, 1, lcf::Data::terms.possessed_items);
	contents->TextDraw(0, 18, 1, lcf::Data::terms.equipped_items);

	contents->TextDraw(120, 2, Font::ColorDefault, std::to_string(number), Text::AlignRight);

	contents->TextDraw(120, 18, Font::ColorDefault, std::to_string(equipped), Text::AlignRight);
}

void Window_ShopStatus::SetItemId(int new_item_id) {
	if (new_item_id != item_id) {
		item_id = new_item_id;
		Refresh();
	}
}


/*end of file .\window_shopstatus.cpp*/

/*start of file .\window_skill.cpp*/

/* ... license chunk ... */

// Headers
#include <iomanip>
#include <sstream>
#include "window_skill.h"
#include "game_actor.h"
#include "game_actors.h"
#include "game_party.h"
#include "bitmap.h"
#include "font.h"
#include "player.h"
#include "output.h"
#include <lcf/reader_util.h>
#include "game_battle.h"

Window_Skill::Window_Skill(int ix, int iy, int iwidth, int iheight) :
	Window_Selectable(ix, iy, iwidth, iheight), subset(0) {
	column_max = 2;
}

void Window_Skill::SetActor(const Game_Actor& actor) {
	this->actor = &actor;
	Refresh();
}

const lcf::rpg::Skill* Window_Skill::GetSkill() const {
	if (index < 0) {
		return nullptr;
	}

	return lcf::ReaderUtil::GetElement(lcf::Data::skills, data[index]);
}

void Window_Skill::Refresh() {
	data.clear();

	const std::vector<int16_t>& skills = actor->GetSkills();
	for (size_t i = 0; i < skills.size(); ++i) {
		if (CheckInclude(skills[i]))
			data.push_back(skills[i]);
	}

	if (data.size() == 0) {
		data.push_back(0);
	}

	item_max = data.size();

	CreateContents();

	contents->Clear();

	for (int i = 0; i < item_max; ++i) {
		DrawItem(i);
	}
}

void Window_Skill::DrawItem(int index) {
	Rect rect = GetItemRect(index);
	contents->ClearRect(rect);

	int skill_id = data[index];

	if (skill_id > 0) {
		int costs = actor->CalculateSkillCost(skill_id);

		bool enabled = CheckEnable(skill_id);
		int color = !enabled ? Font::ColorDisabled : Font::ColorDefault;

		contents->TextDraw(rect.x + rect.width - 24, rect.y, color, fmt::format("{}{:3d}", lcf::rpg::Terms::TermOrDefault(lcf::Data::terms.easyrpg_skill_cost_separator, "-"), costs));

		// Skills are guaranteed to be valid
		DrawSkillName(*lcf::ReaderUtil::GetElement(lcf::Data::skills, skill_id), rect.x, rect.y, enabled);
	}
}

void Window_Skill::UpdateHelp() {
	help_window->SetText(GetSkill() == nullptr ? "" : ToString(GetSkill()->description));
}

bool Window_Skill::CheckInclude(int skill_id) {
	if (!Game_Battle::IsBattleRunning()) {
		return true;
	}

	if (Player::IsRPG2k()) {
		return true;
	}
	else {
		if (subset == 0) {
			return true;
		}

		const lcf::rpg::Skill* skill = lcf::ReaderUtil::GetElement(lcf::Data::skills, skill_id);
		if (skill) {
			return skill->type == subset;
		}

		Output::Warning("Window Skill: Invalid skill ID {}", skill_id);
		return false;
	}
}

bool Window_Skill::CheckEnable(int skill_id) {
	return actor->IsSkillLearned(skill_id) && actor->IsSkillUsable(skill_id);
}

void Window_Skill::SetSubsetFilter(int subset) {
	this->subset = subset;
}


/*end of file .\window_skill.cpp*/

/*start of file .\window_skillstatus.cpp*/

/* ... license chunk ... */

// Headers
#include "window_skillstatus.h"
#include "game_actor.h"
#include "game_actors.h"
#include "bitmap.h"
#include "font.h"
#include "player.h"

Window_SkillStatus::Window_SkillStatus(int ix, int iy, int iwidth, int iheight) :
	Window_Base(ix, iy, iwidth, iheight) {

	SetContents(Bitmap::Create(width - 16, height - 16));
}

void Window_SkillStatus::SetActor(const Game_Actor& actor) {
	this->actor = &actor;
	Refresh();
}

void Window_SkillStatus::Refresh() {
	contents->ClearRect(Rect(0, 0, contents->GetWidth(), 16));

	// Actors are guaranteed to be valid
	int x = 0;
	int y = 2;
	DrawActorName(*actor, x, y);
	x += 80;
	DrawActorLevel(*actor, x, y);
	x += 44;
	DrawActorState(*actor, x, y);
	int hpdigits = (actor->MaxHpValue() >= 1000) ? 4 : 3;
	int spdigits = (actor->MaxSpValue() >= 1000) ? 4 : 3;
	x += (96 - hpdigits * 6 - spdigits * 6);
	DrawActorHp(*actor, x, y, hpdigits);
	x += (66 + hpdigits * 6 - spdigits * 6);
	DrawActorSp(*actor, x, y, spdigits);
}


/*end of file .\window_skillstatus.cpp*/

/*start of file .\window_stringview.cpp*/

/* ... license chunk ... */

// Headers
#include <vector>
#include "window_stringview.h"
#include "bitmap.h"
#include "game_message.h"
#include "game_system.h"
#include "input.h"
#include "player.h"
#include "json_helper.h"

Window_StringView::Window_StringView(int ix, int iy, int iwidth, int iheight) :
	Window_Selectable(ix, iy, iwidth, iheight) {
	column_max = 1;
}

Window_StringView::~Window_StringView() {

}

void Window_StringView::SetDisplayData(std::string_view data) {
	display_data_raw = ToString(data);
#ifdef HAVE_NLOHMANN_JSON
	this->json_data = nullptr;
#endif
}

std::string Window_StringView::GetDisplayData(bool eval_cmds) {
	std::string display_str = ToString(this->display_data_raw);

#ifdef HAVE_NLOHMANN_JSON
	if (this->json_data && pretty_print) {
		if (auto parsed_json = Json_Helper::Parse(display_str)) {
			display_str = Json_Helper::PrettyPrint(*parsed_json, 2);
		}
	}
#endif

	if (eval_cmds) {
		return PendingMessage::ApplyTextInsertingCommands(display_str, Player::escape_char, Game_Message::CommandCodeInserter);
	}
	return display_str;
}

#ifdef HAVE_NLOHMANN_JSON
void Window_StringView::SetDisplayData(std::string_view data, const nlohmann::ordered_json& json_data) {
	display_data_raw = ToString(data);
	this->json_data = &json_data;
}
#endif

void Window_StringView::Refresh() {
	lines.clear();
	line_numbers.clear();
	line_count = 0;

	std::string value = GetDisplayData(cmd_eval);

	// determine line count
	size_t pos = 0;
	while ((pos = value.find("\n", pos)) != std::string::npos) {
		value = value.substr(pos + 1);
		pos = 0;
		line_count++;
	}
	if (!value.empty()) {
		line_count++;
	}

	//compute how many digits there are needed for the line numbers
	line_no_max_digits = std::log10(line_count) + 1;

	value = GetDisplayData(cmd_eval);

	//create vector of display lines
	pos = 0;
	int c = 0;
	int limit = 6 * (max_str_length - line_no_max_digits);

	while ((pos = value.find("\n", pos)) != std::string::npos) {
		std::string new_line = value.substr(0, pos);

		line_numbers.push_back(++c);
		if (auto_linebreak) {
			bool skipFirstNo = true;
			Game_Message::WordWrap(new_line, limit, [&](std::string_view line) {
				if (!skipFirstNo)
					line_numbers.push_back(0);
				skipFirstNo = false;
				lines.push_back(std::string(line));
			}, *Font::DefaultBitmapFont());
		} else {
			lines.push_back(new_line);
		}
		value = value.substr(pos + 1);
		pos = 0;
	}
	if (!value.empty()) {
		lines.push_back(value);
		line_numbers.push_back(++c);
	}

	item_max = lines.size() + GetReservedLineCount();

	CreateContents();
	contents->Clear();
	DrawCmdLines();

	for (int i = 0; i < item_max - GetReservedLineCount(); ++i) {
		DrawLine(i);
	}
}

void Window_StringView::Update() {
	Window_Selectable::Update();
	if (active && index >= 0 && index < GetReservedLineCount() && Input::IsTriggered(Input::DECISION)) {
		if (index == 0) {
			auto_linebreak = !auto_linebreak;
		} else if (index == 1) {
			cmd_eval = !cmd_eval;
		} else {
			pretty_print = !pretty_print;
		}

		Main_Data::game_system->SePlay(Main_Data::game_system->GetSystemSE(Main_Data::game_system->SFX_Decision));
		Refresh();
	}
}

void Window_StringView::DrawCmdLines() {
	Rect rect = GetItemRect(0);
	contents->ClearRect(rect);

	contents->TextDraw(rect.x, rect.y, Font::ColorHeal, "Automatic line break: ");
	contents->TextDraw(GetWidth() - 16, rect.y, Font::ColorCritical, auto_linebreak ? "[ON]" : "[OFF]", Text::AlignRight);

	rect = GetItemRect(1);
	contents->ClearRect(rect);

	contents->TextDraw(rect.x, rect.y, Font::ColorHeal, "Command evaluation: ");
	contents->TextDraw(GetWidth() - 16, rect.y, Font::ColorCritical, cmd_eval ? "[ON]" : "[OFF]", Text::AlignRight);

#ifdef HAVE_NLOHMANN_JSON
	if (this->json_data) {
		rect = GetItemRect(2);
		contents->ClearRect(rect);

		contents->TextDraw(rect.x, rect.y, Font::ColorHeal, "Pretty Print: ");
		contents->TextDraw(GetWidth() - 16, rect.y, Font::ColorCritical, pretty_print ? "[ON]" : "[OFF]", Text::AlignRight);
	}
#endif
}

void Window_StringView::DrawLine(int index) {
	Rect rect = GetItemRect(index + GetReservedLineCount());
	//contents->ClearRect(rect);

	std::string line = lines[index];

	if (!line.empty()) {
		if (line_numbers[index]) {
			contents->TextDraw(rect.x, rect.y, Font::ColorDisabled, fmt::format("{:0" + std::to_string(line_no_max_digits) + "d}", line_numbers[index]));
		}
		contents->TextDraw(rect.x + line_no_max_digits * 6 + 6, rect.y, Font::ColorDefault, line);
	}
}


/*end of file .\window_stringview.cpp*/

/*start of file .\window_targetstatus.cpp*/

/* ... license chunk ... */

// Headers
#include <sstream>
#include "window_targetstatus.h"
#include "game_party.h"
#include "bitmap.h"
#include "font.h"
#include <lcf/reader_util.h>

Window_TargetStatus::Window_TargetStatus(int ix, int iy, int iwidth, int iheight) :
	Window_Base(ix, iy, iwidth, iheight), id(-1), use_item(false) {

	SetContents(Bitmap::Create(width - 16, height - 16));
}

void Window_TargetStatus::Refresh() {
	contents->Clear();

	if (id < 0) {
		return;
	}

	if (use_item) {
		contents->TextDraw(0, 2, 1, lcf::Data::terms.possessed_items);
	} else {
		contents->TextDraw(0, 2, 1, lcf::Data::terms.sp_cost);
	}

	// Scene_ActorTarget validates items and skills
	std::string str;
	if (use_item) {
		str = std::to_string(Main_Data::game_party->GetItemCount(id));
	} else {
		str = std::to_string((*Main_Data::game_party)[actor_index].CalculateSkillCost(id));
	}

	FontRef font = Font::Default();
	contents->TextDraw(contents->GetWidth(), 2, Font::ColorDefault, str, Text::AlignRight);
}

void Window_TargetStatus::SetData(int id, bool is_item, int actor_index) {
	this->id = id;
	use_item = is_item;
	this->actor_index = actor_index;

	Refresh();
}


/*end of file .\window_targetstatus.cpp*/

/*start of file .\window_teleport.cpp*/

/* ... license chunk ... */

// Headers
#include <vector>
#include "window_teleport.h"
#include "bitmap.h"
#include "font.h"
#include "game_map.h"
#include "game_targets.h"

Window_Teleport::Window_Teleport(int ix, int iy, int iwidth, int iheight) :
	Window_Selectable(ix, iy, iwidth, iheight) {
	column_max = 2;

	Refresh();
}

const lcf::rpg::SaveTarget& Window_Teleport::GetTarget() const {
	const auto& targets = Main_Data::game_targets->GetTeleportTargets();

	return targets[GetIndex()];
}

void Window_Teleport::Refresh() {
	const auto& targets = Main_Data::game_targets->GetTeleportTargets();
	item_max = (int)targets.size();
	CreateContents();

	for (size_t i = 0; i < targets.size(); ++i) {
		Rect rect = GetItemRect(i);
		contents->ClearRect(rect);

		contents->TextDraw(rect, Font::ColorDefault, Game_Map::GetMapName(targets[i].map_id));
	}
}


/*end of file .\window_teleport.cpp*/

/*start of file .\window_varlist.cpp*/

/* ... license chunk ... */

// Headers
#include <sstream>
#include <iomanip>
#include "window_varlist.h"
#include "game_switches.h"
#include "game_variables.h"
#include "game_strings.h"
#include "bitmap.h"
#include <lcf/data.h>
#include <lcf/reader_util.h>
#include "input.h"
#include "output.h"
#include "game_party.h"
#include "game_map.h"
#include "game_system.h"

constexpr int LINE_COUNT = 10;

Window_VarList::Window_VarList() :
	Window_Selectable(0, 32, 224, 176) {

	item_max = LINE_COUNT;
	items.reserve(LINE_COUNT);
	for (int i = 0; i < LINE_COUNT; i++)
		items.push_back("");

	index = 0;
	SetContents(Bitmap::Create(this->width - 16, item_max * menu_item_height));
}

Window_VarList::~Window_VarList() {

}

void Window_VarList::Refresh() {
	contents->Clear();

	for (int i = 0; i < LINE_COUNT; i++) {
		DrawItem(i, Font::ColorDefault);
	}
	const int item_count = GetItemCount();
	for (int i = 0; i < item_count; i++) {
		DrawItemValue(i);
	}
}

int Window_VarList::GetItemIndex() const {
	return GetIndex() * GetItemCount() / LINE_COUNT;
}

void Window_VarList::SetItemIndex(int index) {
	SetIndex(index * LINE_COUNT / GetItemCount());
}

void Window_VarList::DrawItem(int index, Font::SystemColor color) {
	const int y = menu_item_height * index + 2;
	contents->ClearRect(Rect(0, y, contents->GetWidth() - 0, menu_item_height));
	contents->TextDraw(0, y + menu_item_height / 8, color, items[index]);
}

void Window_VarList::DrawItemValue(int index){
	if (!DataIsValid(first_var+index)) {
		return;
	}
	const int y = menu_item_height * index * LINE_COUNT / GetItemCount() + 2;
	switch (mode) {
		case eSwitch:
			{
				auto value = Main_Data::game_switches->Get(first_var + index);
				auto font = (!value) ? Font::ColorCritical : Font::ColorDefault;
				contents->TextDraw(GetWidth() - 16, y, font, value ? "[ON]" : "[OFF]", Text::AlignRight);
			}
			break;
		case eVariable:
			{
				auto value = Main_Data::game_variables->Get(first_var + index);
				auto font = (value < 0) ? Font::ColorCritical : Font::ColorDefault;
				contents->TextDraw(GetWidth() - 16, y, font, std::to_string(value), Text::AlignRight);
			}
			break;
		case eItem:
			{
				auto value = Main_Data::game_party->GetItemCount(first_var + index);
				auto font = (value == 0) ? Font::ColorCritical : Font::ColorDefault;
				contents->TextDraw(GetWidth() - 16, y, font, std::to_string(value), Text::AlignRight);
			}
			break;
		case eTroop:
		case eMap:
		case eHeal:
		case eCommonEvent:
		case eMapEvent:
			{
				contents->TextDraw(GetWidth() - 16, y, Font::ColorDefault, "", Text::AlignRight);
			}
			break;
		case eLevel:
			{
				auto value = Main_Data::game_party->GetActors()[first_var + index - 1]->GetLevel();
				contents->TextDraw(GetWidth() - 16, y, Font::ColorDefault, std::to_string(value), Text::AlignRight);
			}
			break;
		case eString:
			DrawStringVarItem(index, y);
		break;
		case eNone:
			break;
	}
}

void Window_VarList::UpdateList(int first_value){
	static std::stringstream ss;
	first_var = first_value;
	int map_idx = 0;
	if (mode == eMap) {
		auto iter = std::lower_bound(lcf::Data::treemap.maps.begin(), lcf::Data::treemap.maps.end(), first_value,
				[](const lcf::rpg::MapInfo& l, int r) { return l.ID < r; });
		map_idx = iter - lcf::Data::treemap.maps.begin();
	}

	for (int i = 0; i < LINE_COUNT; i++) {
		this->SetItemText(i, "");
	}

	const int item_count = GetItemCount();
	for (int i = 0; i < item_count; i++){
		if (!DataIsValid(first_var+i)) {
			continue;
		}
		ss.str("");
		ss << std::setfill('0') << std::setw(GetDigitCount()) << (first_value + i) << ": ";
		switch (mode) {
			case eSwitch:
				ss << Main_Data::game_switches->GetName(first_value + i);
				break;
			case eVariable:
				ss << Main_Data::game_variables->GetName(first_value + i);
				break;
			case eItem:
				ss << lcf::ReaderUtil::GetElement(lcf::Data::items, first_value+i)->name;
				break;
			case eTroop:
				ss << lcf::ReaderUtil::GetElement(lcf::Data::troops, first_value+i)->name;
				break;
			case eMap:
				if (map_idx < static_cast<int>(lcf::Data::treemap.maps.size())) {
					auto& map = lcf::Data::treemap.maps[map_idx];
					if (map.ID == first_value + i) {
						ss << map.name;
						++map_idx;
					}
				}
				break;
			case eHeal:
				if (first_value + i == 1) {
					ss << "Party";
				} else {
					auto* actor = Main_Data::game_party->GetActors()[first_value + i-2];
					ss << actor->GetName() << " " << actor->GetHp() << " / " << actor->GetMaxHp();
				}
				break;
			case eLevel:
				if (first_value + i >= 1) {
					auto* actor = Main_Data::game_party->GetActors()[first_value + i-1];
					ss << actor->GetName();
				}
				break;
			case eCommonEvent:
				ss << lcf::ReaderUtil::GetElement(lcf::Data::commonevents, first_value+i)->name;
				break;
			case eMapEvent:
				ss << Game_Map::GetEvent(first_value + i)->GetName();
				break;
			case eString:
				if (show_detail) {
					std::string strvar_name = ToString(Main_Data::game_strings->GetName(first_value + i));
					if (strvar_name.empty()) {
						strvar_name = "---";
					}
					ss << strvar_name;
				}
				break;
			default:
				break;
		}
		int item_idx = i * LINE_COUNT / item_count;
		this->SetItemText(item_idx, ss.str());
	}
}

void Window_VarList::SetItemText(unsigned index, std::string_view text) {
	if (static_cast<int>(index) < item_max) {
		items[index] = ToString(text);
	}
}

void Window_VarList::SetMode(Mode mode) {
	this->mode = mode;
	SetVisible((mode != eNone));
	Refresh();
}

bool Window_VarList::DataIsValid(int range_index) {
	switch (mode) {
		case eSwitch:
			return Main_Data::game_switches->IsValid(range_index);
		case eVariable:
			return Main_Data::game_variables->IsValid(range_index);
		case eItem:
			return range_index > 0 && range_index <= static_cast<int>(lcf::Data::items.size());
		case eTroop:
			return range_index > 0 && range_index <= static_cast<int>(lcf::Data::troops.size());
		case eMap:
			return range_index > 0 && range_index <= (lcf::Data::treemap.maps.size() > 0 ? lcf::Data::treemap.maps.back().ID : 0);
		case eHeal:
			return range_index > 0 && range_index <= static_cast<int>(Main_Data::game_party->GetActors().size()) + 1;
		case eLevel:
			return range_index > 0 && range_index <= static_cast<int>(Main_Data::game_party->GetActors().size());
		case eCommonEvent:
			return range_index > 0 && range_index <= static_cast<int>(lcf::Data::commonevents.size());
		case eMapEvent:
			return Game_Map::GetEvent(range_index) != nullptr;
		case eString:
			return range_index > 0 && range_index <= Main_Data::game_strings->GetSizeWithLimit();
		default:
			break;
	}
	return false;
}

int Window_VarList::GetNumElements(Mode mode) {
	switch (mode) {
		case Window_VarList::eSwitch:
			return Main_Data::game_switches->GetSizeWithLimit();
		case Window_VarList::eVariable:
			return Main_Data::game_variables->GetSizeWithLimit();
		case eItem:
			return static_cast<int>(lcf::Data::items.size());
		case eTroop:
			return static_cast<int>(lcf::Data::troops.size());
		case eMap:
			return lcf::Data::treemap.maps.size() > 0 ? lcf::Data::treemap.maps.back().ID : 0;
		case eCommonEvent:
			return static_cast<int>(lcf::Data::commonevents.size());
		case eMapEvent:
			return Game_Map::GetHighestEventId();
		case eString:
			return Main_Data::game_strings->GetSizeWithLimit();
		default:
			return -1;
	}
}

void Window_VarList::Update() {
	int index_prev = this->index;

	if (show_detail) {
		suspend_cursor_refresh = true;
	}

	Window_Selectable::Update();

	if (show_detail) {
		int div = LINE_COUNT / GetItemCount();
		if (int offs = index % div; offs > 0) {
			if (index < index_prev) {
				index -= offs;
				if (index < 0) {
					index = 0;
				}
			} else if (index > index_prev) {
				index -= offs;
				if (index + div < item_max) {
					index += div;
				} else if (index_prev != 0) {
					index = 0;
				}
			}
		}
		suspend_cursor_refresh = false;
		UpdateCursorRect();
		SetCursorRect({ cursor_rect.x, cursor_rect.y, cursor_rect.width, cursor_rect.height * div });
	}
}

void Window_VarList::UpdateCursorRect() {
	if (suspend_cursor_refresh) {
		return;
	}
	Window_Selectable::UpdateCursorRect();
}

void Window_VarList::DrawStringVarItem(int index, int y) {
	auto value = ToString(Main_Data::game_strings->Get(first_var + index));
	const int space_reserved = (GetDigitCount() + 2);
	int x = space_reserved * 6, max_len_vals = 32 - space_reserved;

	bool is_json = false;
#ifdef HAVE_NLOHMANN_JSON
	auto& json_cache = Main_Data::game_strings->_json_cache;
	is_json = json_cache.find(first_var + index) != json_cache.end();
#endif

	if (is_json) {
		if (show_detail) {
			contents->TextDraw(GetWidth() - 16, y, Font::ColorHeal, "[JSON]", Text::AlignRight);
		} else {
			contents->TextDraw(GetWidth() - 16, y, Font::ColorHeal, "[J]", Text::AlignRight);
		}
	}

	if (show_detail) {
		x = 6;
		y += menu_item_height;
		max_len_vals += space_reserved;
	}
	if (value.empty()) {
		contents->TextDraw(x, y, Font::ColorDisabled, "undefined", Text::AlignLeft);
	} else {
		size_t pos = 0;
		while ((pos = value.find("\n", pos)) != std::string::npos) {
			value.replace(pos, 1, "\\n");
			pos += 3;
		}
		if (static_cast<int>(value.length()) > max_len_vals) {
			value = value.substr(0, max_len_vals - 3) + "...";
		}
		if (show_detail) {
			contents->TextDraw(x, y, Font::ColorDisabled, "\"", Text::AlignLeft);
			contents->TextDraw(x + 6, y, Font::ColorCritical, value, Text::AlignLeft);
			contents->TextDraw(x + value.length() * 6 + 6, y, Font::ColorDisabled, "\"", Text::AlignLeft);
		} else {
			contents->TextDraw(x, y, Font::ColorCritical, value, Text::AlignLeft);
		}
	}
}


/*end of file .\window_varlist.cpp*/

/*start of file .\_license_chunk.txt*/

/*
 * This file is part of EasyRPG Player.
 *
 * EasyRPG Player is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * EasyRPG Player is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with EasyRPG Player. If not, see <http://www.gnu.org/licenses/>.
 */

/*end of file .\_license_chunk.txt*/

/*start of file .\lcf\data.h*/

/*
 * This file is part of liblcf. Copyright (c) 2020 liblcf authors.
 * https://github.com/EasyRPG/liblcf - https://easyrpg.org
 *
 * liblcf is Free/Libre Open Source Software, released under the MIT License.
 * For the full copyright and license information, please view the COPYING
 * file that was distributed with this source code.
 */

#ifndef LCF_DATA_H
#define LCF_DATA_H

#include <string>
#include <vector>
#include "lcf/rpg/actor.h"
#include "lcf/rpg/skill.h"
#include "lcf/rpg/item.h"
#include "lcf/rpg/enemy.h"
#include "lcf/rpg/troop.h"
#include "lcf/rpg/attribute.h"
#include "lcf/rpg/state.h"
#include "lcf/rpg/terrain.h"
#include "lcf/rpg/animation.h"
#include "lcf/rpg/chipset.h"
#include "lcf/rpg/terms.h"
#include "lcf/rpg/system.h"
#include "lcf/rpg/commonevent.h"
#include "lcf/rpg/class.h"
#include "lcf/rpg/battlecommand.h"
#include "lcf/rpg/battleranimation.h"
#include "lcf/rpg/sound.h"
#include "lcf/rpg/music.h"
#include "lcf/rpg/eventcommand.h"
#include "lcf/rpg/treemap.h"
#include "lcf/rpg/database.h"

namespace lcf {

/**
 * Data namespace
 */
namespace Data {
	/** Database Data (ldb) */
	extern rpg::Database data;
	/** @{ */
	extern std::vector<rpg::Actor>& actors;
	extern std::vector<rpg::Skill>& skills;
	extern std::vector<rpg::Item>& items;
	extern std::vector<rpg::Enemy>& enemies;
	extern std::vector<rpg::Troop>& troops;
	extern std::vector<rpg::Terrain>& terrains;
	extern std::vector<rpg::Attribute>& attributes;
	extern std::vector<rpg::State>& states;
	extern std::vector<rpg::Animation>& animations;
	extern std::vector<rpg::Chipset>& chipsets;
	extern std::vector<rpg::CommonEvent>& commonevents;
	extern rpg::BattleCommands& battlecommands;
	extern std::vector<rpg::Class>& classes;
	extern std::vector<rpg::BattlerAnimation>& battleranimations;
	extern rpg::Terms& terms;
	extern rpg::System& system;
	extern std::vector<rpg::Switch>& switches;
	extern std::vector<rpg::Variable>& variables;
	extern std::vector<rpg::StringVariable>& maniac_string_variables;
	/** @} */

	/** TreeMap (lmt) */
	extern rpg::TreeMap treemap;

	/**
	 * Clears database data.
	 */
	void Clear();
}

} //namespace lcf

#endif


/*end of file .\lcf\data.h*/

